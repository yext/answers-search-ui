(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.ANSWERS = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /** @module SearchStates */

  /**
   * SearchStates is an ENUM for the various stages of searching,
   * used to show different templates
   * @enum {string}
   */
  var SearchStates = {
    PRE_SEARCH: 'pre-search',
    SEARCH_LOADING: 'search-loading',
    SEARCH_COMPLETE: 'search-complete'
  };

  /** @module Result */
  var Result = function Result() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Result);

    /**
     * The raw profile data
     * @type {Object}
     * @private
     */
    this._raw = data.raw || null;
    /**
     * The formatted profile data
     * @type {Object}
     * @private
     */

    this._formatted = data.formatted;
    /**
     * The highlighted profile data with highlights applied to applicable fields
     * @type {Object}
     * @private
     */

    this._highlighted = data.highlighted;
    /**
     * The index number of the result
     * @type {Number}
     */

    this.ordinal = data.ordinal || null;
    /**
     * The title of the result card
     * @type {string|null}
     */

    this.title = data.title || null;
    /**
     * The body of the details section of the result card, can contain HTML
     * @type {string| null}
     */

    this.details = data.details || null;
    /**
     * The destination link for the title of the result card
     * @type {string|null}
     */

    this.link = data.link || null;
    /**
     * The Entity ID, or other unique identifier, used for to power interactivity
     * @type {string|null}
     */

    this.id = data.id || null;
    /**
     * The subtitle on the result card
     * @type {string|null}
     */

    this.subtitle = data.subtitle || null;
    /**
     * The class modifier, usually derived from the vertical configuration ID
     * Used to apply different styling to different result card types
     * @type {string|null}
     */

    this.modifier = data.modifier || null;
    /**
     * A large date, of the format { month: 'Jan', day: '01' }
     * @type {Object|null}
     */

    this.bigDate = data.bigDate || null;
    /**
     * An image profile object, expected to have a url property
     * @type {Object|null}
     */

    this.image = data.image || null;
    /**
     * An array of calls to action, of the format:
     * { icon: '', url: '', text: '', eventType: '', eventOptions: {}}
     * @type {Array}
     */

    this.callsToAction = data.callsToAction || [];
    /**
     * Determines if an accordian result should be collapsed by default
     * @type {boolean}
     */

    this.collapsed = data.collapsed === undefined ? true : data.collapsed;
  };

  /** @module HighlightedValue */

  /**
   * Model representing a highlighted value.
   */
  var HighlightedValue =
  /*#__PURE__*/
  function () {
    function HighlightedValue() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HighlightedValue);

      this.value = data.value || data.shortValue || '';
      this.matchedSubstrings = data.matchedSubstrings || [];
    }
    /**
     * get highlighted value string
     * @returns {string}
     */


    _createClass(HighlightedValue, [{
      key: "get",
      value: function get() {
        this._sortMatchedSubstrings();

        return this.buildHighlightedValue(this.value, this.matchedSubstrings);
      }
      /**
       * get inverted highlighted value string
       * @returns {string}
       */

    }, {
      key: "getInverted",
      value: function getInverted() {
        this._sortMatchedSubstrings();

        var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

        return this.buildHighlightedValue(this.value, invertedSubstrings);
      }
      /**
       * introduces highlighting to input data according to highlighting specifiers
       *
       * @param {Object} val input object to apply highlighting to
       *
       *  example object :
       *  {
       *    name: 'ATM',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 ATMs'
       *    }
       *  }
       *
       * @param {Object} highlightedSubstrings highlighting specifiers to apply to input object
       *
       *  example object :
       *  {
       *    name: {
       *      matchedSubstrings: [{
       *        length: 3,
       *        offset: 0
       *      }],
       *      value: 'ATM'
       *    },
       *    featuredMessage: {
       *      description: {
       *        matchedSubstrings: [{
       *          length: 4,
       *          offset: 45
       *        }],
       *        value: 'Save time & bank on your terms at over 1,800 ATMs'
       *      }
       *    }
       *  }
       *
       * @returns {string} copy of input value with highlighting applied
       *
       *  example object :
       *  {
       *    name: '<strong>ATM</strong>',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 <strong>ATMs</strong>'
       *    }
       *  }
       *
       */

    }, {
      key: "buildHighlightedValue",
      value: function buildHighlightedValue(val, highlightedSubstrings) {
        var highlightedValue = '';
        var nextStart = 0;

        if (highlightedSubstrings.length === 0) {
          return val;
        }

        for (var j = 0; j < highlightedSubstrings.length; j++) {
          var start = Number(highlightedSubstrings[j].offset);
          var end = start + highlightedSubstrings[j].length;
          highlightedValue += [val.slice(nextStart, start), '<strong>', val.slice(start, end), '</strong>'].join('');

          if (j === highlightedSubstrings.length - 1 && end < val.length) {
            highlightedValue += val.slice(end);
          }

          nextStart = end;
        }

        return highlightedValue;
      }
    }, {
      key: "_sortMatchedSubstrings",
      value: function _sortMatchedSubstrings() {
        this.matchedSubstrings.sort(function (a, b) {
          if (a.offset < b.offset) {
            return -1;
          }

          if (a.offset > b.offset) {
            return 1;
          }

          return 0;
        });
      }
    }, {
      key: "_getInvertedSubstrings",
      value: function _getInvertedSubstrings(matchedSubstrings, valueLength) {
        var invertedSubstrings = [];

        for (var i = 0; i < matchedSubstrings.length; i++) {
          var substring = matchedSubstrings[i];
          var nextOffset = substring.offset + substring.length;

          if (i === 0 && substring.offset !== 0) {
            invertedSubstrings.push({
              offset: 0,
              length: substring.offset
            });
          }

          if (valueLength > nextOffset) {
            invertedSubstrings.push({
              offset: nextOffset,
              length: i < matchedSubstrings.length - 1 ? matchedSubstrings[i + 1].offset - nextOffset : valueLength - nextOffset
            });
          }
        }

        return invertedSubstrings;
      }
    }]);

    return HighlightedValue;
  }();

  /** @module Errors */

  /**
   * AnswersBaseError is an extension of the base Error object.
   * This is the object that is used to when reporting to the server.
   * @extends Error
   *
   * Error codes fall into one of four categories:
   * 1XX errors: Basic errors
   * 2XX errors: UI errors
   * 3XX errors: Endpoint errors
   * 4XX errors: Core errors
   */
  var AnswersBaseError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(AnswersBaseError, _Error);

    function AnswersBaseError(errorCode, message) {
      var _this;

      var boundary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unknown';
      var causedBy = arguments.length > 3 ? arguments[3] : undefined;

      _classCallCheck(this, AnswersBaseError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnswersBaseError).call(this, message));
      _this.errorCode = errorCode;
      _this.errorMessage = message;
      _this.boundary = boundary;
      _this.reported = false;

      if (causedBy) {
        _this.causedBy = causedBy instanceof AnswersBaseError ? causedBy : AnswersBaseError.from(causedBy);
        _this.stack = "".concat(_this.stack, "\nCaused By: ").concat(_this.causedBy.stack);
      }

      return _this;
    }

    _createClass(AnswersBaseError, [{
      key: "toJson",
      value: function toJson() {
        return JSON.stringify(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        var string = "".concat(this.errorMessage, " (").concat(this.boundary, ")");

        if (this.causedBy) {
          string += "\n  Caused By: ".concat(this.causedBy.toString());
        }

        return string;
      }
    }], [{
      key: "from",
      value: function from(builtinError, boundary) {
        var error = new AnswersBasicError(builtinError.message, boundary);
        error.stack = builtinError.stack;
        return error;
      }
    }]);

    return AnswersBaseError;
  }(_wrapNativeSuper(Error));
  /**
   * AnswersBasicError is a wrapper around all the built-in errors
   * e.g. undefined variables, incorrect syntax, types, missing methods, etc.
   * @extends AnswersBaseError
   */

  var AnswersBasicError =
  /*#__PURE__*/
  function (_AnswersBaseError) {
    _inherits(AnswersBasicError, _AnswersBaseError);

    function AnswersBasicError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersBasicError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersBasicError).call(this, 100, message, boundary, causedBy));
    }

    return AnswersBasicError;
  }(AnswersBaseError);
  /**
   * AnswersUiError used for things like DOM errors.
   * @extends AnswersBaseError
   */

  var AnswersConfigError =
  /*#__PURE__*/
  function (_AnswersBaseError2) {
    _inherits(AnswersConfigError, _AnswersBaseError2);

    function AnswersConfigError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersConfigError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersConfigError).call(this, 101, message, boundary, causedBy));
    }

    return AnswersConfigError;
  }(AnswersBaseError);
  /**
   * AnswersComponentError is used for Component oriented errors
   * e.g. failure to render, or catching unknowns.
   * @extends AnswersBaseError
   */

  var AnswersComponentError =
  /*#__PURE__*/
  function (_AnswersBaseError4) {
    _inherits(AnswersComponentError, _AnswersBaseError4);

    function AnswersComponentError(message, component, causedBy) {
      _classCallCheck(this, AnswersComponentError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersComponentError).call(this, 201, message, component, causedBy));
    }

    return AnswersComponentError;
  }(AnswersBaseError);
  /**
   * AnswersEndpointError represents all network related errors.
   * @extends AnswersBaseError
   */

  var AnswersEndpointError =
  /*#__PURE__*/
  function (_AnswersBaseError5) {
    _inherits(AnswersEndpointError, _AnswersBaseError5);

    function AnswersEndpointError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersEndpointError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersEndpointError).call(this, 300, message, boundary, causedBy));
    }

    return AnswersEndpointError;
  }(AnswersBaseError);
  /**
   * AnswersCoreError represents errors for precondition failures in the core library
   * @extends AnswersBaseError
   */

  var AnswersCoreError =
  /*#__PURE__*/
  function (_AnswersBaseError6) {
    _inherits(AnswersCoreError, _AnswersBaseError6);

    function AnswersCoreError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersCoreError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersCoreError).call(this, 400, message, boundary, causedBy));
    }

    return AnswersCoreError;
  }(AnswersBaseError);
  /**
   * AnswersStorageError represents storage related errors
   * @extends AnswersBaseError
   */

  var AnswersStorageError =
  /*#__PURE__*/
  function (_AnswersBaseError7) {
    _inherits(AnswersStorageError, _AnswersBaseError7);

    function AnswersStorageError(message, storageKey, data, causedBy) {
      var _this2;

      _classCallCheck(this, AnswersStorageError);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersStorageError).call(this, 401, message, 'Storage', causedBy));
      _this2.storageKey = storageKey;
      _this2.data = data;
      return _this2;
    }

    return AnswersStorageError;
  }(AnswersBaseError);
  /**
   * AnswersAnalyticsError is used for errors when reporting analytics
   * @extends AnswersBaseError
   */

  var AnswersAnalyticsError =
  /*#__PURE__*/
  function (_AnswersBaseError8) {
    _inherits(AnswersAnalyticsError, _AnswersBaseError8);

    function AnswersAnalyticsError(message, event, causedBy) {
      var _this3;

      _classCallCheck(this, AnswersAnalyticsError);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersAnalyticsError).call(this, 402, message, 'Analytics', causedBy));
      _this3.event = event;
      return _this3;
    }

    return AnswersAnalyticsError;
  }(AnswersBaseError);

  var ResultFactory =
  /*#__PURE__*/
  function () {
    function ResultFactory() {
      _classCallCheck(this, ResultFactory);
    }

    _createClass(ResultFactory, null, [{
      key: "from",

      /**
       * Converts an API result object into a Result view model.
       * Includes default mappings of GoogleCustomSearchEngine results to
       * the fields exposed by the template.
       * @param resultsData  {Array} expected format: { data: { ... }, highlightedFields: { ... }}
       * @param {Object.<string, function>} formatters The formatters to apply to the result
       * @param {string} verticalId The vertical of these results
       * @param {string} source Backend source of these results
       * @returns {Result[]}
       */
      value: function from(resultsData, formatters, verticalId, source) {
        var results = [];

        for (var i = 0; i < resultsData.length; i++) {
          var data = resultsData[i].data || resultsData[i];

          switch (source) {
            case 'GOOGLE_CSE':
              results.push(ResultFactory.fromGoogleCustomSearchEngine(data));
              break;

            case 'BING_CSE':
              results.push(ResultFactory.fromBingCustomSearchEngine(data));
              break;

            case 'ZENDESK':
              results.push(ResultFactory.fromZendeskSearchEngine(data));
              break;

            case 'ALGOLIA':
              results.push(ResultFactory.fromAlgoliaSearchEngine(data));
              break;

            case 'KNOWLEDGE_MANAGER':
              var highlightedFields = resultsData[i].highlightedFields || {};
              results.push(ResultFactory.fromKnowledgeManager(data, formatters, verticalId, highlightedFields, i));
              break;

            default:
              results.push(ResultFactory.fromGeneric(data, i));
          }
        }

        return results;
      }
      /**
       * Applies field formatters to Knowledge Manager Entity Profile Data
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} formatters Developer specified Field Formatters
       * @param {string} verticalId Identifier for Vertical
       * @param {Object} highlightedEntityProfileData Subset of Entity Profile Data with highlighting applied
       * @returns {Object} Subset of Entity Profile Data Fields with field formatters applied
       */

    }, {
      key: "computeFormattedData",
      value: function computeFormattedData(entityProfileData, formatters, verticalId, highlightedEntityProfileData) {
        // if no field formatters specified, nothing to format
        if (Object.keys(formatters).length === 0) {
          return {};
        }

        var formattedData = {};
        Object.entries(entityProfileData).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              fieldName = _ref2[0],
              fieldVal = _ref2[1];

          // check if a field formatter exists for the current entity profile field
          if (formatters[fieldName] === undefined) {
            return;
          } // verify the field formatter provided is a formatter function as expected


          if (typeof formatters[fieldName] !== 'function') {
            throw new AnswersCoreError('Field formatter is not of expected type function', 'ResultFactory');
          } // if highlighted version of field value is available, make it available to field formatter


          var highlightedFieldVal = null;

          if (highlightedEntityProfileData && highlightedEntityProfileData[fieldName]) {
            highlightedFieldVal = highlightedEntityProfileData[fieldName];
          } // call formatter function associated with the field name
          // the input object defines the interface that field formatter functions work with


          formattedData[fieldName] = formatters[fieldName]({
            entityProfileData: entityProfileData,
            entityFieldValue: fieldVal,
            highlightedEntityFieldValue: highlightedFieldVal,
            verticalId: verticalId,
            isDirectAnswer: false
          });
        });
        return formattedData;
      }
      /**
       * Applies highlighting to substrings within Knowledge Manager Entity Field Values
       * according to highlighting specifiers returned from the Knowledge Manager Search Backend
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} highlightedFields KM specified highlighting instructions to highlight certain Fields
       * @returns {Object} Subset of Entity Profile Data Fields with highlighting applied
       */

    }, {
      key: "computeHighlightedData",
      value: function computeHighlightedData(entityProfileData, highlightedFields) {
        // if no highlighted fields specified, nothing to highlight
        if (Object.keys(highlightedFields).length === 0) {
          return {};
        }

        var highlightedData = {}; // iterate through entity fields that have highlighting instructions

        Object.entries(highlightedFields).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              highlightedFieldName = _ref4[0];

          // verify that the highlighted field name corresponds to an existing entity profile field
          if (entityProfileData[highlightedFieldName] === undefined) {
            throw new AnswersCoreError('Highlighted Field Name does not exist in Entity Profile', 'ResultFactory');
          }

          var highlightedField = highlightedFields[highlightedFieldName]; // check for nested fields

          if (_typeof(highlightedField) === 'object' && Object.keys(highlightedField).length > 0 && highlightedField['matchedSubstrings'] === undefined) {
            // recurse to children fields
            highlightedData[highlightedFieldName] = ResultFactory.computeHighlightedData(entityProfileData[highlightedFieldName], highlightedFields[highlightedFieldName]);
          } else {
            var highlightedDataValue = new HighlightedValue(entityProfileData).buildHighlightedValue(highlightedField.value, highlightedField.matchedSubstrings);
            highlightedData[highlightedFieldName] = highlightedDataValue;
          }
        });
        return highlightedData;
      }
      /**
       * Converts an API result object into a generic result view model.
       * @param {Object} data
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromGeneric",
      value: function fromGeneric(data, index) {
        return new Result({
          raw: data,
          title: data.name,
          details: this.truncate(data.description),
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a Knowledge Manager result view model.
       * @param {Object} data
       * @param {Object} formatters
       * @param {string} verticalId
       * @param {Object} highlightedFields
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromKnowledgeManager",
      value: function fromKnowledgeManager(data, formatters, verticalId, highlightedFields, index) {
        // compute highlighted entity profile data
        var highlightedEntityProfileData = ResultFactory.computeHighlightedData(data, highlightedFields); // compute formatted entity profile data

        var formattedEntityProfileData = ResultFactory.computeFormattedData(data, formatters, verticalId, highlightedEntityProfileData); // set result details checking the following in order of priority : formatted, highlighted, raw

        var resultDetails = null;

        if (formattedEntityProfileData.description !== undefined) {
          resultDetails = formattedEntityProfileData.description;
        } else if (highlightedEntityProfileData.description !== undefined) {
          resultDetails = this.truncate(highlightedEntityProfileData.description);
        } else {
          resultDetails = this.truncate(data.description);
        }

        return new Result({
          raw: data,
          formatted: formattedEntityProfileData,
          highlighted: highlightedEntityProfileData,
          title: formattedEntityProfileData.name || data.name,
          details: resultDetails,
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Google Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromGoogleCustomSearchEngine",
      value: function fromGoogleCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.htmlTitle.replace(/(<([^>]+)>)/ig, ''),
          details: data.htmlSnippet,
          link: data.link
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Bing Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromBingCustomSearchEngine",
      value: function fromBingCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.name,
          details: data.snippet,
          link: data.url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Zendesk Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromZendeskSearchEngine",
      value: function fromZendeskSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.title,
          details: data.snippet,
          link: data.html_url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Algolia Search Engine object.
       * Details field is set to objectID since response has only one general field objectID.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromAlgoliaSearchEngine",
      value: function fromAlgoliaSearchEngine(data) {
        return new Result({
          raw: data,
          details: data.objectID,
          id: data.objectID
        });
      }
      /**
       * Truncates strings to 250 characters, attempting to preserve whole words
       * @param str {string} the string to truncate
       * @param limit {Number} the maximum character length to return
       * @param trailing {string} a trailing string to denote truncation, e.g. '...'
       * @param sep {string} the word separator
       * @returns {string}
       */

    }, {
      key: "truncate",
      value: function truncate(str) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
        var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';
        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';

        if (!str || str.length <= limit) {
          return str;
        } // TODO (bmcginnis): split punctuation too so we don't end up with "foo,..."


        var words = str.split(sep);
        var max = limit - trailing.length;
        var truncated = '';

        for (var i = 0; i < words.length; i++) {
          var word = words[i];

          if (truncated.length + word.length > max || i !== 0 && truncated.length + word.length + sep.length > max) {
            truncated += trailing;
            break;
          }

          truncated += i === 0 ? word : sep + word;
        }

        return truncated;
      }
    }]);

    return ResultFactory;
  }();

  var Section =
  /*#__PURE__*/
  function () {
    function Section(data, url, formatters) {
      _classCallCheck(this, Section);

      this.searchState = SearchStates.SEARCH_COMPLETE;
      this.verticalConfigId = data.verticalConfigId || null;
      this.resultsCount = data.resultsCount || 0;
      this.encodedState = data.encodedState || '';
      this.appliedQueryFilters = AppliedQueryFilter.from(data.appliedQueryFilters);
      this.facets = data.facets || null;
      this.results = ResultFactory.from(data.results, formatters, this.verticalConfigId, data.source);
      this.map = Section.parseMap(data.results);
      this.verticalURL = url || null;
    }

    _createClass(Section, null, [{
      key: "parseMap",
      value: function parseMap(results) {
        var mapMarkers = [];
        var centerCoordinates = {};

        for (var j = 0; j < results.length; j++) {
          // TODO(billy) Remove legacy fallback from all data format
          var result = results[j].data || results[j];

          if (result && result.yextDisplayCoordinate) {
            if (!centerCoordinates.latitude) {
              centerCoordinates = {
                latitude: result.yextDisplayCoordinate.latitude,
                longitude: result.yextDisplayCoordinate.longitude
              };
            }

            mapMarkers.push({
              item: result,
              label: mapMarkers.length + 1,
              latitude: result.yextDisplayCoordinate.latitude,
              longitude: result.yextDisplayCoordinate.longitude
            });
          }
        }

        return {
          'mapCenter': centerCoordinates,
          'mapMarkers': mapMarkers
        };
      }
      /**
       * Create a section from the provided data
       * @param {Object|Array} modules The result modules
       * @param {Object} urls The tab urls
       * @param {Object.<string, function>} formatters Field formatters for results
       */

    }, {
      key: "from",
      value: function from(modules, urls, formatters) {
        var sections = [];

        if (!modules) {
          return sections;
        }

        if (!Array.isArray(modules)) {
          return new Section(modules, null, formatters);
        } // Our sections should contain a property of mapMarker objects


        for (var i = 0; i < modules.length; i++) {
          sections.push(new Section(modules[i], urls[modules[i].verticalConfigId], formatters));
        }

        return sections;
      }
    }]);

    return Section;
  }();

  var AppliedQueryFilter =
  /*#__PURE__*/
  function () {
    // Support legacy model and new model until fully migrated.
    // TODO(billy) Remove the left expression during assignment when migrated.
    function AppliedQueryFilter(appliedQueryFilter) {
      _classCallCheck(this, AppliedQueryFilter);

      this.key = appliedQueryFilter.key || appliedQueryFilter.displayKey;
      this.value = appliedQueryFilter.value || appliedQueryFilter.displayValue;
    }

    _createClass(AppliedQueryFilter, null, [{
      key: "from",
      value: function from(appliedQueryFilters) {
        var filters = [];

        for (var i = 0; i < appliedQueryFilters.length; i++) {
          filters.push(new AppliedQueryFilter(appliedQueryFilters[i]));
        }

        return filters;
      }
    }]);

    return AppliedQueryFilter;
  }();

  var UniversalResults =
  /*#__PURE__*/
  function () {
    function UniversalResults(data) {
      _classCallCheck(this, UniversalResults);

      this.queryId = data.queryId || null;
      this.sections = data.sections || [];
      /**
       * The current state of the search, used to render different templates before, during,
       * and after loading
       * @type {string}
       */

      this.searchState = data.searchState || SearchStates.SEARCH_COMPLETE;
    }
    /**
     * Create universal results from server data
     * @param {Object} response The server response
     * @param {Object} urls The tab urls
     * @param {Object.<string, function>} formatters The field formatters to use
     */


    _createClass(UniversalResults, null, [{
      key: "from",
      value: function from(response, urls, formatters) {
        return new UniversalResults({
          queryId: response.queryId,
          sections: Section.from(response.modules, urls, formatters)
        });
      }
      /**
       * Construct a UnivervalResults object representing loading results
       * @return {UniversalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new UniversalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }]);

    return UniversalResults;
  }();

  /** @module DirectAnswer */
  var DirectAnswer =
  /*#__PURE__*/
  function () {
    function DirectAnswer() {
      var directAnswer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, DirectAnswer);

      Object.assign(this, directAnswer);
      Object.freeze(this);
    }
    /**
     * Create a DirectAnswer model from the given server data and formatters
     * @param {Object} response The server direct answer
     * @param {Object.<string, function>} formatters The formatters to apply to this direct answer
     */


    _createClass(DirectAnswer, null, [{
      key: "from",
      value: function from(response, formatters) {
        var data = _objectSpread({}, response);

        var answer = data.answer,
            relatedItem = data.relatedItem;

        if (answer && formatters[answer.fieldApiName]) {
          answer.value = formatters[answer.fieldApiName](answer.value, relatedItem.data.fieldValues, relatedItem.verticalConfigId, true);
        }

        return new DirectAnswer(data);
      }
    }]);

    return DirectAnswer;
  }();

  /** @module Navigation */
  var Navigation =
  /*#__PURE__*/
  function () {
    function Navigation(tabOrder) {
      _classCallCheck(this, Navigation);

      this.tabOrder = tabOrder || [];
      Object.freeze(this);
    }

    _createClass(Navigation, null, [{
      key: "from",
      value: function from(modules) {
        var nav = [];

        if (!modules || !Array.isArray(modules)) {
          return nav;
        }

        for (var i = 0; i < modules.length; i++) {
          nav.push(modules[i].verticalConfigId);
        }

        return new Navigation(nav);
      }
    }]);

    return Navigation;
  }();

  /** @module ResultsContext */

  /**
   * ResultsContext is an ENUM that provides context
   * for the results that we are storing from server
   * data
   * @enum {string}
   */
  var ResultsContext = {
    NORMAL: 'normal',
    NO_RESULTS: 'no-results'
  };

  var VerticalResults =
  /*#__PURE__*/
  function () {
    function VerticalResults() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, VerticalResults);

      Object.assign(this, {
        searchState: SearchStates.SEARCH_COMPLETE
      }, data);
      /**
       * The context of the results, used to provide more information about why
       * these specific results were returned.
       * @type {ResultsContext}
       */

      this.resultsContext = data.resultsContext;
      Object.freeze(this);
    }
    /**
     * Append the provided results to the current results
     * @param {VerticalResults} results the results to append to the current results
     */


    _createClass(VerticalResults, [{
      key: "append",
      value: function append(results) {
        if (results.resultsContext !== this.resultsContext) {
          throw new AnswersCoreError('Cannot merge results with different contexts', 'VerticalResults');
        }

        var merged = _objectSpread({}, this);

        merged.resultsContext = this.resultsContext;
        merged.results = this.results.concat(results.results);
        merged.map.mapMarkers = this.map.mapMarkers.concat(results.map.mapMarkers);
        return new VerticalResults(merged);
      }
      /**
       * Form response as if the results from `allResultsForVertical` were the actual
       * results in `results`
       * @param {Object} response The server response
       */

    }], [{
      key: "_formResponseFromAllResultsForVertical",
      value: function _formResponseFromAllResultsForVertical(response) {
        var _ref = response.allResultsForVertical || {},
            results = _ref.results,
            resultsCount = _ref.resultsCount,
            facets = _ref.facets;

        return _objectSpread({}, response, {
          results: results || [],
          resultsCount: resultsCount || 0,
          facets: facets
        });
      }
      /**
       * Create vertical results from server data
       * @param {Object} response The server response
       * @param {Object.<string, function>} formatters The field formatters to use
       */

    }, {
      key: "from",
      value: function from(response, formatters, verticalKey) {
        var hasResults = response.results && response.results.length > 0;

        if (!hasResults) {
          var data = Section.from(VerticalResults._formResponseFromAllResultsForVertical(response), null, formatters);
          return new VerticalResults(_objectSpread({}, data, {
            verticalConfigId: verticalKey,
            resultsContext: ResultsContext.NO_RESULTS
          }));
        } else {
          var _data = Section.from(response, null, formatters);

          return new VerticalResults(_objectSpread({}, _data, {
            verticalConfigId: verticalKey,
            resultsContext: ResultsContext.NORMAL
          }));
        }
      }
      /**
       * Construct a VerticalResults object representing loading results
       * @return {VerticalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new VerticalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }]);

    return VerticalResults;
  }();

  /** @module SpellCheck */

  /**
   * SpellCheck is the core state model
   * to power the SpellCheck component
   */
  var SpellCheck =
  /*#__PURE__*/
  function () {
    function SpellCheck(data) {
      _classCallCheck(this, SpellCheck);

      /**
       * The original query
       * @type {string}
       */
      this.query = data.query || null;
      /**
       * The corrected query
       * @type {string}
       */

      this.correctedQuery = data.correctedQuery || null;
      /**
       * The spell check type
       * @type {string}
       */

      this.type = data.type || null;
      /**
       * Should show spell check or not
       * @type {boolean}
       */

      this.shouldShow = this.correctedQuery !== null;
    }
    /**
     * Create a spell check model from the provided data
     * @param {Object} response The spell check response
     */


    _createClass(SpellCheck, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return {};
        }

        return new SpellCheck({
          query: response.originalQuery,
          correctedQuery: response.correctedQuery,
          type: response.type
        });
      }
    }]);

    return SpellCheck;
  }();

  /** @module StorageKeys */

  /**
   * StorageKeys is an ENUM are considered the root context
   * for how data is stored and scoped in the storage.
   *
   * @enum {string}
   */
  var StorageKeys = {
    NAVIGATION: 'navigation',
    UNIVERSAL_RESULTS: 'universal-results',
    VERTICAL_RESULTS: 'vertical-results',
    ALTERNATIVE_VERTICALS: 'alternative-verticals',
    AUTOCOMPLETE: 'autocomplete',
    DIRECT_ANSWER: 'direct-answer',
    FILTER: 'filter',
    QUERY: 'query',
    QUERY_ID: 'query-id',
    FACET_FILTER: 'facet-filter',
    DYNAMIC_FILTERS: 'dynamic-filters',
    PARAMS: 'params',
    GEOLOCATION: 'geolocation',
    INTENTS: 'intents',
    QUESTION_SUBMISSION: 'question-submission',
    SEARCH_CONFIG: 'search-config',
    SEARCH_OFFSET: 'search-offset',
    SPELL_CHECK: 'spell-check',
    LOCATION_BIAS: 'location-bias',
    SESSIONS_OPT_IN: 'sessions-opt-in',
    VERTICAL_PAGES_CONFIG: 'vertical-pages-config',
    LOCALE: 'locale',
    SORT_BYS: 'sort-bys',
    NO_RESULTS_CONFIG: 'no-results-config'
  };

  /** @module DynamicFilters */

  /**
   * Model representing a set of dynamic filters
   */
  var DynamicFilters =
  /*#__PURE__*/
  function () {
    function DynamicFilters(data) {
      _classCallCheck(this, DynamicFilters);

      /**
       * The list of filters this model holds
       * @type {{label: string, fieldId: string, options: object[]}}
       */
      this.filters = data.filters || [];
      Object.freeze(this);
    }
    /**
     * Organize 'facets' from the api response into dynamic filters
     * @param {Object} response dynamic filter response from the api
     * @returns {DynamicFilters}
     */


    _createClass(DynamicFilters, null, [{
      key: "from",
      value: function from(response) {
        var facets = response.resultsCount === 0 && response.allResultsForVertical ? response.allResultsForVertical.facets : response.facets;
        var dynamicFilters = facets.map(function (f) {
          return {
            label: f['displayName'],
            fieldId: f['fieldId'],
            options: f.options.map(function (o) {
              return {
                label: o['displayName'],
                countLabel: o['count'],
                selected: o['selected'],
                filter: o['filter']
              };
            })
          };
        });
        return new DynamicFilters({
          filters: dynamicFilters
        });
      }
    }]);

    return DynamicFilters;
  }();

  /** @module SearchIntents */
  var SearchIntents =
  /*#__PURE__*/
  function () {
    function SearchIntents(intents) {
      _classCallCheck(this, SearchIntents);

      /**
       * The intent to find results based on the user's location
       * @type {boolean}
       */
      this.nearMe = intents.nearMe;
      Object.freeze(this);
    }
    /**
     * Create SearchIntents from server response
     * @param {Object} response The server response intents
     * @returns {SearchIntents}
     */


    _createClass(SearchIntents, null, [{
      key: "from",
      value: function from(response) {
        var intents = response || [];
        return new SearchIntents({
          nearMe: intents.includes('NEAR_ME')
        });
      }
    }]);

    return SearchIntents;
  }();

  /** @module LocationBias */

  /**
   * LocationBias is the core state model
   * to power the LocationBias component
   */
  var LocationBias =
  /*#__PURE__*/
  function () {
    function LocationBias(data) {
      _classCallCheck(this, LocationBias);

      /**
       * The location bias accuracy which are IP, DEVICE and UNKNWON
       * @type {string}
       */
      this.accuracy = data.accuracy || null;
      /**
       * The latitude used for location bias
       * @type {number}
       */

      this.latitude = data.latitude || null;
      /**
       * The longitude used for location bias
       * @type {number}
       */

      this.longitude = data.longitude || null;
      /**
       * The location display name
       * @type {string}
       */

      this.locationDisplayName = data.locationDisplayName || null;
    }
    /**
     * Create a location bias model from the provided data
     * @param {Object} response The location bias response
     */


    _createClass(LocationBias, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return new LocationBias({
            accuracy: 'UNKNOWN'
          });
        }

        return new LocationBias({
          accuracy: response.accuracy,
          latitude: response.latitude,
          longitude: response.longitude,
          locationDisplayName: response.locationDisplayName
        });
      }
    }]);

    return LocationBias;
  }();

  var AlternativeVerticals =
  /*#__PURE__*/
  function () {
    function AlternativeVerticals(data) {
      _classCallCheck(this, AlternativeVerticals);

      /**
       * Alternative verticals that have results for the current query
       * @type {Section}
       */
      this.alternativeVerticals = data || [];
    }
    /**
     * Create alternative verticals from server data
     * @param {Object} response The server response
     * @param {Object.<string, function>} formatters The field formatters to use
     */


    _createClass(AlternativeVerticals, null, [{
      key: "from",
      value: function from(response, formatters) {
        var alternativeVerticals = response.alternativeVerticals;

        if (!alternativeVerticals || !alternativeVerticals.modules) {
          return new AlternativeVerticals();
        }

        return new AlternativeVerticals(Section.from(alternativeVerticals.modules, {}, formatters));
      }
    }]);

    return AlternativeVerticals;
  }();

  /**
   * A Data Transformer that takes the response object from a Search request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   */

  var SearchDataTransformer =
  /*#__PURE__*/
  function () {
    function SearchDataTransformer() {
      _classCallCheck(this, SearchDataTransformer);
    }

    _createClass(SearchDataTransformer, null, [{
      key: "transform",
      value: function transform(data) {
        var _ref;

        var urls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var formatters = arguments.length > 2 ? arguments[2] : undefined;
        var response = data.response;
        return _ref = {}, _defineProperty(_ref, StorageKeys.QUERY_ID, response.queryId), _defineProperty(_ref, StorageKeys.NAVIGATION, Navigation.from(response.modules)), _defineProperty(_ref, StorageKeys.DIRECT_ANSWER, DirectAnswer.from(response.directAnswer, formatters)), _defineProperty(_ref, StorageKeys.UNIVERSAL_RESULTS, UniversalResults.from(response, urls, formatters)), _defineProperty(_ref, StorageKeys.INTENTS, SearchIntents.from(response.searchIntents)), _defineProperty(_ref, StorageKeys.SPELL_CHECK, SpellCheck.from(response.spellCheck)), _defineProperty(_ref, StorageKeys.LOCATION_BIAS, LocationBias.from(response.locationBias)), _ref;
      }
    }, {
      key: "transformVertical",
      value: function transformVertical(data, formatters, verticalKey) {
        var _ref2;

        // TODO (tmeyer): SPR-1923, centralize the allResultsForVertical parsing here.
        return _ref2 = {}, _defineProperty(_ref2, StorageKeys.QUERY_ID, data.response.queryId), _defineProperty(_ref2, StorageKeys.NAVIGATION, new Navigation()), _defineProperty(_ref2, StorageKeys.VERTICAL_RESULTS, VerticalResults.from(data.response, formatters, verticalKey)), _defineProperty(_ref2, StorageKeys.DYNAMIC_FILTERS, DynamicFilters.from(data.response)), _defineProperty(_ref2, StorageKeys.INTENTS, SearchIntents.from(data.response.searchIntents)), _defineProperty(_ref2, StorageKeys.SPELL_CHECK, SpellCheck.from(data.response.spellCheck)), _defineProperty(_ref2, StorageKeys.ALTERNATIVE_VERTICALS, AlternativeVerticals.from(data.response, formatters)), _defineProperty(_ref2, StorageKeys.LOCATION_BIAS, LocationBias.from(data.response.locationBias)), _ref2;
      }
    }]);

    return SearchDataTransformer;
  }();

  /** @module QuestionSubmission */

  /**
   * QuestionSubmission is the core state model
   * to power the QuestionSubmission component
   */
  var QuestionSubmission =
  /*#__PURE__*/
  function () {
    function QuestionSubmission() {
      var question = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var errors = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, QuestionSubmission);

      /**
       * The author of the question
       * @type {string}
       */
      this.name = question.name || null;
      /**
       * The email address of the question
       * @type {string}
       */

      this.email = question.email || null;
      /**
       * True if the privacy policy was approved
       * @type {boolean}
       */

      this.privacyPolicy = question.privacyPolicy || null;
      /**
       * The question to be sent to the server
       * @type {string}
       */

      this.questionText = question.questionText || null;
      /**
       * Alternative question meta information
       * @type {string}
       */

      this.questionDescription = question.questionDescription || null;
      /**
       * Whether the form is expanded or not. Defaults to true.
       */

      this.questionExpanded = typeof question.expanded !== 'boolean' || question.expanded;
      /**
       * Contains any errors about the question submission
       * @type {object}
       */

      this.errors = errors || null;
      /**
       * Whether the form has been submitted or not. Defaults to false.
       */

      this.questionSubmitted = question.submitted || false;
      Object.freeze(this);
    }

    _createClass(QuestionSubmission, null, [{
      key: "submitted",
      value: function submitted() {
        return {
          questionSubmitted: true,
          questionExpanded: true
        };
      }
    }, {
      key: "errors",
      value: function errors(question, _errors) {
        return QuestionSubmission(question, _errors);
      }
    }]);

    return QuestionSubmission;
  }();

  /** @module Filter */

  /**
   * Represents an api filter and provides static methods for easily constructing Filters.
   * See https://developer.yext.com/docs/api-reference/#operation/listEntities for structure details
   */
  var Filter =
  /*#__PURE__*/
  function () {
    function Filter() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Filter);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Parse a JSON format filter returned from the server into a Filter
     * @param {*} responseFilter A filter in JSON format returned from the backend
     * @returns {Filter}
     */


    _createClass(Filter, null, [{
      key: "fromResponse",
      value: function fromResponse(responseFilter) {
        return new Filter(JSON.parse(responseFilter));
      }
      /**
       * Return a new Filter representing the OR of all provided filters
       * @param  {...Filter} filters The filters to OR together
       * @returns {Filter}
       */

    }, {
      key: "or",
      value: function or() {
        for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
          filters[_key] = arguments[_key];
        }

        return new Filter({
          '$or': filters
        });
      }
      /**
       * Return a new Filter representing the AND of all provided filters
       * @param  {...Filter} filters The filters to AND together
       * @returns {Filter}
       */

    }, {
      key: "and",
      value: function and() {
        for (var _len2 = arguments.length, filters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          filters[_key2] = arguments[_key2];
        }

        return new Filter({
          '$and': filters
        });
      }
      /**
       * OR filters with the same keys, then AND the resulting groups
       * @param  {...Filter} filters The filters to group
       * @returns {Filter}
       */

    }, {
      key: "group",
      value: function group() {
        var groups = {};

        for (var _len3 = arguments.length, filters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          filters[_key3] = arguments[_key3];
        }

        for (var _i = 0, _filters = filters; _i < _filters.length; _i++) {
          var filter = _filters[_i];
          var key = Object.keys(filter)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(filter);
        }

        var groupFilters = [];

        for (var _i2 = 0, _Object$keys = Object.keys(groups); _i2 < _Object$keys.length; _i2++) {
          var field = _Object$keys[_i2];
          groupFilters.push(groups[field].length > 1 ? Filter.or.apply(Filter, _toConsumableArray(groups[field])) : groups[field][0]);
        }

        return groupFilters.length > 1 ? Filter.and.apply(Filter, groupFilters) : groupFilters[0];
      }
      /**
       * Create a new "equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be equal to
       * @returns {Filter}
       */

    }, {
      key: "equal",
      value: function equal(field, value) {
        return Filter._fromMatcher(field, '$eq', value);
      }
      /**
       * Create a new "less than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than
       * @returns {Filter}
       */

    }, {
      key: "lessThan",
      value: function lessThan(field, value) {
        return Filter._fromMatcher(field, '$lt', value);
      }
      /**
       * Create a new "less than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than or equal to
       * @returns {Filter}
       */

    }, {
      key: "lessThanEqual",
      value: function lessThanEqual(field, value) {
        return Filter._fromMatcher(field, '$le', value);
      }
      /**
       * Create a new "greater than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than
       * @returns {Filter}
       */

    }, {
      key: "greaterThan",
      value: function greaterThan(field, value) {
        return Filter._fromMatcher(field, '$gt', value);
      }
      /**
       * Create a new "greater than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than or equal to
       * @returns {Filter}
       */

    }, {
      key: "greaterThanEqual",
      value: function greaterThanEqual(field, value) {
        return Filter._fromMatcher(field, '$ge', value);
      }
      /**
       * Create a new inclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "inclusiveRange",
      value: function inclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$ge': min,
          '$le': max
        }));
      }
      /**
       * Create a new exclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "exclusiveRange",
      value: function exclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$gt': min,
          '$lt': max
        }));
      }
      /**
       * Create a new position filter
       * @param {number} lat The latitude of the position
       * @param {number} lng The longitude of the position
       * @param {number} radius The search radius (in meters)
       */

    }, {
      key: "position",
      value: function position(lat, lng, radius) {
        return Filter._fromMatcher('builtin.location', '$near', {
          lat: lat,
          lng: lng,
          radius: radius
        });
      }
      /**
       * Create a new filter with the given matcher
       * @private
       * @param {string} field The subject field of the filter
       * @param {string} matcher The matcher for the filer
       * @param {*} value The value for the filter
       * @returns {Filter}
       */

    }, {
      key: "_fromMatcher",
      value: function _fromMatcher(field, matcher, value) {
        return new Filter(_defineProperty({}, field, _defineProperty({}, matcher, value)));
      }
    }]);

    return Filter;
  }();

  /** @typedef {import('./services/searchservice').default} SearchService */

  /** @typedef {import('./services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./services/questionanswerservice').default} QuestionAnswerService */

  /**
   * Core is the main application container for all of the network and storage
   * related behaviors of the application.
   */

  var Core =
  /*#__PURE__*/
  function () {
    function Core() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Core);

      /**
       * A reference to the client API Key used for all requests
       * @type {string}
       * @private
       */
      this._apiKey = config.apiKey;
      /**
       * A reference to the client Answers Key used for all requests
       * @type {string}
       * @private
       */

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * A reference to the client locale used for all requests. If not specified, defaults to "en" (for
       * backwards compatibility).
       * @type {string}
       * @private
       */

      this._locale = config.locale;
      /**
       * A map of field formatters used to format results, if present
       * @type {Object.<string, function>}
       * @private
       */

      this._fieldFormatters = config.fieldFormatters || {};
      /**
       * A reference to the core data storage that powers the UI
       * @type {GlobalStorage}
       * @private
       */

      this.globalStorage = config.globalStorage;
      /**
       * A reference to the core persistent storage
       * @type {PersistentStorage}
       * @private
       */

      this.persistentStorage = config.persistentStorage;
      /**
       * An abstraction containing the integration with the RESTful search API
       * For both vertical and universal search
       * @type {SearchService}
       * @private
       */

      this._searcher = config.searchService;
      /**
       * An abstraction containing the integration with the RESTful autocomplete API
       * For filter search, vertical autocomplete, and universal autocomplete
       * @type {AutoCompleteService}
       * @private
       */

      this._autoComplete = config.autoCompleteService;
      /**
       * An abstraction for interacting with the Q&A rest interface
       * @type {QuestionAnswerService}
       * @private
       */

      this._questionAnswer = config.questionAnswerService;
    }
    /**
     * Search in the context of a vertical
     * @param {string} verticalKey vertical ID for the search
     * @param {object} query The query details
     * @param {string} query.input The input to search for
     * @param {string} query.filter The filter to use in the search
     * @param {string} query.facetFilter The facet filter to use in the search
     * @param {number} query.limit The max number of results to include, max of 50
     * @param {number} query.offset The results offset, for fetching more results of the same query
     * @param {string} query.id The query ID to use. If paging within a query, the same ID should be used
     * @param {boolean} query.append If true, adds the results of this query to the end of the current results, defaults false
     */


    _createClass(Core, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, query) {
        var _this = this;

        if (!query.append) {
          this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading());
          this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
          this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        }

        return this._searcher.verticalSearch(verticalKey, _objectSpread({
          limit: this.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit,
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION)
        }, query, {
          isDynamicFiltersEnabled: this._isDynamicFiltersEnabled,
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN),
          sortBys: this.globalStorage.getState(StorageKeys.SORT_BYS)
        })).then(function (response) {
          return SearchDataTransformer.transformVertical(response, _this._fieldFormatters, verticalKey);
        }).then(function (data) {
          _this.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          _this.globalStorage.set(StorageKeys.ALTERNATIVE_VERTICALS, data[StorageKeys.ALTERNATIVE_VERTICALS]);

          if (query.append) {
            var mergedResults = _this.globalStorage.getState(StorageKeys.VERTICAL_RESULTS).append(data[StorageKeys.VERTICAL_RESULTS]);

            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, mergedResults);
          } else {
            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, data[StorageKeys.VERTICAL_RESULTS]);
          }

          if (data[StorageKeys.DYNAMIC_FILTERS]) {
            _this.globalStorage.set(StorageKeys.DYNAMIC_FILTERS, data[StorageKeys.DYNAMIC_FILTERS]);
          }

          if (data[StorageKeys.SPELL_CHECK]) {
            _this.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);
          }

          if (data[StorageKeys.LOCATION_BIAS]) {
            _this.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);
          }

          _this.globalStorage["delete"]('skipSpellCheck');

          _this.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Page within the results of the last query
       * @param {string} verticalKey The vertical key to use in the search
       * @param {number} offset The offset to use in the search
       */

    }, {
      key: "verticalPage",
      value: function verticalPage(verticalKey, offset) {
        var allFilters = this.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var facetFilter = this.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.verticalSearch(verticalKey, {
          input: this.globalStorage.getState(StorageKeys.QUERY),
          id: this.globalStorage.getState(StorageKeys.QUERY_ID),
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter),
          offset: offset
        });
      }
    }, {
      key: "search",
      value: function search(queryString, urls) {
        var _this2 = this;

        this.globalStorage.set(StorageKeys.DIRECT_ANSWER, {});
        this.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
        this.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, {});
        this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
        this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        return this._searcher.universalSearch(queryString, {
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION),
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        }).then(function (response) {
          return SearchDataTransformer.transform(response, urls, _this2._fieldFormatters);
        }).then(function (data) {
          _this2.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this2.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this2.globalStorage.set(StorageKeys.DIRECT_ANSWER, data[StorageKeys.DIRECT_ANSWER]);

          _this2.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, data[StorageKeys.UNIVERSAL_RESULTS], urls);

          _this2.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          _this2.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);

          _this2.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);

          _this2.globalStorage["delete"]('skipSpellCheck');

          _this2.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Given an input, query for a list of similar results and set into storage
       *
       * @param {string} input     the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       */

    }, {
      key: "autoCompleteUniversal",
      value: function autoCompleteUniversal(input, namespace) {
        var _this3 = this;

        return this._autoComplete.queryUniversal(input).then(function (data) {
          _this3.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);

          return data;
        });
      }
      /**
       * Given an input, query for a list of similar results in the provided vertical
       * and set into storage
       *
       * @param {string} input       the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       * @param {string} verticalKey the vertical key for the experience
       */

    }, {
      key: "autoCompleteVertical",
      value: function autoCompleteVertical(input, namespace, verticalKey) {
        var _this4 = this;

        return this._autoComplete.queryVertical(input, verticalKey).then(function (data) {
          _this4.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);

          return data;
        });
      }
      /**
       * Given an input, provide a list of suitable filters for autocompletion
       *
       * @param {string} input  the string to search for filters with
       * @param {object} config  the config to serach for filters with
       * @param {string} config.namespace  the namespace to use for the storage key
       * @param {string} config.verticalKey the vertical key for the config
       * @param {object} config.searchParameters  the search parameters for the config v2
       */

    }, {
      key: "autoCompleteFilter",
      value: function autoCompleteFilter(input, config) {
        var _this5 = this;

        return this._autoComplete.queryFilter(input, config).then(function (data) {
          _this5.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(config.namespace), data);
        });
      }
      /**
       * Submits a question to the server and updates the underlying question model
       * @param {object} question The question object to submit to the server
       * @param {number} question.entityId The entity to associate with the question (required)
       * @param {string} question.lanuage The language of the question
       * @param {string} question.site The "publisher" of the (e.g. 'FIRST_PARTY')
       * @param {string} question.name The name of the author
       * @param {string} question.email The email address of the author
       * @param {string} question.questionText The question
       * @param {string} question.questionDescription Additional information about the question
       */

    }, {
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var _this6 = this;

        return this._questionAnswer.submitQuestion(question).then(function (data) {
          _this6.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, QuestionSubmission.submitted());
        });
      }
      /**
       * Stores the given sortBy into storage, to be used for the next search
       * @param {Object} sortByOptions
       */

    }, {
      key: "setSortBys",
      value: function setSortBys() {
        for (var _len = arguments.length, sortByOptions = new Array(_len), _key = 0; _key < _len; _key++) {
          sortByOptions[_key] = arguments[_key];
        }

        var sortBys = sortByOptions.map(function (option) {
          return {
            type: option.type,
            field: option.field,
            direction: option.direction
          };
        });
        this.globalStorage.set(StorageKeys.SORT_BYS, JSON.stringify(sortBys));
      }
      /**
       * Clears the sortBys key in global storage.
       */

    }, {
      key: "clearSortBys",
      value: function clearSortBys() {
        this.globalStorage["delete"](StorageKeys.SORT_BYS);
      }
      /**
       * Stores the given query into storage, to be used for the next search
       * @param {string} query the query to store
       */

    }, {
      key: "setQuery",
      value: function setQuery(query) {
        this.globalStorage.set(StorageKeys.QUERY, query);
      }
      /**
       * Stores the provided query ID, to be used in analytics
       * @param {string} queryId The query id to store
       */

    }, {
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this.globalStorage.set(StorageKeys.QUERY_ID, queryId);
      }
      /**
       * Stores the given filter into storage, to be used for the next search
       *
       * @param {string} namespace the namespace to use for the storage key
       * @param {Filter} filter    the filter to set
       */

    }, {
      key: "setFilter",
      value: function setFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "setFacetFilter",
      value: function setFacetFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FACET_FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "enableDynamicFilters",
      value: function enableDynamicFilters() {
        this._isDynamicFiltersEnabled = true;
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        return this.globalStorage.on(evt, moduleId, cb);
      }
    }]);

    return Core;
  }();

  /** @module DOM */

  /* global HTMLElement, HTMLDocument, Window, Event, Element */
  var document$1 = window.document;
  /**
   * Static interface for interacting with the DOM API.
   * @namespace
   */

  var DOM =
  /*#__PURE__*/
  function () {
    function DOM() {
      _classCallCheck(this, DOM);
    }

    _createClass(DOM, null, [{
      key: "setup",
      value: function setup(d, p) {
        document$1 = d;
      }
      /**
       * create a HTMLElement from and HTML string
       * @param {string} html The HTML to parse to a DOM node.
       * @return {HTMLElement}
       */

    }, {
      key: "create",
      value: function create(html) {
        if ('createRange' in document$1) {
          // prefer this implementation as it has wider browser support
          // and it's better performing.
          // see https://davidwalsh.name/convert-html-stings-dom-nodes
          var container = document$1.createElement('div');
          var frag = document$1.createRange().createContextualFragment(html);
          container.appendChild(frag);
          return container;
        } // fallback to this because of a bug in jsdom that causes tests to fail
        // see: https://github.com/jsdom/jsdom/issues/399


        return new DOMParser().parseFromString(html, 'text/html').body;
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {HTMLElement} the FIRST node it finds, if any
       */

    }, {
      key: "query",
      value: function query(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof Window || selector instanceof HTMLDocument) {
          return selector;
        }

        return parent.querySelector(selector);
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {Array} the FIRST node it finds, if any
       */

    }, {
      key: "queryAll",
      value: function queryAll(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        } // handle the case where client code is using a pointer to a dom node and it's null, e.g. this._container


        if (parent == null) {
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof Window) {
          return [selector];
        }

        return Array.from(parent.querySelectorAll(selector));
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        if (document$1.readyState === 'complete' || document$1.readyState === 'loaded' || document$1.readyState === 'interactive') {
          cb();
          return;
        }

        DOM.on(document$1, 'DOMContentLoaded', cb);
      }
      /**
       * createEle will create a {HTMLElement} and apply the properties attributes through an object provided.
       * @param {string} el The element `tag` name to construct
       * @param {Object} opts_data Optional attributes to apply to the new HTMLElement
       */

    }, {
      key: "createEl",
      value: function createEl(el) {
        var opts_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var node = document$1.createElement(el);
        var props = Object.keys(opts_data);

        for (var i = 0; i < props.length; i++) {
          if (props[i] === 'class') {
            DOM.addClass(node, opts_data[props[i]]);
            continue;
          }

          node[props[i]] = opts_data[props[i]];
        }

        return node;
      }
    }, {
      key: "append",
      value: function append(parent, node) {
        if (node === undefined) {
          node = parent;
          parent = document$1;
        }

        if (typeof parent === 'string') {
          parent = DOM.query(parent);
        } // Support HTML injection as well as HTMLElement appends


        if (typeof node === 'string') {
          parent.insertAdjacentHTML('afterBegin', node);
        } else {
          parent.appendChild(node);
        }
      }
    }, {
      key: "addClass",
      value: function addClass(node, className) {
        if (!node) {
          return;
        }

        var classes = className.split(',');
        var len = classes.length;

        for (var i = 0; i < len; i++) {
          node.classList.add(classes[i]);
        }
      }
    }, {
      key: "empty",
      value: function empty(parent) {
        parent.innerHTML = '';
      }
    }, {
      key: "css",
      value: function css(selector, styles) {
        var node = DOM.query(selector);

        for (var prop in styles) {
          node.style[prop] = styles[prop];
        }
      }
    }, {
      key: "attr",
      value: function attr(selector, _attr, val) {
        DOM.query(selector).setAttribute(_attr, val);
      }
    }, {
      key: "attributes",
      value: function attributes(selector, attrs) {
        var _this = this;

        Object.entries(attrs).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              attr = _ref2[0],
              val = _ref2[1];

          return _this.attr(selector, attr, val);
        });
      }
    }, {
      key: "trigger",
      value: function trigger(selector, event, settings) {
        var e = DOM._customEvent(event, settings);

        DOM.query(selector).dispatchEvent(e);
      } // TODO (agrow) investigate removing this
      // Event constructor polyfill

    }, {
      key: "_customEvent",
      value: function _customEvent(event, settings) {
        if (typeof window.CustomEvent === 'function') {
          return new Event(event, Object.assign({
            'bubbles': true,
            'cancelable': true
          }, settings || {}));
        }

        settings = settings || {
          bubbles: false,
          cancelable: false,
          detail: null
        };
        var evt = document$1.createEvent('CustomEvent');
        evt.initCustomEvent(event, settings.bubbles, settings.cancelable, settings.detail);
        return evt;
      }
    }, {
      key: "on",
      value: function on(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler);
      }
    }, {
      key: "once",
      value: function once(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler, {
          once: true
        });
      }
    }, {
      key: "off",
      value: function off(selector, evt, handler) {
        DOM.query(selector).removeEventListener(evt, handler);
      }
    }, {
      key: "delegate",
      value: function delegate(ctxt, selector, evt, handler) {
        var el = DOM.query(ctxt);
        el.addEventListener(evt, function (event) {
          var target = event.target;

          while (!target.isEqualNode(el)) {
            if (DOM.matches(target, selector)) {
              handler(event, target);
              break;
            }

            target = target.parentNode;
          }
        });
      } // TODO (agrow) investigate removing this
      // Element.matches polyfill

    }, {
      key: "matches",
      value: function matches(element, potentialMatch) {
        if (Element.prototype.matches) {
          return element.matches(potentialMatch);
        }

        if (Element.prototype.msMatchesSelector) {
          return element.msMatchesSelector(potentialMatch);
        }

        if (Element.prototype.webkitMatchesSelector) {
          return element.webkitMatchesSelector(potentialMatch);
        }
      }
    }]);

    return DOM;
  }();

  /** @module SearchParams */

  /* global window */

  /**
   * SearchParams is a class to get the search params in a URL.
   * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
   */
  var SearchParams =
  /*#__PURE__*/
  function () {
    function SearchParams(url) {
      _classCallCheck(this, SearchParams);

      /**
       * Mapping of all query parameters in the given url, query param -> value
       * Only used if URLSearchParams does not exist in the window
       * @type {Object}
       * @private
       */
      this._params = {};

      if (window && window.URLSearchParams) {
        return new URLSearchParams(url);
      } else {
        this._params = this.parse(url);
      }
    }
    /**
     * parse creates a mapping of all query params in a given url
     * The query param values are decoded before being put in the map
     * Three types of input are supported
     *   (1) full URL e.g. http://www.yext.com/?q=hello
     *   (2) params with ? e.g. ?q=hello
     *   (1) params without ? e.g. q=hello
     * @param {string} url The url
     * @returns {Object} mapping from query param -> value where value is '' if no value is provided
     */


    _createClass(SearchParams, [{
      key: "parse",
      value: function parse(url) {
        var params = {};
        var search = url;

        if (search === '') {
          return params;
        } // Normalize all url inputs to string of query params separated by &


        if (url.indexOf('?') > -1) {
          search = url.slice(url.indexOf('?') + 1);
        }

        var encodedParams = search.split('&');

        for (var i = 0; i < encodedParams.length; i++) {
          var keyVal = encodedParams[i].split('=');

          if (keyVal.length > 1) {
            params[keyVal[0]] = SearchParams.decode(keyVal[1]);
          } else {
            params[keyVal[0]] = '';
          }
        }

        return params;
      }
      /**
       * get returns the value of the given query param
       * @param {string} query the query param key to get the value of
       * @return {string} param value, null otherwise
       */

    }, {
      key: "get",
      value: function get(query) {
        if (typeof this._params[String(query)] === 'undefined') {
          return null;
        }

        return this._params[query];
      }
      /**
       * set changes the value of a given query param
       * @param {string} name the query param key
       * @param {string} value the value of the query param update with
       */

    }, {
      key: "set",
      value: function set(name, value) {
        this._params[String(name)] = String(value);
      }
      /**
       * has checks to see if the given query param key exists in the params object
       * @param {string} query the query param to check
       * @return {boolean} true if the query param is in the params object, false o/w
       */

    }, {
      key: "has",
      value: function has(query) {
        return query in this._params;
      }
      /**
       * delete removes the given query param and its associated value from the params object
       * @param {string} name the query param key
       */

    }, {
      key: "delete",
      value: function _delete(name) {
        delete this._params[String(name)];
      }
      /**
       * toString returns a url with all the query params in the params object (without a ?)
       * @return {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        var string = [];

        for (var key in this._params) {
          string.push("".concat(key, "=").concat(SearchParams.encode(this._params[key])));
        }

        return string.join('&');
      }
    }, {
      key: "entries",
      value: function entries() {
        var entries = [];

        for (var key in this._params) {
          entries.push([key, this._params[key]]);
        }

        return entries;
      }
      /**
       * decode returns the decoded representation of the given string
       * @param {string} string the string to decode
       * @return {string}
       */

    }], [{
      key: "decode",
      value: function decode(string) {
        return decodeURIComponent(string.replace(/[ +]/g, '%20'));
      }
      /**
       * decode returns the encoded representation of the given string (e.g. + -> %2B)
       * @param {string} string the string to encode
       * @return {string}
       */

    }, {
      key: "encode",
      value: function encode(string) {
        var replace = {
          '!': '%21',
          "'": '%27',
          '(': '%28',
          ')': '%29',
          '%20': '+'
        };
        return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
          return replace[match];
        });
      }
    }]);

    return SearchParams;
  }();

  /** @module Renderer */

  /**
   * Renderer is an abstract class that all Renderers should extend and implement
   */
  var Renderer =
  /*#__PURE__*/
  function () {
    function Renderer() {
      _classCallCheck(this, Renderer);
    }

    _createClass(Renderer, [{
      key: "render",

      /**
       * render is a core method for all renderers.
       * All implementations should override this class
       * @param {string} template
       * @param {object} data
       */
      value: function render(template, data) {
        return template;
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {}
    }, {
      key: "compile",
      value: function compile(template) {}
    }]);

    return Renderer;
  }();

  var SVGIcon =
  /*#__PURE__*/
  function () {
    /**
     * @param config
     * @param config.name
     * @param config.path
     * @param config.complexContents
     * @param config.viewBox
     * @constructor
     */
    function SVGIcon(config) {
      _classCallCheck(this, SVGIcon);

      /**
       * the name of the icon
       */
      this.name = config.name;
      /**
       * an svg path definition
       */

      this.path = config.path;
      /**
       * if not using a path, a the markup for a complex SVG
       */

      this.complexContents = config.complexContents;
      /**
       * the view box definition, defaults to 24x24
       * @type {string}
       */

      this.viewBox = config.viewBox || '0 0 24 24';
      /**
       * actual contents used
       */

      this.contents = this.pathDefinition();
    }

    _createClass(SVGIcon, [{
      key: "pathDefinition",
      value: function pathDefinition() {
        if (this.complexContents) {
          return this.complexContents;
        }

        return "<path d=\"".concat(this.path, "\"></path>");
      }
    }, {
      key: "parseContents",
      value: function parseContents(complexContentsParams) {
        var contents = this.contents;

        if (typeof contents === 'function') {
          contents = contents(complexContentsParams);
        }

        return "<svg viewBox=\"".concat(this.viewBox, "\" xmlns=\"http://www.w3.org/2000/svg\">").concat(contents, "</svg>");
      }
      /**
       * returns the svg markup
       */

    }, {
      key: "markup",
      value: function markup() {
        var _this = this;

        if (typeof this.contents === 'function') {
          return function (complexContentsParams) {
            return _this.parseContents(complexContentsParams);
          };
        }

        return this.parseContents();
      }
    }]);

    return SVGIcon;
  }();

  var thumbIcon = new SVGIcon({
    name: 'thumb',
    viewBox: '0 0 24 22',
    path: 'M15.273 1H5.455c-.906 0-1.68.55-2.008 1.342L.153 10.097A2.19 2.19 0 000 10.9v2.2c0 1.21.982 2.2 2.182 2.2h6.883L8.03 20.327l-.033.352c0 .451.186.869.48 1.166L9.633 23l7.178-7.249a2.16 2.16 0 00.644-1.551v-11c0-1.21-.982-2.2-2.182-2.2zm0 13.2l-4.735 4.774L11.75 13.1H2.182v-2.2l3.273-7.7h9.818v11zM19.636 1H24v13.2h-4.364V1z'
  });

  var receiptIcon = new SVGIcon({
    name: 'receipt',
    path: 'M14.606 9.5c-.671-.515-1.591-.833-2.606-.833 1.015 0 1.935.318 2.606.833zm-7.985 0H1.655A1.66 1.66 0 010 7.833V3.667C0 2.747.741 2 1.655 2h20.69A1.66 1.66 0 0124 3.667v4.166A1.66 1.66 0 0122.345 9.5h-4.966V22H6.621V9.5h2.773H6.62zm10.758-1.667h4.966V3.667H1.655v4.166h4.966v-2.5h10.758v2.5z'
  });

  var pantheonIcon = new SVGIcon({
    name: 'pantheon',
    path: 'M9.947 16.598h.252V9.412h-.252a.432.432 0 01-.23-.065c-.07-.043-.106-.093-.106-.15L9.15 7.82v-.15c0-.044.028-.08.084-.109a.691.691 0 01.105-.086.254.254 0 01.146-.043H13.6c.056 0 .104.015.146.043.042.03.091.058.147.086a.271.271 0 01.063.108c.014.043.007.093-.02.15l-.42 1.378a.374.374 0 01-.147.15.37.37 0 01-.19.065h-.251v7.186h.252a.37.37 0 01.189.065c.07.043.119.093.147.15l.42 1.378c.027.028.034.071.02.129a.275.275 0 01-.063.129 1.364 1.364 0 00-.147.086.254.254 0 01-.146.043H9.485a.254.254 0 01-.146-.043.691.691 0 01-.105-.086c-.056-.029-.084-.072-.084-.13v-.128l.461-1.377c0-.058.035-.108.105-.151a.432.432 0 01.231-.065zm5.792 0h.252V9.412h-.252a.432.432 0 01-.23-.065.374.374 0 01-.148-.15l-.42-1.377c-.027-.029-.034-.072-.02-.13a.275.275 0 01.063-.129c.056-.028.105-.057.146-.086a.254.254 0 01.147-.043h4.114c.055 0 .104.015.146.043a.691.691 0 01.105.086c.056.03.084.072.084.13v.129l-.42 1.377a.374.374 0 01-.146.15.432.432 0 01-.231.065h-.21v7.186h.21a.43.43 0 01.23.065c.07.043.12.093.148.15l.42 1.378v.15c0 .043-.029.08-.085.108a.691.691 0 01-.105.086.254.254 0 01-.146.043h-4.114a.254.254 0 01-.147-.043 1.364 1.364 0 00-.146-.086.271.271 0 01-.063-.108c-.014-.043-.007-.093.02-.15l.42-1.377a.374.374 0 01.147-.151.432.432 0 01.231-.065zm-11.794-.086h.252V9.498h-.252a.334.334 0 01-.21-.065.386.386 0 01-.126-.193l-.42-1.377a.248.248 0 01-.02-.172.854.854 0 01.063-.173c.028-.057.07-.1.126-.129a.365.365 0 01.168-.043h4.07c.057 0 .113.015.169.043a.278.278 0 01.126.13.854.854 0 01.062.172.248.248 0 01-.02.172l-.42 1.377a.386.386 0 01-.126.193.334.334 0 01-.21.065h-.21v7.014h.21c.084 0 .154.029.21.086a.673.673 0 01.126.172l.42 1.378a.248.248 0 01.02.172.854.854 0 01-.062.172.278.278 0 01-.126.129.365.365 0 01-.168.043H3.526a.365.365 0 01-.168-.043.278.278 0 01-.126-.13.854.854 0 01-.063-.171.248.248 0 01.02-.172l.42-1.378a.673.673 0 01.126-.172.281.281 0 01.21-.086zM1.763 6.658a.717.717 0 01-.504-.194.644.644 0 01-.21-.495v-.43a.73.73 0 01.105-.387.68.68 0 01.273-.259C4.309 3.402 6.54 2.276 8.121 1.515 9.702.755 10.493.361 10.493.332c.531-.258.972-.366 1.322-.323.35.043.734.165 1.154.366l8.31 4.518c.14.058.245.144.315.259a.73.73 0 01.105.387v.43c0 .201-.07.366-.21.495a.717.717 0 01-.504.194H1.763zm-.714 13.34a.54.54 0 01.168-.387.516.516 0 01.378-.172h19.642c.168 0 .308.057.42.172a.541.541 0 01.168.387v.818a.522.522 0 01-.168.408.605.605 0 01-.42.151H1.595a.551.551 0 01-.378-.15.522.522 0 01-.168-.41v-.817zm21.405 2.022c.14 0 .266.058.378.173a.592.592 0 01.168.43v.818a.541.541 0 01-.168.387.516.516 0 01-.378.172L.546 23.957a.516.516 0 01-.378-.172.541.541 0 01-.168-.387v-.818a.59.59 0 01.168-.43.516.516 0 01.378-.173l21.908.043z'
  });

  var micIcon = new SVGIcon({
    name: 'mic',
    path: 'M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z'
  });

  var directionsIcon = new SVGIcon({
    name: 'directions',
    path: 'M23.649 11.154L12.846.35a1.195 1.195 0 00-1.692 0L.35 11.154a1.195 1.195 0 000 1.692L11.154 23.65a1.195 1.195 0 001.692 0L23.65 12.846c.468-.456.468-1.212 0-1.692zm-9.254 3.853v-3.001H9.593v3.6h-2.4v-4.8c0-.66.54-1.2 1.2-1.2h6.002V6.604l4.2 4.2-4.2 4.202z'
  });

  var calendarIcon = new SVGIcon({
    name: 'calendar',
    path: 'M18.111 13.2H12v6h6.111v-6zM16.89 0v2.4H7.11V0H4.667v2.4H3.444c-1.356 0-2.432 1.08-2.432 2.4L1 21.6C1 22.92 2.088 24 3.444 24h17.112C21.9 24 23 22.92 23 21.6V4.8c0-1.32-1.1-2.4-2.444-2.4h-1.223V0H16.89zm3.667 21.6H3.444V8.4h17.112v13.2z'
  });

  var calloutIcon = new SVGIcon({
    name: 'callout',
    path: 'M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z'
  });

  var infoIcon = new SVGIcon({
    name: 'info',
    path: 'M12 8.4A1.2 1.2 0 1012 6a1.2 1.2 0 000 2.4zM12 0c6.624 0 12 5.376 12 12s-5.376 12-12 12S0 18.624 0 12 5.376 0 12 0zm0 18c.66 0 1.2-.54 1.2-1.2V12c0-.66-.54-1.2-1.2-1.2-.66 0-1.2.54-1.2 1.2v4.8c0 .66.54 1.2 1.2 1.2z'
  });

  var briefcaseIcon = new SVGIcon({
    name: 'briefcase',
    path: 'M20 7h-4V5c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 20c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V9c0-1.11-.89-2-2-2zm-6 0h-4V5h4v2z'
  });

  var kabobIcon = new SVGIcon({
    name: 'kabob',
    viewBox: '0 0 3 11',
    complexContents: "<circle cx=\"1.5\" cy=\"1.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"5.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"9.5\" r=\"1.5\"/>"
  });

  var personIcon = new SVGIcon({
    name: 'person',
    viewBox: '0 0 18 18',
    path: 'M9 9c2.486 0 4.5-2.014 4.5-4.5S11.486 0 9 0a4.499 4.499 0 00-4.5 4.5C4.5 6.986 6.514 9 9 9zm0 2.25c-3.004 0-9 1.508-9 4.5v1.125C0 17.494.506 18 1.125 18h15.75c.619 0 1.125-.506 1.125-1.125V15.75c0-2.992-5.996-4.5-9-4.5z'
  });

  var magnifyingGlassIcon = new SVGIcon({
    name: 'magnifying_glass',
    path: 'M16.124 13.051a5.154 5.154 0 110-10.308 5.154 5.154 0 010 10.308M16.114 0a7.886 7.886 0 00-6.46 12.407L0 22.06 1.94 24l9.653-9.653A7.886 7.886 0 1016.113 0'
  });

  var officeIcon = new SVGIcon({
    name: 'office',
    path: 'M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z'
  });

  var linkIcon = new SVGIcon({
    name: 'link',
    path: 'M2.28 12A3.723 3.723 0 016 8.28h4.8V6H6c-3.312 0-6 2.688-6 6s2.688 6 6 6h4.8v-2.28H6A3.723 3.723 0 012.28 12zm4.92 1.2h9.6v-2.4H7.2v2.4zM18 6h-4.8v2.28H18A3.723 3.723 0 0121.72 12 3.723 3.723 0 0118 15.72h-4.8V18H18c3.312 0 6-2.688 6-6s-2.688-6-6-6z'
  });

  var windowIcon = new SVGIcon({
    name: 'window',
    path: 'M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z'
  });

  var phoneIcon = new SVGIcon({
    name: 'phone',
    path: 'M4.827 10.387a20.198 20.198 0 008.786 8.786l2.934-2.933c.36-.36.893-.48 1.36-.32a15.21 15.21 0 004.76.76c.733 0 1.333.6 1.333 1.333v4.654C24 23.4 23.4 24 22.667 24 10.147 24 0 13.853 0 1.333 0 .6.6 0 1.333 0H6c.733 0 1.333.6 1.333 1.333 0 1.667.267 3.267.76 4.76.147.467.04.987-.333 1.36l-2.933 2.934z'
  });

  var tagIcon = new SVGIcon({
    name: 'tag',
    viewBox: '0 0 18 18',
    path: 'M17.469 8.622l-8.1-8.1A1.789 1.789 0 008.1 0H1.8C.81 0 0 .81 0 1.8v6.3c0 .495.198.945.531 1.278l8.1 8.1c.324.324.774.522 1.269.522a1.76 1.76 0 001.269-.531l6.3-6.3A1.76 1.76 0 0018 9.9c0-.495-.207-.954-.531-1.278zM3.15 4.5c-.747 0-1.35-.603-1.35-1.35 0-.747.603-1.35 1.35-1.35.747 0 1.35.603 1.35 1.35 0 .747-.603 1.35-1.35 1.35z'
  });

  var documentIcon = new SVGIcon({
    name: 'document',
    path: 'M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z'
  });

  var chevronIcon = new SVGIcon({
    name: 'chevron',
    viewBox: '0 0 7 9',
    complexContents: "<g fill-rule=\"evenodd\" transform=\"translate(-1 -8)\"><path d=\"m2.6417004 8-1.1417004 1.0575 3.70850202 3.4425-3.70850202 3.4425 1.1417004 1.0575 4.8582996-4.5z\"/></g>"
  });

  var supportIcon = new SVGIcon({
    name: 'support',
    path: 'M12,0 C5.376,0 0,5.376 0,12 C0,18.624 5.376,24 12,24 C18.624,24 24,18.624 24,12 C24,5.376 18.624,0 12,0 Z M13,19 L11,19 L11,17 L13,17 L13,19 Z M15.07,11.25 L14.17,12.17 C13.45,12.9 13,13.5 13,15 L11,15 L11,14.5 C11,13.4 11.45,12.4 12.17,11.67 L13.41,10.41 C13.78,10.05 14,9.55 14,9 C14,7.9 13.1,7 12,7 C10.9,7 10,7.9 10,9 L8,9 C8,6.79 9.79,5 12,5 C14.21,5 16,6.79 16,9 C16,9.88 15.64,10.68 15.07,11.25 Z'
  });

  var yextIcon = new SVGIcon({
    name: 'yext',
    viewBox: '0 0 30 30',
    path: 'M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z'
  });

  var pinIcon = new SVGIcon({
    name: 'pin',
    viewBox: '5 0 9 18',
    path: 'm9.375 0c-3.52446429 0-6.375 2.817-6.375 6.3 0 4.725 6.375 11.7 6.375 11.7s6.375-6.975 6.375-11.7c0-3.483-2.8505357-6.3-6.375-6.3zm.00000018 8.55000007c-1.25678576 0-2.27678579-1.008-2.27678579-2.25s1.02000003-2.25 2.27678579-2.25c1.25678572 0 2.27678582 1.008 2.27678582 2.25s-1.0200001 2.25-2.27678582 2.25z'
  });

  var gearIcon = new SVGIcon({
    name: 'gear',
    path: 'M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42a.353.353 0 01.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16a.353.353 0 01-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z'
  });

  var lightBulbIcon = new SVGIcon({
    name: 'light_bulb',
    viewBox: '0 0 32 35',
    path: 'M11.585 31.056l8.38-.493v-.986l-8.38.493zM11.585 33.028L15.775 35l4.19-1.972V31.55l-8.38.493v.986zm6.926-.407l-2.736 1.29-2.13-1.004 4.866-.286zM15.775 7.394c-4.63 0-8.38 3.205-8.38 8.38 0 5.177 4.19 6.902 4.19 12.818v.493l8.38-.493c0-5.916 4.19-8.188 4.19-12.817a8.38 8.38 0 00-8.38-8.38zm5.617 13.48c-1.025 1.837-2.174 3.892-2.381 6.786l-6.44.38c-.129-3.01-1.29-5.021-2.32-6.808-.493-.8-.928-1.636-1.299-2.5h13.556c-.325.708-.704 1.403-1.116 2.142zm1.479-3.128H8.627a7.793 7.793 0 01-.247-1.971c0-4.353 3.042-7.395 7.395-7.395a7.394 7.394 0 017.394 7.395 6.739 6.739 0 01-.3 1.971h.002zM26.62 15.282h4.93v1h-4.93zM23.094 7.756l2.091-2.091.698.697-2.092 2.092zM15.282 0h1v4.93h-1zM5.666 6.362l.697-.697 2.091 2.091-.697.697zM0 15.282h4.93v1H0z'
  });

  var starIcon = new SVGIcon({
    name: 'star',
    viewBox: '0 0 18 18',
    path: 'M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z'
  });

  var close = new SVGIcon({
    name: 'close',
    complexContents: "\n    <path d=\"M7 8l9.716 9.716m0-9.716L7 17.716\" \n          stroke=\"currentColor\" \n          stroke-width=\"2\"/>\n  "
  });

  var elements = new SVGIcon({
    name: 'elements',
    path: 'M13,15 L13,17 L21,17 L21,19 L13,19 L13,21 L11,21 L11,15 L13,15 Z M9,17 L9,19 L3,19 L3,17 L9,17 Z M9,15 L7,15 L7,13 L3,13 L3,11 L7,11 L7,9 L9,9 L9,15 Z M21,11 L21,13 L11,13 L11,11 L21,11 Z M17,3 L17,5 L21,5 L21,7 L17,7 L17,9 L15,9 L15,3 L17,3 Z M13,5 L13,7 L3,7 L3,5 L13,5 Z'
  });

  var yextAnimatedForward = new SVGIcon({
    name: 'yext_animated_reverse',
    viewBox: '0 0 72 72',
    complexContents: function complexContents() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var iconPrefix = params.iconPrefix || 'yxt';
      return "<defs>\n      <mask id=\"".concat(iconPrefix, "_reverse_Mask-1\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-2\">\n        <rect x=\"-144.3\" y=\"144.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-3\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M489.8 277.4c0 0 78 18.8 78 18.8c0 0-96.1 61.5-96.1 61.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-13.9 14-13.9 14m-67.8-108.1c0 0 73.9 1.3 73.9 1.3c0 0-33.8 54.5-33.8 54.5c0 0 18.6-3.2 18.6-3.2c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-32.1 9.8-32.1 9.8\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-4\">\n        <rect x=\"-91.1\" y=\"91.1\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-5\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M488.4 291.4c0 0 40.5 39.3 40.5 39.3c0 0-57.2 27-57.2 27c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-15.3 28-15.3 28m-90.5-97.4c0 0 52-11.3 52-11.3c0 0-6 45.2-6 45.2c0 0 36.8-6 36.8-6c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-56.2 34.5-56.2 34.5\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-6\">\n        <rect x=\"-61.3\" y=\"61.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-7\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M481.8 298.4c0 0 27.5 39.8 27.5 39.8c0 0-37.6 19.5-37.6 19.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-21.9 35-21.9 35m-108.1-79.7c0 0 30.2-23.8 30.2-23.8c0 0 21.7 35.9 21.7 35.9c0 0 55.1-8.9 55.1-8.9c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-80.4 59.2-80.4 59.2\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-8\">\n        <rect x=\"-42.6\" y=\"42.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-9\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M475.2 305.4c0 0 14.5 40.3 14.5 40.3c0 0-18 12-18 12c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-28.5 42-28.5 42m-113.6-74.3c0 0 17.9-18.5 17.9-18.5c0 0 36.4 25.3 36.4 25.3c0 0 64.8-16 64.8-16c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-10\">\n        <rect x=\"-29.6\" y=\"29.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-11\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M468.6 312.4c0 0 1.5 40.8 1.5 40.8c0 0 1.6 4.5 1.6 4.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-35.1 49-35.1 49m-107-81.3c0 0 15.1 4.9 15.1 4.9c0 0 38.2 13.3 38.2 13.3c0 0 65.8-27.4 65.8-27.4c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-12\">\n        <rect x=\"-20.3\" y=\"20.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-13\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M456.6 311.9c0 0-7 35.6-7 35.6c0 0 22.1 10.2 22.1 10.2c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-47.1 48.5-47.1 48.5m-95-80.8c0 0 12.3 28.3 12.3 28.3c0 0 39.9 1.3 39.9 1.3c0 0 66.9-38.8 66.9-38.8c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-14\">\n        <rect x=\"-13.4\" y=\"13.4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-15\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M444.6 311.4c0 0-15.6 30.5-15.6 30.5c0 0 42.7 15.8 42.7 15.8c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-59.1 48-59.1 48m-83-80.3c0 0 9.5 51.7 9.5 51.7c0 0 41.7-10.8 41.7-10.8c0 0 67.9-50.1 67.9-50.1c0 0 50.6-31.9 50.6-31.9c0 0-77.2-30.5-77.2-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-16\">\n        <rect x=\"-7.3\" y=\"7.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-17\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-18\">\n        <rect x=\"-4\" y=\"4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-19\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_reverse_Mask-20\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <clipPath id=\"").concat(iconPrefix, "_reverse_ClipPath-1\">\n        <rect width=\"720\" height=\"720\" />\n      </clipPath>\n    </defs>\n    <g transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_reverse_Mask-1)\">\n        <path d=\"M377.5 395.3c0 0 64.8 0 64.8 0c0 0 0 129.6 0 129.6c0 0 28.8 0 28.8 0c0 0 0-129.6 0-129.6c0 0 64.8 0 64.8 0c0 0 0-28.8 0-28.8c0 0-158.4 0-158.4 0c0 0 0 28.8 0 28.8Z\" />\n        <path d=\"M338.9 363.6c0 0-62.5 62.4-62.5 62.4c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 62.4-62.4 62.4-62.4c0 0-20.3-20.4-20.3-20.4Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-60.7-72.8-60.7-72.8c0 0-22.1 18.6-22.1 18.6c0 0 68.4 82 68.4 82c0 0 0 62.4 0 62.4c0 0 28.8 0 28.8 0c0 0 0-62.6 0-62.6c0 0 68.4-81.8 68.4-81.8c0 0-22-18.6-22-18.6c0 0-60.8 72.8-60.8 72.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-353.7c195.2 0 353.7 158.5 353.7 353.7c0 195.2-158.5 353.7-353.7 353.7c-195.2 0-353.7-158.5-353.7-353.7c0-195.2 158.5-353.7 353.7-353.7Z\" fill=\"none\" transform=\"translate(359.8,360.4) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-2)\" transform=\"translate(144.3,-144.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-3)\">\n        <path d=\"M390.6 395.2c0 0 51.7 .1 51.7 .1c0 0 .1 103.6 .1 103.6c0 0 28.7 0 28.7 0c0 0 0-103.6 0-103.6c0 0 52-0.1 52-0.1c0 0 0-28.4 0-28.4c0 0-132.5 0-132.5 0c0 0 0 28.4 0 28.4Z\" />\n        <path d=\"M329 373.4c0 .1-52.6 52.6-52.6 52.6c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 52.6-52.6 52.6-52.6c0 0-20.4-20.3-20.4-20.3Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-48.7-58.3-48.7-58.3c0 0-21.1 19-21.1 19c0 0 55.5 67.2 55.5 67.2c0 0 .3 50 .3 50c0 0 28.4 0 28.4 0c0 0 0-50.3 0-50.3c0 0 55.4-66.9 55.4-66.9c0 0-21-18.6-21-18.6c0 0-48.8 57.9-48.8 57.9Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-336.2c185.6 0 336.2 150.6 336.2 336.2c0 185.6-150.6 336.2-336.2 336.2c-185.6 0-336.2-150.6-336.2-336.2c0-185.6 150.6-336.2 336.2-336.2Z\" fill=\"none\" display=\"block\" transform=\"translate(370.8,347.5) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_reverse_Mask-4)\" transform=\"translate(91.1,-91.1)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#").concat(iconPrefix, "_reverse_Mask-5)\">\n        <path d=\"M409.7 395.1c0 0 32.6 .2 32.6 .2c0 0 .3 65.5 .3 65.5c0 0 28.5 0 28.5 0c0 0 0-65.5 0-65.5c0 0 33.1-0.2 33.1-0.2c0 0 0-27.8 0-27.8c0 0-94.5 0-94.5 0c0 0 0 27.8 0 27.8Z\" />\n        <path d=\"M319.7 382.8c0 0-43.3 43.2-43.3 43.2c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 43.4-43.3 43.4-43.3c0 0-20.5-20.3-20.5-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l69.8-69.9l.3-0.2l-20.3-20.4l-71.2 71.1c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-31.1-37-31.1-37c0 0-19.7 19.5-19.7 19.5c0 0 36.7 45.6 36.7 45.6c0 0 .7 31.8 .7 31.8c0 0 27.7 0 27.7 0c0 0 0-32.4 0-32.4c0 0 36.5-44.9 36.5-44.9c0 0-19.6-18.6-19.6-18.6c0 0-31.2 36-31.2 36Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-310c171.1 0 310 138.9 310 310c0 171.1-138.9 310-310 310c-171.1 0-310-138.9-310-310c0-171.1 138.9-310 310-310Z\" fill=\"none\" transform=\"translate(387.8,328.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-6)\" transform=\"translate(61.3,-61.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#").concat(iconPrefix, "_reverse_Mask-7)\">\n        <path d=\"M420.4 395c0 0 21.9 .3 21.9 .3c0 0 .4 44.1 .4 44.1c0 0 28.4 0 28.4 0c0 0 0-44.1 0-44.1c0 0 22.6-0.3 22.6-0.3c0 0 0-27.5 0-27.5c0 0-73.3 0-73.3 0c0 0 0 27.5 0 27.5Z\" />\n        <path d=\"M313.2 389.2c0 0-36.8 36.8-36.8 36.8c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 37-36.9 37-36.9c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M500 200c-13.4-9.9-27.2-16.2-45.3-16.2c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l57.7-57.7l-20.3-20.4l-58.8 58.7c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-21.2-25.1-21.2-25.1c0 0-19 19.8-19 19.8c0 0 26.2 33.5 26.2 33.5c0 0 1 21.6 1 21.6c0 0 27.2 0 27.2 0c0 0 0-22.3 0-22.3c0 0 25.9-32.7 25.9-32.7c0 0-18.8-18.6-18.8-18.6c0 0-21.3 23.8-21.3 23.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-294.3c162.4 0 294.3 131.9 294.3 294.3c0 162.4-131.9 294.3-294.3 294.3c-162.4 0-294.3-131.9-294.3-294.3c0-162.4 131.9-294.3 294.3-294.3Z\" fill=\"none\" display=\"block\" transform=\"translate(398.7,318.2) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_reverse_Mask-8)\" transform=\"translate(42.6,-42.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-9)\">\n        <path d=\"M427.2 394.9c0 0 15.1 .4 15.1 .4c0 0 .4 30.7 .4 30.7c0 0 28.4 0 28.4 0c0 0 0-30.7 0-30.7c0 0 15.9-0.4 15.9-0.4c0 0 0-27.2 0-27.2c0 0-59.8 0-59.8 0c0 0 0 27.2 0 27.2Z\" />\n        <path d=\"M307.4 395c0 0-31 31-31 31c0 0-53.9-54-53.9-54c0 0-20.4 20.4-20.4 20.4c0 0 54 54 54 54c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 54 54 54 54c0 0 20.4-20.3 20.4-20.3c0 0-54-54.1-54-54.1c0 0 31.2-31.1 31.2-31.1c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l45.5-45.5l-20.4-20.4l-46.5 46.5c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-15-17.6-15-17.6c0 0-18.4 20-18.4 20c0 0 19.4 25.8 19.4 25.8c0 0 1.2 15.2 1.2 15.2c0 0 27 0 27 0c0 0 0-15.9 0-15.9c0 0 19.1-24.9 19.1-24.9c0 0-18.2-18.7-18.2-18.7c0 0-15.1 16.1-15.1 16.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-284.4c157 0 284.4 127.4 284.4 284.4c0 157-127.4 284.4-284.4 284.4c-157 0-284.4-127.4-284.4-284.4c0-157 127.4-284.4 284.4-284.4Z\" fill=\"none\" transform=\"translate(406.1,311.6) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-10)\" transform=\"translate(29.6,-29.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-11)\">\n        <path d=\"M436 393.5c0 0 8.7 .4 8.7 .4c0 0 .4 17.8 .4 17.8c0 0 23.6 0 23.6 0c0 0 0-17.8 0-17.8c0 0 9.4-0.4 9.4-0.4c0 0 0-22.6 0-22.6c0 0-42.1 0-42.1 0c0 0 0 22.6 0 22.6Z\" />\n        <path d=\"M297.2 405.2c0 0-20.8 20.8-20.8 20.8c0 0-35.4-35.6-35.4-35.6c0 0-20.3 20.5-20.3 20.5c0 0 35.4 35.5 35.4 35.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 35.6 35.5 35.6 35.5c0 0 20.2-20.2 20.2-20.2c0 0-35.4-35.7-35.4-35.7c0 0 21.1-21 21.1-21c0 0-20.7-20.2-20.7-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l33.7-33.7l-20.4-20.3l-34.7 34.6c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-10.7-12.4-10.7-12.4c0 0-18.1 20.1-18.1 20.1c0 0 14.9 20.6 14.9 20.6c0 0 1.2 10.7 1.2 10.7c0 0 26.8 0 26.8 0c0 0 0-11.5 0-11.5c0 0 14.6-19.6 14.6-19.6c0 0-17.9-18.6-17.9-18.6c0 0-10.8 10.7-10.8 10.7Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-277.5c153.1 0 277.5 124.4 277.5 277.5c0 153.1-124.4 277.5-277.5 277.5c-153.1 0-277.5-124.4-277.5-277.5c0-153.1 124.4-277.5 277.5-277.5Z\" fill=\"none\" display=\"block\" transform=\"translate(411.2,307.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-12)\" transform=\"translate(20.3,-20.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-13)\">\n        <path d=\"M446 390.8c0 0 3.5 .2 3.5 .2c0 0 .2 7.3 .2 7.3c.1 0 14.2 0 14.2 0c0 0 0-7.3 0-7.3c0 0 4-0.2 4-0.2c0 0 0-13.5 0-13.5c0 0-21.9 0-21.9 0c0 0 0 13.5 0 13.5Z\" />\n        <path d=\"M287.9 414.4c0 0-11.5 11.6-11.5 11.6c0 0-18.5-18.8-18.5-18.8c0 0-20.3 20.5-20.3 20.5c0 0 18.5 18.7 18.5 18.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 18.7 18.7 18.7 18.7c0 0 20.2-20 20.2-20c0 0-18.5-19.1-18.5-19.1c0 0 11.9-11.8 11.9-11.8c0 0-20.8-20.2-20.8-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l22.4-22.4l-20.4-20.4l-23.4 23.4c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 259.4c0 0-4.5-5.2-4.5-5.2c0 0-10.7 12.1-10.7 12.1c0 0 6.9 10.1 6.9 10.1c0 0 .8 4.5 .8 4.5c0 0 16 0 16 0c0 0 0-5 0-5c0 0 6.7-9.4 6.7-9.4c0 0-10.6-11.2-10.6-11.2c0 0-4.6 4.1-4.6 4.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-272.5c150.4 0 272.5 122.1 272.5 272.5c0 150.4-122.1 272.5-272.5 272.5c-150.4 0-272.5-122.1-272.5-272.5c0-150.4 122.1-272.5 272.5-272.5Z\" fill=\"none\" display=\"block\" transform=\"translate(414.9,303.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-14)\" transform=\"translate(13.4,-13.4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-15)\">\n        <path d=\"M453.6 388.1c0 0 .7 0 .7 0c0 0 .1 1.7 .1 1.7c0 0 4.7 0 4.7 0c0 0 0-1.7 0-1.7c0 0 1 0 1 0c0 0 0-4.5 0-4.5c0 0-6.5 0-6.5 0c0 0 0 4.5 0 4.5Z\" />\n        <path d=\"M280.8 421.5c0 0-4.4 4.5-4.4 4.5c0 0-5.5-5.9-5.5-5.9c0 0-20.3 20.6-20.3 20.6c0 0 5.5 5.7 5.5 5.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 5.8 5.7 5.8 5.7c0 0 20.1-19.9 20.1-19.9c0 0-5.5-6.2-5.5-6.2c0 0 4.8-4.6 4.8-4.6c0 0-20.8-20.3-20.8-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l11.9-11.9l-20.4-20.3l-12.9 12.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 262.9c0 0-1-1.2-1-1.2c0 0-3.6 4-3.6 4c0 0 1.9 2.8 1.9 2.8c0 0 .2 1.1 .2 1.1c0 0 5.4 0 5.4 0c0 0 0-1.2 0-1.2c0 0 1.7-2.6 1.7-2.6c0 0-3.5-3.7-3.5-3.7c0 0-1.1 .8-1.1 .8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-268.8c148.4 0 268.8 120.4 268.8 268.8c0 148.4-120.4 268.8-268.8 268.8c-148.4 0-268.8-120.4-268.8-268.8c0-148.4 120.4-268.8 268.8-268.8Z\" fill=\"none\" display=\"block\" transform=\"translate(417.6,301.3) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-16)\" transform=\"translate(7.3,-7.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-17)\">\n        <path d=\"M275.4 426.9c0 0-19.3 19.5-19.3 19.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 19.9-19.7 19.9-19.7c0 0-20.9-20.2-20.9-20.2Z\" />\n        <path d=\"M411.4 291.3l20.7 20.7l.1-0.1c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 21.9 6.3 35.3 16.2l-7.9 20.3c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10.1 2.9 19.5 7.9 27.5Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-265.6c146.6 0 265.6 119 265.6 265.6c0 146.6-119 265.6-265.6 265.6c-146.6 0-265.6-119-265.6-265.6c0-146.6 119-265.6 265.6-265.6Z\" fill=\"none\" display=\"block\" transform=\"translate(420,299.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-18)\" transform=\"translate(4,-4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-19)\">\n        <path d=\"M265.4 437.1c0 0-9.3 9.3-9.3 9.3c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 9.8-9.6 9.8-9.6c0 0-20.8-20.1-20.8-20.1Z\" />\n        <path d=\"M403 299.3l20.9 20.9l8.3-8.3c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 34.6 5.8 48.1 15.8l-20.7 20.7c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10 2.9 19.3 7.8 27.3Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-263.8c145.6 0 263.8 118.2 263.8 263.8c0 145.6-118.2 263.8-263.8 263.8c-145.6 0-263.8-118.2-263.8-263.8c0-145.6 118.2-263.8 263.8-263.8Z\" fill=\"none\" display=\"block\" transform=\"translate(421.2,297.8) scale(.977,.977)\" />\n    </g>\n    <g clip-path=\"url(#").concat(iconPrefix, "_reverse_ClipPath-1)\" opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_reverse_Mask-20)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-261.7c144.4 0 261.7 117.3 261.7 261.7c0 144.4-117.3 261.7-261.7 261.7c-144.4 0-261.7-117.3-261.7-261.7c0-144.4 117.3-261.7 261.7-261.7Z\" fill=\"none\" display=\"block\" transform=\"translate(422.8,296.4) scale(.977,.977)\" />\n    </g>");
    }
  });

  var yextAnimatedReverse = new SVGIcon({
    name: 'yext_animated_forward',
    viewBox: '0 0 72 72',
    complexContents: function complexContents() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var iconPrefix = params.iconPrefix || 'yxt';
      return "<defs>\n      <mask id=\"".concat(iconPrefix, "_forward_Mask-1\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-2\">\n        <rect x=\"-144.3\" y=\"144.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-3\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M489.8 277.4c0 0 78 18.8 78 18.8c0 0-96.1 61.5-96.1 61.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-13.9 14-13.9 14m-67.8-108.1c0 0 73.9 1.3 73.9 1.3c0 0-33.8 54.5-33.8 54.5c0 0 18.6-3.2 18.6-3.2c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-32.1 9.8-32.1 9.8\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-4\">\n        <rect x=\"-91.1\" y=\"91.1\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-5\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M488.4 291.4c0 0 40.5 39.3 40.5 39.3c0 0-57.2 27-57.2 27c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-15.3 28-15.3 28m-90.5-97.4c0 0 52-11.3 52-11.3c0 0-6 45.2-6 45.2c0 0 36.8-6 36.8-6c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-56.2 34.5-56.2 34.5\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-6\">\n        <rect x=\"-61.3\" y=\"61.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-7\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M481.8 298.4c0 0 27.5 39.8 27.5 39.8c0 0-37.6 19.5-37.6 19.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-21.9 35-21.9 35m-108.1-79.7c0 0 30.2-23.8 30.2-23.8c0 0 21.7 35.9 21.7 35.9c0 0 55.1-8.9 55.1-8.9c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-80.4 59.2-80.4 59.2\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-8\">\n        <rect x=\"-42.6\" y=\"42.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-9\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M475.2 305.4c0 0 14.5 40.3 14.5 40.3c0 0-18 12-18 12c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-28.5 42-28.5 42m-113.6-74.3c0 0 17.9-18.5 17.9-18.5c0 0 36.4 25.3 36.4 25.3c0 0 64.8-16 64.8-16c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-10\">\n        <rect x=\"-29.6\" y=\"29.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-11\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M468.6 312.4c0 0 1.5 40.8 1.5 40.8c0 0 1.6 4.5 1.6 4.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-35.1 49-35.1 49m-107-81.3c0 0 15.1 4.9 15.1 4.9c0 0 38.2 13.3 38.2 13.3c0 0 65.8-27.4 65.8-27.4c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-12\">\n        <rect x=\"-20.3\" y=\"20.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-13\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M456.6 311.9c0 0-7 35.6-7 35.6c0 0 22.1 10.2 22.1 10.2c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-47.1 48.5-47.1 48.5m-95-80.8c0 0 12.3 28.3 12.3 28.3c0 0 39.9 1.3 39.9 1.3c0 0 66.9-38.8 66.9-38.8c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-14\">\n        <rect x=\"-13.4\" y=\"13.4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-15\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M444.6 311.4c0 0-15.6 30.5-15.6 30.5c0 0 42.7 15.8 42.7 15.8c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-59.1 48-59.1 48m-83-80.3c0 0 9.5 51.7 9.5 51.7c0 0 41.7-10.8 41.7-10.8c0 0 67.9-50.1 67.9-50.1c0 0 50.6-31.9 50.6-31.9c0 0-77.2-30.5-77.2-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-16\">\n        <rect x=\"-7.3\" y=\"7.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-17\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-18\">\n        <rect x=\"-4\" y=\"4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-19\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"").concat(iconPrefix, "_forward_Mask-20\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <clipPath id=\"").concat(iconPrefix, "_forward_ClipPath-1\">\n        <rect width=\"720\" height=\"720\" />\n      </clipPath>\n    </defs>\n    <g transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_forward_Mask-1)\">\n        <path d=\"M377.5 395.3c0 0 64.8 0 64.8 0c0 0 0 129.6 0 129.6c0 0 28.8 0 28.8 0c0 0 0-129.6 0-129.6c0 0 64.8 0 64.8 0c0 0 0-28.8 0-28.8c0 0-158.4 0-158.4 0c0 0 0 28.8 0 28.8Z\" />\n        <path d=\"M338.9 363.6c0 0-62.5 62.4-62.5 62.4c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 62.4-62.4 62.4-62.4c0 0-20.3-20.4-20.3-20.4Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-60.7-72.8-60.7-72.8c0 0-22.1 18.6-22.1 18.6c0 0 68.4 82 68.4 82c0 0 0 62.4 0 62.4c0 0 28.8 0 28.8 0c0 0 0-62.6 0-62.6c0 0 68.4-81.8 68.4-81.8c0 0-22-18.6-22-18.6c0 0-60.8 72.8-60.8 72.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-353.7c195.2 0 353.7 158.5 353.7 353.7c0 195.2-158.5 353.7-353.7 353.7c-195.2 0-353.7-158.5-353.7-353.7c0-195.2 158.5-353.7 353.7-353.7Z\" fill=\"none\" transform=\"translate(359.8,360.4) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-2)\" transform=\"translate(144.3,-144.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-3)\">\n        <path d=\"M390.6 395.2c0 0 51.7 .1 51.7 .1c0 0 .1 103.6 .1 103.6c0 0 28.7 0 28.7 0c0 0 0-103.6 0-103.6c0 0 52-0.1 52-0.1c0 0 0-28.4 0-28.4c0 0-132.5 0-132.5 0c0 0 0 28.4 0 28.4Z\" />\n        <path d=\"M329 373.4c0 .1-52.6 52.6-52.6 52.6c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 52.6-52.6 52.6-52.6c0 0-20.4-20.3-20.4-20.3Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-48.7-58.3-48.7-58.3c0 0-21.1 19-21.1 19c0 0 55.5 67.2 55.5 67.2c0 0 .3 50 .3 50c0 0 28.4 0 28.4 0c0 0 0-50.3 0-50.3c0 0 55.4-66.9 55.4-66.9c0 0-21-18.6-21-18.6c0 0-48.8 57.9-48.8 57.9Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-336.2c185.6 0 336.2 150.6 336.2 336.2c0 185.6-150.6 336.2-336.2 336.2c-185.6 0-336.2-150.6-336.2-336.2c0-185.6 150.6-336.2 336.2-336.2Z\" fill=\"none\" display=\"block\" transform=\"translate(370.8,347.5) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_forward_Mask-4)\" transform=\"translate(91.1,-91.1)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#").concat(iconPrefix, "_forward_Mask-5)\">\n        <path d=\"M409.7 395.1c0 0 32.6 .2 32.6 .2c0 0 .3 65.5 .3 65.5c0 0 28.5 0 28.5 0c0 0 0-65.5 0-65.5c0 0 33.1-0.2 33.1-0.2c0 0 0-27.8 0-27.8c0 0-94.5 0-94.5 0c0 0 0 27.8 0 27.8Z\" />\n        <path d=\"M319.7 382.8c0 0-43.3 43.2-43.3 43.2c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 43.4-43.3 43.4-43.3c0 0-20.5-20.3-20.5-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l69.8-69.9l.3-0.2l-20.3-20.4l-71.2 71.1c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-31.1-37-31.1-37c0 0-19.7 19.5-19.7 19.5c0 0 36.7 45.6 36.7 45.6c0 0 .7 31.8 .7 31.8c0 0 27.7 0 27.7 0c0 0 0-32.4 0-32.4c0 0 36.5-44.9 36.5-44.9c0 0-19.6-18.6-19.6-18.6c0 0-31.2 36-31.2 36Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-310c171.1 0 310 138.9 310 310c0 171.1-138.9 310-310 310c-171.1 0-310-138.9-310-310c0-171.1 138.9-310 310-310Z\" fill=\"none\" transform=\"translate(387.8,328.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-6)\" transform=\"translate(61.3,-61.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#").concat(iconPrefix, "_forward_Mask-7)\">\n        <path d=\"M420.4 395c0 0 21.9 .3 21.9 .3c0 0 .4 44.1 .4 44.1c0 0 28.4 0 28.4 0c0 0 0-44.1 0-44.1c0 0 22.6-0.3 22.6-0.3c0 0 0-27.5 0-27.5c0 0-73.3 0-73.3 0c0 0 0 27.5 0 27.5Z\" />\n        <path d=\"M313.2 389.2c0 0-36.8 36.8-36.8 36.8c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 37-36.9 37-36.9c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M500 200c-13.4-9.9-27.2-16.2-45.3-16.2c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l57.7-57.7l-20.3-20.4l-58.8 58.7c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-21.2-25.1-21.2-25.1c0 0-19 19.8-19 19.8c0 0 26.2 33.5 26.2 33.5c0 0 1 21.6 1 21.6c0 0 27.2 0 27.2 0c0 0 0-22.3 0-22.3c0 0 25.9-32.7 25.9-32.7c0 0-18.8-18.6-18.8-18.6c0 0-21.3 23.8-21.3 23.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-294.3c162.4 0 294.3 131.9 294.3 294.3c0 162.4-131.9 294.3-294.3 294.3c-162.4 0-294.3-131.9-294.3-294.3c0-162.4 131.9-294.3 294.3-294.3Z\" fill=\"none\" display=\"block\" transform=\"translate(398.7,318.2) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#").concat(iconPrefix, "_forward_Mask-8)\" transform=\"translate(42.6,-42.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-9)\">\n        <path d=\"M427.2 394.9c0 0 15.1 .4 15.1 .4c0 0 .4 30.7 .4 30.7c0 0 28.4 0 28.4 0c0 0 0-30.7 0-30.7c0 0 15.9-0.4 15.9-0.4c0 0 0-27.2 0-27.2c0 0-59.8 0-59.8 0c0 0 0 27.2 0 27.2Z\" />\n        <path d=\"M307.4 395c0 0-31 31-31 31c0 0-53.9-54-53.9-54c0 0-20.4 20.4-20.4 20.4c0 0 54 54 54 54c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 54 54 54 54c0 0 20.4-20.3 20.4-20.3c0 0-54-54.1-54-54.1c0 0 31.2-31.1 31.2-31.1c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l45.5-45.5l-20.4-20.4l-46.5 46.5c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-15-17.6-15-17.6c0 0-18.4 20-18.4 20c0 0 19.4 25.8 19.4 25.8c0 0 1.2 15.2 1.2 15.2c0 0 27 0 27 0c0 0 0-15.9 0-15.9c0 0 19.1-24.9 19.1-24.9c0 0-18.2-18.7-18.2-18.7c0 0-15.1 16.1-15.1 16.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-284.4c157 0 284.4 127.4 284.4 284.4c0 157-127.4 284.4-284.4 284.4c-157 0-284.4-127.4-284.4-284.4c0-157 127.4-284.4 284.4-284.4Z\" fill=\"none\" transform=\"translate(406.1,311.6) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-10)\" transform=\"translate(29.6,-29.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-11)\">\n        <path d=\"M436 393.5c0 0 8.7 .4 8.7 .4c0 0 .4 17.8 .4 17.8c0 0 23.6 0 23.6 0c0 0 0-17.8 0-17.8c0 0 9.4-0.4 9.4-0.4c0 0 0-22.6 0-22.6c0 0-42.1 0-42.1 0c0 0 0 22.6 0 22.6Z\" />\n        <path d=\"M297.2 405.2c0 0-20.8 20.8-20.8 20.8c0 0-35.4-35.6-35.4-35.6c0 0-20.3 20.5-20.3 20.5c0 0 35.4 35.5 35.4 35.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 35.6 35.5 35.6 35.5c0 0 20.2-20.2 20.2-20.2c0 0-35.4-35.7-35.4-35.7c0 0 21.1-21 21.1-21c0 0-20.7-20.2-20.7-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l33.7-33.7l-20.4-20.3l-34.7 34.6c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-10.7-12.4-10.7-12.4c0 0-18.1 20.1-18.1 20.1c0 0 14.9 20.6 14.9 20.6c0 0 1.2 10.7 1.2 10.7c0 0 26.8 0 26.8 0c0 0 0-11.5 0-11.5c0 0 14.6-19.6 14.6-19.6c0 0-17.9-18.6-17.9-18.6c0 0-10.8 10.7-10.8 10.7Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-277.5c153.1 0 277.5 124.4 277.5 277.5c0 153.1-124.4 277.5-277.5 277.5c-153.1 0-277.5-124.4-277.5-277.5c0-153.1 124.4-277.5 277.5-277.5Z\" fill=\"none\" display=\"block\" transform=\"translate(411.2,307.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-12)\" transform=\"translate(20.3,-20.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-13)\">\n        <path d=\"M446 390.8c0 0 3.5 .2 3.5 .2c0 0 .2 7.3 .2 7.3c.1 0 14.2 0 14.2 0c0 0 0-7.3 0-7.3c0 0 4-0.2 4-0.2c0 0 0-13.5 0-13.5c0 0-21.9 0-21.9 0c0 0 0 13.5 0 13.5Z\" />\n        <path d=\"M287.9 414.4c0 0-11.5 11.6-11.5 11.6c0 0-18.5-18.8-18.5-18.8c0 0-20.3 20.5-20.3 20.5c0 0 18.5 18.7 18.5 18.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 18.7 18.7 18.7 18.7c0 0 20.2-20 20.2-20c0 0-18.5-19.1-18.5-19.1c0 0 11.9-11.8 11.9-11.8c0 0-20.8-20.2-20.8-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l22.4-22.4l-20.4-20.4l-23.4 23.4c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 259.4c0 0-4.5-5.2-4.5-5.2c0 0-10.7 12.1-10.7 12.1c0 0 6.9 10.1 6.9 10.1c0 0 .8 4.5 .8 4.5c0 0 16 0 16 0c0 0 0-5 0-5c0 0 6.7-9.4 6.7-9.4c0 0-10.6-11.2-10.6-11.2c0 0-4.6 4.1-4.6 4.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-272.5c150.4 0 272.5 122.1 272.5 272.5c0 150.4-122.1 272.5-272.5 272.5c-150.4 0-272.5-122.1-272.5-272.5c0-150.4 122.1-272.5 272.5-272.5Z\" fill=\"none\" display=\"block\" transform=\"translate(414.9,303.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-14)\" transform=\"translate(13.4,-13.4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-15)\">\n        <path d=\"M453.6 388.1c0 0 .7 0 .7 0c0 0 .1 1.7 .1 1.7c0 0 4.7 0 4.7 0c0 0 0-1.7 0-1.7c0 0 1 0 1 0c0 0 0-4.5 0-4.5c0 0-6.5 0-6.5 0c0 0 0 4.5 0 4.5Z\" />\n        <path d=\"M280.8 421.5c0 0-4.4 4.5-4.4 4.5c0 0-5.5-5.9-5.5-5.9c0 0-20.3 20.6-20.3 20.6c0 0 5.5 5.7 5.5 5.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 5.8 5.7 5.8 5.7c0 0 20.1-19.9 20.1-19.9c0 0-5.5-6.2-5.5-6.2c0 0 4.8-4.6 4.8-4.6c0 0-20.8-20.3-20.8-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l11.9-11.9l-20.4-20.3l-12.9 12.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 262.9c0 0-1-1.2-1-1.2c0 0-3.6 4-3.6 4c0 0 1.9 2.8 1.9 2.8c0 0 .2 1.1 .2 1.1c0 0 5.4 0 5.4 0c0 0 0-1.2 0-1.2c0 0 1.7-2.6 1.7-2.6c0 0-3.5-3.7-3.5-3.7c0 0-1.1 .8-1.1 .8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-268.8c148.4 0 268.8 120.4 268.8 268.8c0 148.4-120.4 268.8-268.8 268.8c-148.4 0-268.8-120.4-268.8-268.8c0-148.4 120.4-268.8 268.8-268.8Z\" fill=\"none\" display=\"block\" transform=\"translate(417.6,301.3) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-16)\" transform=\"translate(7.3,-7.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-17)\">\n        <path d=\"M275.4 426.9c0 0-19.3 19.5-19.3 19.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 19.9-19.7 19.9-19.7c0 0-20.9-20.2-20.9-20.2Z\" />\n        <path d=\"M411.4 291.3l20.7 20.7l.1-0.1c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 21.9 6.3 35.3 16.2l-7.9 20.3c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10.1 2.9 19.5 7.9 27.5Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-265.6c146.6 0 265.6 119 265.6 265.6c0 146.6-119 265.6-265.6 265.6c-146.6 0-265.6-119-265.6-265.6c0-146.6 119-265.6 265.6-265.6Z\" fill=\"none\" display=\"block\" transform=\"translate(420,299.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-18)\" transform=\"translate(4,-4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-19)\">\n        <path d=\"M265.4 437.1c0 0-9.3 9.3-9.3 9.3c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 9.8-9.6 9.8-9.6c0 0-20.8-20.1-20.8-20.1Z\" />\n        <path d=\"M403 299.3l20.9 20.9l8.3-8.3c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 34.6 5.8 48.1 15.8l-20.7 20.7c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10 2.9 19.3 7.8 27.3Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-263.8c145.6 0 263.8 118.2 263.8 263.8c0 145.6-118.2 263.8-263.8 263.8c-145.6 0-263.8-118.2-263.8-263.8c0-145.6 118.2-263.8 263.8-263.8Z\" fill=\"none\" display=\"block\" transform=\"translate(421.2,297.8) scale(.977,.977)\" />\n    </g>\n    <g clip-path=\"url(#").concat(iconPrefix, "_forward_ClipPath-1)\" opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#").concat(iconPrefix, "_forward_Mask-20)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-261.7c144.4 0 261.7 117.3 261.7 261.7c0 144.4-117.3 261.7-261.7 261.7c-144.4 0-261.7-117.3-261.7-261.7c0-144.4 117.3-261.7 261.7-261.7Z\" fill=\"none\" display=\"block\" transform=\"translate(422.8,296.4) scale(.977,.977)\" />\n    </g>");
    }
  });

  var iconsArray = [thumbIcon, receiptIcon, pantheonIcon, micIcon, directionsIcon, calendarIcon, calloutIcon, infoIcon, briefcaseIcon, kabobIcon, personIcon, magnifyingGlassIcon, officeIcon, linkIcon, windowIcon, phoneIcon, tagIcon, documentIcon, chevronIcon, supportIcon, yextIcon, pinIcon, gearIcon, lightBulbIcon, elements, close, yextAnimatedForward, yextAnimatedReverse, starIcon];
  var Icons = {};
  iconsArray.forEach(function (icon) {
    Icons[icon.name] = icon.markup();
  });
  Icons["default"] = starIcon.markup();

  /**
   * HandlebarsRenderer is a wrapper around the nativate handlebars renderer.
   * @extends Renderer
   */

  var HandlebarsRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    _inherits(HandlebarsRenderer, _Renderer);

    function HandlebarsRenderer() {
      var _this;

      var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HandlebarsRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(HandlebarsRenderer).call(this));
      /**
       * A local reference to the handlebars compiler
       * @type {Handlebars}
       * @private
       */

      _this._handlebars = templates._hb || null;
      /**
       * A local reference to the pre-compiled handlebars templates
       * @type {Handlebars}
       * @private
       */

      _this._templates = templates || {};
      return _this;
    }

    _createClass(HandlebarsRenderer, [{
      key: "init",
      value: function init(templates) {
        // Assign the handlebars compiler and templates based on
        // information provided from external dep (in default case, it comes from external server request)
        this._handlebars = templates._hb;
        this._templates = templates; // TODO(billy) Once we re-write templates using the new helpers library
        // we probably don't need these custom helpers anymore

        this._registerCustomHelpers();
      }
      /**
       * registerHelper is a public interface for external dependencies to
       * register their own custom helpers to our internal Handlebars Compiler
       */

    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this._handlebars.registerHelper(name, cb);
      }
      /**
       * SafeString is a public interface for external dependencies to
       * mark a string as 'safe'. Handlebars will not escape a SafeString
       */

    }, {
      key: "SafeString",
      value: function SafeString(string) {
        return new this._handlebars.SafeString(string);
      }
      /**
       * EscapeExpression is a public interface for external dependencies to
       * escape a string
       */

    }, {
      key: "escapeExpression",
      value: function escapeExpression(string) {
        return this._handlebars.escapeExpression(string);
      }
      /**
       * compile a handlebars template so that it can be rendered,
       * using the {Handlebars} compiler
       * @param {string} template The template string to compile
       */

    }, {
      key: "compile",
      value: function compile(template) {
        if (typeof template !== 'string') {
          return '';
        }

        return this._handlebars.compile(template);
      }
      /**
       * render will render a template with data
       * @param {Object} config Provide either a templateName or a pre-compiled template
       * @param {Object} data The data to provide to the template
       */

    }, {
      key: "render",
      value: function render(config, data) {
        // If a custom template is provided, use it,
        // otherwise fall back to the template name
        // TODO(billy) This interface should probably be less ugly
        if (config.template !== null) {
          return config.template(data);
        }

        try {
          return this._templates[config.templateName](data);
        } catch (e) {
          throw new Error('Can not find/render template: ' + config.templateName, e);
        }
      }
    }, {
      key: "_registerCustomHelpers",
      value: function _registerCustomHelpers() {
        this.registerHelper('ifeq', function (arg1, arg2, options) {
          return arg1 === arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('ifnoteq', function (arg1, arg2, options) {
          return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('formatPhoneNumber', function (phoneNumberString) {
          var cleaned = ('' + phoneNumberString).replace(/\D/g, '');
          var match = cleaned.match(/^(1|)?(\d{3})(\d{3})(\d{4})$/);

          if (match) {
            var intlCode = match[1] ? '+1 ' : '';
            return [intlCode, '(', match[2], ') ', match[3], '-', match[4]].join('');
          }

          return null;
        });
        this.registerHelper('assign', function (name, value, options) {
          var args = arguments;
          options = args[args.length - 1];

          if (!options.data.root) {
            options.data.root = {};
          }

          var v = '';

          for (var i = 1; i < args.length - 1; i++) {
            v = v + args[i];
          }

          options.data.root[name] = v;
        });
        this.registerHelper('json', function (name, value, options) {
          return name === undefined ? '' : JSON.stringify(name);
        });
        this.registerHelper('plural', function (number, singularText, pluralText) {
          return number === 1 ? singularText : pluralText;
        });
        var self = this;
        self.registerHelper('icon', function (name, complexContentsParams, options) {
          var icon = Icons["default"];

          if (!Icons[name]) {
            return self.SafeString(icon);
          }

          if (typeof Icons[name] === 'function') {
            icon = Icons[name](complexContentsParams);
          } else {
            icon = Icons[name];
          }

          return self.SafeString(icon);
        });
        self.registerHelper('highlightValue', function (value, getInverted) {
          var escapedInput = self.escapeExpression(value.value || value.shortValue);
          var highlightedVal = new HighlightedValue({
            value: escapedInput,
            matchedSubstrings: value.matchedSubstrings
          });
          return getInverted ? self.SafeString(highlightedVal.getInverted()) : self.SafeString(highlightedVal.get());
        });
      }
    }]);

    return HandlebarsRenderer;
  }(Renderer);

  /** @module */
  // E.g. Mustache, SOY, HandleBars, React, etc.

  var Renderers = {
    SOY: Renderer,
    Handlebars: HandlebarsRenderer
  };

  /** @module */

  /** The current lib version, reported with errors and analytics */
  var LIB_VERSION = 'v0.13.1';
  /** The identifier of the production environment */

  var PRODUCTION = 'production';
  /** The identifier of the sandbox environment */

  var SANDBOX = 'sandbox';
  /** The default url for compiled component templates */

  var COMPILED_TEMPLATES_URL = "https://assets.sitescdn.net/answers/".concat(LIB_VERSION, "/answerstemplates.compiled.min.js");

  /**
   * DefaultTemplatesLoader exposes an interface for loading the default set of compiled templates
   * asynchronously from the server. Note that this class cannot be repurposed to fetch custom
   * templates hosted by a client.
   */

  var DefaultTemplatesLoader =
  /*#__PURE__*/
  function () {
    function DefaultTemplatesLoader(onLoaded) {
      _classCallCheck(this, DefaultTemplatesLoader);

      if (!DefaultTemplatesLoader.setInstance(this)) {
        return DefaultTemplatesLoader.getInstance();
      }

      this._templates = {};

      this._onLoaded = onLoaded || function () {};

      this._fetchTemplates();
    }

    _createClass(DefaultTemplatesLoader, [{
      key: "_fetchTemplates",
      value: function _fetchTemplates() {
        // If template have already been loaded, do nothing
        var node = DOM.query('#yext-answers-templates');

        if (node) {
          return;
        } // Inject a script to fetch the compiled templates,
        // wrapping it a Promise for cleanliness


        return new Promise(function (resolve, reject) {
          var script = DOM.createEl('script', {
            id: 'yext-answers-templates',
            onload: resolve,
            onerror: reject,
            async: true,
            src: COMPILED_TEMPLATES_URL
          });
          DOM.append('body', script);
        });
      }
      /**
       * register the templates internally so that they can be later consumed
       * (e.g. by components and renderers) with convienience.
       *
       * `fetchTemplates` will automatically call this, providing the compiled templates from the server.
       */

    }, {
      key: "register",
      value: function register(templates) {
        this._templates = templates; // Notify our consumers that the templates are here :)

        this._onLoaded(this._templates);

        return this;
      }
    }, {
      key: "get",
      value: function get(templateName) {
        return this._templates[templateName];
      }
      /**
       * @return The internal template collection
       */

    }, {
      key: "getTemplates",
      value: function getTemplates() {
        return this._templates;
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return DefaultTemplatesLoader;
  }();

  /** @module */

  /** @module EventEmitter */

  /**
   * EventEmitter is a base class for any object that wants to expose
   * a pub/sub interface, for emitting messages and providing listeners.
   */
  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      /**
       * The subscribers of messages
       * @type {object[]}
       * @private
       */
      this._listeners = {};
    }
    /**
     * on is the public interface for subscribing events that are emitted.
     * @param {string} evt the event name to listen to
     * @param {function} cb The callback to invoke when the {evt} is emitted
     * @param {boolean} once Optional value which will only handle the message once
     */


    _createClass(EventEmitter, [{
      key: "on",
      value: function on(evt, cb, once) {
        if (typeof cb !== 'function') {
          throw new Error('callback handler should be of type {function}');
        }

        if (this._listeners[evt] === undefined) {
          this._listeners[evt] = [];
        }

        this._listeners[evt].push({
          event: evt,
          cb: cb,
          once: once || false
        });

        return this;
      }
      /**
       * once is the public interface for subscribing events that are emitted.
       * The handler will only be triggered once.
       *
       * @param {string} evt the event name to listen to
       * @param {function} cb The callback to invoke when the {evt} is emitted
       * @param {boolean} once Optional value which will only handle the message once
       */

    }, {
      key: "once",
      value: function once(evt, cb) {
        return this.on(evt, cb, true);
      }
      /**
       * off is the public interface for unsubscribing from an event
       * @param {string} evt the event name to unsubscribe from
       */

    }, {
      key: "off",
      value: function off(evt) {
        delete this._listeners[evt];
        return this;
      }
      /**
       * emit is the public interface for broadcasting messages/events
       * @param {string} evt the event name to publish from
       * @param {Object} data the data to send along to the subscribers
       */

    }, {
      key: "emit",
      value: function emit(evt, data) {
        var listeners = this._listeners[evt];

        if (listeners === undefined) {
          return;
        } // Invoke each of all the listener handlers and remove the ones that should fire only once.


        var keep = [];

        for (var i = 0; i < listeners.length; i++) {
          listeners[i].cb(data);

          if (listeners[i].once === true) {
            continue;
          } // Instead of having a 'dirty' array with deleted or 'undefined' entries,
          // we just create a brand new array without the listeners that were removed


          keep.push(listeners[i]);
        } // Update our old list of listeners to the newly created array


        this._listeners[evt] = keep;
        return this;
      }
    }]);

    return EventEmitter;
  }();

  /**
   * State contains the data for the component
   * and exposes an {EventEmitter} interface so that external
   * dependencies can listen/hook subscribe to messages/updates.
   * @extends EventEmitter
   */

  var State =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(State, _EventEmitter);

    function State(data) {
      var _this;

      _classCallCheck(this, State);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(State).call(this));
      /**
       * The initial state of the component
       * @type {Object}
       * @private
       */

      _this._state = data || {};
      return _this;
    }
    /**
     * Set the initial state of the component.
     * NOTE(billy): Does not fire an update message
     */


    _createClass(State, [{
      key: "init",
      value: function init(prop, optVal) {
        this._set(prop, optVal);
      }
      /**
       * setter for the state
       * @param prop {string|Object} The property to set
       * @param optVal Optional, if prop is a {string}, it will assign the value to that property
       */

    }, {
      key: "set",
      value: function set(prop, optVal) {
        this._set(prop, optVal);

        this.emit('update');
      }
      /**
       * setter for the state enables you to update a single property, or complete state
       * depending on the arguments provided.
       * @param prop {string|Object} The property to set
       * @param optVal If prop is a {string}, provide its value
       * @private
       */

    }, {
      key: "_set",
      value: function _set(prop, optVal) {
        if (optVal === undefined) {
          this._state = prop;
        } else {
          this._state[prop] = optVal;
        }
      }
    }, {
      key: "update",
      value: function update(data) {
        this._state = data;
        this.emit('update');
      }
      /**
       * Retrieve a properties value from the state
       * If no property provided, return the full state
       * @param {string} optProp optional property to retrieve
       */

    }, {
      key: "get",
      value: function get(optProp) {
        if (optProp === undefined) {
          return this._state;
        }

        return this._state[optProp];
      }
    }, {
      key: "has",
      value: function has(prop) {
        return this._state[prop] !== undefined;
      }
    }, {
      key: "asJSON",
      value: function asJSON() {
        return this._state;
      }
    }]);

    return State;
  }(EventEmitter);

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  var DOMException = self.DOMException;
  try {
    new DOMException();
  } catch (err) {
    DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
  }

  function fetch$1(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch$1.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch$1;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  /**
   * Types of HTTP requests
   */

  var Methods = {
    GET: 'get',
    POST: 'post',
    PUT: 'put',
    DELETE: 'delete'
  };
  /**
   * HttpRequester is a wrapper around the native implementation of AJAX
   * related matters. It's used to make all types of network requests
   * and exposes a promise interface.
   */

  var HttpRequester =
  /*#__PURE__*/
  function () {
    function HttpRequester() {
      _classCallCheck(this, HttpRequester);
    }

    _createClass(HttpRequester, [{
      key: "get",

      /**
       * Create a GET HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} data The data to provide (gets encoded into the URL)
       * @param {Object} opts Configuration options to use for the request
       */
      value: function get(url, data, opts) {
        return this.request(Methods.GET, this.encodeParams(url, data), opts);
      }
      /**
       * Create a POST HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} urlParams The params to encode into the URL
       * @param {Object} jsonBody The request body (json) to provide with the POST request
       * @param {Object} requestConfig Configuration options to use for the request
       */

    }, {
      key: "post",
      value: function post(url, urlParams, jsonBody, requestConfig) {
        return this.request(Methods.POST, this.encodeParams(url, urlParams), Object.assign({}, {
          body: JSON.stringify(jsonBody),
          credentials: undefined
        }, requestConfig));
      }
    }, {
      key: "request",
      value: function request(method, url, opts) {
        var reqArgs = Object.assign({}, {
          'method': method,
          'credentials': 'include'
        }, opts);
        return this._fetch(url, reqArgs);
      } // TODO (agrow) investigate removing this
      // Use imported fetchPolyfill if it does not already exist on window

    }, {
      key: "_fetch",
      value: function _fetch(url, reqArgs) {
        if (!window.fetch) {
          return fetch$1(url, reqArgs);
        }

        return fetch(url, reqArgs);
      }
      /**
       * Send a beacon to the provided url which will send a non-blocking request
       * to the server that is guaranteed to send before page load. No response is returned,
       * so beacons are primarily used for analytics reporting.
       * @param {string} url The url to send the beacon to
       * @param {object} data The data payload to send in the beacon
       * @return {boolean} true if the request is successfully queued
       */

    }, {
      key: "beacon",
      value: function beacon(url, data) {
        return this._sendBeacon(url, JSON.stringify(data));
      } // TODO (agrow) investigate removing this
      // Navigator.sendBeacon polyfill
      // Combination of the compact Financial Times polyfill:
      // https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/navigator/sendBeacon/polyfill.js
      // with the async-by-default behavior of Miguel Mota's polyfill:
      // https://github.com/miguelmota/Navigator.sendBeacon/blob/master/sendbeacon.js

    }, {
      key: "_sendBeacon",
      value: function _sendBeacon(url, data) {
        if (window.navigator && window.navigator.sendBeacon) {
          return window.navigator.sendBeacon(url, data);
        }

        var event = window.event && window.event.type;
        var sync = event === 'unload' || event === 'beforeunload';
        var xhr = 'XMLHttpRequest' in window ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
        xhr.open('POST', url, !sync);
        xhr.setRequestHeader('Accept', '*/*');

        if (typeof data === 'string') {
          xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
        } else if (Object.prototype.toString.call(data) === '[object Blob]') {
          if (data.type) {
            xhr.setRequestHeader('Content-Type', data.type);
          }
        }

        xhr.send(data);
        return true;
      }
    }, {
      key: "encodeParams",
      value: function encodeParams(url, params) {
        if (_typeof(params) !== 'object') {
          return;
        }

        var hasParam = url.indexOf('?') > -1;
        var searchQuery = '';

        for (var key in params) {
          if (!hasParam) {
            hasParam = true;
            searchQuery += '?';
          } else {
            searchQuery += '&';
          }

          searchQuery += key + '=' + encodeURIComponent(params[key]);
        }

        return url + searchQuery;
      }
    }]);

    return HttpRequester;
  }();

  /**
   * Returns the base url for the live api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getLiveApiUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi.yext.com';
  }
  /**
   * Returns the base url for the live api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getCachedLiveApiUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi-cached.yext.com';
  }
  /**
   * Returns the base url for the knowledge api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getKnowledgeApiUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    return env === SANDBOX ? 'https://api-sandbox.yext.com' : 'https://api.yext.com';
  }
  /**
   * Returns the base url for the analytics backend in the desired environment.
   * @param {string} env The desired environment.
   * @param {boolean} conversionTrackingEnabled If conversion tracking has been opted into.
   */

  function getAnalyticsUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    var conversionTrackingEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (conversionTrackingEnabled) {
      return env === SANDBOX ? 'https://sandbox-realtimeanalytics.yext.com' : 'https://realtimeanalytics.yext.com';
    }

    return env === SANDBOX ? 'https://sandbox-answers.yext-pixel.com' : 'https://answers.yext-pixel.com';
  }
  /**
   * Returns the passed in url with the query appended to it.
   * @param {string} url
   * @param {params} Object
   * @returns {string}
   */

  function addParamsToUrl(url) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var urlParams = new SearchParams(window.location.search.substring(1));

    for (var paramKey in params) {
      urlParams.set(paramKey, params[paramKey]);
    }

    return url.split('?')[0] + '?' + urlParams;
  }

  /**
   * ApiRequest is the base class for all API requests.
   * It defines all of the core properties required to make a request
   */

  var ApiRequest =
  /*#__PURE__*/
  function () {
    // TODO (tmeyer): Create an ApiService interface and pass an implementation to the current
    // consumers of ApiRequest as a dependency.
    function ApiRequest() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, ApiRequest);

      /**
       * An abstraction used for making network request and handling errors
       * @type {HttpRequester}
       * @private
       */
      this._requester = new HttpRequester();
      /**
       * The environment the request should be made to
       * @type {string}
       * @private
       */

      this._environment = opts.environment || PRODUCTION;
      /**
       * The baseUrl to use for making a request
       * @type {string}
       * @private
       */

      this._baseUrl = opts.baseUrl || getLiveApiUrl(this._environment);
      /**
       * The endpoint to use in the url (appended to the {baseUrl})
       * @type {string}
       * @private
       */

      this._endpoint = opts.endpoint || null;
      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */

      this._apiKey = opts.apiKey || null;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = opts.version || 20190101;
      /**
       * Additional data params that are sent along with the request
       * @type {string}
       * @private
       */

      this._params = opts.params || {};

      if (!globalStorage) {
        throw new AnswersBasicError('Must include global storage', 'ApiRequest');
      }
      /**
       * @type {GlobalStorage}
       * @private
       */


      this._globalStorage = globalStorage;
    }
    /**
     * get creates a new `GET` request to the server using the configuration of the request class
     * @returns {Promise<Response>}
     */


    _createClass(ApiRequest, [{
      key: "get",
      value: function get() {
        return this._requester.get(this._baseUrl + this._endpoint, Object.assign({}, this.baseParams(), this.sanitizeParams(this._params)));
      }
      /**
       * @param {Object} opts
       * @returns {Promise<Response>}
       */

    }, {
      key: "post",
      value: function post(opts) {
        return this._requester.post(this._baseUrl + this._endpoint, this.baseParams()
        /* urlParams */
        , this.sanitizeParams(this._params)
        /* jsonBody */
        , opts
        /* requestConfig */
        );
      }
      /**
       * @returns {Object}
       * @private
       */

    }, {
      key: "baseParams",
      value: function baseParams() {
        var baseParams = {
          'v': this._version,
          'api_key': this._apiKey,
          'jsLibVersion': LIB_VERSION,
          'sessionTrackingEnabled': this._globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        };
        var urlParams = new SearchParams(window.location.search.substring(1));

        if (urlParams.has('beta')) {
          baseParams['beta'] = urlParams.get('beta');
        }

        return baseParams;
      }
    }, {
      key: "sanitizeParams",
      value: function sanitizeParams() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Remove any paramaters whos value is `undefined`.
        //
        // NOTE(billy) Probably better to be explicit about how to handle this at the request building level,
        // but I can't see any cases where we'd ever want to send 'undefined' as a value to the server.
        // So it's probably fine to 'clean' the params object here
        Object.keys(params).forEach(function (key) {
          if (params[key] === undefined || params[key] === null) {
            delete params[key];
          }
        });
        return params;
      }
    }]);

    return ApiRequest;
  }();

  /**
   * SearchApi is the API for doing various types of search
   * over the network (e.g. vertical or universal)
   *
   * @implements {SearchService}
   */

  var SearchApi =
  /*#__PURE__*/
  function () {
    function SearchApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchApi);

      /**
       * A local reference to the API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'Search');
      }

      this._apiKey = config.apiKey;
      /**
       * A local reference to the Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'Search');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * A local reference to the locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'Search');
      }

      this._locale = config.locale;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
    }
    /** @inheritdoc */


    _createClass(SearchApi, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger,
            sessionTrackingEnabled = _ref.sessionTrackingEnabled,
            sortBys = _ref.sortBys;

        if (limit > 50) {
          throw new AnswersCoreError('Provided search limit unsupported', 'SearchApi');
        }

        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/vertical/query',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'filters': filter,
            'facetFilters': facetFilter,
            'verticalKey': verticalKey,
            'limit': limit,
            'offset': offset,
            'location': geolocation ? "".concat(geolocation.lat, ",").concat(geolocation.lng) : null,
            'radius': geolocation ? geolocation.radius : null,
            'queryId': id,
            'retrieveFacets': isDynamicFiltersEnabled,
            'locale': this._locale,
            'skipSpellCheck': skipSpellCheck,
            'queryTrigger': queryTrigger,
            'sessionTrackingEnabled': sessionTrackingEnabled,
            'sortBys': sortBys
          }
        };
        var request = new ApiRequest(requestConfig, {
          getState: function getState() {
            return sessionTrackingEnabled;
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/query',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'location': params.geolocation ? "".concat(params.geolocation.lat, ",").concat(params.geolocation.lng) : null,
            'radius': params.geolocation ? params.geolocation.radius : null,
            'version': this._experienceVersion,
            'locale': this._locale,
            'skipSpellCheck': params.skipSpellCheck,
            'queryTrigger': params.queryTrigger
          }
        };
        var request = new ApiRequest(requestConfig, {
          getState: function getState() {
            return params.sessionTrackingEnabled;
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
    }]);

    return SearchApi;
  }();

  /**
   * Model for the analytics event type
   */
  var AnalyticsEvent =
  /*#__PURE__*/
  function () {
    function AnalyticsEvent(type, label) {
      _classCallCheck(this, AnalyticsEvent);

      /**
       * The type of event to report
       * @type {string}
       */
      this.eventType = type.toUpperCase();
      /**
       * An optional label to be provided for the event
       * @type {string}
       */

      if (label) {
        this.label = label;
      }
    }
    /**
     * Adds the provided options to the event
     * @param {object} options Additional options for the event
     */


    _createClass(AnalyticsEvent, [{
      key: "addOptions",
      value: function addOptions(options) {
        Object.assign(this, options);
        return this;
      }
      /**
       * Return the event in the api format, typically for reporting to the api
       */

    }, {
      key: "toApiEvent",
      value: function toApiEvent() {
        return Object.assign({}, this);
      }
    }]);

    return AnalyticsEvent;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * Class for reporting analytics events to the server via HTTP
   *
   * @implements {AnalyticsReporterService}
   */

  var AnalyticsReporter =
  /*#__PURE__*/
  function () {
    function AnalyticsReporter(core, experienceKey, experienceVersion, businessId) {
      var _this = this;

      var globalOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var environment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : PRODUCTION;

      _classCallCheck(this, AnalyticsReporter);

      /**
       * The internal business identifier used for reporting
       * @type {number}
       */
      this._businessId = businessId;
      /**
       * Options to include with every analytic event reported to the server
       * @type {object}
       * @private
       */

      this._globalOptions = Object.assign({}, globalOptions, {
        experienceKey: experienceKey
      });
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = environment;
      /**
       * Base URL for the analytics API
       * @type {string}
       * @private
       */

      this._baseUrl = getAnalyticsUrl(this._environment);
      /**
       * Boolean indicating if opted in or out of conversion tracking
       * @type {boolean}
       * @private
       */

      this._conversionTrackingEnabled = false;

      if (experienceVersion) {
        this._globalOptions.experienceVersion = experienceVersion;
      } // listen to query id updates


      core.globalStorage.on('update', StorageKeys.QUERY_ID, function (id) {
        return _this.setQueryId(id);
      });
    }

    _createClass(AnalyticsReporter, [{
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this._globalOptions.queryId = queryId;
      }
      /** @inheritdoc */

    }, {
      key: "report",
      value: function report(event) {
        var cookieData = {};

        if (this._conversionTrackingEnabled && typeof ytag === 'function') {
          ytag('optin', true);
          cookieData = ytag('yfpc', null);
        } else if (this._conversionTrackingEnabled) {
          throw new AnswersAnalyticsError('Tried to enable conversion tracking without including ytag');
        }

        if (!(event instanceof AnalyticsEvent)) {
          throw new AnswersAnalyticsError('Tried to send invalid analytics event', event);
        }

        event.addOptions(this._globalOptions);
        return new HttpRequester().beacon("".concat(this._baseUrl, "/realtimeanalytics/data/answers/").concat(this._businessId), _objectSpread({
          data: event.toApiEvent()
        }, cookieData));
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {
        this._conversionTrackingEnabled = isEnabled;
        this._baseUrl = getAnalyticsUrl(this._environment, isEnabled);
      }
    }]);

    return AnalyticsReporter;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @implements {AnalyticsReporterService}
   */
  var NoopAnalyticsReporter =
  /*#__PURE__*/
  function () {
    function NoopAnalyticsReporter() {
      _classCallCheck(this, NoopAnalyticsReporter);
    }

    _createClass(NoopAnalyticsReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(event) {
        return true;
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {}
    }]);

    return NoopAnalyticsReporter;
  }();

  /**
   * ModuleData is used as a generic model for Storage.
   * Typically an instance of ModuleData powers a single component.

   * A data model that exposes an event emitter interface.
   * @extends EventEmitter
   */

  var ModuleData =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(ModuleData, _EventEmitter);

    function ModuleData(id) {
      var _this;

      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ModuleData);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ModuleData).call(this));
      _this._id = id;
      _this._history = [];
      _this._data = data;

      _this.set(data);

      return _this;
    }
    /**
     * replaces the currently held data with the given data
     * @param {*} data the data to replace the current data
     */


    _createClass(ModuleData, [{
      key: "set",
      value: function set(data) {
        this.capturePrevious();

        if (_typeof(data) !== 'object' || Array.isArray(data) || Object.keys(data).length !== Object.keys(this._data).length) {
          this._data = data;
          this.emit('update', this._data);
          return;
        } // check for shallow equality


        for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this._data[key] !== data[key]) {
            this._data = data;
            this.emit('update', this._data);
            return;
          }
        }
      }
    }, {
      key: "capturePrevious",
      value: function capturePrevious() {
        if (this._history === undefined) {
          this._history = [];
        }

        if (this._history.length + 1 > 5) {
          this._history.shift();
        } // If data is ever undefined, we default to empty object


        this._history.push(JSON.stringify(this._data || {}));
      }
    }, {
      key: "undo",
      value: function undo() {
        var previous = {};

        if (this._previous.length > 0) {
          previous = JSON.parse(this._previous.pop());
        }

        this._data.set(previous);
      }
    }, {
      key: "raw",
      value: function raw() {
        return this._data;
      }
    }]);

    return ModuleData;
  }(EventEmitter);

  /**
   * Storage is a container around application state.
   * It exposes an interface for CRUD operations as well as listening
   * for stateful changes.
   */

  var GlobalStorage =
  /*#__PURE__*/
  function () {
    function GlobalStorage() {
      _classCallCheck(this, GlobalStorage);

      this._moduleDataContainer = {};
      this._futureListeners = {};
    }
    /**
     * Set the data in storage with the given key to the provided data,
     * completely overwriting any existing data.
     * @param {string} key the storage key to set
     * @param {*} data the data to set
     */


    _createClass(GlobalStorage, [{
      key: "set",
      value: function set(key, data) {
        this._initDataContainer(key, data);

        this._moduleDataContainer[key].set(data);
      }
      /**
       * Add all key/value pairs in the provided map to the storage
       * @param {*} data The key/value pairs to set in the storage
       */

    }, {
      key: "setAll",
      value: function setAll(data) {
        for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              val = _Object$entries$_i[1];

          if (key === StorageKeys.QUERY) {
            continue;
          }

          this.set(key, val);
        } // Update query last since it triggers a search
        // TODO: move listeners up so all of storage can be updated at the same time


        if (data[StorageKeys.QUERY]) {
          this.set(StorageKeys.QUERY, data[StorageKeys.QUERY]);
        }
      }
    }, {
      key: "_initDataContainer",
      value: function _initDataContainer(key, data) {
        if (key === undefined || key === null || typeof key !== 'string') {
          throw new AnswersStorageError('Invalid storage key provided', key, data);
        }

        if (data === undefined || data === null) {
          throw new AnswersStorageError('No data provided', key, data);
        }

        if (this._moduleDataContainer[key] === undefined) {
          this._moduleDataContainer[key] = new ModuleData(key);

          this._applyFutureListeners(key);
        }
      }
    }, {
      key: "getState",
      value: function getState(moduleId) {
        if (this._moduleDataContainer[moduleId]) {
          return this._moduleDataContainer[moduleId].raw();
        }

        return null;
      }
    }, {
      key: "getAll",
      value: function getAll(key) {
        var data = [];

        for (var _i2 = 0, _Object$keys = Object.keys(this._moduleDataContainer); _i2 < _Object$keys.length; _i2++) {
          var dataKey = _Object$keys[_i2];

          if (dataKey.startsWith(key) && this._moduleDataContainer[dataKey].raw() !== null) {
            data.push(this._moduleDataContainer[dataKey].raw());
          }
        }

        return data;
      }
      /**
       * Remove the data in storage with the given key to the provided data,
       * @param {string} key the storage key to delete
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        // Note: Do we need to clean up listeners here?
        delete this._moduleDataContainer[key];
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] === undefined) {
            this._futureListeners[moduleId] = [];
          }

          this._futureListeners[moduleId].push({
            event: evt,
            cb: cb
          });

          return;
        }

        this._moduleDataContainer[moduleId].on(evt, cb);

        return this;
      }
    }, {
      key: "off",
      value: function off(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] !== undefined) {
            this._futureListeners[moduleId].pop();
          }

          return this;
        }

        this._moduleDataContainer[moduleId].off(evt, cb);

        return this;
      }
    }, {
      key: "_applyFutureListeners",
      value: function _applyFutureListeners(moduleId) {
        var futures = this._futureListeners[moduleId];

        if (!futures) {
          return;
        }

        for (var i = 0; i < futures.length; i++) {
          var future = futures[i];
          this.on(future.event, moduleId, future.cb);
        }

        delete this._futureListeners[moduleId];
      }
    }]);

    return GlobalStorage;
  }();

  /** @module */

  /**
   * Component is an abstraction that encapsulates state, behavior,
   * and view for a particular chunk of functionality on the page.
   *
   * The API exposes event life cycle hooks for when things are rendered,
   * mounted, created, etc.
   */

  var Component =
  /*#__PURE__*/
  function () {
    function Component() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Component);

      this.moduleId = null;
      /**
       * Unique name of this component instance
       * Used to distinguish between other components of the same type
       * @type {String}
       */

      this.name = config.name || this.constructor.type;
      /**
       * Cache the options so that we can propogate properly to child components
       * @type {Object}
       */

      this._config = config;
      /**
       * An identifier used to classify the type of component.
       * The component manager uses this information in order to persist and organize components
       * @type {string|ComponentType}
       */

      this._type = this.constructor.name;
      /**
       * A local reference to the parent component, if exists
       * @type {Component}
       */

      this._parentContainer = config.parentContainer || null;
      /**
       * A container for all the child components
       * @type {Component[]}
       */

      this._children = [];
      /**
       * The state (data) of the component to be provided to the template for rendering
       * @type {object}
       */

      this._state = new State(config.state);
      /**
       * TODO(billy) This should be 'services'
       */

      this.core = systemConfig.core || null;
      /**
       * A local reference to the component manager, which contains all of the component classes
       * eligible to be created
       * @type {ComponentManager}
       */

      this.componentManager = systemConfig.componentManager || null;
      /**
       * A local reference to the analytics reporter, used to report events for this component
       * @type {AnalyticsReporter}
       */

      this.analyticsReporter = systemConfig.analyticsReporter || null;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      this._analyticsOptions = config.analyticsOptions || {};
      /**
       * A reference to the DOM node that the component will be appended to when mounted/rendered.
       * @type {HTMLElement}
       */

      if (this._parentContainer === null) {
        if (typeof config.container === 'string') {
          this._container = DOM.query(config.container) || null;

          if (this._container === null) {
            throw new Error('Cannot find container DOM node: ' + config.container);
          }
        }
      } else {
        this._container = DOM.query(this._parentContainer, config.container); // If we have a parent, and the container is missing from the DOM,
        // we construct the container and append it to the parent

        if (this._container === null) {
          this._container = DOM.createEl('div', {
            "class": config.container.substring(1, config.container.length)
          });
          DOM.append(this._parentContainer, this._container);
        }
      }
      /**
       * A custom class to be applied to {this._container} node
       * @type {string}
       */


      this._className = config["class"] || 'component';
      /**
       * A custom render function to be used instead of using the default renderer
       * @type {Renderer}
       */

      this._render = config.render || null;
      /**
       * A local reference to the default {Renderer} that will be used for rendering the template
       * @type {Renderer}
       */

      this._renderer = systemConfig.renderer || Renderers.Handlebars;
      /**
       * The template string to use for rendering the component
       * If this is left empty, we lookup the template the base templates using the templateName
       * @type {string}
       */

      this._template = config.template ? this._renderer.compile(config.template) : null;
      /**
       * The templateName to use for rendering the component.
       * This is only used if _template is empty.
       * @type {string}
       */

      this._templateName = config.templateName || this.constructor.defaultTemplateName(config);
      /**
       * An internal state indicating whether or not the component has been mounted to the DOM
       * @type {boolean}
       */

      this._isMounted = false;
      /**
       * A local reference to the callback, thats used to transform the internal data
       * models of the components, before it gets applied to the component state.
       * By default, no transformation happens.
       * @type {function}
       */

      this.transformData = config.transformData || this.transformData || function () {};
      /**
       * The a local reference to the callback that will be invoked when a component is created.
       * @type {function}
       */


      this.onCreate = config.onCreateOverride || this.onCreate || function () {};

      this.onCreate = this.onCreate.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a component is Mounted.
       * @type {function}
       */

      this.onMount = config.onMountOverride || this.onMount || function () {};

      this.onMount = this.onMount.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a components state is updated.
       * @type {function}
       */

      this.onUpdate = config.onUpdateOverride || this.onUpdate || function () {};

      this.onUpdate = this.onUpdate.bind(this);
      /**
       * A user provided onCreate callback
       * @type {function}
       */

      this.userOnCreate = config.onCreate || function () {};
      /**
       * A user provided onMount callback
       * @type {function}
       */


      this.userOnMount = config.onMount || function () {};
      /**
       * A user provided onUpdate callback
       * @type {function}
       */


      this.userOnUpdate = config.onUpdate || function () {};
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(Component, [{
      key: "init",
      value: function init(opts) {
        var _this = this;

        try {
          this.setState(opts.data || opts.state || {});
          this.onCreate();
          this.userOnCreate();
        } catch (e) {
          throw new AnswersComponentError('Error initializing component', this.constructor.type, e);
        }

        this._state.on('update', function () {
          try {
            _this.onUpdate();

            _this.userOnUpdate();

            _this.unMount();

            _this.mount();
          } catch (e) {
            throw new AnswersComponentError('Error updating component', _this.constructor.type, e);
          }
        });

        DOM.addClass(this._container, this._className);
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var newState = Object.assign({}, {
          _config: this._config
        }, data);

        this._state.set(newState);

        return this;
      }
    }, {
      key: "getState",
      value: function getState(prop) {
        return this._state.get(prop);
      }
    }, {
      key: "hasState",
      value: function hasState(prop) {
        return this._state.has(prop);
      }
    }, {
      key: "transformData",
      value: function transformData(data) {
        return data;
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        var childComponent = this.componentManager.create(type, Object.assign({
          name: data.name,
          parentContainer: this._container,
          data: data
        }, opts || {}, {
          _parentOpts: this._config
        }));

        this._children.push(childComponent);

        return childComponent;
      }
      /**
       * Unmount and remove this component and its children from the list
       * of active components
       */

    }, {
      key: "remove",
      value: function remove() {
        this._children.forEach(function (c) {
          return c.remove();
        });

        this.componentManager.remove(this);
      }
      /**
       * Set the render method to be used for rendering the component
       * @param {Function} render
       * @return {string}
       */

    }, {
      key: "setRender",
      value: function setRender(render) {
        this._render = render;
        return this;
      }
      /**
       * Set the renderer for the component
       * @param {RendererType} renderer
       */

    }, {
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = Renderers[renderer];
        return this;
      }
      /**
       * Sets the template for the component to use when rendering
       * @param {string} template
       */

    }, {
      key: "setTemplate",
      value: function setTemplate(template) {
        this._template = this._renderer.compile(template);
      }
    }, {
      key: "unMount",
      value: function unMount() {
        if (!this._container) {
          return this;
        }

        this._children.forEach(function (child) {
          child.unMount();
        });

        DOM.empty(this._container);

        this._children.forEach(function (c) {
          return c.remove();
        });

        this._children = [];
        this.onUnMount();
      }
    }, {
      key: "mount",
      value: function mount(container) {
        var _this2 = this;

        if (container) {
          this._container = container;
        }

        if (!this._container) {
          return this;
        }

        if (this.beforeMount() === false) {
          return this;
        }

        DOM.append(this._container, this.render(this._state.asJSON())); // Process the DOM to determine if we should create
        // in-memory sub-components for rendering

        var domComponents = DOM.queryAll(this._container, '[data-component]:not([data-is-component-mounted])');
        var data = this.transformData(JSON.parse(JSON.stringify(this._state.get())));
        domComponents.forEach(function (c) {
          return _this2._createSubcomponent(c, data);
        });

        this._children.forEach(function (child) {
          child.mount();
        }); // Attach analytics hooks as necessary


        if (this.analyticsReporter) {
          var domHooks = DOM.queryAll(this._container, '[data-eventtype]:not([data-is-analytics-attached])');
          domHooks.forEach(this._createAnalyticsHook.bind(this));
        }

        this._isMounted = true;
        this.onMount(this);
        this.userOnMount(this);
        return this;
      }
      /**
       * render the template using the {Renderer} with the current state and template of the component
       * @returns {string}
       */

    }, {
      key: "render",
      value: function render() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._state.get();
        this.beforeRender(); // Temporary fix for passing immutable data to transformData().

        data = this.transformData(JSON.parse(JSON.stringify(data)));
        var html = ''; // Use either the custom render function or the internal renderer
        // dependant on the component configuration

        if (typeof this._render === 'function') {
          html = this._render(data);

          if (typeof html !== 'string') {
            throw new Error('Render method must return HTML as type {string}');
          }
        } else {
          // Render the existing templates as a string
          html = this._renderer.render({
            template: this._template,
            templateName: this._templateName
          }, data);
        } // We create an HTML Document fragment with the rendered string
        // So that we can query it for processing of sub components


        var el = DOM.create(html);
        this.afterRender();
        return el.innerHTML;
      }
    }, {
      key: "_createSubcomponent",
      value: function _createSubcomponent(domComponent, data) {
        var _this3 = this;

        domComponent.dataset.isComponentMounted = true;
        var dataset = domComponent.dataset;
        var type = dataset.component;
        var prop = dataset.prop;
        var opts = dataset.opts ? JSON.parse(dataset.opts) : {};
        var childData = data[prop] || {};
        opts = _objectSpread({}, opts, {
          container: domComponent
        }); // TODO(billy) Right now, if we provide an array as the data prop,
        // the behavior is to create many components for each item in the array.
        // THAT interface SHOULD change to use a different property that defines
        // whether to array data should be used for a single component or
        // to create many components for each item.
        // Overloading and having this side effect is unintuitive and WRONG

        if (!Array.isArray(childData)) {
          // Rendering a sub component should be within the context,
          // of the node that we processed it from
          this.addChild(childData, type, opts);
          return;
        }

        childData.reverse();
        childData.forEach(function (data) {
          _this3.addChild(data, type, opts);
        });
      }
    }, {
      key: "_createAnalyticsHook",
      value: function _createAnalyticsHook(domComponent) {
        var _this4 = this;

        domComponent.dataset.isAnalyticsAttached = true;
        var dataset = domComponent.dataset;
        var type = dataset.eventtype;
        var label = dataset.eventlabel;
        var options = dataset.eventoptions ? JSON.parse(dataset.eventoptions) : {};
        DOM.on(domComponent, 'click', function (e) {
          var event = new AnalyticsEvent(type, label);
          event.addOptions(_this4._analyticsOptions);
          event.addOptions(options);

          _this4.analyticsReporter.report(event);
        });
      }
      /**
       * onCreate is triggered when the component is constructed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onCreate",
      value: function onCreate(cb) {}
      /**
       * onUpdate is triggered when the state of the component changes
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUpdate",
      value: function onUpdate(cb) {}
      /**
       * beforeRender event is triggered before the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeRender",
      value: function beforeRender(cb) {}
      /**
       * afterRender event is triggered after the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "afterRender",
      value: function afterRender(cb) {}
      /**
       * onMount is triggered when the component is appended to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onMount",
      value: function onMount(cb) {}
      /**
       * onUnMount is triggered when the component is removed from the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUnMount",
      value: function onUnMount(cb) {}
      /**
       * beforeMount is triggered before the component is mounted to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeMount",
      value: function beforeMount(cb) {}
      /**
       * onDestroy is triggered when the component is destroyed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onDestroy",
      value: function onDestroy(cb) {}
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'default';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return false;
      }
    }, {
      key: "type",
      get: function get() {
        return 'Component';
      }
    }]);

    return Component;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * ErrorReporter is used for reporting errors to the console and API
   *
   * @implements {ErrorReporterService}
   */

  var ErrorReporter =
  /*#__PURE__*/
  function () {
    function ErrorReporter(config, globalStorage) {
      var _this = this;

      _classCallCheck(this, ErrorReporter);

      /**
       * The apiKey to use for reporting
       * @type {string}
       */
      this.apiKey = config.apiKey;
      /**
       * The experienceKey to use when reporting
       * @type {string}
       */

      this.experienceKey = config.experienceKey;
      /**
       * The answers config version used for api requests
       * @type {string|number}
       */

      this.experienceVersion = config.experienceVersion || 'config1.0';
      /**
       * If true, print entire error objects to the console for inspection
       * @type {boolean}
       */

      this.printVerbose = config.printVerbose;
      /**
       * If true, report the error the server for logging and monitoring
       * @type {boolean}
       */

      this.sendToServer = config.sendToServer;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       */

      if (this.sendToServer && !globalStorage) {
        throw new AnswersBasicError('Must include globalStorage to send errors to server', 'ErrorReporter');
      }

      this.globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this.environment = config.environment; // Attach reporting listeners to window

      window.addEventListener('error', function (e) {
        return _this.report(e.error);
      });
      window.addEventListener('unhandledrejection', function (e) {
        return _this.report(e.error);
      });
    }
    /**
     * report pretty prints the error to the console, optionally
     * prints the entire error if `printVerbose` is true, and sends the
     * error to the server to be logged if `sendToServer` is true
     * @param {AnswersBaseError} err The error to be reported
     * @returns {AnswersBaseError} The reported error
     */


    _createClass(ErrorReporter, [{
      key: "report",
      value: function report(err) {
        if (!(err instanceof AnswersBaseError) || err.reported) {
          return;
        }

        err.reported = true;
        this.printError(err);

        if (this.sendToServer) {
          var requestConfig = {
            endpoint: '/v2/accounts/me/answers/errors',
            apiKey: this.apiKey,
            version: 20190301,
            environment: this.environment,
            params: {
              'libVersion': LIB_VERSION,
              'experienceVersion': this.experienceVersion,
              'experienceKey': this.experienceKey,
              'error': err.toJson()
            }
          };
          var request = new ApiRequest(requestConfig, this.globalStorage); // TODO(amullings): We should probably change this endpoint to POST,
          // ideally using the beacon API. Stack traces will likely easily hit URL
          // length limits.

          request.get()["catch"](console.err);
        }

        return err;
      }
      /**
       * prints the given error to the browser console
       * @param {AnswersBaseError} err The error to be printed
       */

    }, {
      key: "printError",
      value: function printError(err) {
        if (this.printVerbose) {
          console.error("error: ".concat(err.errorMessage, "\ncode: ").concat(err.errorCode, "\nboundary: ").concat(err.boundary, "\nstack: ").concat(err.stack));
        } else {
          console.error(err.toString());
        }
      }
    }]);

    return ErrorReporter;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * @implements {ErrorReporterService}
   */
  var ConsoleErrorReporter =
  /*#__PURE__*/
  function () {
    function ConsoleErrorReporter() {
      _classCallCheck(this, ConsoleErrorReporter);
    }

    _createClass(ConsoleErrorReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(err) {
        console.error(err.toString());
      }
    }]);

    return ConsoleErrorReporter;
  }();

  /** @module PersistentStorage */

  var PersistentStorage =
  /*#__PURE__*/
  function () {
    function PersistentStorage() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, PersistentStorage);

      /**
       * The current params model
       * @type {SearchParams}
       */
      this._params = new SearchParams(window.location.search.substring(1));
      /**
       * The current history edit timer, if any
       * @type {number}
       */

      this._historyTimer = null;
      /**
       * The list of listeners to every storage update
       * @type {function[]}
       */

      this._updateListener = config.updateListener || function () {};
      /**
       * The list of listeners to storage resets
       * @type {function[]}
       */


      this._resetListener = config.resetListener || function () {};

      window.onpopstate = function () {
        _this._params = new SearchParams(window.location.search.substring(1));

        _this._callListener(_this._updateListener);

        _this._callListener(_this._resetListener);
      };
    }
    /**
     * Insert the given key/value pair into storage
     * @param {string} key The key to insert the data in
     * @param {*} data The data to insert
     * @param {boolean} replace history instead of pushing new state
     */


    _createClass(PersistentStorage, [{
      key: "set",
      value: function set(key, data) {
        var replaceHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (typeof key !== 'string') {
          throw new AnswersStorageError('Storage data key must be a string', key, data);
        }

        var newData = data;

        if (typeof data !== 'string') {
          newData = JSON.stringify(data);
        }

        this._params.set(key, newData);

        this._updateHistory(replaceHistory);
      }
      /**
       * Delete the given key from storage
       * @param {string} key The key to delete
       * @param {boolean} replace history instead of pushing new state
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        var replaceHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this._params["delete"](key);

        this._updateHistory(replaceHistory);
      }
    }, {
      key: "_updateHistory",
      value: function _updateHistory() {
        var _this2 = this;

        var replaceHistory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this._historyTimer) {
          clearTimeout(this._historyTimer);
        } // batch update calls across components to avoid updating the url too much


        this._historyTimer = setTimeout(function () {
          _this2._historyTimer = null;

          if (replaceHistory) {
            window.history.replaceState(null, null, "?".concat(_this2._params.toString()));
          } else {
            window.history.pushState(null, null, "?".concat(_this2._params.toString()));
          }

          _this2._callListener(_this2._updateListener);
        });
      }
      /**
       * Invoke the given list of callbacks with the current storage data
       * @param {function[]} listeners The callbacks to invoke
       * @private
       */

    }, {
      key: "_callListener",
      value: function _callListener(listener) {
        listener(this.getAll(), this._params.toString());
      }
      /**
       * Get all the key/value pairs in storage
       */

    }, {
      key: "getAll",
      value: function getAll() {
        var allParams = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._params.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                val = _step$value[1];

            allParams[key] = val;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return allParams;
      }
    }]);

    return PersistentStorage;
  }();

  /** @module SearchConfig */

  var SearchConfig =
  /*#__PURE__*/
  function () {
    function SearchConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchConfig);

      /**
       * The max results per search.
       * Also defines the number of results per page, if pagination is enabled
       * @type {number}
       */
      this.limit = config.limit || 20;
      /**
       * The vertical key to use for all searches
       * @type {string}
       */

      this.verticalKey = config.verticalKey || null;
      /**
       * A default search to use on initialization for vertical searchers, when the user has't provided a query
       * @type {string}
       */

      this.defaultInitialSearch = config.defaultInitialSearch;
      this.validate();
      Object.freeze(this);
    }

    _createClass(SearchConfig, [{
      key: "validate",
      value: function validate() {
        if (typeof this.limit !== 'number' || this.limit < 1 || this.limit > 50) {
          throw new AnswersConfigError('Search Limit must be between 1 and 50', 'SearchConfig');
        }
      }
    }]);

    return SearchConfig;
  }();

  /** @module AutoCompleteData */
  var AutoCompleteData =
  /*#__PURE__*/
  function () {
    function AutoCompleteData() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AutoCompleteData);

      this.sections = data.sections || [];
      this.queryId = data.queryId || '';
      this.inputIntents = data.inputIntents || [];
      Object.freeze(this);
    }

    _createClass(AutoCompleteData, null, [{
      key: "from",
      value: function from(response) {
        var sections;

        if (response.sections) {
          sections = response.sections.map(function (s) {
            return {
              label: s.label,
              results: s.results.map(function (r) {
                return new AutoCompleteResult(r);
              })
            };
          });
        } else {
          sections = [{
            results: response.results.map(function (r) {
              return new AutoCompleteResult(r);
            })
          }];
        }

        var inputIntents = response.input ? response.input.queryIntents : [];
        return new AutoCompleteData({
          sections: sections,
          queryId: response.queryId,
          inputIntents: inputIntents
        });
      }
    }]);

    return AutoCompleteData;
  }();
  var AutoCompleteResult = function AutoCompleteResult() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AutoCompleteResult);

    this.filter = data.filter || {};
    this.key = data.key || '';
    this.matchedSubstrings = data.matchedSubstrings || [];
    this.value = data.value || '';
    this.shortValue = data.shortValue || this.value;
    this.intents = data.queryIntents || [];
    Object.freeze(this);
  };

  /**
   * A Data Transformer that takes the response object from a AutoComplete request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   *
   * TODO(billy) Create our own front-end data models
   */

  var AutoCompleteDataTransformer =
  /*#__PURE__*/
  function () {
    function AutoCompleteDataTransformer() {
      _classCallCheck(this, AutoCompleteDataTransformer);
    }

    _createClass(AutoCompleteDataTransformer, null, [{
      key: "clean",
      value: function clean(moduleId, data) {
        if (data.sections && data.sections.length === 0) {
          delete data.sections;
        }

        if (data.sections && data.sections.length === 1 && data.sections[0].results.length === 0) {
          delete data.sections;
        }

        return _defineProperty({}, moduleId, data);
      }
    }, {
      key: "universal",
      value: function universal(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "filter",
      value: function filter(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "vertical",
      value: function vertical(response) {
        return AutoCompleteData.from(response);
      }
    }]);

    return AutoCompleteDataTransformer;
  }();

  /** @typedef {import('./autocompleteservice').default} AutoCompleteService */

  /**
   * AutoCompleteApi exposes an interface for network related matters
   * for all the autocomplete endpoints.
   *
   * @implements {AutoCompleteService}
   */

  var AutoCompleteApi =
  /*#__PURE__*/
  function () {
    function AutoCompleteApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, AutoCompleteApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'AutoComplete');
      }

      this._apiKey = config.apiKey;
      /**
       * The Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'AutoComplete');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'AutoComplete');
      }

      this._locale = config.locale;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'AutoComplete');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
      /**
       * The base url for the autocomplete API request
       * @type {string}
       * @private
       */

      this._baseUrl = getCachedLiveApiUrl(this._environment);
    }
    /** @inheritdoc */


    _createClass(AutoCompleteApi, [{
      key: "queryFilter",
      value: function queryFilter(input, config) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/filtersearch',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': config.verticalKey,
            'locale': this._locale,
            'search_parameters': JSON.stringify(config.searchParameters)
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.filter(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Filter search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/vertical/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          baseUrl: this._baseUrl,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': verticalKey,
            'locale': this._locale
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.vertical(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Vertical search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(queryString) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          baseUrl: this._baseUrl,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'locale': this._locale
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get(queryString).then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.universal(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Universal search request failed', 'AutoComplete', error);
        });
      }
    }]);

    return AutoCompleteApi;
  }();

  /** @typedef {import('../services/autocompleteservice').default} AutoCompleteService */

  var universalOptions = ['what is yext', 'who is the ceo of yext'];
  var verticalOptions = ['near me', 'in new york', 'available now'];
  /**
   * MockAutoCompleteService serves autocomplete queries with mock data
   *
   * @implements {AutoCompleteService}
   */

  var MockAutoCompleteService =
  /*#__PURE__*/
  function () {
    function MockAutoCompleteService() {
      _classCallCheck(this, MockAutoCompleteService);
    }

    _createClass(MockAutoCompleteService, [{
      key: "queryFilter",

      /** @inheritdoc */
      value: function queryFilter(input, config) {
        // TODO(amullings): Simulate filter search, with sections
        return emptyResults();
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey) {
        return filterOptions(input, verticalOptions.map(function (opt) {
          return "".concat(verticalKey, " ").concat(opt);
        }).concat(universalOptions));
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(input) {
        return filterOptions(input, universalOptions);
      }
    }]);

    return MockAutoCompleteService;
  }();

  function filterOptions(input, options) {
    if (input.length === 0) {
      return emptyResults();
    }

    var lowercase = input.toLowerCase();
    var results = options.filter(function (opt) {
      return opt.includes(lowercase);
    }).map(function (opt) {
      return new AutoCompleteResult({
        value: opt,
        matchedSubstrings: [{
          offset: opt.indexOf(lowercase),
          length: lowercase.length
        }]
      });
    });
    return Promise.resolve(new AutoCompleteData({
      sections: [{
        results: results
      }],
      queryId: randomString()
    }));
  }
  /**
   * @returns {Promise<AutoCompleteData>}
   */


  function emptyResults() {
    return Promise.resolve(new AutoCompleteData({
      sections: [{}],
      queryId: randomString()
    }));
  }
  /**
   * @returns {string}
   */


  function randomString() {
    return Math.random().toString(36).substring(2);
  }

  /** @typedef {import('./questionanswerservice').default} QuestionAnswerService */

  /**
   * QuestionAnswerApi submits questions via the Q&A REST API
   *
   * @implements {QuestionAnswerService}
   */

  var QuestionAnswerApi =
  /*#__PURE__*/
  function () {
    function QuestionAnswerApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, QuestionAnswerApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'QuestionAnswerApi');
      }

      this._apiKey = config.apiKey;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'QuestionAnswerApi');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment || PRODUCTION;
    }
    /** @inheritdoc */


    _createClass(QuestionAnswerApi, [{
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var requestConfig = {
          baseUrl: getKnowledgeApiUrl(this._environment),
          endpoint: '/v2/accounts/me/createQuestion',
          apiKey: this._apiKey,
          params: {
            'entityId': question.entityId,
            'site': question.site,
            'name': question.name,
            'email': question.email,
            'questionText': question.questionText,
            'questionDescription': question.questionDescription,
            'questionLanguage': question.questionLanguage
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.post({
          mode: 'cors',
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(function (response) {
          return response.json();
        })["catch"](function (error) {
          throw new AnswersEndpointError('Question submit failed', 'QuestionAnswerApi', error);
        });
      }
    }]);

    return QuestionAnswerApi;
  }();

  /** @module MockQuestionAnswerService */

  /** @typedef {import('../services/questionanswerservice').default} QuestionAnswerService */

  /**
   * @implements {QuestionAnswerService}
   */
  var MockQuestionAnswerService =
  /*#__PURE__*/
  function () {
    function MockQuestionAnswerService() {
      _classCallCheck(this, MockQuestionAnswerService);
    }

    _createClass(MockQuestionAnswerService, [{
      key: "submitQuestion",

      /** @inheritdoc */
      value: function submitQuestion(question) {
        // TODO(amullings): Make actual response object once we're using it for
        // something
        return Promise.resolve({});
      }
    }]);

    return MockQuestionAnswerService;
  }();

  /* global fetch */

  /** @typedef {import('../models/section').default} Section */

  /** @typedef {import('../services/searchservice').default} SearchService */

  /**
   * @typedef {Object} ResultData
   * @property {Object} data
   * @property {string } htmlTitle
   */

  /**
   * @callback ResultsModifier
   * @param {ResultData[]} results
   * @returns {ResultData[]}
   */

  /**
   * @callback MockDataConsumer
   * @param {Section[]} sections
   * @returns {Promise<Object>}
   */
  var ARBITRARY_BUSINESS_ID = 919871;
  /**
   * @implements {SearchService}
   */

  var MockSearchService =
  /*#__PURE__*/
  function () {
    function MockSearchService() {
      _classCallCheck(this, MockSearchService);

      /**
       * @type {Promise<string>}
       * @private
       */
      this._getMockDataJson = fetch('https://assets.sitescdn.net/answers/testdata/search/mockdata_v1.json').then(function (resp) {
        return resp.text();
      })["catch"](console.error);
    }
    /** @inheritdoc */


    _createClass(MockSearchService, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger;
        return this.useMockData(function (sections) {
          if (input === '') {
            return delayedResponse(constructVerticalResponse({
              results: [],
              appliedQueryFilters: []
            }));
          } // Either find a section with matching ID, or pick one at random


          var section = sections.find(function (verticalModule) {
            return verticalKey === verticalModule['verticalConfigId'];
          });

          if (section == null) {
            section = sections[Math.floor(Math.random() * sections.length)];
          }

          modifyResults(section, getResultsFilterer(input));

          if (offset != null && limit != null) {
            modifyResults(section, function limit(results) {
              return results.slice(offset, offset + limit);
            });
          }

          var resp = constructVerticalResponse(section);
          return delayedResponse(resp);
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        return this.useMockData(function (sections) {
          if (queryString === '') {
            return delayedResponse(constructUniversalResponse([]));
          }

          sections.forEach(function (section) {
            modifyResults(section, getResultsFilterer(queryString));
          });
          sections = sections.filter(function (section) {
            return section.results.length > 0;
          });
          var resp = constructUniversalResponse(sections);
          return delayedResponse(resp);
        });
      }
      /**
       * @param {MockDataConsumer} consumer
       * @returns {Promise<Object>}
       * @private
       */

    }, {
      key: "useMockData",
      value: function useMockData(consumer) {
        return this._getMockDataJson.then(JSON.parse).then(consumer);
      }
    }]);

    return MockSearchService;
  }();

  function getResultsFilterer(queryString) {
    return function (results) {
      return results.filter(function (result) {
        if (result.htmlTitle && result.htmlTitle.toLowerCase().includes(queryString)) {
          return true;
        }

        for (var prop in result.data) {
          var val = result.data[prop];

          if (typeof val === 'string' && val.toLowerCase().includes(queryString)) {
            return true;
          }
        }

        return false;
      });
    };
  }
  /**
   * @param {Section} section
   * @param {ResultsModifier} modifyFn
   */


  function modifyResults(section, modifyFn) {
    section.results = modifyFn(section.results);
  }
  /**
   * @param {Section[]} sections A list of mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructUniversalResponse(sections) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    sections = sections.map(fillSectionFields);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: {
        businessId: ARBITRARY_BUSINESS_ID,
        modules: sections,
        failedVerticals: [],
        queryId: uuidV4(),
        searchIntents: []
      }
    };
  }
  /**
   * @param {Section} section A mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructVerticalResponse(section) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    section = fillSectionFields(section);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: Object.assign(section, {
        businessId: ARBITRARY_BUSINESS_ID,
        queryId: uuidV4(),
        searchIntents: []
      })
    };
  }
  /**
   * @param {Section}
   * @returns {Section}
   */


  function fillSectionFields(section) {
    return {
      verticalConfigId: section.verticalConfigId,
      resultsCount: section.results.length,
      encodedState: '',
      results: section.results,
      appliedQueryFilters: section.appliedQueryFilters,
      queryDurationMillis: randomInt(50, 1000),
      facets: section.facets,
      source: section.source
    };
  }
  /**
   * @param {Object} resp
   * @returns {Promise<Object>}
   */


  function delayedResponse(resp) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(resp);
      }, randomInt(250, 1000));
    });
  }
  /**
   * Code-golf-y but legit basic UUID v4 implementation. Not cryptographically secure.
   * From https://gist.github.com/jed/982883
   * @returns {string} A v4-compliant UUID
   */


  function uuidV4() {
    return function b(a) {
      return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
    }();
  }
  /**
   * @param {number} min inclusive
   * @param {number} max exclusive
   * @returns {number} A random integer in the specified range
   */


  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }

  /**
   * The debounce duration for resize events
   * @type {number}
   */

  var RESIZE_DEBOUNCE = 100;
  /**
   * The breakpoint for mobile
   * @type {number}
   */

  var MOBILE_BREAKPOINT = 767;
  /**
   * Enum options for mobile overflow beahvior
   * @type {Object.<string, string>}
   */

  var MOBILE_OVERFLOW_BEHAVIOR_OPTION = {
    COLLAPSE: 'COLLAPSE',
    INNERSCROLL: 'INNERSCROLL'
  };
  /**
   * The Tab is a model that is used to power the Navigation tabs in the view.
   * It's initialized through the configuration provided to the component.
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(config) {
      _classCallCheck(this, Tab);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label;

      if (typeof this.label !== 'string') {
        throw new AnswersComponentError('label is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The complete URL, including the params
       * @type {string}
       */


      this.url = config.url;

      if (typeof this.url !== 'string') {
        throw new AnswersComponentError('url is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */


      this.verticalKey = config.verticalKey || null;
      /**
       * The base URL used for constructing the URL with params
       * @type {string}
       */

      this.baseUrl = config.url;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }
    /**
     * from will construct a map of verticalKey to {Tab} from
     * a configuration file
     * @param {object} tabsConfig the configuration to use
     */


    _createClass(Tab, null, [{
      key: "from",
      value: function from(tabsConfig) {
        var tabs = {}; // Parse the options and build out our tabs and

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = _objectSpread({}, tabsConfig[i]); // If a tab is configured to be hidden in this component,
          // do not process it


          if (tab.hideInNavigation) {
            continue;
          } // For tabs without config ids, map their URL to the configID
          // to avoid duplication of renders


          if (tab.verticalKey === null && tabs[tab.verticalKey] === undefined) {
            tab.verticalKey = tab.url;
          }

          tabs[tab.verticalKey] = new Tab(tab);
        }

        return tabs;
      }
    }]);

    return Tab;
  }();
  /**
   * NavigationComponent exposes an interface for building a dynamic
   * navigation that is powered by universal search updates.
   * @extends Component
   */

  var NavigationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(NavigationComponent, _Component);

    function NavigationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, NavigationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NavigationComponent).call(this, config, systemConfig));
      /**
       * The label to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowLabel = config.overflowLabel || 'More';
      /**
       * The optional icon to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowIcon = config.overflowIcon || 'kabob';
      /**
       * The data storage key
       * @type {string}
       */

      _this.moduleId = StorageKeys.NAVIGATION;
      /**
       * Tabs config from global navigation config
       * @type {Array.<object>}
       * @private
       */

      _this._tabsConfig = _this.core.globalStorage.getState(StorageKeys.VERTICAL_PAGES_CONFIG).get();
      /**
       * Unordered map of each tab, keyed by VS verticalKey
       * @type {Object.<String, Object>}
       * @private
       */

      _this._tabs = Tab.from(_this._tabsConfig);
      /**
       * The order of the tabs, parsed from configuration or URL.
       * This gets updated based on the server results
       * @type {Array.<String>} The list of VS verticalKeys
       * @private
       */

      _this._tabOrder = _this.getDefaultTabOrder(_this._tabsConfig, _this.getUrlParams());
      /**
       * Breakpoints at which navigation items move to the "more" dropdown
       * @type {number[]}
       * @private
       */

      _this._navBreakpoints = [];
      /**
       *  The mobile overflow behavior config
       *  @type {string}
       */

      _this._mobileOverflowBehavior = config.mobileOverflowBehavior || MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE;
      /**
       *  The ARIA label
       *  @type {string}
       */

      _this._ariaLabel = config.ariaLabel || 'Search Page Navigation';
      _this.checkOutsideClick = _this.checkOutsideClick.bind(_assertThisInitialized(_this));
      _this.checkMobileOverflowBehavior = _this.checkMobileOverflowBehavior.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(NavigationComponent, [{
      key: "onCreate",
      value: function onCreate() {
        // TODO: Re-rendering and re-mounting the component every tim e the window changes size
        // is not great.
        DOM.on(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        DOM.off(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        if (this.shouldCollapse()) {
          this._navBreakpoints = [];
          this.bindOverflowHandlers();
          this.refitNav();
          DOM.on(DOM.query(this._container, '.yxt-Nav-more'), 'click', this.toggleMoreDropdown.bind(this));
        }
      }
    }, {
      key: "onUnMount",
      value: function onUnMount() {
        this.unbindOverflowHandlers();
      }
    }, {
      key: "bindOverflowHandlers",
      value: function bindOverflowHandlers() {
        DOM.on(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "unbindOverflowHandlers",
      value: function unbindOverflowHandlers() {
        DOM.off(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "refitNav",
      value: function refitNav() {
        var container = DOM.query(this._container, '.yxt-Nav-container');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        var mainLinks = DOM.query(this._container, '.yxt-Nav-expanded');
        var collapsedLinks = DOM.query(this._container, '.yxt-Nav-modal');
        var navWidth = moreButton.classList.contains('yxt-Nav-item--more') ? container.offsetWidth : container.offsetWidth - moreButton.offsetWidth;
        var numBreakpoints = this._navBreakpoints.length; // sum child widths instead of using parent's width to avoid
        // browser inconsistencies

        var mainLinksWidth = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = mainLinks.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var el = _step.value;
            mainLinksWidth += el.offsetWidth;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (mainLinksWidth > navWidth) {
          this._navBreakpoints.push(mainLinksWidth);

          var lastLink = mainLinks.children.item(mainLinks.children.length - 1);

          if (lastLink === null) {
            return;
          }

          this._prepend(collapsedLinks, lastLink);

          if (moreButton.classList.contains('yxt-Nav-item--more')) {
            moreButton.classList.remove('yxt-Nav-item--more');
          }
        } else {
          if (numBreakpoints && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
            var firstLink = collapsedLinks.children.item(0);

            if (firstLink === null) {
              return;
            }

            mainLinks.append(firstLink);

            this._navBreakpoints.pop();

            numBreakpoints--;
          }

          if (collapsedLinks.children.length === 0) {
            moreButton.classList.add('yxt-Nav-item--more');
          }
        }

        this.closeMoreDropdown();

        if (mainLinksWidth > navWidth || numBreakpoints > 0 && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
          this.refitNav();
        }
      }
    }, {
      key: "closeMoreDropdown",
      value: function closeMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.remove('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', false);
      }
    }, {
      key: "openMoreDropdown",
      value: function openMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.add('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', true);
      }
    }, {
      key: "toggleMoreDropdown",
      value: function toggleMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.toggle('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', collapsed.classList.contains('is-active'));
      }
    }, {
      key: "checkOutsideClick",
      value: function checkOutsideClick(e) {
        if (this._closest(e.target, '.yxt-Nav-container')) {
          return;
        }

        this.closeMoreDropdown();
      }
    }, {
      key: "checkMobileOverflowBehavior",
      value: function checkMobileOverflowBehavior() {
        if (this._checkMobileOverflowBehaviorTimer) {
          clearTimeout(this._checkMobileOverflowBehaviorTimer);
        }

        this._checkMobileOverflowBehaviorTimer = setTimeout(this.setState.bind(this), RESIZE_DEBOUNCE);
      }
      /**
       * Since the server data only provides a list of
       * VS verticalKeys, we need to compute and transform
       * the data into the proper format for rendering.
       *
       * @override
       */

    }, {
      key: "setState",
      value: function setState() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (data.tabOrder !== undefined) {
          this._tabOrder = this.mergeTabOrder(data.tabOrder, this._tabOrder);
        } // Since the tab ordering can change based on the server data
        // we need to update each tabs URL to include the order as part of their params.
        // This helps with persisting state across verticals.


        var tabs = [];

        for (var i = 0; i < this._tabOrder.length; i++) {
          var tab = this._tabs[this._tabOrder[i]];

          if (tab !== undefined) {
            tab.url = this.generateTabUrl(tab.baseUrl, this.getUrlParams());
            tabs.push(tab);
          }
        }

        return _get(_getPrototypeOf(NavigationComponent.prototype), "setState", this).call(this, {
          tabs: tabs,
          overflowLabel: this.overflowLabel,
          overflowIcon: this.overflowIcon,
          showCollapse: this.shouldCollapse(),
          ariaLabel: this._ariaLabel
        });
      } // TODO (agrow) investigate removing this
      // ParentNode.prepend polyfill
      // https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend#Polyfill

    }, {
      key: "_prepend",
      value: function _prepend(collapsedLinks, lastLink) {
        if (!collapsedLinks.hasOwnProperty('prepend')) {
          var docFrag = document.createDocumentFragment();
          var isNode = lastLink instanceof Node;
          docFrag.appendChild(isNode ? lastLink : document.createTextNode(String(lastLink)));
          collapsedLinks.insertBefore(docFrag, collapsedLinks.firstChild);
          return;
        }

        collapsedLinks.prepend(lastLink);
      } // TODO (agrow) investigate removing this
      // Adapted from Element.closest polyfill
      // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill

    }, {
      key: "_closest",
      value: function _closest(el, closestElSelector) {
        if (!el.hasOwnProperty('closest')) {
          do {
            if (DOM.matches(el, closestElSelector)) return el;
            el = el.parentElement || el.parentNode;
          } while (el !== null && el.nodeType === 1);

          return null;
        }

        return el.closest(closestElSelector);
      }
    }, {
      key: "getUrlParams",
      value: function getUrlParams() {
        return new SearchParams(window.location.search.substring(1));
      }
    }, {
      key: "shouldCollapse",
      value: function shouldCollapse() {
        switch (this._mobileOverflowBehavior) {
          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE:
            return true;

          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.INNERSCROLL:
            var container = DOM.query(this._container, '.yxt-Nav-container') || this._container;

            var navWidth = container.offsetWidth;
            return navWidth > MOBILE_BREAKPOINT;
        }
      }
      /**
       * getDefaultTabOrder will compute the initial tab ordering based
       * on a combination of the configuration provided directly to the component
       * and the url params.
       * @param {Object[]} tabsConfig
       * @param {SearchParams}
       */

    }, {
      key: "getDefaultTabOrder",
      value: function getDefaultTabOrder(tabsConfig, urlParams) {
        var tabOrder = []; // Use the ordering from the URL as the primary configuration
        // And then merge it with the local configuration, if provided.

        if (urlParams && urlParams.has('tabOrder')) {
          tabOrder = urlParams.get('tabOrder').split(',');
        }

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = tabsConfig[i]; // Some tabs don't have verticalKey, so we map it from URL

          if (!tab.verticalKey) {
            tab.verticalKey = tab.url;
          } // Avoid duplicates if config was provided from URL


          if (tabOrder.includes(tab.verticalKey)) {
            continue;
          } // isFirst should always be the first element in the list


          if (tab.isFirst) {
            tabOrder.unshift(tab.verticalKey);
          } else {
            tabOrder.push(tab.verticalKey);
          }
        }

        return tabOrder;
      }
      /**
       * mergeTabOrder merges two arrays into one
       * by appending additional tabs to the end of the original array
       * @param {string[]} tabOrder Tab order provided by the server
       * @param {string[]} otherTabOrder Tab order provided by configuration
       * @return {string[]}
       */

    }, {
      key: "mergeTabOrder",
      value: function mergeTabOrder(tabOrder, otherTabOrder) {
        for (var i = 0; i < otherTabOrder.length; i++) {
          var tabConfig = otherTabOrder[i];

          if (tabOrder.includes(tabConfig)) {
            continue;
          } // isFirst should be an override to dynamic tab ordering.


          if (this._tabs[tabConfig] && this._tabs[tabConfig].isFirst) {
            tabOrder.unshift(tabConfig);
          } else {
            tabOrder.push(tabConfig);
          }
        }

        return tabOrder;
      }
    }, {
      key: "generateTabUrl",
      value: function generateTabUrl(baseUrl) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();
        // We want to persist the params from the existing URL to the new
        // URLS we create.
        params.set('tabOrder', this._tabOrder);
        return baseUrl + '?' + params.toString();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'navigation/navigation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Navigation';
      }
    }]);

    return NavigationComponent;
  }(Component);

  var IconState = {
    'YEXT': 0,
    'MAGNIFYING_GLASS': 1
  };
  /**
   * SearchComponent exposes an interface in order to create
   * a UI Search experience for vertical and universal search.
   *
   * @extends Component
   */

  var SearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SearchComponent, _Component);

    function SearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchComponent).call(this, config, systemConfig));
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, auto-complete and search will be based on universal
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided. If not provided, no title will be included.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The label text is used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.labelText = config.labelText || 'Conduct a search';
      /**
       * The submit text is used for labeling the submit button, also provided to the template.
       * @type {string}
       */

      _this.submitText = config.submitText || 'Submit';
      /**
       * The clear text is used for labeling the clear button, also provided to the template.
       * @type {string}
       */

      _this.clearText = config.clearText || 'Clear';
      /**
       * The submit icon is an icon for the submit button, if provided it will be displayed and the
       * submit text will be used for screen readers.
       * @type {string|null}
       */

      _this.submitIcon = config.submitIcon || null;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * If true, show an "x" that allows the user to clear the current
       * query
       * @type {boolean}
       */

      _this.clearButton = config.clearButton === undefined ? true : config.clearButton;
      /**
       * When autofocusing on load, optionally open the autocomplete
       * (preset prompts)
       * @type {boolean}
       */

      _this.autocompleteOnLoad = config.autocompleteOnLoad || false;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * true if there is another search bar present on the page.
       * Twins only update the query, and do not search
       */

      _this._isTwin = config.isTwin;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string|null}
       */

      _this.query = config.query || _this.core.globalStorage.getState(StorageKeys.QUERY);

      _this.core.globalStorage.on('update', StorageKeys.QUERY, function (q) {
        _this.query = q;

        if (_this.queryEl) {
          _this.queryEl.value = q;
        }

        _this.debouncedSearch(q);
      });
      /**
       * The minimum time allowed in milliseconds between searches to prevent
       * many duplicate searches back-to-back
       * @type {number}
       * @private
       */


      _this._searchCooldown = config.searchCooldown || 300;
      /**
       * When true and "near me" intent is expressed, prompt the user for their geolocation
       * @type {boolean}
       * @private
       */

      _this._promptForLocation = config.promptForLocation === undefined ? true : Boolean(config.promptForLocation);
      /**
       * Controls showing and hiding the search clear button
       */

      _this._showClearButton = _this.clearButton && _this.query;
      /**
       * For vertical search bars, whether or not to allow empty searches.
       * @type {boolean}
       * @private
       */

      _this._allowEmptySearch = !!config.allowEmptySearch;
      /**
       * The name of the child AutoComplete component.
       * @type {string}
       * @private
       */

      _this._autoCompleteName = "".concat(_this.name, ".autocomplete");
      return _this;
    }

    _createClass(SearchComponent, [{
      key: "onCreate",
      value: function onCreate() {
        if (this.query != null && !this.redirectUrl) {
          this.core.setQuery(this.query);
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        this.queryEl = DOM.query(this._container, this._inputEl);

        if (this.autoFocus && !this.query && !this.autocompleteOnLoad) {
          this.focusInputElement();
        }

        this.isUsingYextAnimatedIcon = !this._config.customIconUrl && !this.submitIcon;

        if (this.isUsingYextAnimatedIcon) {
          this.initAnimatedIcon();
        } // Wire up our search handling and auto complete


        this.initSearch(this._formEl);
        this.initAutoComplete(this._inputEl);

        if (this.clearButton) {
          this.initClearButton();
        }

        if (this.autoFocus && !this.query && this.autocompleteOnLoad) {
          this.focusInputElement();
        }
      }
    }, {
      key: "requestIconAnimationFrame",
      value: function requestIconAnimationFrame(iconState) {
        var _this2 = this;

        if (this.iconState === iconState) {
          return;
        }

        this.iconState = iconState;

        if (!this.isRequestingAnimationFrame) {
          this.isRequestingAnimationFrame = true;
          window.requestAnimationFrame(function () {
            _this2.forwardIcon.classList.remove('yxt-SearchBar-AnimatedIcon--paused');

            _this2.reverseIcon.classList.remove('yxt-SearchBar-AnimatedIcon--paused');

            if (_this2.iconState === IconState.MAGNIFYING_GLASS) {
              _this2.forwardIcon.classList.remove('yxt-SearchBar-AnimatedIcon--inactive');

              _this2.reverseIcon.classList.add('yxt-SearchBar-AnimatedIcon--inactive');
            } else if (_this2.iconState === IconState.YEXT) {
              _this2.forwardIcon.classList.add('yxt-SearchBar-AnimatedIcon--inactive');

              _this2.reverseIcon.classList.remove('yxt-SearchBar-AnimatedIcon--inactive');
            }

            _this2.isRequestingAnimationFrame = false;
          });
        }
      }
    }, {
      key: "animateIconToMagnifyingGlass",
      value: function animateIconToMagnifyingGlass() {
        if (this.iconIsFrozen) {
          return;
        }

        this.requestIconAnimationFrame(IconState.MAGNIFYING_GLASS);
      }
    }, {
      key: "animateIconToYext",
      value: function animateIconToYext(e) {
        var focusStillInSearchbar = false;

        if (e && e.relatedTarget) {
          focusStillInSearchbar = this._container.contains(e.relatedTarget);
        }

        if (this.iconIsFrozen || focusStillInSearchbar) {
          return;
        }

        this.requestIconAnimationFrame(IconState.YEXT);
      }
    }, {
      key: "initAnimatedIcon",
      value: function initAnimatedIcon() {
        var _this3 = this;

        this.iconState = this.autoFocus && !this.query ? IconState.MAGNIFYING_GLASS : IconState.YEXT;
        this.forwardIcon = DOM.query(this._container, '.js-yxt-AnimatedForward');
        this.reverseIcon = DOM.query(this._container, '.js-yxt-AnimatedReverse');
        var clickableElementSelectors = ['.js-yext-submit', '.js-yxt-SearchBar-clear'];

        for (var _i = 0, _clickableElementSele = clickableElementSelectors; _i < _clickableElementSele.length; _i++) {
          var selector = _clickableElementSele[_i];
          var clickableEl = DOM.query(this._container, selector);

          if (clickableEl) {
            DOM.on(clickableEl, 'mousedown', function () {
              _this3.iconIsFrozen = true;
            });
            DOM.on(clickableEl, 'mouseup', function () {
              _this3.iconIsFrozen = false;
            });
          }
        }

        DOM.on(this.queryEl, 'focus', function () {
          _this3.animateIconToMagnifyingGlass();
        });
        DOM.on(this._container, 'focusout', function (e) {
          _this3.animateIconToYext(e);
        });
      }
    }, {
      key: "remove",
      value: function remove() {
        this._autocomplete.remove();

        _get(_getPrototypeOf(SearchComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "initClearButton",
      value: function initClearButton() {
        var _this4 = this;

        var button = DOM.query(this._container, '.js-yxt-SearchBar-clear');
        this._showClearButton = this._showClearButton || this.query;
        button.classList.toggle('yxt-SearchBar--hidden', !this._showClearButton);
        DOM.on(button, 'click', function () {
          _this4.query = '';
          _this4._showClearButton = false;
          button.classList.add('yxt-SearchBar--hidden');
          _this4.queryEl.value = _this4.query;

          _this4.core.persistentStorage.set(StorageKeys.QUERY, _this4.query);

          _this4.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this4.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this4.core.setQuery(_this4.query); // Focus the input element after clearing the query, regardless of whether
          // or not the autoFocus option is enabled.
          // NOTE(amullings): This depends heavily on the fact that the re-renders
          // triggered by setState and core.setQuery happen synchronously; if this
          // stops being the case at some point, we'll need an alternative solution


          _this4.focusInputElement();
        });
        DOM.on(this.queryEl, 'input', function (e) {
          var input = e.target.value;
          _this4.query = input;

          if (!_this4._showClearButton && input.length > 0) {
            _this4._showClearButton = true;
            button.classList.remove('yxt-SearchBar--hidden');
          } else if (_this4._showClearButton && input.length === 0) {
            _this4._showClearButton = false;
            button.classList.add('yxt-SearchBar--hidden');
          }
        });
      }
      /**
       * A helper method to use for wiring up searching on form submission
       * @param {string} formSelector CSS selector to bind our submit handling to
       */

    }, {
      key: "initSearch",
      value: function initSearch(formSelector) {
        var _this5 = this;

        this._formEl = formSelector;

        this._container.classList.add('yxt-SearchBar-wrapper');

        var form = DOM.query(this._container, formSelector);

        if (!form) {
          throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._formEl, '`.');
        }

        DOM.on(form, 'submit', function (e) {
          e.preventDefault(); // TODO(oshi) we should not use the same css selector (this._inputEl)
          // For both the autocomplete AND the search bar input
          // This is incredibly confusing, and also makes the first DOM.query
          // Rely on the order of the input el and autocomplete in the template

          var inputEl = form.querySelector(_this5._inputEl);
          var query = inputEl.value;
          _this5.query = query;
          var params = new SearchParams(window.location.search.substring(1));
          params.set('query', query); // If we have a redirectUrl, we want the form to be
          // serialized and submitted.

          if (typeof _this5.redirectUrl === 'string') {
            window.location.href = _this5.redirectUrl + '?' + params.toString();
            return false;
          }

          inputEl.blur();
          DOM.query(_this5._container, '.js-yext-submit').blur(); // TODO: move this into initClearButton

          if (_this5.clearButton) {
            var button = DOM.query(_this5._container, '.js-yxt-SearchBar-clear');

            if (_this5.query) {
              _this5._showClearButton = true;
              button.classList.remove('yxt-SearchBar--hidden');
            } else {
              _this5._showClearButton = false;
              button.classList.add('yxt-SearchBar--hidden');
            }
          }

          if (_this5.isUsingYextAnimatedIcon) {
            _this5.animateIconToYext();
          }

          _this5.core.persistentStorage.set(StorageKeys.QUERY, query);

          _this5.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this5.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this5.core.setQuery(query);

          _this5.debouncedSearch(query);

          return false;
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this6 = this;

        this._inputEl = inputSelector;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: this._autoCompleteName,
          container: '.yxt-SearchBar-autocomplete',
          autoFocus: this.autoFocus && !this.autocompleteOnLoad,
          verticalKey: this._verticalKey,
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          inputEl: inputSelector,
          onSubmit: function onSubmit() {
            DOM.trigger(DOM.query(_this6._container, _this6._formEl), 'submit');
          },
          onChange: function onChange() {
            DOM.trigger(DOM.query(_this6._container, inputSelector), 'input');
          }
        });
      }
      /**
       * Performs a debounced query using the provided string input. Specifically, a new search is not
       * performed if we recently searched, if there's no query for universal search, or if this
       * is a twin searchbar.
       * @param {string} query The string to query against.
       * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
       */

    }, {
      key: "debouncedSearch",
      value: function debouncedSearch(query) {
        var _this7 = this;

        if (this._throttled || !query && !this._verticalKey || !query && this._verticalKey && !this._allowEmptySearch || this._isTwin) {
          return;
        }

        this._throttled = true;
        setTimeout(function () {
          _this7._throttled = false;
        }, this._searchCooldown); // If _promptForLocation is enabled, we will compute the query's intent and, from there,
        // determine if it's necessary to prompt the user for their location information. It will
        // be unnecessary if the query does not have near me intent or we already have their location
        // stored.

        if (this._promptForLocation) {
          this.fetchQueryIntents(query).then(function (queryIntents) {
            return queryIntents.includes('NEAR_ME');
          }).then(function (queryHasNearMeIntent) {
            if (queryHasNearMeIntent && !_this7.core.globalStorage.getState(StorageKeys.GEOLOCATION)) {
              return new Promise(function (resolve, reject) {
                return navigator.geolocation.getCurrentPosition(function (position) {
                  _this7.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    radius: position.coords.accuracy
                  });

                  resolve(_this7.search(query));
                }, function () {
                  return resolve(_this7.search(query));
                });
              });
            } else {
              return _this7.search(query);
            }
          });
        } else {
          return this.search(query);
        }
      }
      /**
       * Performs a query using the provided string input.
       * @param {string} query The string to query against.
       * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
       */

    }, {
      key: "search",
      value: function search(query) {
        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          return this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0
          });
        } else {
          // NOTE(billy) Temporary hack for DEMO
          // Remove me after the demo
          var nav = this.componentManager.getActiveComponent('Navigation');

          if (nav) {
            var tabs = nav.getState('tabs');
            var urls = {};

            if (tabs && Array.isArray(tabs)) {
              for (var i = 0; i < tabs.length; i++) {
                var params = new SearchParams(tabs[i].url.split('?')[1]);
                params.set('query', query);
                var url = tabs[i].baseUrl;

                if (params.toString().length > 0) {
                  url += '?' + params.toString();
                }

                urls[tabs[i].configId] = url;
              }
            }

            return this.core.search(query, urls);
          }

          return this.core.search(query);
        }
      }
      /**
       * A helper method that computes the intents of the provided query. If the query was entered
       * manually into the search bar or selected via autocomplete, its intents will have been stored
       * already in globalStorage. Otherwise, a new API call will have to be issued to determine
       * intent.
       * @param {string} query The query whose intent is needed.
       * @returns {Promise} A promise containing the intents of the query.
       */

    }, {
      key: "fetchQueryIntents",
      value: function fetchQueryIntents(query) {
        var autocompleteData = this.core.globalStorage.getState("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(this._autoCompleteName));

        if (!autocompleteData) {
          var autocompleteRequest = this._verticalKey ? this.core.autoCompleteVertical(query, this._autoCompleteName, this._verticalKey) : this.core.autoCompleteUniversal(query, this._autoCompleteName);
          return autocompleteRequest.then(function (data) {
            return data.inputIntents;
          });
        } else {
          // There are two alternatives to consider here. The user could have selected the query
          // as an autocomplete option or manually input it themselves. If the former, use the intents
          // of the corresponding autocomplete option. If the latter, use the inputIntents of the
          // autocompleteData.
          var results = autocompleteData.sections.flatMap(function (section) {
            return section.results;
          });
          var matchingResult = results.find(function (result) {
            return result.value === query;
          });
          var queryIntents = matchingResult ? matchingResult.intents : autocompleteData.inputIntents;
          return Promise.resolve(queryIntents);
        }
      }
      /**
       * A helper method that constructs the meta information needed by the SEARCH_CLEAR_BUTTON
       * analytics event.
       */

    }, {
      key: "eventOptions",
      value: function eventOptions() {
        var queryId = this.core.globalStorage.getState(StorageKeys.QUERY_ID);
        var options = Object.assign({}, queryId && {
          queryId: queryId
        }, this._verticalKey && {
          verticalKey: this._verticalKey
        });
        return JSON.stringify(options);
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var forwardIconOpts = {
          iconName: 'yext_animated_forward',
          classNames: 'Icon--lg',
          complexContentsParams: {
            iconPrefix: this.name
          }
        };
        var reverseIconOpts = {
          iconName: 'yext_animated_reverse',
          classNames: 'Icon--lg',
          complexContentsParams: {
            iconPrefix: this.name
          }
        };
        return _get(_getPrototypeOf(SearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          labelText: this.labelText,
          submitIcon: this.submitIcon,
          submitText: this.submitText,
          clearText: this.clearText,
          showClearButton: this._showClearButton,
          query: this.query || '',
          eventOptions: this.eventOptions(),
          iconId: this.name,
          forwardIconOpts: forwardIconOpts,
          reverseIconOpts: reverseIconOpts,
          autoFocus: this.autoFocus && !this.query
        }, data));
      }
    }, {
      key: "focusInputElement",
      value: function focusInputElement() {
        DOM.query(this._container, this._inputEl).focus();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/search';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SearchBar';
      }
    }]);

    return SearchComponent;
  }(Component);

  /** @module SearchParamsParser */
  function buildSearchParameters(searchParameterConfigs) {
    var searchParameters = {
      sectioned: false,
      fields: []
    };

    if (searchParameterConfigs === undefined) {
      return searchParameters;
    }

    if (searchParameterConfigs.sectioned) {
      searchParameters.sectioned = searchParameterConfigs.sectioned;
    }

    searchParameters.fields = buildFields(searchParameterConfigs.fields);
    return searchParameters;
  }

  function buildFields(fieldConfigs) {
    if (fieldConfigs === undefined) {
      return [];
    }

    return fieldConfigs.map(function (fc) {
      return _objectSpread({
        fetchEntities: false
      }, fc);
    });
  }

  /**
   * FilterSearchComponent is used for autocomplete using the FilterSearch backend.
   * It'll allow you to pick pre-set filters that are setup on the backend within
   * a vertical search context.
   *
   * @extends Component
   */

  var FilterSearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterSearchComponent, _Component);

    function FilterSearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterSearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterSearchComponent).call(this, config, systemConfig));
      /**
       * The vertical key for vertical search configuration
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * If true, store the filter value but do not search on change
       * @type {boolean}
       * @private
       */

      _this._storeOnChange = config.storeOnChange || false;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The search text used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.searchText = config.searchText || 'What are you interested in?';
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string}
       */

      _this.query = config.query || _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.search();
      });
      /**
       * The filter string to use for the provided query
       * Optionally provided
       * @type {string}
       */


      _this.filter = config.filter || _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || '';

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.searchParameters = buildSearchParameters(config.searchParameters);

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      return _this;
    }

    _createClass(FilterSearchComponent, [{
      key: "onCreate",
      // TODO(oshi): SPR-1925 check that it is safe to remove this, it runs an extra search
      // For no obvious reasons
      value: function onCreate() {
        if (this.query && this.filter) {
          this.search();
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        // Wire up our search handling and auto complete
        this.initAutoComplete(this._inputEl);

        if (this.autoFocus === true && this.query.length === 0) {
          DOM.query(this._container, this._inputEl).focus();
        }
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this2 = this;

        this._inputEl = inputSelector;
        this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.yxt-SearchBar-autocomplete',
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._verticalKey,
          searchParameters: this.searchParameters,
          onSubmit: function onSubmit(query, filter) {
            var params = new SearchParams(window.location.search.substring(1));
            params.set("".concat(_this2.name, ".query"), query);
            params.set("".concat(_this2.name, ".filter"), filter); // If we have a redirectUrl, we want the params to be
            // serialized and submitted.

            if (typeof _this2.redirectUrl === 'string') {
              window.location.href = _this2.redirectUrl + '?' + params.toString();
              return false;
            } // save the filter to storage for the next search


            _this2.query = query;
            _this2.filter = Filter.fromResponse(filter);

            _this2.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(_this2.name), _this2.query);

            _this2.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(_this2.name), _this2.filter);

            _this2.core.setFilter(_this2.name, _this2.filter);

            _this2.search();
          }
        });
      }
      /**
       * Perform the vertical search with all saved filters and query,
       * optionally redirecting based on config
       */

    }, {
      key: "search",
      value: function search() {
        if (this._storeOnChange) {
          return;
        }

        var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = filters[0];

        if (filters.length > 1) {
          totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
        }

        var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: searchQuery,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(FilterSearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          searchText: this.searchText,
          query: this.query,
          filter: this.filter
        }, data));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/filtersearch';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterSearch';
      }
    }]);

    return FilterSearchComponent;
  }(Component);

  var Keys = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESCAPE: 27,
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DELETE: 46,
    DOWN: 40,
    LEFT_OS_KEY: 91,
    RIGHT_OS_KEY: 92,
    SELECT_KEY: 93
  };

  var AutoCompleteComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AutoCompleteComponent, _Component);

    function AutoCompleteComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AutoCompleteComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AutoCompleteComponent).call(this, opts, systemOpts));
      /**
       * Whether autocomplete is simple or filter
       * @type {boolean}
       */

      _this.isFilterSearch = opts.isFilterSearch || false;
      /**
       * The `verticalKey` of the vertical search to use for auto-complete
       * @type {string}
       */

      _this._verticalKey = opts.verticalKey || null;
      /**
       * A reference to the input el selector for auto complete
       * @type {string}
       */

      _this._inputEl = opts.inputEl || '.js-yext-query';
      /**
       * A selector for the autocomplete elementes
       * @type {string}
       */

      _this._autocompleteEls = opts.autoCompleteEls || '.js-yext-autocomplete-option';
      /**
       * An internal reference for the data-storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = "".concat(StorageKeys.AUTOCOMPLETE, ".").concat(_this.name);
      /**
       * An internal reference to the input value when typing.
       * We use this for resetting the state of the input value when other interactions (e.g. result navigation)
       * change based on interactions. For instance, hitting escape should reset the value to the original typed query.
       * @type {string}
       */

      _this._originalQuery = opts.originalQuery || '';
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current section we're navigating in.
       * @type {number}
       */

      _this._sectionIndex = 0;
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current result index we're navigating on.
       * @type {number}
       */

      _this._resultIndex = -1;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = opts.promptHeader || null;
      /**
       * Whether the input is autocomatically focused or not
       * @type {boolean}
       */

      _this._autoFocus = opts.autoFocus || false;
      /**
       * Callback invoked when the `Enter` key is pressed on auto complete.
       */

      _this._onSubmit = opts.onSubmit || function () {};
      /**
       * Callback invoked when keys are used to navigate through the auto complete. Note that this is
       * not called when either the `Enter` key is pressed or the mouse is used to select an
       * autocomplete option.
       */


      _this._onChange = opts.onChange || function () {};

      _this._searchParameters = opts.searchParameters || null;
      return _this;
    }
    /**
     * The aliased used by the component manager for creation.
     */


    _createClass(AutoCompleteComponent, [{
      key: "setState",

      /**
       * setState is overridden so that we can provide additional meta data
       * to the template (e.g. the sectionIndex and resultIndex), since
       * those are client-interaction specific values and aren't returned from the server.
       */
      value: function setState(data) {
        if (!this.isQueryInputFocused()) {
          this._sectionIndex = 0;
          this._resultIndex = -1;
          data = {};
        }

        _get(_getPrototypeOf(AutoCompleteComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          hasResults: this.hasResults(data),
          sectionIndex: this._sectionIndex,
          resultIndex: this._resultIndex,
          promptHeader: this._originalQuery.length === 0 ? this.promptHeader : null
        }));
      }
    }, {
      key: "isQueryInputFocused",
      value: function isQueryInputFocused() {
        return document.activeElement && document.activeElement.className.includes(this._inputEl.substring(1));
      }
      /**
       * updateState is a helper to apply the current state with new client-state.
       */

    }, {
      key: "updateState",
      value: function updateState() {
        this.setState(this._state.get());
      }
      /**
       * onCreate is triggered when the component is constructed from the framework.
       * Once we're initalized, we wire up all of our user interactions
       */

    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        // Use the context of the parent component to find the input node.
        var queryInput = DOM.query(this._parentContainer, this._inputEl);

        if (!queryInput) {
          throw new Error('Could not initialize AutoComplete. Can not find {HTMLElement} `', this._inputEl, '`.');
        } // Disable the native autocomplete, autocorrect & spellcheck


        DOM.attributes(queryInput, {
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: 'false'
        }); // The user exits the input, so we want to reset the state and close
        // the auto complete
        // TODO(jdelerme): Close logic to be moved to parent

        DOM.on(document, 'click', function (e) {
          if (DOM.matches(e.target, '.js-yxt-AutoComplete-wrapper *') || DOM.matches(e.target, _this2._inputEl)) {
            return;
          }

          _this2.close();
        }); // When a user focuses the input, we should populate the autocomplete based
        // on the current value

        DOM.on(queryInput, 'focus', function () {
          _this2.reset();

          _this2.autoComplete(queryInput.value);
        }); // Allow the user to navigate between the results using the keyboard

        DOM.on(queryInput, 'keydown', function (e) {
          _this2.handleNavigateResults(e.keyCode, e);

          _this2.handleSubmitResult(e.keyCode, queryInput.value, e);
        });

        if (this._autoFocus) {
          DOM.once(queryInput, 'click', function () {
            _this2.autoComplete(queryInput.value);
          });
        } // Allow the user to select a result with the mouse


        DOM.delegate(this._container, '.js-yext-autocomplete-option', 'click', function (evt, target) {
          var data = target.dataset;
          var val = data["short"];

          _this2.updateQuery(val);

          _this2._onSubmit(val, data.filter);

          _this2.close();
        }); // When the user is typing in the input, process the auto complete.

        DOM.on(queryInput, 'keyup', function (e) {
          _this2.handleTyping(e.keyCode, queryInput.value, e);
        });
      }
      /**
       * close will hide the auto complete results and reset the state.
       */

    }, {
      key: "close",
      value: function close() {
        this.setState({});
        this.reset();
      }
      /**
       * resets the client state to their original values and triggers
       * a template-rerender via updateState
       */

    }, {
      key: "reset",
      value: function reset() {
        this._sectionIndex = 0;
        this._resultIndex = -1;
        this.updateState();
      }
      /**
       * Helper method to update the input text
       * @param {string} optValue Option value provided.
       * If no value provided, we'll try to find it based on the selection indexes.
       */

    }, {
      key: "updateQuery",
      value: function updateQuery(optValue) {
        // Only want to update the query string if theres a value.
        // If one is provided, great.
        // Otherwise, lets try to find it from the current selection in the results.
        if (optValue === undefined) {
          var sections = this._state.get('sections');

          var results = sections[this._sectionIndex].results;
          optValue = results[this._resultIndex].shortValue;
        }

        var queryEl = DOM.query(this._parentContainer, this._inputEl);
        queryEl.value = optValue;
      }
    }, {
      key: "handleTyping",
      value: function handleTyping(key, value, e) {
        var ignoredKeys = [Keys.DOWN, Keys.UP, Keys.CTRL, Keys.ALT, Keys.SHIFT, Keys.LEFT, Keys.RIGHT, Keys.LEFT_OS_KEY, Keys.RIGHT_OS_KEY, Keys.ENTER, Keys.TAB, Keys.SELECT_KEY];

        if (ignoredKeys.indexOf(key) > -1) {
          return;
        } // User escapes out of auto complete, so we reset it to the original input


        if (key === Keys.ESCAPE) {
          this.updateQuery(this._originalQuery);
          this.close();
          return;
        } // Update the original value based on the user input


        this._originalQuery = value;
        this.reset();
        this.autoComplete(value);
      }
    }, {
      key: "autoComplete",
      value: function autoComplete(input) {
        if (this.isFilterSearch) {
          this.core.autoCompleteFilter(input, {
            namespace: this.name,
            verticalKey: this._verticalKey,
            searchParameters: this._searchParameters
          });
        } else if (this._verticalKey) {
          this.core.autoCompleteVertical(input, this.name, this._verticalKey);
        } else {
          this.core.autoCompleteUniversal(input, this.name);
        }
      }
      /**
       * returns true if we have results in any section
       * @returns boolean
       */

    }, {
      key: "hasResults",
      value: function hasResults(data) {
        if (!data) {
          return false;
        }

        var sections = data['sections'];

        if (!sections) {
          return false;
        }

        for (var i = 0; i < sections.length; i++) {
          var _data = sections[i];

          if (!_data) {
            continue;
          }

          var results = _data.results;

          if (!results) {
            continue;
          }

          if (results.length > 0) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "handleNavigateResults",
      value: function handleNavigateResults(key, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          return;
        } // Tabbing out or enter should close the auto complete.


        if (key === Keys.TAB) {
          this.close();
          return;
        }

        var results = sections[this._sectionIndex].results;

        if (key === Keys.UP) {
          e.preventDefault();

          if (this._resultIndex <= 0) {
            if (this._sectionIndex > 0) {
              this._sectionIndex--;
              this._resultIndex = sections[this._sectionIndex].results.length - 1;
            } else {
              this.updateQuery(this._originalQuery);
              this.reset();
              return;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex--;
          this.updateState();
          this.updateQuery();
          return;
        }

        if (key === Keys.DOWN) {
          e.preventDefault();

          if (this._resultIndex >= results.length - 1) {
            if (this._sectionIndex < sections.length - 1) {
              this._sectionIndex++;
              this._resultIndex = 0;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex++;
          this.updateQuery();
          this.updateState();
        }
      }
    }, {
      key: "handleSubmitResult",
      value: function handleSubmitResult(key, value, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          if (this.isFilterSearch) {
            this.autoComplete(value);
          }

          return;
        } // submit the search on enter


        if (key === Keys.ENTER) {
          e.preventDefault();

          if (this.isFilterSearch && this._resultIndex === -1) {
            return;
          }

          var filter = '';

          if (this._sectionIndex >= 0 && this._resultIndex >= 0) {
            filter = JSON.stringify(sections[this._sectionIndex].results[this._resultIndex].filter);
          }

          this.updateQuery(value);
          this._originalQuery = value;

          this._onSubmit(value, filter);

          this.close();
        } else {
          this._onChange();
        }
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'search/autocomplete';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AutoComplete';
      }
    }]);

    return AutoCompleteComponent;
  }(Component);

  var DEFAULT_CONFIG = {
    suggestionHelpText: 'Did you mean:'
  };
  /**
   * SpellCheckComponent will support displaying suggestion, autocorrect and combined(maybe in the future)
   * provided from spelling correction.
   *
   * @extends Component
   */

  var SpellCheckComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SpellCheckComponent, _Component);

    function SpellCheckComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SpellCheckComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SpellCheckComponent).call(this, _objectSpread({}, DEFAULT_CONFIG, {}, config), systemConfig));
      _this.moduleId = StorageKeys.SPELL_CHECK;
      return _this;
    }

    _createClass(SpellCheckComponent, [{
      key: "onCreate",
      value: function onCreate() {
        this.core.persistentStorage["delete"]('skipSpellCheck', true);
        this.core.persistentStorage["delete"]('queryTrigger', true);
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        return _get(_getPrototypeOf(SpellCheckComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          shouldShow: data.correctedQuery !== undefined,
          correctedQueryUrl: this._buildRedirectQueryUrl(data.correctedQuery, data.type),
          helpText: this._getHelpText(data.type)
        }, val));
      }
    }, {
      key: "_buildRedirectQueryUrl",
      value: function _buildRedirectQueryUrl(query, type) {
        if (query === undefined) {
          return '';
        }

        var params = new SearchParams(window.location.search.substring(1));
        params.set('query', query.value);
        params.set('skipSpellCheck', true);
        params.set('queryTrigger', type.toLowerCase());
        return '?' + params.toString();
      }
    }, {
      key: "_getHelpText",
      value: function _getHelpText(type) {
        switch (type) {
          case 'SUGGEST':
            return this._config.suggestionHelpText;

          default:
            return '';
        }
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/spellcheck';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SpellCheck';
      }
    }]);

    return SpellCheckComponent;
  }(Component);

  var DEFAULT_CONFIG$1 = {
    ipAccuracyHelpText: 'based on your internet address',
    deviceAccuracyHelpText: 'based on your device',
    updateLocationButtonText: 'Update your location'
  };
  /**
   * LocationBiasComponent will show the user where is used for location bias and allow user to
   * improve accuracy with HTML5 geolocation.
   *
   * @extends Component
   */

  var LocationBiasComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(LocationBiasComponent, _Component);

    function LocationBiasComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LocationBiasComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationBiasComponent).call(this, _objectSpread({}, DEFAULT_CONFIG$1, {}, config), systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.LOCATION_BIAS;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, when location updated,
       * a universal search will be triggered.
       * @type {string}
       */
      // TODO: Remove config.verticalKey

      _this._verticalKey = config.verticalKey || _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey || null;
      /**
       * The element used for updating location
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._updateLocationEl = config.updateLocationEl || '.js-locationBias-update-location';
      _this._locationDisplayName = '';
      _this._accuracy = '';
      _this._allowUpdate = true;
      return _this;
    }

    _createClass(LocationBiasComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (!this._allowUpdate) {
          return;
        }

        this._disableLocationUpdateIfGeolocationDenied();

        DOM.on(this._updateLocationEl, 'click', function (e) {
          if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(function (position) {
              _this2.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                radius: position.coords.accuracy
              });

              _this2._doSearch();
            }, function (err) {
              if (err.code === 1) {
                _this2._disableLocationUpdate();
              }
            });
          } // TODO: Should we throw error or warning here if no geolocation?

        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        this._locationDisplayName = data.locationDisplayName;
        this._accuracy = data.accuracy;
        return _get(_getPrototypeOf(LocationBiasComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          locationDisplayName: this._getLocationDisplayName(data),
          accuracyText: this._getAccuracyHelpText(data.accuracy),
          isPreciseLocation: data.accuracy === 'DEVICE' && this._allowUpdate,
          isUnknownLocation: data.accuracy === 'UNKNOWN',
          shouldShow: data.accuracy !== undefined,
          allowUpdate: this._allowUpdate
        }, val));
      }
    }, {
      key: "_getLocationDisplayName",
      value: function _getLocationDisplayName(data) {
        if (data.accuracy === 'UNKNOWN') {
          return 'Unknown Location';
        }

        return data.locationDisplayName;
      }
    }, {
      key: "_getAccuracyHelpText",
      value: function _getAccuracyHelpText(accuracy) {
        accuracy = 'DEVICE';

        switch (accuracy) {
          case 'IP':
            return this._config.ipAccuracyHelpText;

          case 'DEVICE':
            return this._config.deviceAccuracyHelpText;

          default:
            return '';
        }
      }
    }, {
      key: "_doSearch",
      value: function _doSearch() {
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0,
            facetFilter: JSON.stringify(facetFilter)
          });
        } else {
          this.core.search(query);
        }
      }
    }, {
      key: "_disableLocationUpdateIfGeolocationDenied",
      value: function _disableLocationUpdateIfGeolocationDenied() {
        var _this3 = this;

        if ('permissions' in navigator) {
          navigator.permissions.query({
            name: 'geolocation'
          }).then(function (result) {
            if (result.state === 'denied') {
              _this3._disableLocationUpdate();
            }
          });
        }
      }
    }, {
      key: "_disableLocationUpdate",
      value: function _disableLocationUpdate() {
        this.core.globalStorage["delete"](StorageKeys.GEOLOCATION);
        this._allowUpdate = false;
        this.setState({
          locationDisplayName: this._locationDisplayName,
          accuracy: this._accuracy
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/locationbias';
      }
    }, {
      key: "type",
      get: function get() {
        return 'LocationBias';
      }
    }]);

    return LocationBiasComponent;
  }(Component);

  /** @module Facet */

  /**
   * Model representing a facet filter with the format of
   * {
   *   "field_name": [ Filters... ],
   *   ...
   * }
   *
   * @see {@link Filter}
   */
  var Facet =
  /*#__PURE__*/
  function () {
    function Facet() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Facet);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Create a facet filter from a list of Filters
     * @param  {...Filter} filters The filters to use in this facet
     * @returns {Facet}
     */


    _createClass(Facet, null, [{
      key: "fromFilters",
      value: function fromFilters(availableFieldIds) {
        var groups = {};
        availableFieldIds.forEach(function (fieldId) {
          groups[fieldId] = [];
        });

        for (var _len = arguments.length, filters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          filters[_key - 1] = arguments[_key];
        }

        var flatFilters = filters.flatMap(function (f) {
          return f.$or || f;
        });
        flatFilters.forEach(function (f) {
          var key = Object.keys(f)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(f);
        });
        return new Facet(groups);
      }
    }]);

    return Facet;
  }();

  var FilterBoxConfig =
  /*#__PURE__*/
  function () {
    function FilterBoxConfig(config) {
      _classCallCheck(this, FilterBoxConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFilter = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFilterLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFilters = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFiltersLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The selector of the apply button
       * @type {string}
       */

      this.applyButtonSelector = config.applyButtonSelector || '.js-yext-filterbox-apply';
      /**
       * The list of filters to display and control, ignoring empty sections
       * @type {object[]}
       */

      this.filterConfigs = config.filters.filter(function (f) {
        return f.options.length !== 0;
      });
      /**
       * Whether or not this filterbox contains facets. This affects the
       * the way the filters are used in the search
       * @type {boolean}
       */

      this.isDynamic = config.isDynamic || false;
      this.validate();
    }

    _createClass(FilterBoxConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FilterBoxConfig;
  }();
  /**
   * Renders a set of filters, and searches with them when applied.
   * Multiple FilterBox components will AND together but will not share state.
   * @extends Component
   */


  var FilterBoxComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterBoxComponent, _Component);

    function FilterBoxComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterBoxComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterBoxComponent).call(this, config, systemConfig));
      _this.config = new FilterBoxConfig(config);

      if (!config.filters || !(config.filters instanceof Array)) {
        throw new AnswersComponentError('FilterBox requires filters to be provided as an array', 'FilterBox');
      }
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */


      _this._verticalKey = config.verticalKey || null;
      /**
       * The components created for each filter config
       * @type {Component[]}
       * @private
       */

      _this._filterComponents = [];
      /**
       * The current state of the filter components in the box
       * @type {Filter}
       * @private
       */

      _this._filters = [];

      if (!_this.config.showCount) {
        _this.config.filterConfigs.forEach(function (config) {
          config.options.forEach(function (option) {
            option.countLabel = null;
          });
        });
      }

      return _this;
    }

    _createClass(FilterBoxComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(FilterBoxComponent.prototype), "setState", this).call(this, Object.assign({}, data, this.config, {
          showReset: this.config.resetFilters,
          resetLabel: this.config.resetFiltersLabel,
          showApplyButton: !this.config.searchOnChange
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._filterComponents.length) {
          this._filterComponents.forEach(function (c) {
            return c.remove();
          });

          this._filterComponents = [];
          this._filters = [];
        } // Initialize filters from configs


        var _loop = function _loop(i) {
          var config = _this2.config.filterConfigs[i];

          var component = _this2.componentManager.create(config.type, Object.assign({}, config, _this2.config, {
            parentContainer: _this2._container,
            name: "".concat(_this2.name, ".filter").concat(i),
            storeOnChange: false,
            container: ".js-yext-filterbox-filter".concat(i),
            showReset: _this2.config.resetFilter,
            resetLabel: _this2.config.resetFilterLabel,
            showExpand: _this2.config.expand,
            onChange: function onChange(filter) {
              _this2.onFilterChange(i, filter);
            }
          }));

          component.mount();

          _this2._filterComponents.push(component);

          _this2._filters[i] = component.getFilter();

          _this2._saveFiltersToStorage();
        };

        for (var i = 0; i < this.config.filterConfigs.length; i++) {
          _loop(i);
        } // Initialize apply button


        if (!this.config.searchOnChange) {
          var button = DOM.query(this._container, this.config.applyButtonSelector);

          if (button) {
            DOM.on(button, 'click', function () {
              _this2._saveFiltersToStorage();

              _this2._search();
            });
          }
        } // Initialize reset button


        if (this.config.resetFilters) {
          DOM.on(DOM.query(this._container, '.js-yxt-FilterBox-reset'), 'click', this.resetFilters.bind(this));
        }
      }
    }, {
      key: "resetFilters",
      value: function resetFilters() {
        this._filterComponents.forEach(function (filter) {
          return filter.clearOptions();
        });
      }
      /**
       * Handle changes to child filter components
       * @param {number} index The index of the changed filter
       * @param {Filter} filter The new filter
       */

    }, {
      key: "onFilterChange",
      value: function onFilterChange(index, filter) {
        this._filters[index] = filter;

        if (this.config.searchOnChange) {
          this._saveFiltersToStorage();

          this._search();
        }
      }
      /**
       * Remove all filter components along with this component
       */

    }, {
      key: "remove",
      value: function remove() {
        this._filterComponents.forEach(function (c) {
          return c.remove();
        });

        _get(_getPrototypeOf(FilterBoxComponent.prototype), "remove", this).call(this);
      }
      /**
       * Save current filters to storage to be used in the next search
       * @private
       */

    }, {
      key: "_saveFiltersToStorage",
      value: function _saveFiltersToStorage() {
        var validFilters = this._filters.filter(function (f) {
          return f !== undefined && f !== null && Object.keys(f).length > 0;
        });

        if (this.config.isDynamic) {
          var availableFieldIds = this.config.filterConfigs.map(function (config) {
            return config.fieldId;
          });
          var combinedFilter = Facet.fromFilters.apply(Facet, [availableFieldIds].concat(_toConsumableArray(validFilters)));
          this.core.setFacetFilter(this.name, combinedFilter || {});
        } else {
          var _combinedFilter = validFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(validFilters)) : validFilters[0];

          this.core.setFilter(this.name, _combinedFilter || {});
        }
      }
      /**
       * Trigger a search with all filters in storage
       */

    }, {
      key: "_search",
      value: function _search() {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: query,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'filters/filterbox';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterBox';
      }
    }]);

    return FilterBoxComponent;
  }(Component);

  /**
   * The currently supported controls
   * @type {string[]}
   */

  var SUPPORTED_CONTROLS = ['singleoption', 'multioption'];

  var FilterOptionsConfig =
  /*#__PURE__*/
  function () {
    function FilterOptionsConfig(config) {
      _classCallCheck(this, FilterOptionsConfig);

      /**
       * The type of control to display
       * @type {string}
       */
      this.control = config.control;
      /**
       * The list of filter options to display with checked status
       * @type {object[]}
       */

      this.options = config.options;
      /**
       * The label to be used in the legend
       * @type {string}
       */

      this.label = config.label || 'Filters';
      /**
       * The callback function to call when changed
       * @type {function}
       */

      this.onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       */


      this.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
      /**
       * If true, show a button to reset the current filter selection
       * @type {boolean}
       */

      this.showReset = config.showReset && this.options.length > 0;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetLabel = config.resetLabel || 'reset';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      this.showMore = this.showMore && this.options.length > this.showMoreLimit;
      /**
       * If true, allow expanding and collapsing the group of facets
       * @type {boolean}
       */

      this.showExpand = config.showExpand === undefined ? true : config.showExpand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * The selector used for options in the template
       * @type {string}
       */

      this.optionSelector = config.optionSelector || '.js-yext-filter-option';
      this.validate();

      if (typeof config.previousOptions === 'string') {
        try {
          config.previousOptions = JSON.parse(config.previousOptions);
        } catch (e) {
          config.previousOptions = [];
        }
      }

      var selectedOptions = config.previousOptions || [];
      this.options = this.setDefaultSelectedValues(this.options, selectedOptions);
    }

    _createClass(FilterOptionsConfig, [{
      key: "setDefaultSelectedValues",
      value: function setDefaultSelectedValues(options, selectedOptions) {
        return options.map(function (o) {
          return _objectSpread({}, o, {
            selected: selectedOptions.length ? selectedOptions.includes(o.label) : o.selected
          });
        });
      }
    }, {
      key: "getSelectedCount",
      value: function getSelectedCount() {
        return this.options.reduce(function (numSelected, option) {
          return option.selected ? numSelected + 1 : numSelected;
        }, 0);
      }
    }, {
      key: "validate",
      value: function validate() {
        if (!this.control || !SUPPORTED_CONTROLS.includes(this.control)) {
          throw new AnswersComponentError('FilterOptions requires a valid "control" to be provided', 'FilterOptions');
        }

        if (!this.options) {
          throw new AnswersComponentError('FilterOptions component requires options to be provided', 'FilterOptions');
        }
      }
    }]);

    return FilterOptionsConfig;
  }();
  /**
   * Renders a set of options, each one representing a filter in a search.
   */


  var FilterOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterOptionsComponent, _Component);

    function FilterOptionsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterOptionsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterOptionsComponent).call(this, config, systemConfig));

      var previousOptions = _this.core.globalStorage.getState(_this.name);

      _this.core.globalStorage["delete"](_this.name);
      /**
       * The component config
       * @type {FilterOptionsConfig}
       */


      _this.config = new FilterOptionsConfig(_objectSpread({
        previousOptions: previousOptions
      }, config));

      var selectedCount = _this.config.getSelectedCount();
      /**
       * True if the option list is expanded and visible
       * @type {boolean}
       */


      _this.expanded = _this.config.showExpand ? selectedCount > 0 : true;
      /**
       * True if all options are shown, false if some are hidden based on config
       * @type {boolean}
       */

      _this.allShown = false;
      return _this;
    }

    _createClass(FilterOptionsComponent, [{
      key: "setState",
      value: function setState(data) {
        var options = this.config.options;

        if (this.config.showMore && !this.allShown) {
          options = this.config.options.slice(0, this.config.showMoreLimit);
        }

        var selectedCount = this.config.getSelectedCount();

        _get(_getPrototypeOf(FilterOptionsComponent.prototype), "setState", this).call(this, Object.assign({}, data, _objectSpread({
          name: this.name.toLowerCase()
        }, this.config, {
          showReset: this.config.showReset && selectedCount > 0,
          expanded: this.expanded,
          allShown: this.allShown,
          selectedCount: selectedCount,
          isSingleOption: this.config.control === 'singleoption',
          options: options
        })));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        DOM.delegate(DOM.query(this._container, ".yxt-FilterOptions-options"), this.config.optionSelector, 'click', function (event) {
          _this2._updateOption(parseInt(event.target.dataset.index), event.target.checked);
        });
        var selectedCount = this.config.getSelectedCount(); // reset button

        if (this.config.showReset && selectedCount > 0) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-reset'), 'click', this.clearOptions.bind(this));
        } // show more/less button


        if (this.config.showMore) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-showToggle'), 'click', function () {
            _this2.allShown = !_this2.allShown;

            _this2.setState();
          });
        } // expand button


        if (this.config.showExpand) {
          var legend = DOM.query(this._container, '.yxt-FilterOptions-clickableLegend');
          DOM.on(legend, 'mousedown', function (click) {
            if (click.button === 0) {
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
          DOM.on(legend, 'keydown', function (key) {
            if (key.key === ' ' || key.key === 'Enter') {
              key.preventDefault();
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
        }
      }
    }, {
      key: "clearOptions",
      value: function clearOptions() {
        this.config.options = this.config.options.map(function (o) {
          return Object.assign({}, o, {
            selected: false
          });
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "updateListeners",
      value: function updateListeners() {
        var filter = this._buildFilter();

        if (this.config.storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.config.onChange(filter);
      }
    }, {
      key: "_updateOption",
      value: function _updateOption(index, selected) {
        if (this.config.control === 'singleoption') {
          this.config.options = this.config.options.map(function (o) {
            return Object.assign({}, o, {
              selected: false
            });
          });
        }

        this.config.options[index] = Object.assign({}, this.config.options[index], {
          selected: selected
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Clear all options
       */

    }, {
      key: "clear",
      value: function clear() {
        var elements = DOM.queryAll(this._container, this.config.optionSelector);
        elements.forEach(function (e) {
          return e.setAttribute('checked', 'false');
        });

        this._applyFilter();
      }
      /**
       * Build and return the Filter that represents the current state
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        var filters = this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.filter ? o.filter : Filter.equal(o.field, o.value);
        });
        this.core.persistentStorage.set(this.name, this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.label;
        }));
        return filters.length > 0 ? Filter.group.apply(Filter, _toConsumableArray(filters)) : {};
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render, based on the control
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return "controls/filteroptions";
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterOptions';
      }
    }]);

    return FilterOptionsComponent;
  }(Component);

  var DEFAULT_CONFIG$2 = {
    minPlaceholderText: 'Min',
    maxPlaceholderText: 'Max'
  };

  var RangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(RangeFilterComponent, _Component);

    function RangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, RangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeFilterComponent).call(this, _objectSpread({}, DEFAULT_CONFIG$2, {}, config), systemConfig));
      /**
       * The field to filter on
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The callback function to call when the filter value changes
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;

      var minVal = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      if (typeof minVal === 'string') {
        try {
          minVal = Number.parseInt(minVal);
        } catch (e) {}
      }

      var maxVal = _this.core.globalStorage.getState("".concat(_this.name, ".max"));

      if (typeof minVal === 'string') {
        try {
          maxVal = Number.parseInt(maxVal);
        } catch (e) {}
      }
      /**
       * The current range represented
       * @type {object}
       * @private
       */


      _this._range = {
        min: minVal || config.initialMin || 0,
        max: maxVal || config.initialMax || 10
      };
      /**
       * The title to display for the range control
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to display for the min input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to display for the max input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The template to render
       * @type {string}
       * @private
       */

      _this._templateName = "controls/range";
      return _this;
    }

    _createClass(RangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(RangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          minValue: this._range.min,
          maxValue: this._range.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-range', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, Number.parseInt(event.target.value));
        });
      }
    }, {
      key: "setMin",
      value: function setMin(value) {
        this._updateRange('min', value);
      }
    }, {
      key: "setMax",
      value: function setMax(value) {
        this._updateRange('max', value);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Update the current range state
       * @param {string} key The range key to update
       * @param {number} value The new value for the key
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._range = Object.assign({}, this._range, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._range.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._range.max);

        this._onChange(filter);
      }
      /**
       * Build the filter representation of the current state
       * @returns {Filter}
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        return Filter.inclusiveRange(this._field, this._range.min, this._range.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RangeFilter';
      }
    }]);

    return RangeFilterComponent;
  }(Component);

  /**
   * A filter for a range of dates
   */

  var DateRangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DateRangeFilterComponent, _Component);

    function DateRangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DateRangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DateRangeFilterComponent).call(this, config, systemConfig));
      /**
       * The api field this filter controls
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The title to display for the date range
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to show for the min date input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to show for the max date input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The callback used when a date is changed
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
      /**
       * If true, this filter represents an exclusive range, rather than an inclusive one
       * @type {boolean}
       * @private
       */

      _this._isExclusive = config.isExclusive;
      /**
       * The template for this component
       * @private
       */

      _this._templateName = "controls/date";
      var today = new Date();
      var todayString = "".concat(today.getFullYear(), "-").concat("".concat(today.getMonth() + 1).padStart(2, '0'), "-").concat("".concat(today.getDate()).padStart(2, '0'));

      var minDate = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      var maxDate = _this.core.globalStorage.getState("".concat(_this.name, ".max"));
      /**
       * The current date range
       * @private
       */


      _this._date = {
        min: minDate || config.initialMin || todayString,
        max: maxDate || config.initialMax || todayString
      };
      return _this;
    }

    _createClass(DateRangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(DateRangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          dateMin: this._date.min,
          dateMax: this._date.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-date', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, event.target.value);
        });
      }
      /**
       * Set the min date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMin",
      value: function setMin(date) {
        this._updateRange('min', date);
      }
      /**
       * Set the max date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMax",
      value: function setMax(date) {
        this._updateRange('max', date);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Updates the current state of the date range
       * @param {string} key The key for the date value
       * @param {string} value The string date value
       * @private
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._date = Object.assign({}, this._date, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._date.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._date.max);

        this._onChange(filter);
      }
      /**
       * Construct an api filter with the current date state
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        if (this._date.min === '' || this._date.max === '') {
          return {};
        }

        return this._isExclusive ? Filter.exclusiveRange(this._field, this._date.min, this._date.max) : Filter.inclusiveRange(this._field, this._date.min, this._date.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'DateRangeFilter';
      }
    }]);

    return DateRangeFilterComponent;
  }(Component);

  var FacetsConfig =
  /*#__PURE__*/
  function () {
    function FacetsConfig(config) {
      _classCallCheck(this, FacetsConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFacet = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFacetLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFacets = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFacetsLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The controls to use for each field. Each type of filter has a default
       * $eq : multioption (checkbox)
       * @type {Object}
       */

      this.fieldControls = config.fieldControls || {};
      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      this.applyButtonSelector = config.applyButtonSelector || null;
      this.validate();
    }

    _createClass(FacetsConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FacetsConfig;
  }();
  /**
   * Displays a set of dynamic filters returned from the backend
   * @extends Component
   */


  var FacetsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FacetsComponent, _Component);

    function FacetsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FacetsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FacetsComponent).call(this, config, systemConfig));
      _this.config = new FacetsConfig(config);
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */

      _this._verticalKey = config.verticalKey; // config.verticalKey || null;

      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      _this._applyButtonSelector = config.applyButtonSelector || null;
      /**
       * An internal reference for the data storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
      /**
       * The filter box that displays the dynamic filters
       * @type {FilterBoxComponent}
       * @private
       */

      _this._filterbox = null;
      return _this;
    }

    _createClass(FacetsComponent, [{
      key: "remove",
      value: function remove() {
        if (this._filterbox) {
          this._filterbox.remove();
        }

        _get(_getPrototypeOf(FacetsComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this.core.enableDynamicFilters();

        if (this._filterbox) {
          this._filterbox.remove();
        }

        var _this$_state$get = this._state.get(),
            filters = _this$_state$get.filters;

        if (!filters) {
          return;
        }

        filters = filters.map(function (f) {
          return Object.assign({}, f, {
            type: 'FilterOptions',
            control: _this2.config.fieldControls[f.fieldId] || 'multioption'
          });
        });
        this._filterbox = this.componentManager.create('FilterBox', Object.assign({}, this.config, {
          parentContainer: this._container,
          name: "".concat(this.name, ".filterbox"),
          container: '.js-yxt-Facets',
          verticalKey: this._verticalKey,
          resetFilter: this.config.resetFacet,
          resetFilters: this.config.resetFacets,
          resetFilterLabel: this.config.resetFacetLabel,
          resetFiltersLabel: this.config.resetFacetsLabel,
          isDynamic: true,
          filters: filters
        }));

        this._filterbox.mount();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'filters/facets';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Facets';
      }
    }]);

    return FacetsComponent;
  }(Component);

  var METERS_PER_MILE = 1609.344;
  var DEFAULT_CONFIG$3 = {
    /**
     * The radius, in miles, around the user's location to find results.
     * If location accuracy is low, a larger radius may be used automatically
     * @type {number}
     */
    radius: 50,

    /**
     * The vertical key to use
     * @type {string}
     */
    verticalKey: null,

    /**
     * If true, submits a search when the value is changed
     * @type {boolean}
     */
    searchOnChange: false,

    /**
     * The title to display
     * @type {string}
     */
    title: 'Location',

    /**
     * The label to display
     * @type {string}
     */
    label: 'Location',

    /**
     * The icon url to show in the geo button
     * @type {string}
     */
    geoButtonIcon: '',

    /**
     * The alt text to include with the geo button icon
     * @type {string}
     */
    geoButtonIconAltText: 'Use My Location',

    /**
     * The text to show in the geo button
     * @type {string}
     */
    geoButtonText: 'Use My Location',

    /**
     * The text to show when geolocation is enabled
     * @type {string}
     */
    enabledText: 'Current Location',

    /**
     * The text to show when loading the user's location
     * @type {string}
     */
    loadingText: 'Finding Your Location...',

    /**
     * The text to show if the user's location cannot be found
     * @type {string}
     */
    errorText: 'Could Not Find Your Location',

    /**
     * The CSS selector of the toggle button
     * @type {string}
     */
    buttonSelector: '.js-yxt-GeoLocationFilter-button',

    /**
     * The CSS selector of the query input
     * @type {string}
     */
    inputSelector: '.js-yxt-GeoLocationFilter-input'
  };
  /**
   * Renders a button that when clicked adds a static filter representing the user's location
   * @extends Component
   */

  var GeoLocationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(GeoLocationComponent, _Component);

    function GeoLocationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, GeoLocationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GeoLocationComponent).call(this, _objectSpread({}, DEFAULT_CONFIG$3, {}, config), systemConfig));
      /**
       * The query string to use for the input box, provided to template for rendering.
       * @type {string}
       */

      _this.query = _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.setState();
      });
      /**
       * The filter to use for the current query
       * @type {Filter}
       */


      _this.filter = _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || {};

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      _this.searchParameters = buildSearchParameters(config.searchParameters);
      return _this;
    }

    _createClass(GeoLocationComponent, [{
      key: "setState",
      value: function setState(data) {
        var placeholder = '';

        if (this._enabled) {
          placeholder = this._config.enabledText;
        }

        if (data.geoLoading) {
          placeholder = this._config.loadingText;
        }

        if (data.geoError) {
          placeholder = this._config.errorText;
        }

        _get(_getPrototypeOf(GeoLocationComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          title: this._config.title,
          geoEnabled: this._enabled,
          query: this.query,
          labelText: this._config.label,
          enabledText: this._config.enabledText,
          loadingText: this._config.loadingText,
          errorText: this._config.errorText,
          geoButtonIcon: this._config.geoButtonIcon,
          geoValue: this._enabled || data.geoLoading || data.geoError ? '' : this.query,
          geoPlaceholder: placeholder,
          geoButtonText: this._config.geoButtonText
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._initAutoComplete(this._config.inputSelector);

        DOM.on(this._config.buttonSelector, 'click', function () {
          return _this2._toggleGeoFilter();
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       * @private
       */

    }, {
      key: "_initAutoComplete",
      value: function _initAutoComplete(inputSelector) {
        var _this3 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.js-yxt-GeoLocationFilter-autocomplete',
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._config.verticalKey,
          searchParameters: this.searchParameters,
          onSubmit: function onSubmit(query, filter) {
            _this3.query = query;
            _this3.filter = Filter.fromResponse(filter);

            _this3._saveDataToStorage(query, _this3.filter);

            _this3._enabled = false;
          }
        });
      }
      /**
       * Toggles the static filter representing the user's location
       * @private
       */

    }, {
      key: "_toggleGeoFilter",
      value: function _toggleGeoFilter() {
        var _this4 = this;

        if (!navigator.geolocation) {
          this.setState({
            geoError: true
          });
          return;
        }

        if (!this._enabled) {
          this.setState({
            geoLoading: true
          });
          navigator.geolocation.getCurrentPosition(function (position) {
            var filter = _this4._buildFilter(position);

            _this4._saveDataToStorage('', filter, position);

            _this4._enabled = true;

            _this4.setState({});

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.QUERY, ".").concat(_this4.name));

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.FILTER, ".").concat(_this4.name));
          }, function () {
            return _this4.setState({
              geoError: true
            });
          });
        }
      }
      /**
       * Saves the provided filter under this component's name
       * @param {string} query The query to save
       * @param {Filter} filter The filter to save
       * @param {Object} position The position to save
       * @private
       */

    }, {
      key: "_saveDataToStorage",
      value: function _saveDataToStorage(query, filter, position) {
        this.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(this.name), query);
        this.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(this.name), filter);
        this.core.setFilter(this.name, filter);

        if (position) {
          this.core.globalStorage.set(StorageKeys.GEOLOCATION, {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            radius: position.coords.accuracy
          });
        }

        if (this._config.searchOnChange) {
          var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = filters[0];

          if (filters.length > 1) {
            totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
          }

          var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.verticalSearch(this._config.verticalKey, {
            input: searchQuery,
            filter: JSON.stringify(totalFilter),
            facetFilter: JSON.stringify(facetFilter)
          });
        }
      }
      /**
       * Given a position, construct a Filter object
       * @param {Postition} position The position
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter(position) {
        var _position$coords = position.coords,
            latitude = _position$coords.latitude,
            longitude = _position$coords.longitude,
            accuracy = _position$coords.accuracy;
        var radius = Math.max(accuracy, this._config.radius * METERS_PER_MILE);
        return Filter.position(latitude, longitude, radius);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'controls/geolocation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'GeoLocationFilter';
      }
    }]);

    return GeoLocationComponent;
  }(Component);

  /**
   * Renders configuration options for sorting Vertical Results.
   * TODO: how to deal with multiple instances of this component (and filters in general),
   * ideally "identical" filters/sorts would be synced up.
   */

  var SortOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SortOptionsComponent, _Component);

    function SortOptionsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SortOptionsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SortOptionsComponent).call(this, assignDefaults(config), systemConfig)); // TODO SPR-1929 centralize this logic

      _this._config.verticalKey = config.verticalKey || _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;
      _this.options = _this._config.options;
      _this.selectedOptionIndex = parseInt(_this.core.globalStorage.getState(_this.name)) || 0;
      _this.options[_this.selectedOptionIndex].isSelected = true;
      _this.hideExcessOptions = _this._config.showMore && _this.selectedOptionIndex < _this._config.showMoreLimit;
      _this.showReset = _this._config.showReset && _this.selectedOptionIndex !== 0;
      return _this;
    }

    _createClass(SortOptionsComponent, [{
      key: "setState",
      value: function setState(data) {
        var options = this.options;

        if (this.hideExcessOptions) {
          options = this.options.slice(0, this._config.showMoreLimit);
        }

        _get(_getPrototypeOf(SortOptionsComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          options: options,
          hideExcessOptions: this.hideExcessOptions,
          name: this.name,
          showReset: this.showReset
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        // Handle radio button selections
        DOM.on(DOM.query(this._container, '.yxt-SortOptions-fieldSet'), 'change', function (evt) {
          return _this2.handleOptionSelection(parseInt(evt.target.value));
        }); // Register more/less button

        if (this._config.showMore) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-showToggle'), 'click', function () {
            _this2.hideExcessOptions = !_this2.hideExcessOptions;

            _this2.setState();
          });
        } // Register show reset button


        if (this.showReset) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-reset'), 'click', function () {
            return _this2.handleOptionSelection(0);
          });
        } // Register apply button


        if (!this._config.searchOnChange) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-apply'), 'click', function () {
            return _this2._sortResults();
          });
        }
      }
    }, {
      key: "handleOptionSelection",
      value: function handleOptionSelection(optionIndex) {
        this._updateSelectedOption(optionIndex);

        if (this._config.searchOnChange) {
          this._sortResults();
        }
      }
    }, {
      key: "_updateSelectedOption",
      value: function _updateSelectedOption(optionIndex) {
        this.options[this.selectedOptionIndex].isSelected = false;
        this.options[optionIndex].isSelected = true;
        this.selectedOptionIndex = optionIndex;
        this.showReset = this._config.showReset && optionIndex !== 0;
        this.setState();
      }
    }, {
      key: "_sortResults",
      value: function _sortResults() {
        var optionIndex = this.selectedOptionIndex;
        var option = this.options[optionIndex]; // searchOnChange really means sort on change here, just that the sort is done through a search,
        // This was done to have a consistent option name between filters.

        this.core.persistentStorage.set(this.name, optionIndex);

        if (this._config.storeOnChange && optionIndex === 0) {
          this.core.clearSortBys();
        } else if (this._config.storeOnChange) {
          this.core.setSortBys(option);
        }

        this._search();

        this._config.onChange(option);

        this.setState();
      }
      /**
       * Trigger a search with all filters in storage
       */

    }, {
      key: "_search",
      value: function _search() {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var input = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._config.verticalKey, {
          input: input,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'controls/sortoptions';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SortOptions';
      }
    }]);

    return SortOptionsComponent;
  }(Component);

  function assignDefaults(config) {
    var updatedConfig = Object.assign({}, config); // Optional, The label used for the default sort (aka the sort specified by the experience config").

    updatedConfig.defaultSortLabel = config.defaultSortLabel || 'Best Match'; // Array of search options, where an option has type, label, and if is type FIELD also a label and direction

    if (!config.options) {
      throw new AnswersBasicError('config.options are required', 'SortOptions');
    }

    var OPTION_TYPES = ['FIELD', 'RELEVANCE', 'ENTITY_DISTANCE'];

    if (!Array.isArray(config.options)) {
      throw new AnswersBasicError('options must be an array of objects', 'SortOptions');
    }

    updatedConfig.options = config.options.map(function (option) {
      if (!option.label || !option.type) {
        throw new AnswersBasicError("option.label and option.type are required option ".concat(option), 'SortOptions');
      }

      var newOption = {
        isSelected: false
      };
      newOption.label = option.label;
      newOption.type = option.type;
      var isField = OPTION_TYPES.indexOf(newOption.type) === 0;

      if (isField && option.field && option.direction) {
        newOption.field = option.field;
        newOption.direction = option.direction;
      } else if (isField) {
        throw new AnswersBasicError("option.field and option.direction are required for option: ".concat(option), 'SortOptions');
      }

      return newOption;
    }); // Add default option to the front of the options array

    updatedConfig.options.unshift({
      label: updatedConfig.defaultSortLabel,
      isSelected: false
    }); // Optional, the selector used for options in the template

    updatedConfig.optionSelector = config.optionSelector || 'yxt-SortOptions-optionSelector'; // Optional, if true, triggers a search on each change to a filter,
    // if false the component also renders an apply button, defaults to false

    updatedConfig.searchOnChange = config.searchOnChange === undefined ? true : config.searchOnChange; // Optional, show a reset button. Clicking it will always return the user to the default sorting option.

    updatedConfig.showReset = config.showReset || false; // Optional, the label to use for the reset button

    updatedConfig.resetLabel = config.resetLabel || 'reset'; // Optional, the max number of filter options to show before collapsing extras

    updatedConfig.showMoreLimit = config.showMoreLimit || 5; // Optional, allow collapsing excess sort options after a limit

    updatedConfig.showMore = config.showMore === undefined ? true : config.showMore;
    updatedConfig.showMore = updatedConfig.showMore && updatedConfig.options.length > updatedConfig.showMoreLimit; // Optional, the label to show for displaying more options

    updatedConfig.showMoreLabel = config.showMoreLabel || 'Show more'; // Optional, the label to show for displaying less options

    updatedConfig.showLessLabel = config.showLessLabel || 'Show less'; // Optional, the callback function to call when changed

    updatedConfig.onChange = config.onChange || function () {}; // Optional, Top title for the sorting component


    updatedConfig.label = config.label || 'Sorting'; // Optional, when true component does not update globalStorage
    // possibly delegating that to a higher-order/composite component

    updatedConfig.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
    updatedConfig.applyLabel = config.applyLabel || 'Apply';
    updatedConfig.verticalKey = config.verticalKey;

    if (!updatedConfig.verticalKey) {
      throw new AnswersBasicError('vertical key is required', 'SortOptions');
    } // note: showExpand and showNumberApplied explicitly not included, on the grounds that
    // sorting should always be exposed to the user if added.


    return updatedConfig;
  }

  /**
   * EventTypes are explicit strings defined
   * for what the server expects for analytics.
   *
   * @enum
   */

  var EventTypes = {
    THUMBS_UP: 'THUMBS_UP',
    THUMBS_DOWN: 'THUMBS_DOWN'
  };
  var DEFAULT_CONFIG$4 = {
    positiveFeedbackSrText: 'This answered my question',
    negativeFeedbackSrText: 'This did not answer my question',
    footerTextOnSubmission: 'Thank you for your feedback!'
  };

  var DirectAnswerComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DirectAnswerComponent, _Component);

    function DirectAnswerComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DirectAnswerComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectAnswerComponent).call(this, _objectSpread({}, DEFAULT_CONFIG$4, {}, config), systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.DIRECT_ANSWER;
      /**
       * The form used for submitting the feedback
       * @type {string}
       */

      _this._formEl = config.formEl || '.js-directAnswer-feedback-form';
      /**
       * The `thumbs up` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsUpSelector = config.thumbsUpSelector || '.js-directAnswer-thumbUp';
      /**
       * The `thumbs down` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsDownSelector = config.thumbsDownSelector || '.js-directAnswer-thumbDown';
      /**
       * The display text for the View Details click to action link
       * @type {string}
       */

      _this._viewDetailsText = config.viewDetailsText || 'View Details';
      return _this;
    }

    _createClass(DirectAnswerComponent, [{
      key: "beforeMount",

      /**
       * beforeMount, only display the direct answer component if it has data
       */
      value: function beforeMount() {
        if (!this.hasState('answer')) {
          return false;
        }

        return true;
      }
      /**
       * When the DOM is constructed,
       * we want to wire up the behavior for interacting with the quality feedback reporting (thumbsup/down)
       */

    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        // Avoid bindings if the feedback has previously been submitted
        if (this.getState('feedbackSubmitted') === true) {
          return this;
        } // For WCAG compliance, the feedback should be a submittable form


        DOM.on(this._formEl, 'submit', function (e) {
          var formEl = e.target;
          var checkedValue = DOM.query(formEl, 'input:checked').value === 'true';

          _this2.reportQuality(checkedValue);

          _this2.updateState({
            'feedbackSubmitted': true
          });
        }); // Is this actually necessary? I guess it's only necessary if the
        // submit button is hidden.

        DOM.on(this._thumbsUpSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
        DOM.on(this._thumbsDownSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
      }
      /**
       * updateState enables for partial updates (the delta between the old and new)
       * @type {object} The new state to apply to the old
       */

    }, {
      key: "updateState",
      value: function updateState() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var newState = Object.assign({}, this.getState(), state);
        this.setState(newState);
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(DirectAnswerComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          eventOptions: this.eventOptions(data),
          viewDetailsText: this._viewDetailsText
        }));
      }
    }, {
      key: "eventOptions",
      value: function eventOptions(data) {
        if (!data || Object.keys(data).length === 0) {
          return data;
        }

        return JSON.stringify({
          verticalConfigId: data.relatedItem.verticalConfigId,
          searcher: 'UNIVERSAL',
          entityId: data.relatedItem.data.id,
          ctaLabel: this._viewDetailsText.toUpperCase().replace(' ', '_')
        });
      }
      /**
       * reportQuality will send the quality feedback to analytics
       * @param {boolean} isGood true if the answer is what you were looking for
       */

    }, {
      key: "reportQuality",
      value: function reportQuality(isGood) {
        var eventType = isGood === true ? EventTypes.THUMBS_UP : EventTypes.THUMBS_DOWN;
        var event = new AnalyticsEvent(eventType).addOptions({
          'directAnswer': true
        });
        this.analyticsReporter.report(event);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/directanswer';
      }
    }, {
      key: "type",
      get: function get() {
        return 'DirectAnswer';
      }
    }]);

    return DirectAnswerComponent;
  }(Component);

  /**
   * The AlternativeVertical is a model that is used to power the search
   * suggestions info box. It's initialized through the configuration provided
   * to the component.
   */

  var AlternativeVertical = function AlternativeVertical(config) {
    _classCallCheck(this, AlternativeVertical);

    /**
     * The name of the vertical that is exposed for the link
     * @type {string}
     */
    this.label = config.label;

    if (typeof this.label !== 'string') {
      throw new AnswersConfigError('label is a required configuration option for verticalPage.', 'AlternativeVertical');
    }
    /**
     * The complete URL, including the params
     * @type {string}
     */


    this.url = config.url;

    if (typeof this.url !== 'string') {
      throw new AnswersConfigError('url is a required configuration option for verticalPage.', 'AlternativeVertical');
    }
    /**
     * name of an icon from the default icon set
     * @type {string}
     */


    this.iconName = config.iconName;
    /**
     * The number of results to display next to each alternative
     * vertical
     * @type {number}
     */

    this.resultsCount = config.resultsCount;
  };

  var AlternativeVerticalsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AlternativeVerticalsComponent, _Component);

    function AlternativeVerticalsComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AlternativeVerticalsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AlternativeVerticalsComponent).call(this, opts, systemOpts));
      _this.moduleId = StorageKeys.ALTERNATIVE_VERTICALS;
      /**
       * Alternative verticals that have results for the current query
       * This gets updated based on the server results
       * @type {AlternativeVerticals}
       * @private
       */

      _this._alternativeVerticals = opts.data && opts.data.alternativeVerticals || [];
      /**
       * Vertical pages config from global verticals config
       * @type {VerticalPagesConfig}
       * @private
       */

      _this._verticalsConfig = opts.verticalsConfig || [];
      /**
       * The name of the vertical that is exposed for the link
       * @type {string}
       */

      _this._currentVerticalLabel = _this.getCurrentVerticalLabel(opts.verticalsConfig) || '';
      /**
       * The alternative vertical search suggestions, parsed from alternative verticals and
       * the global verticals config.
       * This gets updated based on the server results
       * @type {AlternativeVertical[]}
       */

      _this.verticalSuggestions = AlternativeVerticalsComponent._buildVerticalSuggestions(_this._alternativeVerticals, _this._verticalsConfig);
      /**
       * The url to the universal page to link back to with current query
       * @type {string|null}
       */

      _this._universalUrl = opts.universalUrl || '';
      /**
       * Whether or not results are displaying, used to control language in the info box
       * @type {boolean}
       */

      _this._isShowingResults = opts.isShowingResults || false;
      return _this;
    }

    _createClass(AlternativeVerticalsComponent, [{
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(AlternativeVerticalsComponent.prototype), "setState", this).call(this, Object.assign({
          verticalSuggestions: []
        }, data, {
          universalUrl: this._universalUrl,
          verticalSuggestions: this.verticalSuggestions,
          currentVerticalLabel: this._currentVerticalLabel,
          isShowingResults: this._isShowingResults,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }));
      }
    }, {
      key: "getCurrentVerticalLabel",
      value: function getCurrentVerticalLabel(verticalsConfig) {
        var thisVertical = verticalsConfig.find(function (config) {
          return config.isActive || false;
        });
        return thisVertical ? thisVertical.label : '';
      }
      /**
       * _buildVerticalSuggestions will construct an array of {AlternativeVertical}
       * from alternative verticals and verticalPages configuration
       * @param {object} alternativeVerticals alternativeVerticals server response
       * @param {object} verticalsConfig the configuration to use
       */

    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/alternativeverticals';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "_buildVerticalSuggestions",
      value: function _buildVerticalSuggestions(alternativeVerticals, verticalsConfig) {
        var verticals = [];
        var queryParams = window.location.search;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          var _loop = function _loop() {
            var alternativeVertical = _step.value;
            var verticalKey = alternativeVertical.verticalConfigId;
            var matchingVerticalConfig = verticalsConfig.find(function (config) {
              return config.verticalKey === verticalKey;
            });

            if (!matchingVerticalConfig || alternativeVertical.resultsCount < 1) {
              return "continue";
            }

            verticals.push(new AlternativeVertical({
              label: matchingVerticalConfig.label,
              url: matchingVerticalConfig.url + queryParams,
              iconName: matchingVerticalConfig.icon,
              resultsCount: alternativeVertical.resultsCount
            }));
          };

          for (var _iterator = alternativeVerticals[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return verticals;
      }
    }, {
      key: "type",
      get: function get() {
        return 'AlternativeVerticals';
      }
    }]);

    return AlternativeVerticalsComponent;
  }(Component);

  /** @module MapProvider */

  /**
   * A MapProvider is an interface that represents that should be implemented
   * in order to integrate with a Third Party Map provider for
   * interactive maps. MapProviders are used by the MapComponent.
   *
   * Implementations should extend this interface.
   */
  var MapProvider =
  /*#__PURE__*/
  function () {
    function MapProvider() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MapProvider);

      /**
       * The API Key used for interacting with the map provider
       * @type {string}
       */
      this._apiKey = config.apiKey;
      /**
       * The zoom level of the map, defaults to 14
       * @type {number}
       */

      this._zoom = config.zoom || 14;
      /**
       * The default coordinates to display if there are no results returned
       * Only used if showEmptyMap is set to true
       * @type {Object}
       */

      this._defaultPosition = config.defaultPosition || {
        lat: 37.0902,
        lng: -95.7129
      };
      /**
       * Determines if an empty map should be shown when there are no results
       * @type {boolean}
       */

      this._showEmptyMap = config.showEmptyMap || false;
      /**
       * A reference to the underlying map instance, created by the external lib.
       * @type {number}
       */

      this._map = null;
      /**
       * Temporary boolean tracking whether or not the external JS library is loaded (see TODO below)
       * @type {boolean}
       */

      this._isLoaded = false;
      /**
       * Callback to invoke when a pin is clicked. The clicked item(s) are passed to the callback
       * @type {function}
       */

      this._onPinClick = config.onPinClick || null;
      /**
       * Callback to invoke once the Javascript is loaded
       * @type {function}
       */

      this._onLoaded = config.onLoaded || function () {};
      /**
       * The custom configuration override to use for the map markers
       * @type {Object|Function}
       */


      this._pinConfig = typeof config.pin === 'function' ? config.pin : Object.assign(MapProvider.DEFAULT_PIN_CONFIG, config.pin);
      /**
       * Determines whether or not to collapse pins at the same lat/lng
       * @type {boolean}
       */

      this._collapsePins = config.collapsePins || false;
    }
    /**
     * The default configuration to use for the map markers
     * @type {Object}
     * TODO(billy) Create a configuration model
     */


    _createClass(MapProvider, [{
      key: "onLoaded",
      value: function onLoaded(cb) {
        if (typeof cb !== 'function') {
          return;
        }

        this._onLoaded = cb;

        if (this.isLoaded()) {
          this._onLoaded();
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return this._isLoaded;
      }
    }, {
      key: "loadJS",
      value: function loadJS() {
        throw new Error('Unimplemented Method: loadJS');
      }
    }, {
      key: "init",
      value: function init(mapData) {
        // TODO(billy) This should be based off a promise that gets created from loadJS
        throw new Error('Unimplemented Method: init');
      }
      /**
       * Given a list of markers, combine markers with the same lat/lng into a single marker
       * @param {object[]} markers The markers to collapse
       */

    }, {
      key: "_collapseMarkers",
      value: function _collapseMarkers(markers) {
        var locationToItem = {};
        markers.forEach(function (m) {
          locationToItem["".concat(m.latitude).concat(m.longitude)] ? locationToItem["".concat(m.latitude).concat(m.longitude)].push(m) : locationToItem["".concat(m.latitude).concat(m.longitude)] = [m];
        });
        var collapsedMarkers = [];

        for (var _i = 0, _Object$entries = Object.entries(locationToItem); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              _markers = _Object$entries$_i[1];

          if (_markers.length > 1) {
            var collapsedMarker = {
              item: _markers.map(function (m) {
                return m.item;
              }),
              label: _markers.length,
              latitude: _markers[0].latitude,
              longitude: _markers[0].longitude
            };
            collapsedMarkers.push(collapsedMarker);
          } else {
            collapsedMarkers.push(_markers[0]);
          }
        }

        return collapsedMarkers;
      }
    }], [{
      key: "DEFAULT_PIN_CONFIG",
      get: function get() {
        return {
          icon: {
            anchor: null,
            // e.g. { x: 1, y: 1 }
            svg: null,
            url: null,
            scaledSize: null // e.g. { w: 20, h: 20 }

          },
          labelType: 'numeric'
        };
      }
    }]);

    return MapProvider;
  }();

  /* global google */

  /**
   * GoogleMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var GoogleMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(GoogleMapProvider, _MapProvider);

    function GoogleMapProvider(opts) {
      var _this;

      _classCallCheck(this, GoogleMapProvider);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GoogleMapProvider).call(this, opts)); // normalize because google's zoom is effectively 1 unit of difference away from mapbox zoom

      _this._zoomOffset = 1;
      _this._zoom += _this._zoomOffset;
      _this._clientId = opts.clientId;
      _this._signature = opts.signature;

      if (!_this.hasValidClientCredentials() && !_this._apiKey) {
        throw new Error('GoogleMapsProvider: Missing `apiKey` or {`clientId`, `signature`}');
      }

      return _this;
    }

    _createClass(GoogleMapProvider, [{
      key: "loadJS",
      value: function loadJS() {
        var self = this;

        var onLoad = function onLoad() {
          if (typeof self._onLoaded === 'function') {
            self._onLoaded();
          }
        };

        if (typeof google !== 'undefined') {
          self._isLoaded = true;
          onLoad();
          return;
        }

        var script = DOM.query('#yext-map-js');

        if (script) {
          var onLoadFunc = script.onload;

          script.onload = function () {
            onLoadFunc();
            onLoad();
          };

          return;
        }

        script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            self._isLoaded = true;
            onLoad();
          },
          async: true,
          src: "https://maps.googleapis.com/maps/api/js?".concat(self.generateCredentials())
        });
        DOM.append('body', script);
      }
    }, {
      key: "generateCredentials",
      value: function generateCredentials() {
        if (this.hasValidClientCredentials()) {
          return "client=".concat(this._clientId);
        } else {
          return "key=".concat(this._apiKey);
        }
      }
    }, {
      key: "hasValidClientCredentials",
      value: function hasValidClientCredentials() {
        return this._clientId;
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this2 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        } // NOTE(billy) This timeout is a hack for dealing with async nature.
        // Only here for demo purposes, so we'll fix later.


        setTimeout(function () {
          var container = DOM.query(el);
          _this2.map = new google.maps.Map(container, {
            zoom: _this2._zoom,
            center: _this2.getCenterMarker(mapData)
          }); // Apply our search data to our GoogleMap

          if (mapData && mapData.mapMarkers.length) {
            (function () {
              var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
              var googleMapMarkerConfigs = GoogleMapMarkerConfig.from(collapsedMarkers, _this2._pinConfig, _this2.map);
              var bounds = new google.maps.LatLngBounds();

              var _loop = function _loop(i) {
                var marker = new google.maps.Marker(googleMapMarkerConfigs[i]);

                if (_this2._onPinClick) {
                  marker.addListener('click', function () {
                    return _this2._onPinClick(collapsedMarkers[i].item);
                  });
                }

                bounds.extend(marker.position);
              };

              for (var i = 0; i < googleMapMarkerConfigs.length; i++) {
                _loop(i);
              }

              if (googleMapMarkerConfigs.length >= 2) {
                _this2.map.fitBounds(bounds);
              }
            })();
          }
        }, 100);
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? {
          lng: mapData.mapCenter.longitude,
          lat: mapData.mapCenter.latitude
        } : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return GoogleMapProvider;
  }(MapProvider); // TODO(billy) Move to own class
  var GoogleMapMarkerConfig =
  /*#__PURE__*/
  function () {
    function GoogleMapMarkerConfig(opts) {
      _classCallCheck(this, GoogleMapMarkerConfig);

      /**
       * A reference to the google map, that the marker is appended to
       * @type {GoogleMap}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        lat: undefined,
        lng: undefined
      };
      /**
       * The properties/settings of the icon used for the marker
       * e.g. {
       *        anchor: { x: 0, y: 0 }
       *        url: 'path/to/url.jpg'
       *        scaledSize: { w: 0, h: 0 }
       *       }
       *
       * @type {object}
       */

      this.icon = opts.icon || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {GoogleMapMarkerConfig[]} googleMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(GoogleMapMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(googleMapMarkerConfigs) {
        var serializedMarkers = [];
        googleMapMarkerConfigs.forEach(function (marker) {
          serializedMarkers.push("markers=label:".concat(marker.label, "|").concat(marker.position.lat, ",").concat(marker.position.lng));
        });
        return serializedMarkers.join('&');
      }
      /**
       * Converts the storage data model of markers into GoogleAPIMarker
       * @param {object[]} markers The data of the marker
       * @param {(Object|function)} pinConfig The configuration to apply to the marker
       * @param {GoogleMap} map reference to the google map to apply the marker to
       * @returns {GoogleMapMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var googleMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          } // Transform our Configuration Object into the expected
          // Google API format.


          var icon = {};

          if (pinConfigObj.anchor) {
            icon.anchor = google.maps.Point(pinConfigObj.anchor.x, pinConfigObj.anchor.y);
          }

          if (pinConfigObj.scaledSize) {
            icon.scaledSize = new google.maps.Size(pinConfigObj.scaledSize.w, pinConfigObj.scaledSize.h);
          }

          if (pinConfigObj.url) {
            icon.url = pinConfigObj.url;
          }

          if (pinConfigObj.svg) {
            icon.url = "data:image/svg+xml;charset=utf-8, ".concat(encodeURIComponent(pinConfigObj.svg));
          }

          var label;

          if (pinConfigObj.label) {
            label = pinConfigObj.label;
          } else {
            label = marker.label.toString();
          } // NOTE(billy) Google maps doesn't handle empty icon objects nicely
          // Make google maps happy if no settings for icon are provided;


          if (Object.keys(icon).length === 0) {
            icon = undefined;
          }

          googleMapMarkerConfigs.push(new GoogleMapMarkerConfig({
            map: map,
            position: {
              lat: marker.latitude,
              lng: marker.longitude
            },
            icon: icon,
            label: label
          }));
        });
        return googleMapMarkerConfigs;
      }
    }]);

    return GoogleMapMarkerConfig;
  }();

  /* global mapboxgl */

  /**
   * MapBoxMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var MapBoxMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(MapBoxMapProvider, _MapProvider);

    function MapBoxMapProvider() {
      _classCallCheck(this, MapBoxMapProvider);

      return _possibleConstructorReturn(this, _getPrototypeOf(MapBoxMapProvider).apply(this, arguments));
    }

    _createClass(MapBoxMapProvider, [{
      key: "loadJS",

      /**
       * Load the external JS Library
       * @param {function} onLoad An optional callback to invoke once the JS is loaded.
       */
      value: function loadJS(onLoad) {
        var _this = this;

        var script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            _this._isLoaded = true;
            mapboxgl.accessToken = _this._apiKey;

            if (typeof onLoad === 'function') {
              onLoad();
            }

            if (typeof _this._onLoaded === 'function') {
              _this._onLoaded();
            }
          },
          async: true,
          src: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'
        });
        var css = DOM.createEl('link', {
          id: 'yext-map-css',
          rel: 'stylesheet',
          href: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css'
        });
        DOM.append('body', css);
        DOM.append('body', script);
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this2 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        }

        var container = DOM.query(el);
        this._map = new mapboxgl.Map({
          container: container,
          zoom: this._zoom,
          style: 'mapbox://styles/mapbox/streets-v9',
          center: this.getCenterMarker(mapData)
        });

        if (mapData && mapData.mapMarkers.length) {
          (function () {
            var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
            var mapboxMapMarkerConfigs = MapBoxMarkerConfig.from(collapsedMarkers, _this2._pinConfig, _this2._map);
            var bounds = new mapboxgl.LngLatBounds();

            var _loop = function _loop(i) {
              var wrapper = mapboxMapMarkerConfigs[i].wrapper;
              var coords = new mapboxgl.LngLat(mapboxMapMarkerConfigs[i].position.longitude, mapboxMapMarkerConfigs[i].position.latitude);
              var marker = new mapboxgl.Marker(wrapper).setLngLat(coords);
              bounds.extend(marker.getLngLat());
              marker.addTo(_this2._map);

              if (_this2._onPinClick) {
                marker.getElement().addEventListener('click', function () {
                  return _this2._onPinClick(collapsedMarkers[i].item);
                });
              }
            };

            for (var i = 0; i < mapboxMapMarkerConfigs.length; i++) {
              _loop(i);
            }

            if (mapboxMapMarkerConfigs.length >= 2) {
              _this2._map.fitBounds(bounds, {
                padding: 50
              });
            }
          })();
        }
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? [mapData.mapCenter.longitude, mapData.mapCenter.latitude] : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return MapBoxMapProvider;
  }(MapProvider);
  var MapBoxMarkerConfig =
  /*#__PURE__*/
  function () {
    function MapBoxMarkerConfig(opts) {
      _classCallCheck(this, MapBoxMarkerConfig);

      /**
       * A reference to the mapbox map, that the marker is appended to
       * @type {MapBox}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        latitude: undefined,
        longitude: undefined
      };
      /**
       * The html element to be used as the map marker
       * @type {object}
       */

      this.wrapper = opts.wrapper || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
      /**
       * The url of the pin for the static map
       * @type {string}
       */

      this.staticMapPin = opts.staticMapPin || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {MapBoxMarkerConfig[]} mapboxMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(MapBoxMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(mapboxMapMarkerConfigs) {
        var serializedMarkers = [];
        mapboxMapMarkerConfigs.forEach(function (marker) {
          if (marker.staticMapPin) {
            serializedMarkers.push("url-".concat(marker.staticMapPin, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          } else {
            serializedMarkers.push("pin-s-".concat(marker.label, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          }
        });
        return serializedMarkers.join(',');
      }
      /**
       * Converts the storage data model of markers into MapBoxMarkerConfig
       * @param {MapBox} A reference to the mapbox map to apply the marker to
       * @param {object[]} markers The data of the marker
       * @param {Object} pinConfig The configuration to apply to the marker
       * @returns {MapBoxMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var mapboxMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          }

          var wrapper = pinConfigObj.wrapper ? pinConfigObj.wrapper : null;
          var staticMapPin = pinConfigObj.staticMapPin ? pinConfigObj.staticMapPin : null;
          mapboxMapMarkerConfigs.push(new MapBoxMarkerConfig({
            map: map,
            position: {
              latitude: marker.latitude,
              longitude: marker.longitude
            },
            wrapper: wrapper,
            label: marker.label,
            staticMapPin: staticMapPin
          }));
        });
        return mapboxMapMarkerConfigs;
      }
    }]);

    return MapBoxMarkerConfig;
  }();

  var ProviderTypes = {
    'google': GoogleMapProvider,
    'mapbox': MapBoxMapProvider
  };

  var MapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(MapComponent, _Component);

    function MapComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, MapComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapComponent).call(this, opts, systemOpts));
      /**
       * Bind this component to listen to the storage based on this key
       */

      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      /**
       * An aliased used to determine the type of map provider to use
       * @type {string}
       */

      _this._mapProvider = opts.mapProvider;

      if (!_this._mapProvider || !(_this._mapProvider.toLowerCase() in ProviderTypes)) {
        throw new Error('MapComponent: Invalid Map Provider; must be `google` or `mapBox`');
      }
      /**
       * A reference to an instance of the {MapProvider} that's constructed
       * @type {MapProvider}
       */


      _this._map = null;
      return _this;
    }

    _createClass(MapComponent, [{
      key: "getProviderInstance",
      // TODO(billy) Make ProviderTypes a factory class
      value: function getProviderInstance(type) {
        return new ProviderTypes[type.toLowerCase()](this._config);
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        this._map = this.getProviderInstance(this._mapProvider);

        this._map.loadJS();
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this._map.onLoaded(function () {
          _this2._map.init(_this2._container, _this2.getState('map'));
        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        if (Object.keys(data).length === 0) {
          return this;
        }

        return _get(_getPrototypeOf(MapComponent.prototype), "setState", this).call(this, data, val);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/map';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Map';
      }
    }]);

    return MapComponent;
  }(Component);

  var cardTemplates = {
    'Standard': 'cards/standard',
    'Accordion': 'cards/accordion',
    'Legacy': 'cards/legacy'
  };
  var cardTypes = {
    'Standard': 'StandardCard',
    'Accordion': 'AccordionCard',
    'Legacy': 'LegacyCard'
  };

  var CardConfig = function CardConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CardConfig);

    Object.assign(this, config);
    /**
     * The card type to use
     * @type {string}
     */

    this.cardType = config.cardType || 'Standard';
    /**
     * Data mappings is a function specified in the config
     * that returns config based on the data passed into card
     * @type {Function}
     */

    this.dataMappings = config.dataMappings || function () {};
    /**
     * Either a function that spits out an array of CTA config objects or an array of CTA config objects
     * or api fieldnames
     * @type {Function|Array<Object|string>}
     */


    this.callsToAction = config.callsToAction || [];
    /**
     * The index of the card.
     * @type {number}
     */

    this._index = config._index || 0;
    /**
     * Whether this card is part of a universal search
     */

    this.isUniversal = config.isUniversal || false;
  };

  var CardComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CardComponent, _Component);

    function CardComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CardComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CardComponent).call(this, new CardConfig(config), systemConfig));
      /**
       * config.data comes from the data-prop attribute passed in
       * from the parent component.
       * @type {Object}
       */

      var data = config.data || {};
      /**
       * The result data for this card.
       * @type {Result}
       */

      _this.result = data.result || {};
      /**
       * Vertical key for the search.
       * @type {string}
       */

      _this.verticalKey = data.verticalKey;
      return _this;
    }

    _createClass(CardComponent, [{
      key: "setState",
      value: function setState(data) {
        var cardType = this._config.cardType;

        if (!cardTypes[cardType]) {
          var validCards = "[\"".concat(Object.keys(cardTypes).join('", "'), "\"]");
          var msg = "Card type \"".concat(cardType, "\" is not recognized as a valid built-in card type.") + " Valid types include ".concat(validCards);
          throw new AnswersConfigError(msg, 'CardComponent');
        }

        return _get(_getPrototypeOf(CardComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          result: this.result,
          cardType: cardTypes[cardType]
        }));
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        var updatedData = {
          verticalKey: this.verticalKey,
          result: data
        };

        var newOpts = _objectSpread({
          showOrdinal: this._config.showOrdinal,
          dataMappings: this._config.dataMappings,
          callsToAction: this._config.callsToAction,
          verticalKey: this._config.verticalKey,
          _index: this._config._index,
          isUniversal: this._config.isUniversal
        }, opts);

        return _get(_getPrototypeOf(CardComponent.prototype), "addChild", this).call(this, updatedData, type, newOpts);
      }
      /**
       * Used by children card components like StandardCardComponent to
       * apply given template mappings as config.
       * @param {Result} result
       * @param {Object|Function} dataMappings
       */

    }], [{
      key: "applyDataMappings",
      value: function applyDataMappings(result, dataMappings) {
        var config = {};

        if (typeof dataMappings === 'function') {
          dataMappings = dataMappings(result);
        }

        if (_typeof(dataMappings) === 'object') {
          Object.entries(dataMappings).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                attribute = _ref2[0],
                value = _ref2[1];

            if (typeof value === 'function') {
              config[attribute] = value(result);
            } else {
              config[attribute] = value;
            }
          });
        }

        return config;
      }
    }, {
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'cards/card';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'Card';
      }
    }]);

    return CardComponent;
  }(Component);

  var ResultsHeaderComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ResultsHeaderComponent, _Component);

    function ResultsHeaderComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ResultsHeaderComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultsHeaderComponent).call(this, config, systemConfig));
      /**
       * Whether to display the number of results.
       * @type {boolean}
       */

      _this._config.showResultCount = config.showResultCount === undefined ? true : config.showResultCount;
      /**
       * If present, show the filters that were ultimately applied to this query
       * @type {boolean}
       */

      _this._config.showAppliedFilters = config.showAppliedFilters === undefined ? true : config.showAppliedFilters;
      /**
       * If showAppliedFilters is true, show the field name in the string followed by a colon.
       * @type {boolean}
       */

      _this._config.showFieldNames = config.showFieldNames || false;
      /**
       * If showResultCount and showAppliedFilters are true,
       * display this separator between the result count and the applied query filters
       * @type {string}
       */

      _this._config.resultsCountSeparator = config.resultsCountSeparator || '|';
      var data = config.data || {};
      /**
       * Total number of results.
       * @type {number}
       */

      _this.resultsCount = data.resultsCount || 0;
      /**
       * Number of results displayed on the page.
       * @type {number}
       */

      _this.resultsLength = data.resultsLength || 0;
      /**
       * @type {Array<AppliedQueryFilter>}
       */

      _this.appliedQueryFilters = data.appliedQueryFilters || [];
      return _this;
    }

    _createClass(ResultsHeaderComponent, [{
      key: "getAppliedFiltersArray",
      value: function getAppliedFiltersArray() {
        var groupedFilters = {};
        this.appliedQueryFilters.forEach(function (filter) {
          if (!groupedFilters[filter.key]) {
            groupedFilters[filter.key] = [];
          }

          groupedFilters[filter.key].push(filter.value);
        }); // Has to be parsed into an array because our handlebars can only loop through arrays, not objects.

        return Object.keys(groupedFilters).map(function (label) {
          return {
            label: label,
            displayValues: groupedFilters[label]
          };
        });
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET);
        var hasFilters = this.appliedQueryFilters.length > 0;
        var shouldShowFilters = hasFilters && this._config.showAppliedFilters;
        return _get(_getPrototypeOf(ResultsHeaderComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          resultsCount: this.resultsCount,
          resultsCountStart: offset + 1,
          resultsCountEnd: offset + this.resultsLength,
          showResultSeparator: this._config.showResultCount && shouldShowFilters,
          shouldShowFilters: shouldShowFilters,
          appliedFiltersArray: this.getAppliedFiltersArray()
        }));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsheader';
      }
    }, {
      key: "duplicatesAllowed",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'ResultsHeader';
      }
    }]);

    return ResultsHeaderComponent;
  }(Component);

  var VerticalResultsConfig = function VerticalResultsConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, VerticalResultsConfig);

    Object.assign(this, config);
    /**
     * isUniversal is set to true if this component is added by the UniversalResultsComponent
     * @type {boolean}
     * @private
     */

    this.isUniversal = config.isUniversal || false;
    /**
     * _displayAllResults is set to true if the config option noResults.displayAllResults is true,
     * meaning that all results for the vertical will display when there are no results for a query
     * @type {boolean}
     * @private
     */

    this._displayAllResults = config.noResults && config.noResults.displayAllResults;
    /**
     * Custom no results template
     * @type {string}
     */

    this.noResultsTemplate = config.noResults ? config.noResults.template : '';
    var parentOpts = config._parentOpts || {};
    /**
     * Custom render function
     * @type {function}
     */

    this.renderItem = config.renderItem || parentOpts.renderItem;
    /**
     * Custom item template
     * @type {string}
     */

    this.itemTemplate = config.itemTemplate || parentOpts.itemTemplate;
    /**
     * The maximum number of columns to display, supports 1, 2, 3, or 4.
     * @type {number}
     */

    this.maxNumberOfColumns = config.maxNumberOfColumns || 1;
    /**
     * The config to pass to the card
     * @type {Object}
     */

    this.card = config.card || {};
    /**
     * Config options used in the {@link ResultsHeaderComponent}
     */

    this.resultsHeaderOpts = {
      /**
       * Whether to display the number of results.
       * @type {boolean}
       */
      showResultCount: config.showResultCount === undefined ? true : config.showResultCount,

      /**
       * If present, show the filters that were ultimately applied to this query
       * @type {boolean}
       */
      showAppliedFilters: config.showAppliedFilters === undefined ? true : config.showAppliedFilters,

      /**
       * If showResultCount and showAppliedFilters are true,
       * display this separator between the result count and the applied query filters
       * @type {string}
       */
      resultsCountSeparator: config.resultsCountSeparator || '|',

      /**
       * If showAppliedFilters is true, show the field name in the string followed by a colon.
       * @type {boolean}
       */
      showFieldNames: config.showFieldNames || false
    };
  };

  var VerticalResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(VerticalResultsComponent, _Component);

    function VerticalResultsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, VerticalResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(VerticalResultsComponent).call(this, new VerticalResultsConfig(config), systemConfig));
      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      _this._verticalsConfig = _this.core.globalStorage.getState(StorageKeys.VERTICAL_PAGES_CONFIG).get() || [];
      /**
       * @type {Array<Result>}
       */

      _this.results = [];
      _this.numColumns = _this._config.maxNumberOfColumns;

      _this.core.globalStorage.set(StorageKeys.NO_RESULTS_CONFIG, _this._config.noResults || {});

      return _this;
    }

    _createClass(VerticalResultsComponent, [{
      key: "mount",
      value: function mount() {
        if (Object.keys(this.getState()).length > 0) {
          _get(_getPrototypeOf(VerticalResultsComponent.prototype), "mount", this).call(this);
        }

        return this;
      }
    }, {
      key: "getUniversalUrl",
      value: function getUniversalUrl() {
        var universalConfig = this._verticalsConfig.find(function (config) {
          return !config.verticalKey;
        }) || {};

        if (universalConfig.url) {
          return addParamsToUrl(universalConfig.url, {
            query: this.query
          });
        }
      }
    }, {
      key: "getVerticalURL",
      value: function getVerticalURL(data) {
        var _this2 = this;

        var verticalConfig = this._verticalsConfig.find(function (config) {
          return config.verticalKey === _this2.verticalKey;
        }) || {};
        var verticalURL = verticalConfig.url || data.verticalURL || this.verticalKey + '.html';
        return addParamsToUrl(verticalURL, {
          query: this.query
        });
      }
    }, {
      key: "setState",
      value: function setState() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var val = arguments.length > 1 ? arguments[1] : undefined;

        /**
         * @type {Array<Result>}
         */
        this.results = data.results || [];
        this.resultsCount = data.resultsCount;
        this.verticalKey = data.verticalConfigId;
        this.appliedQueryFilters = data.appliedQueryFilters;
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        var displayResultsIfExist = this._config.isUniversal || this._config._displayAllResults || data.resultsContext === ResultsContext.NORMAL;
        var showResultsHeader = this._config.resultsHeaderOpts.showResultCount || this._config.resultsHeaderOpts.showAppliedFilters;
        this.query = this.core.globalStorage.getState(StorageKeys.QUERY);
        return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "setState", this).call(this, Object.assign({
          results: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          eventOptions: this.eventOptions(),
          universalUrl: this.getUniversalUrl(),
          verticalURL: this.getVerticalURL(data),
          query: this.query,
          currentVerticalLabel: this._currentVerticalLabel,
          resultsPresent: displayResultsIfExist && this.results.length !== 0,
          showNoResults: data.resultsContext === ResultsContext.NO_RESULTS,
          placeholders: new Array(this._config.maxNumberOfColumns + 1),
          numColumns: Math.min(this._config.maxNumberOfColumns, this.results.length),
          showResultsHeader: showResultsHeader,
          useLegacyNoResults: this._config.isUniversal || !this._config.noResults
        }), val);
      }
      /**
       * helper to construct the eventOptions object for the view all link
       * @returns {string}
       */

    }, {
      key: "eventOptions",
      value: function eventOptions() {
        return JSON.stringify({
          verticalConfigId: this.verticalKey
        });
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        if (type === MapComponent.type) {
          var newOpts = Object.assign({}, this._config.mapConfig, opts);
          return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "addChild", this).call(this, {
            map: data
          }, type, newOpts);
        } else if (type === CardComponent.type) {
          var updatedData = {
            result: this.results[opts._index],
            verticalKey: this.verticalKey
          };

          var _newOpts = _objectSpread({}, this._config.card, {
            isUniversal: this._config.isUniversal,
            template: this._config.itemTemplate,
            render: this._config.renderItem
          }, opts);

          return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "addChild", this).call(this, updatedData, type, _newOpts);
        } else if (type === AlternativeVerticalsComponent.type) {
          var hasResults = this.results && this.results.length > 0;
          data = this.core.globalStorage.getState(StorageKeys.ALTERNATIVE_VERTICALS);

          var _newOpts2 = _objectSpread({
            template: this._config.noResultsTemplate,
            universalUrl: this.getUniversalUrl(),
            verticalsConfig: this._verticalsConfig,
            isShowingResults: this._config._displayAllResults && hasResults
          }, opts);

          return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "addChild", this).call(this, data, type, _newOpts2);
        } else if (type === ResultsHeaderComponent.type) {
          var resultsHeaderData = _objectSpread({
            resultsLength: this.results.length,
            resultsCount: this.resultsCount,
            appliedQueryFilters: this.appliedQueryFilters
          }, data);

          return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "addChild", this).call(this, resultsHeaderData, type, opts);
        }

        return _get(_getPrototypeOf(VerticalResultsComponent.prototype), "addChild", this).call(this, data, type, opts);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/verticalresults';
      }
    }, {
      key: "duplicatesAllowed",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'VerticalResults';
      }
    }]);

    return VerticalResultsComponent;
  }(Component);

  var AccordionResultsComponent =
  /*#__PURE__*/
  function (_VerticalResultsCompo) {
    _inherits(AccordionResultsComponent, _VerticalResultsCompo);

    function AccordionResultsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AccordionResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AccordionResultsComponent).call(this, config, systemConfig));
      /**
       * base selector to use when finding DOM targets
       * @type {string}
       */

      _this._selectorBase = config.selectorBase || '.js-yxt-AccordionResult';
      /**
       * collapsed state class
       * @type {string}
       */

      _this.collapsedClass = config.collapsedClass || 'is-collapsed';
      /**
       * vertical config id is required for analytics
       * @type {string|null}
       */

      _this.verticalConfigId = config.verticalConfigId || config._parentOpts.verticalConfigId || null;
      return _this;
    }
    /**
     * the component type
     * @returns {string}
     * @override
     */


    _createClass(AccordionResultsComponent, [{
      key: "onMount",

      /**
       * overrides onMount to add bindings to change the height on click
       * @returns {AccordionResultsComponent}
       * @override
       */
      value: function onMount() {
        var _this2 = this;

        _get(_getPrototypeOf(AccordionResultsComponent.prototype), "onMount", this).call(this); // NOTE(amullings): This is a hack, since currently components with siblings
        // have no way of referring to their own element. We have to grab the first
        // element since sections get added in reverse.


        var selfEl = this._container.firstElementChild;
        var accordionEls = DOM.queryAll(selfEl, this._selectorBase);
        accordionEls.forEach(function (accordionEl) {
          var toggleEl = DOM.query(accordionEl, _this2.toggleSelector());
          var contentEl = DOM.query(accordionEl, _this2.bodySelector());

          _this2.changeHeight(contentEl, accordionEl);

          toggleEl.addEventListener('click', function () {
            _this2.handleClick(accordionEl, toggleEl, contentEl);
          });
        });
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(AccordionResultsComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          modifier: this.verticalConfigId
        }));
      }
      /**
       * click handler for the accordion toggle button
       * @param wrapperEl {HTMLElement} the toggle container
       * @param toggleEl {HTMLElement} the button
       * @param contentEl {HTMLElement} the toggle target
       */

    }, {
      key: "handleClick",
      value: function handleClick(wrapperEl, toggleEl, contentEl) {
        var event = new AnalyticsEvent(this.isCollapsed(wrapperEl) ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
          verticalConfigId: this.verticalConfigId,
          entityId: toggleEl.dataset.entityId
        });
        wrapperEl.classList.toggle(this.collapsedClass);
        this.changeHeight(contentEl, wrapperEl);
        toggleEl.setAttribute('aria-expanded', this.isCollapsed(wrapperEl) ? 'false' : 'true');
        this.analyticsReporter.report(event);
      }
      /**
       * returns true if the element is currently collapsed
       * @param wrapperEl {HTMLElement} the toggle container
       * @returns {boolean}
       */

    }, {
      key: "isCollapsed",
      value: function isCollapsed(wrapperEl) {
        if (!wrapperEl) {
          return false;
        }

        return wrapperEl.classList.contains(this.collapsedClass);
      }
      /**
       * toggles the height between 0 and the content height for smooth animation
       * @param targetEl {HTMLElement}
       * @param wrapperEl {HTMLElement}
       */

    }, {
      key: "changeHeight",
      value: function changeHeight(targetEl, wrapperEl) {
        targetEl.style.height = "".concat(this.isCollapsed(wrapperEl) ? 0 : targetEl.scrollHeight, "px");
      }
      /**
       * helper for composing child element selectors
       * @param child {string}
       * @returns {string}
       */

    }, {
      key: "buildSelector",
      value: function buildSelector(child) {
        return "".concat(this._selectorBase).concat(child);
      }
      /**
       * helper for the toggle button selector
       * @returns {string}
       */

    }, {
      key: "toggleSelector",
      value: function toggleSelector() {
        return this.buildSelector('-toggle');
      }
      /**
       * helper for the content element selector
       * @returns {string}
       */

    }, {
      key: "bodySelector",
      value: function bodySelector() {
        return this.buildSelector('-body');
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsaccordion';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AccordionResults';
      }
    }]);

    return AccordionResultsComponent;
  }(VerticalResultsComponent);

  var UniversalResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(UniversalResultsComponent, _Component);

    function UniversalResultsComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, UniversalResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UniversalResultsComponent).call(this, opts, systemOpts));
      _this.moduleId = StorageKeys.UNIVERSAL_RESULTS;
      _this._limit = opts.limit || 10;
      return _this;
    }

    _createClass(UniversalResultsComponent, [{
      key: "init",
      value: function init(opts) {
        _get(_getPrototypeOf(UniversalResultsComponent.prototype), "init", this).call(this, opts);

        return this;
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        var sections = data.sections || [];
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "setState", this).call(this, Object.assign({
          sections: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          showNoResults: sections.length === 0,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }), val);
      }
    }, {
      key: "addChild",
      value: function addChild() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var type = arguments.length > 1 ? arguments[1] : undefined;
        var opts = arguments.length > 2 ? arguments[2] : undefined;

        var childOpts = _objectSpread({}, opts, {}, this.getChildConfig([data['verticalConfigId']]));

        if (childOpts.useAccordion === true) {
          return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, AccordionResultsComponent.type, childOpts);
        }

        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, type, childOpts);
      }
    }, {
      key: "getChildConfig",
      value: function getChildConfig(configId) {
        var defaultConfig = {
          verticalConfigId: configId,
          isUniversal: true
        };
        var config = this._config.config;

        if (config === undefined) {
          return defaultConfig;
        }

        return Object.assign(defaultConfig, this._config['config'][configId] || this._config['config']);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/universalresults';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'UniversalResults';
      }
    }]);

    return UniversalResultsComponent;
  }(Component);

  var PaginationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(PaginationComponent, _Component);

    function PaginationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PaginationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PaginationComponent).call(this, config, systemConfig));
      /**
       * The vertical key to use for searches
       * @type {string}
       * @private
       */

      _this._verticalKey = _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

      if (typeof _this._verticalKey !== 'string') {
        throw new AnswersComponentError('verticalKey not provided, but necessary for pagination', 'PaginationComponent');
      }
      /**
       * If true, displays the first page button
       * @type {boolean}
       * @private
       */


      _this._firstPageButtonEnabled = config.showFirst === undefined ? true : config.showFirst;
      /**
       * If true, displays the last page button
       * @type {boolean}
       * @private
       */

      _this._lastPageButtonEnabled = config.showLast === undefined ? true : config.showLast;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      _this._analyticsOptions = {
        verticalKey: _this._verticalKey
      };
      /**
       * Label for a page of results.
       * @type {string}
       * @private
       */

      _this._pageLabel = config.pageLabel || 'Page';
      var offset = _this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

      _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));

      _this.core.globalStorage.on('update', StorageKeys.SEARCH_OFFSET, function (offset) {
        if (typeof offset === 'number') {
          return;
        }

        _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));
      });

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, function (results) {
        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
          _this.setState();
        }
      });

      return _this;
    }

    _createClass(PaginationComponent, [{
      key: "shouldShowControls",
      value: function shouldShowControls(results, limit) {
        var hasResults = results.searchState === 'search-complete' && results.resultsCount > limit;
        var noResultsConfig = this.core.globalStorage.getState(StorageKeys.NO_RESULTS_CONFIG) || {};
        var showControls = hasResults && (results.resultsContext === ResultsContext.NORMAL || noResultsConfig.displayAllResults);
        return showControls;
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var showControls = this.shouldShowControls(results, limit);
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

        if (!showControls) {
          return;
        }

        var previousPageButton = DOM.query(this._container, '.js-yxt-Pagination-previous');
        var nextPageButton = DOM.query(this._container, '.js-yxt-Pagination-next');
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        DOM.on(previousPageButton, 'click', function () {
          return _this2.updatePage(offset - limit);
        });
        DOM.on(nextPageButton, 'click', function () {
          return _this2.updatePage(offset + limit);
        });

        if (this._firstPageButtonEnabled) {
          var firstPageButton = DOM.query(this._container, '.js-yxt-Pagination-first');
          DOM.on(firstPageButton, 'click', function () {
            return _this2.updatePage(0);
          });
        }

        if (this._lastPageButtonEnabled) {
          var lastPageButton = DOM.query(this._container, '.js-yxt-Pagination-last');
          DOM.on(lastPageButton, 'click', function () {
            return _this2.updatePage(maxPage * limit);
          });
        }
      }
    }, {
      key: "updatePage",
      value: function updatePage(offset) {
        this.scrollToTop();
        this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.persistentStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.verticalPage(this._verticalKey, offset);
      }
    }, {
      key: "scrollToTop",
      value: function scrollToTop() {
        document.documentElement.scrollTop = 0; // Safari

        document.body.scrollTop = 0;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var pageNumber = offset / limit;
        var isMoreResults = results.resultsCount > offset + limit;
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        return _get(_getPrototypeOf(PaginationComponent.prototype), "setState", this).call(this, _objectSpread({
          showControls: this.shouldShowControls(results, limit),
          firstPageButtonEnabled: this._firstPageButtonEnabled,
          lastPageButtonEnabled: this._lastPageButtonEnabled,
          pageNumber: pageNumber + 1,
          pageLabel: this._pageLabel,
          showFirstPageButton: pageNumber > 1,
          showPreviousPageButton: pageNumber > 0,
          showNextPageButton: isMoreResults,
          showLastPageButton: pageNumber < maxPage - 1
        }, data));
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'results/pagination';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Pagination';
      }
    }]);

    return PaginationComponent;
  }(Component);

  var CTACollectionComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CTACollectionComponent, _Component);

    function CTACollectionComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CTACollectionComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(CTACollectionComponent).call(this, config, systemConfig));
      var data = _this._config.data || {};
      /**
       * Result data
       * @type {Result}
       */

      _this.result = data.result || {};
      /**
       * Whether the DOM should include legacy class names
       * @type {boolean}
       */

      _this.includeLegacyClasses = _this._config.includeLegacyClasses || false;
      /**
       * Vertical key for the search.
       * @type {string}
       */

      _this.verticalKey = data.verticalKey;
      /**
       * Whether this cta is part of a universal search.
       * @type {boolean}
       */

      _this.isUniversal = _this._config.isUniversal || false;
      /**
       * Either a function that spits out an array of CTA config objects or an array of CTA config objects
       * or api fieldnames
       * @type {Function|Array<Object|string>}
       */

      var callsToAction = _this._config.callsToAction || [];
      /**
       * The config for each calls to action component to render.
       * @type {Array<Object>}
       */

      _this.callsToAction = CTACollectionComponent.resolveCTAMapping.apply(CTACollectionComponent, [_this.result._raw].concat(_toConsumableArray(callsToAction))); // Assign any extra cta config that does not come from the cta mappings.

      var _ctaModifiers = _this._config._ctaModifiers || [];

      if (_this.callsToAction.length === 1) {
        _ctaModifiers.push('solo');
      }

      _this.callsToAction = _this.callsToAction.map(function (cta) {
        return _objectSpread({
          eventOptions: _this.defaultEventOptions(_this.result),
          _ctaModifiers: _ctaModifiers,
          includeLegacyClasses: _this.includeLegacyClasses
        }, cta);
      });
      return _this;
    }
    /**
     * Handles resolving ctas from a cta mapping which are either
     * 1. a function that returns a cta's config
     * 2. an object that has a per-attribute mapping of either a
     *    a) static value
     *    b) function that takes in resut data and returns the given attributes value
     * Note: Intentionally does not allow nesting functions.
     * @param {Object} result
     * @param {Function|...(Object|string)} ctas
     * @returns {Array<Object>}
     */


    _createClass(CTACollectionComponent, [{
      key: "defaultEventOptions",
      value: function defaultEventOptions(result) {
        var eventOptions = {
          verticalKey: this.verticalKey,
          searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
        };

        if (result._raw.id) {
          eventOptions.entityId = result._raw.id;
        }

        return eventOptions;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(CTACollectionComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          includeLegacyClasses: this.includeLegacyClasses,
          callsToAction: this.callsToAction
        }));
      }
    }], [{
      key: "resolveCTAMapping",
      value: function resolveCTAMapping(result) {
        var parsedCTAs = [];

        for (var _len = arguments.length, ctas = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          ctas[_key - 1] = arguments[_key];
        }

        ctas.map(function (ctaMapping) {
          if (typeof ctaMapping === 'function') {
            parsedCTAs = parsedCTAs.concat(ctaMapping(result));
          } else if (_typeof(ctaMapping) === 'object') {
            var ctaObject = _objectSpread({}, ctaMapping);

            for (var _i = 0, _Object$entries = Object.entries(ctaMapping); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  ctaAttribute = _Object$entries$_i[0],
                  attributeMapping = _Object$entries$_i[1];

              if (typeof attributeMapping === 'function') {
                ctaObject[ctaAttribute] = attributeMapping(result);
              }
            }

            parsedCTAs.push(ctaObject);
          }
        });
        parsedCTAs = parsedCTAs.filter(function (cta) {
          return cta;
        });
        parsedCTAs.forEach(function (cta) {
          if (!cta.label && !cta.url) {
            console.warn('Call to Action:', cta, 'is missing both a label and url attribute and is being automatically hidden');
          } else if (!cta.label) {
            console.warn('Call to Action:', cta, 'is missing a label attribute and is being automatically hidden');
          } else if (!cta.url) {
            console.warn('Call to Action:', cta, 'is missing a url attribute and is being automatically hidden');
          }
        });
        return parsedCTAs.filter(function (cta) {
          return cta.url && cta.url.trim() && cta.label && cta.label.trim();
        });
      }
    }, {
      key: "hasCTAs",
      value: function hasCTAs(result, ctas) {
        return CTACollectionComponent.resolveCTAMapping.apply(CTACollectionComponent, [result].concat(_toConsumableArray(ctas))).length > 0;
      }
    }, {
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'ctas/ctacollection';
      }
    }, {
      key: "type",
      get: function get() {
        return 'CTACollection';
      }
    }]);

    return CTACollectionComponent;
  }(Component);

  var StandardCardConfig = function StandardCardConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, StandardCardConfig);

    Object.assign(this, config);
    var data = config.data || {};
    /**
     * The result data
     * @type {Result}
     */

    var result = data.result || {};
    /**
     * The raw profile data
     * @type {Object}
     */

    var rawResult = result._raw || {};
    /**
     * The dataMappings attribute of the config
     * is either a function that returns additional config for
     * a card or an object that is the additional config.
     */

    Object.assign(this, CardComponent.applyDataMappings(rawResult, config.dataMappings || {}));
    /**
     * The result data
     * @type {Result}
     */

    this.result = config.data || {};
    /**
     * Title for the card
     * @type {string}
     */

    this.title = this.title || result.title || rawResult.name || '';
    /**
     * Details for the card
     * @type {string}
     */

    this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
    /**
     * Url when you click the title
     * @type {string}
     */

    this.url = this.url || result.link || rawResult.website;
    /**
     * If showMoreLimit is set, the text that displays beneath it
     * @type {string}
     */

    this.showMoreText = this.showMoreText || 'Show More';
    /**
     * If showMoreLimit is set, the text that displays beneath it when all text is shown
     * @type {string}
     */

    this.showLessText = this.showLessText || 'Show Less';
    /**
     * Add a show more link if this number of characters is shown,
     * and truncate the last 3 characters with an ellipses.
     * Clicking show more should expand the results (but no show less link).
     * @type {number}
     */

    this.showMoreLimit = this.showMoreLimit || 350;
    /**
     * The target attribute for the title link.
     * @type {string}
     */

    this.target = this.target || '_self';
    /**
     * Image url to display
     * @type {string}
     */

    this.image = this.image;
    /**
     * Subtitle
     * @type {string}
     */

    this.subtitle = this.subtitle;
    /**
     * Whether a 'show more' toggle button needs to be rendered at all
     */

    var detailsOverLimit = this.details.length > this.showMoreLimit;
    this.showToggle = this.showMoreLimit && detailsOverLimit;
    /**
     * Either a function that spits out an array of CTA config objects or an array of CTA config objects
     * or api fieldnames
     * @type {Function|Array<Object|string>}
     */

    this.callsToAction = this.callsToAction || [];
    /**
     * Whether to show the ordinal of the card in the results.
     * @type {boolean}
     */

    this.showOrdinal = this.showOrdinal || false;
    /**
     * Whether this card is part of a universal search.
     * @type {boolean}
     */

    this.isUniversal = this.isUniversal || false;
    /**
     * The index of the card.
     * @type {number}
     */

    this._index = config._index || 0;
  };
  /**
   * Card components expect to receive a data config option, containing data regarding entity result
   * each card is assigned to, including all field data in data._raw.
   */


  var StandardCardComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(StandardCardComponent, _Component);

    function StandardCardComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, StandardCardComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(StandardCardComponent).call(this, new StandardCardConfig(config), systemConfig));
      _this.hideExcessDetails = _this._config.showToggle;
      /**
       * @type {Object}
       */

      var data = config.data || {};
      /**
       * Vertical key for the search.
       * @type {string}
       */

      _this.verticalKey = data.verticalKey;
      /**
       * The result data
       * @type {Result}
       */

      _this.result = data.result || {};
      return _this;
    }

    _createClass(StandardCardComponent, [{
      key: "setState",
      value: function setState(data) {
        var details = this.hideExcessDetails ? "".concat(this._config.details.substring(0, this._config.showMoreLimit), "...") : this._config.details;
        return _get(_getPrototypeOf(StandardCardComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          hideExcessDetails: this.hideExcessDetails,
          result: this.result,
          hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction),
          entityId: this.result._raw.id,
          verticalKey: this.verticalKey,
          details: details
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._config.showToggle) {
          var el = DOM.query(this._container, '.js-yxt-StandardCard-toggle');
          DOM.on(el, 'click', function () {
            _this2.hideExcessDetails = !_this2.hideExcessDetails;

            _this2.setState();
          });
        }
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        if (type === CTACollectionComponent.type) {
          var updatedData = {
            verticalKey: this.verticalKey,
            result: data
          };
          return _get(_getPrototypeOf(StandardCardComponent.prototype), "addChild", this).call(this, updatedData, type, _objectSpread({
            callsToAction: this._config.callsToAction,
            isUniversal: this._config.isUniversal,
            _ctaModifiers: ['StandardCard']
          }, opts));
        }

        return _get(_getPrototypeOf(StandardCardComponent.prototype), "addChild", this).call(this, data, type, opts);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return cardTemplates.Standard;
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return cardTypes.Standard;
      }
    }]);

    return StandardCardComponent;
  }(Component);

  var AccordionCardConfig = function AccordionCardConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AccordionCardConfig);

    Object.assign(this, config);
    var data = config.data || {};
    /**
     * The result data
     * @type {Result}
     */

    var result = data.result || {};
    /**
     * The raw profile data
     * @type {Object}
     */

    var rawResult = result._raw || {};
    /**
     * The dataMappings attribute of the config
     * is either a function that returns additional config for
     * a card or an object that is the additional config.
     */

    var dataMappings = config.dataMappings || {};
    Object.assign(this, CardComponent.applyDataMappings(rawResult, dataMappings));
    /**
     * Vertical key for the card, added to analytics events sent by this component.
     * @type {string}
     */

    this.verticalKey = config.verticalKey;
    /**
     * @type {string}
     */

    this.title = this.title || result.title || rawResult.name || '';
    /**
     * @type {string}
     */

    this.subtitle = this.subtitle;
    /**
     * @type {string}
     */

    this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
    /**
     * If expanded is true the first accordion in vertical/universal results renders on page load expanded.
     * @type {boolean}
     */

    this.expanded = this.expanded || false;
    /**
     * Either a function that spits out an array of CTA config objects or an array of CTA config objects
     * or api fieldnames
     * @type {Function|Array<Object|string>}
     */

    this.callsToAction = this.callsToAction || [];
    /**
     * Whether this card is part of a universal search. Used in analytics.
     * @type {boolean}
     */

    this.isUniversal = config.isUniversal || false;
  };

  var AccordionCardComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AccordionCardComponent, _Component);

    function AccordionCardComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AccordionCardComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AccordionCardComponent).call(this, new AccordionCardConfig(config), systemConfig));
      /**
       * Whether the accordion is collapsed or not.
       * Defaults to true only if the expanded option is true
       * and this is the first card in the results.
       * @type {boolean}
       */

      _this.isExpanded = _this._config.expanded && config._index === 0;
      /**
       * @type {Object}
       */

      var data = config.data || {};
      /**
       * Vertical key for the card, added to analytics events sent by this component.
       * @type {string}
       */

      _this.verticalKey = data.verticalKey;
      /**
       * The result data, sent to children CTA Components that need this.
       * @type {Result}
       */

      _this.result = data.result || {};
      return _this;
    }

    _createClass(AccordionCardComponent, [{
      key: "setState",
      value: function setState(data) {
        var id = this.result.id || this.result.ordinal;
        return _get(_getPrototypeOf(AccordionCardComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          result: this.result,
          isExpanded: this.isExpanded,
          id: "".concat(this.name, "-").concat(id, "-").concat(this.verticalKey),
          hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction)
        }));
      }
      /**
       * Click handler for the accordion toggle button
       * This is used over set state because it's a lot smoother, since
       * it doesn't rip the whole component off of the page and remount it.
       * Also reports an analytics event.
       * @param {HTMLElement} toggleEl the toggle element
       * @param {HTMLElement} contentEl the content element
       * @param {HTMLElement} accordionEl the root accordion element
       */

    }, {
      key: "handleClick",
      value: function handleClick(toggleEl, contentEl, accordionEl) {
        this.isExpanded = !this.isExpanded;
        accordionEl.classList.toggle('yxt-AccordionCard--expanded');
        contentEl.style.height = "".concat(this.isExpanded ? contentEl.scrollHeight : 0, "px");
        toggleEl.setAttribute('aria-expanded', this.isExpanded ? 'true' : 'false');
        contentEl.setAttribute('aria-hidden', this.isExpanded ? 'false' : 'true');
        var event = new AnalyticsEvent(this.isExpanded ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
          verticalKey: this.verticalKey,
          entityId: this.result._raw.id,
          searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
        });
        this.analyticsReporter.report(event);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        var toggleEl = DOM.query(this._container, '.js-yxt-AccordionCard-toggle');
        var contentEl = DOM.query(this._container, '.js-yxt-AccordionCard-content');
        var accordionEl = DOM.query(this._container, '.js-yxt-AccordionCard');
        contentEl.style.height = "".concat(this.isExpanded ? contentEl.scrollHeight : 0, "px");
        DOM.on(toggleEl, 'click', function () {
          return _this2.handleClick(toggleEl, contentEl, accordionEl);
        });
      }
      /**
       * For passing functions to the config of children {@link CTACollectionComponent}
       */

    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        if (type === CTACollectionComponent.type) {
          var updatedData = {
            verticalKey: this.verticalKey,
            result: data
          };
          return _get(_getPrototypeOf(AccordionCardComponent.prototype), "addChild", this).call(this, updatedData, type, _objectSpread({
            callsToAction: this._config.callsToAction,
            _ctaModifiers: ['AccordionCard'],
            isUniversal: this._config.isUniversal
          }, opts));
        }

        return _get(_getPrototypeOf(AccordionCardComponent.prototype), "addChild", this).call(this, data, type, opts);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return cardTemplates.Accordion;
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return cardTypes.Accordion;
      }
    }]);

    return AccordionCardComponent;
  }(Component);

  var LegacyCardConfig = function LegacyCardConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, LegacyCardConfig);

    Object.assign(this, config);
    var data = config.data || {};
    /**
     * The result data
     * @type {Result}
     */

    var result = data.result || {};
    /**
     * The raw profile data
     * @type {Object}
     */

    var rawResult = result._raw || {};
    /**
     * The dataMappings attribute of the config
     * is either a function that returns additional config for
     * a card or an object that is the additional config.
     */

    Object.assign(this, CardComponent.applyDataMappings(rawResult, config.dataMappings || {}));
    /**
     * The result data
     * @type {Result}
     */

    this.result = config.data || {};
    /**
     * Title for the card
     * @type {string}
     */

    this.title = this.title || result.title || rawResult.name || '';
    /**
     * Details for the card
     * @type {string}
     */

    this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
    /**
     * Url when you click the title
     * @type {string}
     */

    this.url = this.url || result.link || rawResult.website;
    /**
     * The target attribute for the title link.
     * @type {string}
     */

    this.target = this.target || '_self';
    /**
     * Image url to display
     * @type {string}
     */

    this.image = this.image;
    /**
     * Subtitle
     * @type {string}
     */

    this.subtitle = this.subtitle;
    /**
     * Either a function that spits out an array of CTA config objects or an array of CTA config objects
     * or api fieldnames
     * @type {Function|Array<Object|string>}
     */

    this.callsToAction = this.callsToAction || [];
    /**
     * Whether to show the ordinal of the card in the results.
     * @type {boolean}
     */

    this.showOrdinal = this.showOrdinal || false;
    /**
     * Whether this card is part of a universal search.
     * @type {boolean}
     */

    this.isUniversal = this.isUniversal || false;
    /**
     * The index of the card.
     * @type {number}
     */

    this._index = config._index || 0;
  };
  /**
   * Card components expect to receive a data config option, containing data regarding entity result
   * each card is assigned to, including all field data in data._raw.
   */


  var LegacyCardComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(LegacyCardComponent, _Component);

    function LegacyCardComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LegacyCardComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LegacyCardComponent).call(this, new LegacyCardConfig(config), systemConfig));
      /**
       * @type {Object}
       */

      var data = config.data || {};
      /**
       * Vertical key for the search.
       * @type {string}
       */

      _this.verticalKey = data.verticalKey;
      /**
       * The result data
       * @type {Result}
       */

      _this.result = data.result || {};
      return _this;
    }

    _createClass(LegacyCardComponent, [{
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(LegacyCardComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          eventOptions: this._legacyEventOptions(this.result._raw.id, this.result.link),
          result: this.result,
          hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction),
          entityId: this.result._raw.id,
          verticalKey: this.verticalKey
        }));
      }
    }, {
      key: "_legacyEventOptions",
      value: function _legacyEventOptions(entityId, url) {
        var options = {
          verticalConfigId: this.verticalKey,
          searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
        };

        if (entityId) {
          options.entityId = entityId;
        } else {
          options.url = url;
        }

        return JSON.stringify(options);
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        if (type === CTACollectionComponent.type) {
          var updatedData = {
            verticalKey: this.verticalKey,
            result: data
          };
          return _get(_getPrototypeOf(LegacyCardComponent.prototype), "addChild", this).call(this, updatedData, type, _objectSpread({
            callsToAction: this._config.callsToAction,
            isUniversal: this._config.isUniversal,
            _ctaModifiers: ['LegacyCard'],
            includeLegacyClasses: true
          }, opts));
        }

        return _get(_getPrototypeOf(LegacyCardComponent.prototype), "addChild", this).call(this, data, type, opts);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return cardTemplates.Legacy;
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return cardTypes.Legacy;
      }
    }]);

    return LegacyCardComponent;
  }(Component);

  /**
   * Configurable options for the component
   * @type {Object}
   */

  var DEFAULT_CONFIG$5 = {
    /**
     * The entity identifier that the question is associated with.
     * This is typically an organization object
     * @type {number}
     */
    'entityId': null,

    /**
     * The main CSS selector used to reference the form for the component.
     * @type {string} CSS selector
     */
    'formSelector': 'form',

    /**
     * An optional label to use for the e-mail address input
     * @type {string}
     */
    'emailLabel': 'Email',

    /**
     * An optional label to use for the name input
     * @type {string}
     */
    'nameLabel': 'Name',

    /**
     * An optional label to use for the question
     * @type {string}
     */
    'questionLabel': 'Question',

    /**
     * An optional label to use for the Privacy Policy
     * @type {string}
     */
    'privacyPolicyText': 'By submitting my email address, I consent to being contacted via email at the address provided.',

    /**
     * The label to use for the Submit button
     * @type {string}
     */
    'buttonLabel': 'Submit',

    /**
     * The title to display in the title bar
     * @type {string}
     */
    'sectionTitle': 'Ask a Question',

    /**
     * The description to display in the title bar
     * @type {string}
     */
    'teaser': 'Cant find what you\'re looking for? Ask a question below.',

    /**
     * The name of the icon to use in the title bar
     * @type {string}
     */
    'sectionTitleIconName': 'support',

    /**
     * The text to display in the feedback form ahead of the Question input
     * @type {string}
     */
    'description': 'Enter your question and contact information, and we\'ll get back to you with a response shortly.',

    /**
     * The placeholder text for required inputs
     * @type {string}
     */
    'requiredInputPlaceholder': '(required)',

    /**
     * The placeholder text for the question text area
     * @type {string}
     */
    'questionInputPlaceholder': 'Enter your question here',

    /**
     * The confirmation text to display after successfully submitting feedback
     * @type {string}
     */
    'questionSubmissionConfirmationText': 'Thank you for your question!',

    /**
     * The default privacy policy url label
     * @type {string}
    */
    'privacyPolicyUrlLabel': 'Learn more here.',

    /**
     * The default privacy policy url
     * @type {string}
     */
    'privacyPolicyUrl': '',

    /**
     * The default privacy policy error text, shown when the user does not agree
     * @type {string}
     */
    'privacyPolicyErrorText': '* You must agree to the privacy policy to submit a question.',

    /**
     * The default email format error text, shown when the user submits an invalid email
     * @type {string}
     */
    'emailFormatErrorText': '* Please enter a valid email address.',

    /**
     * The default network error text, shown when there is an issue with the QA Submission
     * request.
     * @type {string}
     */
    'networkErrorText': 'We\'re sorry, an error occurred.',

    /**
     * Whether or not this component is expanded by default.
     * @type {boolean}
     */
    'expanded': true
  };
  /**
   * QuestionSubmissionComponent is a component that creates a form
   * thats displayed whenever a query is run. It enables the user
   * to submit questions that they cant find the answer for.
   */

  var QuestionSubmissionComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(QuestionSubmissionComponent, _Component);

    function QuestionSubmissionComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, QuestionSubmissionComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(QuestionSubmissionComponent).call(this, Object.assign({}, DEFAULT_CONFIG$5, config), systemConfig));
      /**
       * Reference to the storage model
       * @type {string}
       */

      _this.moduleId = StorageKeys.QUESTION_SUBMISSION;
      /**
       * Reference to the locale as set in the global config
       * @type {string}
       */

      _this.locale = _this.core.globalStorage.getState(StorageKeys.LOCALE);
      /**
       * NOTE(billy) if this is a pattern we want to follow for configuration
       * we should bake it into the core class.
       */

      _this.validateConfig();
      /**
       * The QuestionSubmission component should be rendered only once a search has completed. If the
       * search results are still loading, the component should not be displayed.
       */


      var onResultsUpdate = function onResultsUpdate(results) {
        if (results.searchState !== SearchStates.SEARCH_LOADING) {
          var questionText = _this.core.globalStorage.getState(StorageKeys.QUERY);

          _this.setState(new QuestionSubmission({
            questionText: questionText,
            expanded: _this._config.expanded
          }));
        } else {
          _this.unMount();
        }
      };

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, onResultsUpdate);

      _this.core.globalStorage.on('update', StorageKeys.UNIVERSAL_RESULTS, onResultsUpdate);

      return _this;
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(QuestionSubmissionComponent, [{
      key: "validateConfig",

      /**
       * validationConfig contains a bunch of rules
       * that are used to validate aginst configuration provided by the user
       */
      value: function validateConfig() {
        if (this._config.entityId === null || this._config.entityId === undefined) {
          throw new AnswersComponentError('`entityId` is a required configuration option for Question Submission', 'QuestionSubmission');
        }
      }
    }, {
      key: "beforeMount",
      value: function beforeMount() {
        // Avoid mounting the component if theres no data
        // Note, 1 because `config` is always part of the state.
        return Object.keys(this.getState()).length > 1;
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var triggerEl = DOM.query(this._container, '.js-content-visibility-toggle');

        if (triggerEl !== null) {
          this.bindFormToggle(triggerEl);
        }

        var formEl = DOM.query(this._container, this._config.formSelector);

        if (formEl === null) {
          return;
        }

        this.bindFormFocus(formEl);
        this.bindFormSubmit(formEl);
      }
      /**
       * bindFormFocus will wire up the DOM focus event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormFocus",
      value: function bindFormFocus(formEl) {
        var _this2 = this;

        if (this.analyticsReporter === null) {
          return;
        }

        var questionText = DOM.query(formEl, '.js-question-text');
        DOM.on(questionText, 'focus', function () {
          _this2.analyticsReporter.report(_this2.getAnalyticsEvent('QUESTION_FOCUS'));
        });
      }
      /**
       * bindFormSubmit handles submitting the question to the server,
       * and submits an event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormSubmit",
      value: function bindFormSubmit(formEl) {
        var _this3 = this;

        DOM.on(formEl, 'submit', function (e) {
          e.preventDefault();

          _this3.analyticsReporter.report(_this3.getAnalyticsEvent('QUESTION_SUBMIT')); // TODO(billy) we probably want to disable the form from being submitted twice


          var errors = _this3.validate(formEl);

          var formData = _this3.parse(formEl);

          if (Object.keys(errors).length) {
            return _this3.setState(new QuestionSubmission(formData, errors));
          }

          _this3.core.submitQuestion({
            'entityId': _this3._config.entityId,
            'questionLanguage': _this3.locale,
            'site': 'FIRSTPARTY',
            'name': formData.name,
            'email': formData.email,
            'questionText': formData.questionText,
            'questionDescription': formData.questionDescription
          })["catch"](function (error) {
            _this3.setState(new QuestionSubmission(formData, {
              'network': 'We\'re sorry, an error occurred.'
            }));

            throw error;
          });
        });
      }
      /**
       * bindFormToggle handles expanding and mimimizing the component's form.
       * @param {HTMLElement} triggerEl
       */

    }, {
      key: "bindFormToggle",
      value: function bindFormToggle(triggerEl) {
        var _this4 = this;

        DOM.on(triggerEl, 'click', function (e) {
          var formData = _this4.getState();

          _this4.setState(new QuestionSubmission(_objectSpread({}, formData, {
            'expanded': !formData.questionExpanded,
            'submitted': formData.questionSubmitted
          }), formData.errors));
        });
      }
      /**
       * Takes the form, and builds a object that represents the input names
       * and text fields.
       * @param {HTMLElement} formEl
       * @returns {object}
       */

    }, {
      key: "parse",
      value: function parse(formEl) {
        var inputFields = DOM.queryAll(formEl, '.js-question-field');

        if (!inputFields || inputFields.length === 0) {
          return {};
        }

        var obj = {};

        for (var i = 0; i < inputFields.length; i++) {
          var val = inputFields[i].value;

          if (inputFields[i].type === 'checkbox') {
            val = inputFields[i].checked;
          }

          obj[inputFields[i].name] = val;
        }

        return obj;
      }
      /**
       * Validates the fields for correct formatting
       * @param {HTMLElement} formEl
       * @returns {Object} errors object if any errors found
       */

    }, {
      key: "validate",
      value: function validate(formEl) {
        var errors = {};
        var fields = DOM.queryAll(formEl, '.js-question-field');

        for (var i = 0; i < fields.length; i++) {
          if (!fields[i].checkValidity()) {
            if (i === 0) {
              // set focus state on first error
              fields[i].focus();
            }

            switch (fields[i].name) {
              case 'email':
                errors['emailError'] = true;

                if (!fields[i].validity.valueMissing) {
                  errors['emailErrorText'] = this._config.emailFormatErrorText;
                }

                break;

              case 'name':
                errors['nameError'] = true;
                break;

              case 'privacyPolicy':
                errors['privacyPolicyErrorText'] = this._config.privacyPolicyErrorText;
                errors['privacyPolicyError'] = true;
                break;

              case 'questionText':
                errors['questionTextError'] = true;
                break;
            }
          }
        }

        return errors;
      }
      /**
       * Returns an options object describing the context of a reportable event
       */

    }, {
      key: "getAnalyticsEvent",
      value: function getAnalyticsEvent(eventType) {
        var analyticsEvent = new AnalyticsEvent(eventType);
        analyticsEvent.addOptions({
          verticalConfigId: this._verticalKey,
          searcher: this._verticalKey ? 'VERTICAL' : 'UNIVERSAL'
        });
        return analyticsEvent;
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'questions/questionsubmission';
      }
      /**
       * The public interface alias for the component
       * @returns {string}
       * @override
       */

    }, {
      key: "type",
      get: function get() {
        return 'QASubmission';
      }
    }]);

    return QuestionSubmissionComponent;
  }(Component);

  var IconComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(IconComponent, _Component);

    /**
     * IconComponent
     * @param opts
     * @param opts.iconName {string}
     * @param opts.iconUrl {string}
     */
    function IconComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, IconComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(IconComponent).call(this, opts, systemOpts));
      /**
       * name of an icon from the default icon set
       * @type {string}
       */

      _this.iconName = opts.iconName || 'default';
      /**
       * the url to a custom image icon
       * @type {null}
       */

      _this.iconUrl = opts.iconUrl || null;
      /**
       * An additional string to append to the icon's css class. Multiple
       * classes should be space delimited.
       */

      _this.classNames = opts.classNames || null;
      /**
       * A unique id to pass to the icon.
       * @type {Object}
       */

      _this.complexContentsParams = opts.complexContentsParams || {};
      return _this;
    }

    _createClass(IconComponent, [{
      key: "setState",

      /**
       * overrides default functionality to provide name and markup
       * @param data
       * @returns {IconComponent}
       */
      value: function setState(data) {
        return _get(_getPrototypeOf(IconComponent.prototype), "setState", this).call(this, Object.assign(data, {
          iconUrl: this.iconUrl,
          iconName: this.iconName,
          name: this.iconName ? this.iconName : 'custom',
          classNames: this.classNames,
          complexContentsParams: this.complexContentsParams
        }));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'icons/icon';
      }
      /**
       * allowing duplicates
       * @returns {boolean}
       * @override
       */

    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'IconComponent';
      }
    }]);

    return IconComponent;
  }(Component);

  var CTAConfig = function CTAConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CTAConfig);

    Object.assign(this, config);
    /**
     * Label below the CTA icon
     * @type {string}
     */

    this.label = config.label;
    /**
     * CTA icon, maps to a set of icons.
     * @type {string}
     */

    this.icon = config.icon;
    /**
     * Url to custom icon, has priority over icon.
     * @type {string}
     */

    this.iconUrl = config.iconUrl;
    /**
     * Whether the DOM should include legacy class names
     * @type {boolean}
     */

    this.includeLegacyClasses = config.includeLegacyClasses || false;
    /**
     * Click through url for the icon and label
     * @type {string}
     */

    this.url = config.url;
    /**
     * Analytics event that should fire:
     * @type {string}
     */

    this.analyticsEventType = config.analytics || 'CTA_CLICK';
    /**
     * The target attribute for the CTA link.
     * @type {boolean}
     */

    this.target = config.target || '_self';
    /**
     * The eventOptions needed for the event to fire, passed as a string or Object
     * from config.dataMappings || {}.
     * @type {Object}
     */

    if (typeof config.eventOptions === 'string') {
      this.eventOptions = JSON.parse(config.eventOptions);
    }

    this.eventOptions = this.eventOptions;
    /**
     * Additional css className modifiers for the cta
     * @type {string}
     */

    this._ctaModifiers = config._ctaModifiers;
    /**
     * Whether the cta is the only one in its CTACollectionComponent
     * @type {boolean}
     */

    this._isSolo = config._isSolo || false;
  };

  var CTAComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(CTAComponent, _Component);

    function CTAComponent() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CTAComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(CTAComponent).call(this, new CTAConfig(config), systemConfig));
    }

    _createClass(CTAComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this = this;

        var el = DOM.query(this._container, ".js-yxt-CTA");

        if (el && this._config.eventOptions) {
          DOM.on(el, 'click', function () {
            return _this.reportAnalyticsEvent();
          });
        }
      }
    }, {
      key: "reportAnalyticsEvent",
      value: function reportAnalyticsEvent() {
        var analyticsEvent = new AnalyticsEvent(this._config.analyticsEventType);
        analyticsEvent.addOptions(this._config.eventOptions);
        this.analyticsReporter.report(analyticsEvent);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'ctas/cta';
      }
    }, {
      key: "type",
      get: function get() {
        return 'CTA';
      }
    }]);

    return CTAComponent;
  }(Component);

  /** @module */
  var COMPONENT_CLASS_LIST = [// Core Component
  Component, // Navigation Components
  NavigationComponent, // Search Components
  SearchComponent, FilterSearchComponent, AutoCompleteComponent, SpellCheckComponent, LocationBiasComponent, // Filter Components
  FilterBoxComponent, FilterOptionsComponent, RangeFilterComponent, DateRangeFilterComponent, FacetsComponent, GeoLocationComponent, SortOptionsComponent, // Results Components
  DirectAnswerComponent, UniversalResultsComponent, VerticalResultsComponent, PaginationComponent, AccordionResultsComponent, MapComponent, AlternativeVerticalsComponent, ResultsHeaderComponent, // Card Components
  CardComponent, StandardCardComponent, AccordionCardComponent, LegacyCardComponent, // Questions Components
  QuestionSubmissionComponent, // Helper Components
  IconComponent, CTAComponent, CTACollectionComponent];
  /**
   * The component registry is a map that contains
   * all available component classes used for creation or extension.
   * Each component class has a unique type, which is used as the key for the registry
   * @type {Object.<string, Component>}
   */

  var COMPONENT_REGISTRY = COMPONENT_CLASS_LIST.reduce(function (registry, clazz) {
    registry[clazz.type] = clazz;
    return registry;
  }, {});

  /**
   * ComponentManager is a Singletone that contains both an internal registry of
   * eligible components to be created, as well as keeps track of the current
   * instantiated and active components.
   *
   * ALL components should be constructed using the {ComponentManager} via its `create` method.
   */

  var ComponentManager =
  /*#__PURE__*/
  function () {
    function ComponentManager() {
      _classCallCheck(this, ComponentManager);

      /**
       * The active components is an internal container to keep track
       * of all of the components that have been constructed
       */
      this._activeComponents = [];
      /**
       * A local reference to the core library dependency
       *
       * The Core contains both the storage AND services that are needed for performing operations
       * like search and auto complete.
       *
       * The storage is the source of truth for the state of ALL components.
       * Whenever the storage is updated, the state gets pushed down to the necessary components.
       * @type {Core}
       */

      this._core = null;
      /**
       * The primary renderer to use for all components
       * @type {HandlebarsRenderer}
       */

      this._renderer = null;
      /**
       * A local reference to the analytics reporter dependency
       */

      this._analyticsReporter = null;
    }

    _createClass(ComponentManager, [{
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = renderer;
        return this;
      }
    }, {
      key: "setCore",
      value: function setCore(core) {
        this._core = core;
        return this;
      }
    }, {
      key: "setAnalyticsReporter",
      value: function setAnalyticsReporter(reporter) {
        this._analyticsReporter = reporter;
        return this;
      }
      /**
       * registers a component to be eligible for creation and override.
       * @param {Component} The Component Class to register
       */

    }, {
      key: "register",
      value: function register(componentClazz) {
        COMPONENT_REGISTRY[componentClazz.type] = componentClazz;
        return this;
      }
      /**
       * Returns components with names similar to the passed in component class.
       * @param {string} componentType
       */

    }, {
      key: "getSimilarComponents",
      value: function getSimilarComponents(componentType) {
        var similarComponents = Object.keys(COMPONENT_REGISTRY).filter(function (type) {
          return type.startsWith(componentType.substring(0, 2));
        });

        if (similarComponents.length === 0) {
          similarComponents = Object.keys(COMPONENT_REGISTRY);
        }

        return similarComponents;
      }
      /**
       * create is the entry point for constructing any and all components.
       * It will instantiate a new instance of the component, and both apply
       * initial state from the storage and bind it to the storage for updates.
       * @param {string} componentType The component type to create
       * @param {Object} opts The options to pipe to the construction of the component
       */

    }, {
      key: "create",
      value: function create(componentType, opts) {
        // Every component needs local access to the component manager
        // because sometimes components have subcomponents that need to be
        // constructed during creation
        var systemOpts = {
          core: this._core,
          renderer: this._renderer,
          analyticsReporter: this._analyticsReporter,
          componentManager: this
        };
        var componentClass = COMPONENT_REGISTRY[componentType];

        if (!componentClass) {
          throw new AnswersComponentError("Component type ".concat(componentType, " is not recognized as a valid component.") + " You might have meant ".concat(this.getSimilarComponents(componentType).join(', '), "?"));
        }

        if (!componentClass.areDuplicateNamesAllowed() && this._activeComponents.some(function (c) {
          return c.name === opts.name;
        })) {
          throw new AnswersComponentError("Another component with name ".concat(opts.name, " already exists"), componentType);
        }

        var config = _objectSpread({
          isTwin: this._activeComponents.some(function (component) {
            return component.constructor.type === componentType;
          })
        }, opts); // Instantiate our new component and keep track of it


        var component = new COMPONENT_REGISTRY[componentType](config, systemOpts).init(config);

        this._activeComponents.push(component); // If there is a global storage to power state, apply the state
        // from the storage to the component, and then bind the component
        // state to the storage via its updates


        if (this._core && this._core.globalStorage !== null) {
          if (component.moduleId === undefined || component.moduleId === null) {
            return component;
          }

          this._core.globalStorage.on('update', component.moduleId, function (data) {
            component.setState(data);
          });
        }

        return component;
      }
      /**
       * Remove the provided component from the list of active components and remove
       * the associated storage event listener
       * @param {Component} component The component to remove
       */

    }, {
      key: "remove",
      value: function remove(component) {
        this._core.globalStorage.off('update', component.moduleId);

        var index = this._activeComponents.findIndex(function (c) {
          return c.name === component.name;
        });

        this._activeComponents.splice(index, 1);
      }
      /**
       * Remove the component with the given name
       * @param {string} name The name of the compnent to remove
       */

    }, {
      key: "removeByName",
      value: function removeByName(name) {
        var component = this._activeComponents.find(function (c) {
          return c.name === name;
        });

        component.remove();
        DOM.empty(component._container);
      }
    }, {
      key: "getActiveComponent",
      value: function getActiveComponent(type) {
        return this._activeComponents.find(function (c) {
          return c.constructor.type === type;
        });
      }
    }], [{
      key: "getInstance",
      value: function getInstance() {
        if (!this.instance) {
          this.instance = new ComponentManager();
        }

        return this.instance;
      }
    }]);

    return ComponentManager;
  }();

  /** @module VerticalPagesConfig */
  var VerticalPageConfig =
  /*#__PURE__*/
  function () {
    function VerticalPageConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, VerticalPageConfig);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label || null;
      /**
       * The complete URL, including the params
       * @type {string}
       */

      this.url = config.url || null;
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */

      this.verticalKey = config.verticalKey || null;
      /**
       * Determines whether to show this tab in the navigation component
       * @type {boolean}
       */

      this.hideInNavigation = config.hideInNavigation || false;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
      /**
       * name of an icon from the default icon set
       * @type {string}
       */

      this.icon = config.icon;
      Object.freeze(this);
    }

    _createClass(VerticalPageConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return VerticalPageConfig;
  }();

  var VerticalPagesConfig =
  /*#__PURE__*/
  function () {
    function VerticalPagesConfig() {
      var pages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, VerticalPagesConfig);

      this.verticalPagesConfig = VerticalPagesConfig.from(pages);
    }
    /**
     * Using a getter that copies the data instead of providing a reference prevents it from being mutated.
     * This is important for global configuration.
     * @returns {Array<VerticalPageConfig>}
     */


    _createClass(VerticalPagesConfig, [{
      key: "get",
      value: function get() {
        return this.verticalPagesConfig.map(function (page) {
          return _objectSpread({}, page);
        });
      }
    }], [{
      key: "from",
      value: function from(pages) {
        return pages.map(function (page) {
          return new VerticalPageConfig(page);
        });
      }
    }]);

    return VerticalPagesConfig;
  }();

  /** @typedef {import('./core/services/searchservice').default} SearchService */

  /** @typedef {import('./core/services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./core/services/questionanswerservice').default} QuestionAnswerService */

  /** @typedef {import('./core/services/errorreporterservice').default} ErrorReporterService */

  /** @typedef {import('./core/services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @typedef Services
   * @property {SearchService} searchService
   * @property {AutoCompleteService} autoCompleteService
   * @property {QuestionAnswerService} questionAnswerService
   * @property {ErrorReporterService} errorReporterService
   */

  var DEFAULTS = {
    locale: 'en'
  };
  /**
   * The main Answers interface
   */

  var Answers =
  /*#__PURE__*/
  function () {
    function Answers() {
      _classCallCheck(this, Answers);

      if (!Answers.setInstance(this)) {
        return Answers.getInstance();
      }
      /**
       * A reference to the Component base class for custom
       * components to extend
       */


      this.Component = Component;
      /**
       * A reference to the AnalyticsEvent base class for reporting
       * custom analytics
       */

      this.AnalyticsEvent = AnalyticsEvent;
      /**
       * A reference of the renderer to use for the components
       * This is provided during initialization.
       * @type {Renderer}
       */

      this.renderer = new Renderers.Handlebars();
      /**
       * A local reference to the component manager
       * @type {ComponentManager}
       */

      this.components = ComponentManager.getInstance();
      /**
       * A local reference to the core api
       * @type {Core}
       */

      this.core = null;
      /**
       * A callback function to invoke once the library is ready.
       * Typically fired after templates are fetched from server for rendering.
       */

      this._onReady = function () {};
      /**
       * @type {boolean}
       * @private
       */


      this._eligibleForAnalytics = false;
      /**
       * @type {Services}
       * @private
       */

      this._services = null;
      /**
       * @type {AnalyticsReporterService}
       * @private
       */

      this._analyticsReporterService = null;
    }

    _createClass(Answers, [{
      key: "init",
      value: function init(config) {
        var _this = this;

        var parsedConfig = this.parseConfig(config);
        this.validateConfig(parsedConfig);
        parsedConfig.search = new SearchConfig(parsedConfig.search);
        parsedConfig.verticalPages = new VerticalPagesConfig(parsedConfig.verticalPages);
        var globalStorage = new GlobalStorage();
        var persistentStorage = new PersistentStorage({
          updateListener: parsedConfig.onStateChange,
          resetListener: function resetListener(data) {
            return globalStorage.setAll(data);
          }
        });
        globalStorage.setAll(persistentStorage.getAll());
        globalStorage.set(StorageKeys.SEARCH_CONFIG, parsedConfig.search);
        globalStorage.set(StorageKeys.VERTICAL_PAGES_CONFIG, parsedConfig.verticalPages);
        globalStorage.set(StorageKeys.LOCALE, parsedConfig.locale);
        globalStorage.set(StorageKeys.SESSIONS_OPT_IN, parsedConfig.sessionTrackingEnabled);
        this._services = parsedConfig.mock ? getMockServices() : getServices(parsedConfig, globalStorage);
        this.core = new Core({
          apiKey: parsedConfig.apiKey,
          globalStorage: globalStorage,
          persistentStorage: persistentStorage,
          experienceKey: parsedConfig.experienceKey,
          fieldFormatters: parsedConfig.fieldFormatters,
          experienceVersion: parsedConfig.experienceVersion,
          locale: parsedConfig.locale,
          searchService: this._services.searchService,
          autoCompleteService: this._services.autoCompleteService,
          questionAnswerService: this._services.questionAnswerService
        });

        if (parsedConfig.onStateChange && typeof parsedConfig.onStateChange === 'function') {
          parsedConfig.onStateChange(persistentStorage.getAll(), window.location.search.substr(1));
        }

        this.components.setCore(this.core).setRenderer(this.renderer);
        this._eligibleForAnalytics = parsedConfig.businessId != null;

        if (this._eligibleForAnalytics) {
          // TODO(amullings): Initialize with other services
          var reporter = parsedConfig.mock ? new NoopAnalyticsReporter() : new AnalyticsReporter(this.core, parsedConfig.experienceKey, parsedConfig.experienceVersion, parsedConfig.businessId, parsedConfig.analyticsOptions, parsedConfig.environment);
          this._analyticsReporterService = reporter;
          this.components.setAnalyticsReporter(reporter);
          initScrollListener(reporter);
        }

        this._setDefaultInitialSearch(parsedConfig.search);

        this._onReady = parsedConfig.onReady || function () {};

        if (parsedConfig.useTemplates === false || parsedConfig.templateBundle) {
          if (parsedConfig.templateBundle) {
            this.renderer.init(parsedConfig.templateBundle);
          }

          this._onReady();

          return this;
        } // Templates are currently downloaded separately from the CORE and UI bundle.
        // Future enhancement is to ship the components with templates in a separate bundle.


        this.templates = new DefaultTemplatesLoader(function (templates) {
          _this.renderer.init(templates);

          _this._onReady();
        });
        return this;
      }
    }, {
      key: "domReady",
      value: function domReady(cb) {
        DOM.onReady(cb);
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        this._onReady = cb;
        return this;
      }
      /**
       * Parses the config provided by the user. In the parsed config, any options not supplied by the
       * user are given default values.
       * @param {Object} config The user supplied config.
       */

    }, {
      key: "parseConfig",
      value: function parseConfig(config) {
        var parsedConfig = Object.assign({}, DEFAULTS, config);
        var sessionTrackingEnabled = true;

        if (typeof config.sessionTrackingEnabled === 'boolean') {
          sessionTrackingEnabled = config.sessionTrackingEnabled;
        }

        parsedConfig.sessionTrackingEnabled = sessionTrackingEnabled;
        var sandboxPrefix = "".concat(SANDBOX, "-");
        parsedConfig.apiKey.includes(sandboxPrefix) ? parsedConfig.environment = SANDBOX : parsedConfig.environment = PRODUCTION;
        parsedConfig.apiKey = parsedConfig.apiKey.replace(sandboxPrefix, '');
        return parsedConfig;
      }
      /**
       * Validates the Answers config object to ensure things like api key and experience key are
       * properly set.
       * @param {Object} config The Answers config.
       */

    }, {
      key: "validateConfig",
      value: function validateConfig(config) {
        // TODO (tmeyer): Extract this method into it's own class. Investigate the use of JSON schema
        // to validate these configs.
        if (typeof config.apiKey !== 'string') {
          throw new Error('Missing required `apiKey`. Type must be {string}');
        }

        if (typeof config.experienceKey !== 'string') {
          throw new Error('Missing required `experienceKey`. Type must be {string}');
        }
      }
      /**
       * Register a custom component type so it can be created via
       * addComponent and used as a child component
       * @param {Component} componentClass
       */

    }, {
      key: "registerComponentType",
      value: function registerComponentType(componentClass) {
        this.components.register(componentClass);
      }
    }, {
      key: "addComponent",
      value: function addComponent(type, opts) {
        if (typeof opts === 'string') {
          opts = {
            container: opts
          };
        }

        try {
          this.components.create(type, opts).mount();
        } catch (e) {
          throw new AnswersComponentError('Failed to add component', type, e);
        }

        return this;
      }
      /**
       * Remove the component - and all of its children - with the given name
       * @param {string} name The name of the component to remove
       */

    }, {
      key: "removeComponent",
      value: function removeComponent(name) {
        this.components.removeByName(name);
      }
    }, {
      key: "createComponent",
      value: function createComponent(opts) {
        return this.components.create('Component', opts).mount();
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this.renderer.registerHelper(name, cb);
        return this;
      }
      /**
       * Opt in or out of convertion tracking analytics
       * @param {boolean} optIn
       */

    }, {
      key: "setConversionsOptIn",
      value: function setConversionsOptIn(optIn) {
        if (this._eligibleForAnalytics) {
          this._analyticsReporterService.setConversionTrackingEnabled(optIn);
        }
      }
      /**
       * Opt in or out of session cookies
       * @param {boolean} optIn
       */

    }, {
      key: "setSessionsOptIn",
      value: function setSessionsOptIn(optIn) {
        this.core.globalStorage.set(StorageKeys.SESSIONS_OPT_IN, optIn);
      }
      /**
       * Sets a search query on initialization for vertical searchers that have a
       * defaultInitialSearch provided, if the user hasn't already provided their
       * own via URL param.
       * @param {SearchConfig} searchConfig
       * @private
       */

    }, {
      key: "_setDefaultInitialSearch",
      value: function _setDefaultInitialSearch(searchConfig) {
        if (searchConfig.defaultInitialSearch == null || !searchConfig.verticalKey) {
          return;
        }

        var prepopulatedQuery = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (prepopulatedQuery != null) {
          return;
        }

        this.core.globalStorage.set('queryTrigger', 'initialize');
        this.core.setQuery(searchConfig.defaultInitialSearch);
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return Answers;
  }();
  /**
   * @param {Object} config
   * @param {GlobalStorage} globalStorage
   * @returns {Services}
   */


  function getServices(config, globalStorage) {
    return {
      searchService: new SearchApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }),
      autoCompleteService: new AutoCompleteApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }, globalStorage),
      questionAnswerService: new QuestionAnswerApi({
        apiKey: config.apiKey,
        environment: config.environment
      }, globalStorage),
      errorReporterService: new ErrorReporter({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        printVerbose: config.debug,
        sendToServer: !config.suppressErrorReports,
        environment: config.environment
      }, globalStorage)
    };
  }
  /**
   * @returns {Services}
   */


  function getMockServices() {
    return {
      searchService: new MockSearchService(),
      autoCompleteService: new MockAutoCompleteService(),
      questionAnswerService: new MockQuestionAnswerService(),
      errorReporterService: new ConsoleErrorReporter()
    };
  }
  /**
   * Initialize the scroll event listener to send analytics events
   * when the user scrolls to the bottom. Debounces scroll events so
   * they are processed after the user stops scrolling
   */


  function initScrollListener(reporter) {
    var DEBOUNCE_TIME = 100;
    var timeout = null;

    var sendEvent = function sendEvent() {
      if (window.innerHeight + window.pageYOffset >= document.body.scrollHeight) {
        var event = new AnalyticsEvent('SCROLL_TO_BOTTOM_OF_PAGE');
        reporter.report(event);
      }
    };

    document.addEventListener('scroll', function () {
      clearTimeout(timeout);
      timeout = setTimeout(sendEvent, DEBOUNCE_TIME);
    });
  }

  var ANSWERS = new Answers();

  return ANSWERS;

}));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5zd2Vycy11bWQuanMiLCJzb3VyY2VzIjpbInNyYy9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3Jlc3VsdC5qcyIsInNyYy9jb3JlL21vZGVscy9oaWdobGlnaHRlZHZhbHVlLmpzIiwic3JjL2NvcmUvZXJyb3JzL2Vycm9ycy5qcyIsInNyYy9jb3JlL21vZGVscy9yZXN1bHRmYWN0b3J5LmpzIiwic3JjL2NvcmUvbW9kZWxzL3NlY3Rpb24uanMiLCJzcmMvY29yZS9tb2RlbHMvdW5pdmVyc2FscmVzdWx0cy5qcyIsInNyYy9jb3JlL21vZGVscy9kaXJlY3RhbnN3ZXIuanMiLCJzcmMvY29yZS9tb2RlbHMvbmF2aWdhdGlvbi5qcyIsInNyYy9jb3JlL3N0b3JhZ2UvcmVzdWx0c2NvbnRleHQuanMiLCJzcmMvY29yZS9tb2RlbHMvdmVydGljYWxyZXN1bHRzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3NwZWxsY2hlY2suanMiLCJzcmMvY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzLmpzIiwic3JjL2NvcmUvbW9kZWxzL2R5bmFtaWNmaWx0ZXJzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3NlYXJjaGludGVudHMuanMiLCJzcmMvY29yZS9tb2RlbHMvbG9jYXRpb25iaWFzLmpzIiwic3JjL2NvcmUvbW9kZWxzL2FsdGVybmF0aXZldmVydGljYWxzLmpzIiwic3JjL2NvcmUvc2VhcmNoL3NlYXJjaGRhdGF0cmFuc2Zvcm1lci5qcyIsInNyYy9jb3JlL21vZGVscy9xdWVzdGlvbnN1Ym1pc3Npb24uanMiLCJzcmMvY29yZS9tb2RlbHMvZmlsdGVyLmpzIiwic3JjL2NvcmUvY29yZS5qcyIsInNyYy91aS9kb20vZG9tLmpzIiwic3JjL3VpL2RvbS9zZWFyY2hwYXJhbXMuanMiLCJzcmMvdWkvcmVuZGVyaW5nL3JlbmRlcmVyLmpzIiwic3JjL3VpL2ljb25zL2ljb24uanMiLCJzcmMvdWkvaWNvbnMvdGh1bWIuanMiLCJzcmMvdWkvaWNvbnMvcmVjZWlwdC5qcyIsInNyYy91aS9pY29ucy9wYW50aGVvbi5qcyIsInNyYy91aS9pY29ucy9taWMuanMiLCJzcmMvdWkvaWNvbnMvZGlyZWN0aW9ucy5qcyIsInNyYy91aS9pY29ucy9jYWxlbmRhci5qcyIsInNyYy91aS9pY29ucy9jYWxsb3V0LmpzIiwic3JjL3VpL2ljb25zL2luZm8uanMiLCJzcmMvdWkvaWNvbnMvYnJpZWZjYXNlLmpzIiwic3JjL3VpL2ljb25zL2thYm9iLmpzIiwic3JjL3VpL2ljb25zL3BlcnNvbi5qcyIsInNyYy91aS9pY29ucy9tYWduaWZ5aW5nX2dsYXNzLmpzIiwic3JjL3VpL2ljb25zL29mZmljZS5qcyIsInNyYy91aS9pY29ucy9saW5rLmpzIiwic3JjL3VpL2ljb25zL3dpbmRvdy5qcyIsInNyYy91aS9pY29ucy9waG9uZS5qcyIsInNyYy91aS9pY29ucy90YWcuanMiLCJzcmMvdWkvaWNvbnMvZG9jdW1lbnQuanMiLCJzcmMvdWkvaWNvbnMvY2hldnJvbi5qcyIsInNyYy91aS9pY29ucy9zdXBwb3J0LmpzIiwic3JjL3VpL2ljb25zL3lleHQuanMiLCJzcmMvdWkvaWNvbnMvcGluLmpzIiwic3JjL3VpL2ljb25zL2dlYXIuanMiLCJzcmMvdWkvaWNvbnMvbGlnaHRfYnVsYi5qcyIsInNyYy91aS9pY29ucy9zdGFyLmpzIiwic3JjL3VpL2ljb25zL2Nsb3NlLmpzIiwic3JjL3VpL2ljb25zL2VsZW1lbnRzLmpzIiwic3JjL3VpL2ljb25zL3lleHRfYW5pbWF0ZWRfcmV2ZXJzZS5qcyIsInNyYy91aS9pY29ucy95ZXh0X2FuaW1hdGVkX2ZvcndhcmQuanMiLCJzcmMvdWkvaWNvbnMvaW5kZXguanMiLCJzcmMvdWkvcmVuZGVyaW5nL2hhbmRsZWJhcnNyZW5kZXJlci5qcyIsInNyYy91aS9yZW5kZXJpbmcvY29uc3QuanMiLCJzcmMvY29yZS9jb25zdGFudHMuanMiLCJzcmMvdWkvcmVuZGVyaW5nL2RlZmF1bHR0ZW1wbGF0ZXNsb2FkZXIuanMiLCJzcmMvdWkvaW5kZXguanMiLCJzcmMvY29yZS9ldmVudGVtaXR0ZXIvZXZlbnRlbWl0dGVyLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwic3JjL2NvcmUvaHR0cC9odHRwcmVxdWVzdGVyLmpzIiwic3JjL2NvcmUvdXRpbHMvdXJsdXRpbHMuanMiLCJzcmMvY29yZS9odHRwL2FwaXJlcXVlc3QuanMiLCJzcmMvY29yZS9zZWFyY2gvc2VhcmNoYXBpLmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50LmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc3JlcG9ydGVyLmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL25vb3BhbmFseXRpY3NyZXBvcnRlci5qcyIsInNyYy9jb3JlL3N0b3JhZ2UvbW9kdWxlZGF0YS5qcyIsInNyYy9jb3JlL3N0b3JhZ2UvZ2xvYmFsc3RvcmFnZS5qcyIsInNyYy9jb3JlL2luZGV4LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY29tcG9uZW50LmpzIiwic3JjL2NvcmUvZXJyb3JzL2Vycm9ycmVwb3J0ZXIuanMiLCJzcmMvY29yZS9lcnJvcnMvY29uc29sZWVycm9ycmVwb3J0ZXIuanMiLCJzcmMvdWkvc3RvcmFnZS9wZXJzaXN0ZW50c3RvcmFnZS5qcyIsInNyYy9jb3JlL21vZGVscy9zZWFyY2hjb25maWcuanMiLCJzcmMvY29yZS9tb2RlbHMvYXV0b2NvbXBsZXRlZGF0YS5qcyIsInNyYy9jb3JlL3NlYXJjaC9hdXRvY29tcGxldGVkYXRhdHJhbnNmb3JtZXIuanMiLCJzcmMvY29yZS9zZWFyY2gvYXV0b2NvbXBsZXRlYXBpLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2thdXRvY29tcGxldGVzZXJ2aWNlLmpzIiwic3JjL2NvcmUvc2VhcmNoL3F1ZXN0aW9uYW5zd2VyYXBpLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2txdWVzdGlvbmFuc3dlcnNlcnZpY2UuanMiLCJzcmMvY29yZS9zZWFyY2gvbW9ja3NlYXJjaHNlcnZpY2UuanMiLCJzcmMvdWkvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvc2VhcmNoY29tcG9uZW50LmpzIiwic3JjL3VpL3Rvb2xzL3NlYXJjaHBhcmFtc3BhcnNlci5qcyIsInNyYy91aS9jb21wb25lbnRzL3NlYXJjaC9maWx0ZXJzZWFyY2hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvYXV0b2NvbXBsZXRlY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL3NwZWxsY2hlY2tjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvbG9jYXRpb25iaWFzY29tcG9uZW50LmpzIiwic3JjL2NvcmUvbW9kZWxzL2ZhY2V0LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXJib3hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlcm9wdGlvbnNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL3JhbmdlZmlsdGVyY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9kYXRlcmFuZ2VmaWx0ZXJjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZhY2V0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ZpbHRlcnMvZ2VvbG9jYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL3NvcnRvcHRpb25zY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9kaXJlY3RhbnN3ZXJjb21wb25lbnQuanMiLCJzcmMvY29yZS9tb2RlbHMvYWx0ZXJuYXRpdmV2ZXJ0aWNhbC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvYWx0ZXJuYXRpdmV2ZXJ0aWNhbHNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvcHJvdmlkZXJzL21hcHByb3ZpZGVyLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbWFwL3Byb3ZpZGVycy9nb29nbGVtYXBwcm92aWRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL21hcC9wcm92aWRlcnMvbWFwYm94bWFwcHJvdmlkZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvbWFwY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY2FyZHMvY29uc3RzLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY2FyZHMvY2FyZGNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvcmVzdWx0c2hlYWRlcmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvdmVydGljYWxyZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9hY2NvcmRpb25yZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy91bml2ZXJzYWxyZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9wYWdpbmF0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY3Rhcy9jdGFjb2xsZWN0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY2FyZHMvc3RhbmRhcmRjYXJkY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY2FyZHMvYWNjb3JkaW9uY2FyZGNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2NhcmRzL2xlZ2FjeWNhcmRjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9xdWVzdGlvbnMvcXVlc3Rpb25zdWJtaXNzaW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvaWNvbnMvaWNvbmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2N0YXMvY3RhY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVnaXN0cnkuanMiLCJzcmMvdWkvY29tcG9uZW50cy9jb21wb25lbnRtYW5hZ2VyLmpzIiwic3JjL2NvcmUvbW9kZWxzL3ZlcnRpY2FscGFnZXNjb25maWcuanMiLCJzcmMvYW5zd2Vycy11bWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgU2VhcmNoU3RhdGVzICovXG5cbi8qKlxuICogU2VhcmNoU3RhdGVzIGlzIGFuIEVOVU0gZm9yIHRoZSB2YXJpb3VzIHN0YWdlcyBvZiBzZWFyY2hpbmcsXG4gKiB1c2VkIHRvIHNob3cgZGlmZmVyZW50IHRlbXBsYXRlc1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQUkVfU0VBUkNIOiAncHJlLXNlYXJjaCcsXG4gIFNFQVJDSF9MT0FESU5HOiAnc2VhcmNoLWxvYWRpbmcnLFxuICBTRUFSQ0hfQ09NUExFVEU6ICdzZWFyY2gtY29tcGxldGUnXG59O1xuIiwiLyoqIEBtb2R1bGUgUmVzdWx0ICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHByb2ZpbGUgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yYXcgPSBkYXRhLnJhdyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBwcm9maWxlIGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZm9ybWF0dGVkID0gZGF0YS5mb3JtYXR0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaGxpZ2h0ZWQgcHJvZmlsZSBkYXRhIHdpdGggaGlnaGxpZ2h0cyBhcHBsaWVkIHRvIGFwcGxpY2FibGUgZmllbGRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hpZ2hsaWdodGVkID0gZGF0YS5oaWdobGlnaHRlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBudW1iZXIgb2YgdGhlIHJlc3VsdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmRpbmFsID0gZGF0YS5vcmRpbmFsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBvZiB0aGUgZGV0YWlscyBzZWN0aW9uIG9mIHRoZSByZXN1bHQgY2FyZCwgY2FuIGNvbnRhaW4gSFRNTFxuICAgICAqIEB0eXBlIHtzdHJpbmd8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzdGluYXRpb24gbGluayBmb3IgdGhlIHRpdGxlIG9mIHRoZSByZXN1bHQgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmsgPSBkYXRhLmxpbmsgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBFbnRpdHkgSUQsIG9yIG90aGVyIHVuaXF1ZSBpZGVudGlmaWVyLCB1c2VkIGZvciB0byBwb3dlciBpbnRlcmFjdGl2aXR5XG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VidGl0bGUgb24gdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3VidGl0bGUgPSBkYXRhLnN1YnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgbW9kaWZpZXIsIHVzdWFsbHkgZGVyaXZlZCBmcm9tIHRoZSB2ZXJ0aWNhbCBjb25maWd1cmF0aW9uIElEXG4gICAgICogVXNlZCB0byBhcHBseSBkaWZmZXJlbnQgc3R5bGluZyB0byBkaWZmZXJlbnQgcmVzdWx0IGNhcmQgdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tb2RpZmllciA9IGRhdGEubW9kaWZpZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbGFyZ2UgZGF0ZSwgb2YgdGhlIGZvcm1hdCB7IG1vbnRoOiAnSmFuJywgZGF5OiAnMDEnIH1cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iaWdEYXRlID0gZGF0YS5iaWdEYXRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbWFnZSBwcm9maWxlIG9iamVjdCwgZXhwZWN0ZWQgdG8gaGF2ZSBhIHVybCBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gZGF0YS5pbWFnZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2FsbHMgdG8gYWN0aW9uLCBvZiB0aGUgZm9ybWF0OlxuICAgICAqIHsgaWNvbjogJycsIHVybDogJycsIHRleHQ6ICcnLCBldmVudFR5cGU6ICcnLCBldmVudE9wdGlvbnM6IHt9fVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSBkYXRhLmNhbGxzVG9BY3Rpb24gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGFjY29yZGlhbiByZXN1bHQgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzZWQgPSBkYXRhLmNvbGxhcHNlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGRhdGEuY29sbGFwc2VkO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIaWdobGlnaHRlZFZhbHVlICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgaGlnaGxpZ2h0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpZ2hsaWdodGVkVmFsdWUge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWUgfHwgZGF0YS5zaG9ydFZhbHVlIHx8ICcnO1xuICAgIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MgPSBkYXRhLm1hdGNoZWRTdWJzdHJpbmdzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCAoKSB7XG4gICAgdGhpcy5fc29ydE1hdGNoZWRTdWJzdHJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRIaWdobGlnaHRlZFZhbHVlKHRoaXMudmFsdWUsIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBpbnZlcnRlZCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEludmVydGVkICgpIHtcbiAgICB0aGlzLl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MoKTtcbiAgICBjb25zdCBpbnZlcnRlZFN1YnN0cmluZ3MgPSB0aGlzLl9nZXRJbnZlcnRlZFN1YnN0cmluZ3ModGhpcy5tYXRjaGVkU3Vic3RyaW5ncywgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZSh0aGlzLnZhbHVlLCBpbnZlcnRlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGludHJvZHVjZXMgaGlnaGxpZ2h0aW5nIHRvIGlucHV0IGRhdGEgYWNjb3JkaW5nIHRvIGhpZ2hsaWdodGluZyBzcGVjaWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgaW5wdXQgb2JqZWN0IHRvIGFwcGx5IGhpZ2hsaWdodGluZyB0b1xuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnQVRNJyxcbiAgICogICAgZmVhdHVyZWRNZXNzYWdlOiB7XG4gICAqICAgICAgZGVzY3JpcHRpb246ICdTYXZlIHRpbWUgJiBiYW5rIG9uIHlvdXIgdGVybXMgYXQgb3ZlciAxLDgwMCBBVE1zJ1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZFN1YnN0cmluZ3MgaGlnaGxpZ2h0aW5nIHNwZWNpZmllcnMgdG8gYXBwbHkgdG8gaW5wdXQgb2JqZWN0XG4gICAqXG4gICAqICBleGFtcGxlIG9iamVjdCA6XG4gICAqICB7XG4gICAqICAgIG5hbWU6IHtcbiAgICogICAgICBtYXRjaGVkU3Vic3RyaW5nczogW3tcbiAgICogICAgICAgIGxlbmd0aDogMyxcbiAgICogICAgICAgIG9mZnNldDogMFxuICAgKiAgICAgIH1dLFxuICAgKiAgICAgIHZhbHVlOiAnQVRNJ1xuICAgKiAgICB9LFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjoge1xuICAgKiAgICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAqICAgICAgICAgIGxlbmd0aDogNCxcbiAgICogICAgICAgICAgb2Zmc2V0OiA0NVxuICAgKiAgICAgICAgfV0sXG4gICAqICAgICAgICB2YWx1ZTogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIEFUTXMnXG4gICAqICAgICAgfVxuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvcHkgb2YgaW5wdXQgdmFsdWUgd2l0aCBoaWdobGlnaHRpbmcgYXBwbGllZFxuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnPHN0cm9uZz5BVE08L3N0cm9uZz4nLFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIDxzdHJvbmc+QVRNczwvc3Ryb25nPidcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKi9cbiAgYnVpbGRIaWdobGlnaHRlZFZhbHVlICh2YWwsIGhpZ2hsaWdodGVkU3Vic3RyaW5ncykge1xuICAgIGxldCBoaWdobGlnaHRlZFZhbHVlID0gJyc7XG4gICAgbGV0IG5leHRTdGFydCA9IDA7XG5cbiAgICBpZiAoaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IHN0YXJ0ID0gTnVtYmVyKGhpZ2hsaWdodGVkU3Vic3RyaW5nc1tqXS5vZmZzZXQpO1xuICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzW2pdLmxlbmd0aDtcblxuICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSBbdmFsLnNsaWNlKG5leHRTdGFydCwgc3RhcnQpLCAnPHN0cm9uZz4nLCB2YWwuc2xpY2Uoc3RhcnQsIGVuZCksICc8L3N0cm9uZz4nXS5qb2luKCcnKTtcblxuICAgICAgaWYgKGogPT09IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGggLSAxICYmIGVuZCA8IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSB2YWwuc2xpY2UoZW5kKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBoaWdobGlnaHRlZFZhbHVlO1xuICB9XG5cbiAgX3NvcnRNYXRjaGVkU3Vic3RyaW5ncyAoKSB7XG4gICAgdGhpcy5tYXRjaGVkU3Vic3RyaW5ncy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5vZmZzZXQgPCBiLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLm9mZnNldCA+IGIub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRJbnZlcnRlZFN1YnN0cmluZ3MgKG1hdGNoZWRTdWJzdHJpbmdzLCB2YWx1ZUxlbmd0aCkge1xuICAgIGNvbnN0IGludmVydGVkU3Vic3RyaW5ncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1YnN0cmluZyA9IG1hdGNoZWRTdWJzdHJpbmdzW2ldO1xuICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHN1YnN0cmluZy5vZmZzZXQgKyBzdWJzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGkgPT09IDAgJiYgc3Vic3RyaW5nLm9mZnNldCAhPT0gMCkge1xuICAgICAgICBpbnZlcnRlZFN1YnN0cmluZ3MucHVzaCh7IG9mZnNldDogMCwgbGVuZ3RoOiBzdWJzdHJpbmcub2Zmc2V0IH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVMZW5ndGggPiBuZXh0T2Zmc2V0KSB7XG4gICAgICAgIGludmVydGVkU3Vic3RyaW5ncy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IG5leHRPZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoIC0gMVxuICAgICAgICAgICAgPyBtYXRjaGVkU3Vic3RyaW5nc1tpICsgMV0ub2Zmc2V0IC0gbmV4dE9mZnNldFxuICAgICAgICAgICAgOiB2YWx1ZUxlbmd0aCAtIG5leHRPZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFN1YnN0cmluZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEVycm9ycyAqL1xuXG4vKipcbiAqIEFuc3dlcnNCYXNlRXJyb3IgaXMgYW4gZXh0ZW5zaW9uIG9mIHRoZSBiYXNlIEVycm9yIG9iamVjdC5cbiAqIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gd2hlbiByZXBvcnRpbmcgdG8gdGhlIHNlcnZlci5cbiAqIEBleHRlbmRzIEVycm9yXG4gKlxuICogRXJyb3IgY29kZXMgZmFsbCBpbnRvIG9uZSBvZiBmb3VyIGNhdGVnb3JpZXM6XG4gKiAxWFggZXJyb3JzOiBCYXNpYyBlcnJvcnNcbiAqIDJYWCBlcnJvcnM6IFVJIGVycm9yc1xuICogM1hYIGVycm9yczogRW5kcG9pbnQgZXJyb3JzXG4gKiA0WFggZXJyb3JzOiBDb3JlIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0Jhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycm9yQ29kZSwgbWVzc2FnZSwgYm91bmRhcnkgPSAndW5rbm93bicsIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnJlcG9ydGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2F1c2VkQnkpIHtcbiAgICAgIHRoaXMuY2F1c2VkQnkgPSBjYXVzZWRCeSBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3JcbiAgICAgICAgPyBjYXVzZWRCeVxuICAgICAgICA6IEFuc3dlcnNCYXNlRXJyb3IuZnJvbShjYXVzZWRCeSk7XG4gICAgICB0aGlzLnN0YWNrID0gYCR7dGhpcy5zdGFja31cXG5DYXVzZWQgQnk6ICR7dGhpcy5jYXVzZWRCeS5zdGFja31gO1xuICAgIH1cbiAgfVxuXG4gIHRvSnNvbiAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHJpbmcgPSBgJHt0aGlzLmVycm9yTWVzc2FnZX0gKCR7dGhpcy5ib3VuZGFyeX0pYDtcbiAgICBpZiAodGhpcy5jYXVzZWRCeSkge1xuICAgICAgc3RyaW5nICs9IGBcXG4gIENhdXNlZCBCeTogJHt0aGlzLmNhdXNlZEJ5LnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChidWlsdGluRXJyb3IsIGJvdW5kYXJ5KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoYnVpbHRpbkVycm9yLm1lc3NhZ2UsIGJvdW5kYXJ5KTtcbiAgICBlcnJvci5zdGFjayA9IGJ1aWx0aW5FcnJvci5zdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzQmFzaWNFcnJvciBpcyBhIHdyYXBwZXIgYXJvdW5kIGFsbCB0aGUgYnVpbHQtaW4gZXJyb3JzXG4gKiBlLmcuIHVuZGVmaW5lZCB2YXJpYWJsZXMsIGluY29ycmVjdCBzeW50YXgsIHR5cGVzLCBtaXNzaW5nIG1ldGhvZHMsIGV0Yy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNCYXNpY0Vycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigxMDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzVWlFcnJvciB1c2VkIGZvciB0aGluZ3MgbGlrZSBET00gZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0NvbmZpZ0Vycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigxMDEsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzVWlFcnJvciB1c2VkIGZvciB0aGluZ3MgbGlrZSBET00gZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc1VpRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDIwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNDb21wb25lbnRFcnJvciBpcyB1c2VkIGZvciBDb21wb25lbnQgb3JpZW50ZWQgZXJyb3JzXG4gKiBlLmcuIGZhaWx1cmUgdG8gcmVuZGVyLCBvciBjYXRjaGluZyB1bmtub3ducy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNDb21wb25lbnRFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29tcG9uZW50LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDIwMSwgbWVzc2FnZSwgY29tcG9uZW50LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzRW5kcG9pbnRFcnJvciByZXByZXNlbnRzIGFsbCBuZXR3b3JrIHJlbGF0ZWQgZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0VuZHBvaW50RXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDMwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNDb3JlRXJyb3IgcmVwcmVzZW50cyBlcnJvcnMgZm9yIHByZWNvbmRpdGlvbiBmYWlsdXJlcyBpbiB0aGUgY29yZSBsaWJyYXJ5XG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQ29yZUVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcig0MDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzU3RvcmFnZUVycm9yIHJlcHJlc2VudHMgc3RvcmFnZSByZWxhdGVkIGVycm9yc1xuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc1N0b3JhZ2VFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RvcmFnZUtleSwgZGF0YSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcig0MDEsIG1lc3NhZ2UsICdTdG9yYWdlJywgY2F1c2VkQnkpO1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNBbmFseXRpY3NFcnJvciBpcyB1c2VkIGZvciBlcnJvcnMgd2hlbiByZXBvcnRpbmcgYW5hbHl0aWNzXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGV2ZW50LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDQwMiwgbWVzc2FnZSwgJ0FuYWx5dGljcycsIGNhdXNlZEJ5KTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdEZhY3RvcnkgKi9cblxuaW1wb3J0IFJlc3VsdCBmcm9tICcuL3Jlc3VsdCc7XG5pbXBvcnQgSGlnaGxpZ2h0ZWRWYWx1ZSBmcm9tICcuL2hpZ2hsaWdodGVkdmFsdWUnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvcmVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN1bHRGYWN0b3J5IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSBSZXN1bHQgdmlldyBtb2RlbC5cbiAgICogSW5jbHVkZXMgZGVmYXVsdCBtYXBwaW5ncyBvZiBHb29nbGVDdXN0b21TZWFyY2hFbmdpbmUgcmVzdWx0cyB0b1xuICAgKiB0aGUgZmllbGRzIGV4cG9zZWQgYnkgdGhlIHRlbXBsYXRlLlxuICAgKiBAcGFyYW0gcmVzdWx0c0RhdGEgIHtBcnJheX0gZXhwZWN0ZWQgZm9ybWF0OiB7IGRhdGE6IHsgLi4uIH0sIGhpZ2hsaWdodGVkRmllbGRzOiB7IC4uLiB9fVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZvcm1hdHRlcnMgdG8gYXBwbHkgdG8gdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxJZCBUaGUgdmVydGljYWwgb2YgdGhlc2UgcmVzdWx0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIEJhY2tlbmQgc291cmNlIG9mIHRoZXNlIHJlc3VsdHNcbiAgICogQHJldHVybnMge1Jlc3VsdFtdfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3VsdHNEYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBzb3VyY2UpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHJlc3VsdHNEYXRhW2ldLmRhdGEgfHwgcmVzdWx0c0RhdGFbaV07XG5cbiAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgJ0dPT0dMRV9DU0UnOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21Hb29nbGVDdXN0b21TZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCSU5HX0NTRSc6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUJpbmdDdXN0b21TZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaRU5ERVNLJzpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tWmVuZGVza1NlYXJjaEVuZ2luZShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FMR09MSUEnOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21BbGdvbGlhU2VhcmNoRW5naW5lKGRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS05PV0xFREdFX01BTkFHRVInOlxuICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodGVkRmllbGRzID0gcmVzdWx0c0RhdGFbaV0uaGlnaGxpZ2h0ZWRGaWVsZHMgfHwge307XG5cbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tS25vd2xlZGdlTWFuYWdlcihcbiAgICAgICAgICAgIGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRmllbGRzLCBpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUdlbmVyaWMoZGF0YSwgaSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZmllbGQgZm9ybWF0dGVycyB0byBLbm93bGVkZ2UgTWFuYWdlciBFbnRpdHkgUHJvZmlsZSBEYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlQcm9maWxlRGF0YSBFbnRpdHkgUHJvZmlsZSBEYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXR0ZXJzIERldmVsb3BlciBzcGVjaWZpZWQgRmllbGQgRm9ybWF0dGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxJZCBJZGVudGlmaWVyIGZvciBWZXJ0aWNhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSBTdWJzZXQgb2YgRW50aXR5IFByb2ZpbGUgRGF0YSB3aXRoIGhpZ2hsaWdodGluZyBhcHBsaWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFN1YnNldCBvZiBFbnRpdHkgUHJvZmlsZSBEYXRhIEZpZWxkcyB3aXRoIGZpZWxkIGZvcm1hdHRlcnMgYXBwbGllZFxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVGb3JtYXR0ZWREYXRhIChlbnRpdHlQcm9maWxlRGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSkge1xuICAgIC8vIGlmIG5vIGZpZWxkIGZvcm1hdHRlcnMgc3BlY2lmaWVkLCBub3RoaW5nIHRvIGZvcm1hdFxuICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXR0ZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZWREYXRhID0ge307XG5cbiAgICBPYmplY3QuZW50cmllcyhlbnRpdHlQcm9maWxlRGF0YSkuZm9yRWFjaCgoW2ZpZWxkTmFtZSwgZmllbGRWYWxdKSA9PiB7XG4gICAgICAvLyBjaGVjayBpZiBhIGZpZWxkIGZvcm1hdHRlciBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGVudGl0eSBwcm9maWxlIGZpZWxkXG4gICAgICBpZiAoZm9ybWF0dGVyc1tmaWVsZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdmVyaWZ5IHRoZSBmaWVsZCBmb3JtYXR0ZXIgcHJvdmlkZWQgaXMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gYXMgZXhwZWN0ZWRcbiAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyc1tmaWVsZE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29yZUVycm9yKCdGaWVsZCBmb3JtYXR0ZXIgaXMgbm90IG9mIGV4cGVjdGVkIHR5cGUgZnVuY3Rpb24nLCAnUmVzdWx0RmFjdG9yeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBoaWdobGlnaHRlZCB2ZXJzaW9uIG9mIGZpZWxkIHZhbHVlIGlzIGF2YWlsYWJsZSwgbWFrZSBpdCBhdmFpbGFibGUgdG8gZmllbGQgZm9ybWF0dGVyXG4gICAgICBsZXQgaGlnaGxpZ2h0ZWRGaWVsZFZhbCA9IG51bGw7XG4gICAgICBpZiAoaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSAmJiBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZFZhbCA9IGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGFbZmllbGROYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCBmb3JtYXR0ZXIgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBmaWVsZCBuYW1lXG4gICAgICAvLyB0aGUgaW5wdXQgb2JqZWN0IGRlZmluZXMgdGhlIGludGVyZmFjZSB0aGF0IGZpZWxkIGZvcm1hdHRlciBmdW5jdGlvbnMgd29yayB3aXRoXG4gICAgICBmb3JtYXR0ZWREYXRhW2ZpZWxkTmFtZV0gPSBmb3JtYXR0ZXJzW2ZpZWxkTmFtZV0oe1xuICAgICAgICBlbnRpdHlQcm9maWxlRGF0YTogZW50aXR5UHJvZmlsZURhdGEsXG4gICAgICAgIGVudGl0eUZpZWxkVmFsdWU6IGZpZWxkVmFsLFxuICAgICAgICBoaWdobGlnaHRlZEVudGl0eUZpZWxkVmFsdWU6IGhpZ2hsaWdodGVkRmllbGRWYWwsXG4gICAgICAgIHZlcnRpY2FsSWQ6IHZlcnRpY2FsSWQsXG4gICAgICAgIGlzRGlyZWN0QW5zd2VyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBzdWJzdHJpbmdzIHdpdGhpbiBLbm93bGVkZ2UgTWFuYWdlciBFbnRpdHkgRmllbGQgVmFsdWVzXG4gICAqIGFjY29yZGluZyB0byBoaWdobGlnaHRpbmcgc3BlY2lmaWVycyByZXR1cm5lZCBmcm9tIHRoZSBLbm93bGVkZ2UgTWFuYWdlciBTZWFyY2ggQmFja2VuZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5UHJvZmlsZURhdGEgRW50aXR5IFByb2ZpbGUgRGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRGaWVsZHMgS00gc3BlY2lmaWVkIGhpZ2hsaWdodGluZyBpbnN0cnVjdGlvbnMgdG8gaGlnaGxpZ2h0IGNlcnRhaW4gRmllbGRzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFN1YnNldCBvZiBFbnRpdHkgUHJvZmlsZSBEYXRhIEZpZWxkcyB3aXRoIGhpZ2hsaWdodGluZyBhcHBsaWVkXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUhpZ2hsaWdodGVkRGF0YSAoZW50aXR5UHJvZmlsZURhdGEsIGhpZ2hsaWdodGVkRmllbGRzKSB7XG4gICAgLy8gaWYgbm8gaGlnaGxpZ2h0ZWQgZmllbGRzIHNwZWNpZmllZCwgbm90aGluZyB0byBoaWdobGlnaHRcbiAgICBpZiAoT2JqZWN0LmtleXMoaGlnaGxpZ2h0ZWRGaWVsZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0YSA9IHt9O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVudGl0eSBmaWVsZHMgdGhhdCBoYXZlIGhpZ2hsaWdodGluZyBpbnN0cnVjdGlvbnNcbiAgICBPYmplY3QuZW50cmllcyhoaWdobGlnaHRlZEZpZWxkcykuZm9yRWFjaCgoW2hpZ2hsaWdodGVkRmllbGROYW1lXSkgPT4ge1xuICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGhpZ2hsaWdodGVkIGZpZWxkIG5hbWUgY29ycmVzcG9uZHMgdG8gYW4gZXhpc3RpbmcgZW50aXR5IHByb2ZpbGUgZmllbGRcbiAgICAgIGlmIChlbnRpdHlQcm9maWxlRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignSGlnaGxpZ2h0ZWQgRmllbGQgTmFtZSBkb2VzIG5vdCBleGlzdCBpbiBFbnRpdHkgUHJvZmlsZScsICdSZXN1bHRGYWN0b3J5Jyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBoaWdobGlnaHRlZEZpZWxkID0gaGlnaGxpZ2h0ZWRGaWVsZHNbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdO1xuXG4gICAgICAvLyBjaGVjayBmb3IgbmVzdGVkIGZpZWxkc1xuICAgICAgaWYgKHR5cGVvZiBoaWdobGlnaHRlZEZpZWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5rZXlzKGhpZ2hsaWdodGVkRmllbGQpLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkWydtYXRjaGVkU3Vic3RyaW5ncyddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVjdXJzZSB0byBjaGlsZHJlbiBmaWVsZHNcbiAgICAgICAgaGlnaGxpZ2h0ZWREYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSA9IFJlc3VsdEZhY3RvcnkuY29tcHV0ZUhpZ2hsaWdodGVkRGF0YShcbiAgICAgICAgICBlbnRpdHlQcm9maWxlRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0sXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZHNbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBoaWdobGlnaHRlZERhdGFWYWx1ZSA9IG5ldyBIaWdobGlnaHRlZFZhbHVlKGVudGl0eVByb2ZpbGVEYXRhKS5idWlsZEhpZ2hsaWdodGVkVmFsdWUoXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZC52YWx1ZSxcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkLm1hdGNoZWRTdWJzdHJpbmdzKTtcbiAgICAgICAgaGlnaGxpZ2h0ZWREYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSA9IGhpZ2hsaWdodGVkRGF0YVZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgZ2VuZXJpYyByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUdlbmVyaWMgKGRhdGEsIGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEubmFtZSxcbiAgICAgIGRldGFpbHM6IHRoaXMudHJ1bmNhdGUoZGF0YS5kZXNjcmlwdGlvbiksXG4gICAgICBsaW5rOiBkYXRhLndlYnNpdGUsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIG9yZGluYWw6IGluZGV4ICsgMVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSBLbm93bGVkZ2UgTWFuYWdlciByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdHRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsSWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZ2hsaWdodGVkRmllbGRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Lbm93bGVkZ2VNYW5hZ2VyIChkYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBoaWdobGlnaHRlZEZpZWxkcywgaW5kZXgpIHtcbiAgICAvLyBjb21wdXRlIGhpZ2hsaWdodGVkIGVudGl0eSBwcm9maWxlIGRhdGFcbiAgICBsZXQgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSA9IFJlc3VsdEZhY3RvcnkuY29tcHV0ZUhpZ2hsaWdodGVkRGF0YShkYXRhLCBoaWdobGlnaHRlZEZpZWxkcyk7XG4gICAgLy8gY29tcHV0ZSBmb3JtYXR0ZWQgZW50aXR5IHByb2ZpbGUgZGF0YVxuICAgIGNvbnN0IGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhID0gUmVzdWx0RmFjdG9yeS5jb21wdXRlRm9ybWF0dGVkRGF0YShcbiAgICAgIGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEpO1xuXG4gICAgLy8gc2V0IHJlc3VsdCBkZXRhaWxzIGNoZWNraW5nIHRoZSBmb2xsb3dpbmcgaW4gb3JkZXIgb2YgcHJpb3JpdHkgOiBmb3JtYXR0ZWQsIGhpZ2hsaWdodGVkLCByYXdcbiAgICBsZXQgcmVzdWx0RGV0YWlscyA9IG51bGw7XG4gICAgaWYgKGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdERldGFpbHMgPSBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0RGV0YWlscyA9IHRoaXMudHJ1bmNhdGUoaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdERldGFpbHMgPSB0aGlzLnRydW5jYXRlKGRhdGEuZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEsXG4gICAgICBoaWdobGlnaHRlZDogaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSxcbiAgICAgIHRpdGxlOiBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YS5uYW1lIHx8IGRhdGEubmFtZSxcbiAgICAgIGRldGFpbHM6IHJlc3VsdERldGFpbHMsXG4gICAgICBsaW5rOiBkYXRhLndlYnNpdGUsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIG9yZGluYWw6IGluZGV4ICsgMVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgR29vZ2xlIEN1c3RvbSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tR29vZ2xlQ3VzdG9tU2VhcmNoRW5naW5lIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEuaHRtbFRpdGxlLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJyksXG4gICAgICBkZXRhaWxzOiBkYXRhLmh0bWxTbmlwcGV0LFxuICAgICAgbGluazogZGF0YS5saW5rXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBNYXBzIHZpZXcgbW9kZWwgZmllbGRzIGJhc2VkIG9uIHRoZSBBUEkgZGF0YSBmb3IgYSBCaW5nIEN1c3RvbSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tQmluZ0N1c3RvbVNlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLm5hbWUsXG4gICAgICBkZXRhaWxzOiBkYXRhLnNuaXBwZXQsXG4gICAgICBsaW5rOiBkYXRhLnVybFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgWmVuZGVzayBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tWmVuZGVza1NlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgZGV0YWlsczogZGF0YS5zbmlwcGV0LFxuICAgICAgbGluazogZGF0YS5odG1sX3VybFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgQWxnb2xpYSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogRGV0YWlscyBmaWVsZCBpcyBzZXQgdG8gb2JqZWN0SUQgc2luY2UgcmVzcG9uc2UgaGFzIG9ubHkgb25lIGdlbmVyYWwgZmllbGQgb2JqZWN0SUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUFsZ29saWFTZWFyY2hFbmdpbmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICBkZXRhaWxzOiBkYXRhLm9iamVjdElELFxuICAgICAgaWQ6IGRhdGEub2JqZWN0SURcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgc3RyaW5ncyB0byAyNTAgY2hhcmFjdGVycywgYXR0ZW1wdGluZyB0byBwcmVzZXJ2ZSB3aG9sZSB3b3Jkc1xuICAgKiBAcGFyYW0gc3RyIHtzdHJpbmd9IHRoZSBzdHJpbmcgdG8gdHJ1bmNhdGVcbiAgICogQHBhcmFtIGxpbWl0IHtOdW1iZXJ9IHRoZSBtYXhpbXVtIGNoYXJhY3RlciBsZW5ndGggdG8gcmV0dXJuXG4gICAqIEBwYXJhbSB0cmFpbGluZyB7c3RyaW5nfSBhIHRyYWlsaW5nIHN0cmluZyB0byBkZW5vdGUgdHJ1bmNhdGlvbiwgZS5nLiAnLi4uJ1xuICAgKiBAcGFyYW0gc2VwIHtzdHJpbmd9IHRoZSB3b3JkIHNlcGFyYXRvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHRydW5jYXRlIChzdHIsIGxpbWl0ID0gMjUwLCB0cmFpbGluZyA9ICcuLi4nLCBzZXAgPSAnICcpIHtcbiAgICBpZiAoIXN0ciB8fCBzdHIubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKGJtY2dpbm5pcyk6IHNwbGl0IHB1bmN0dWF0aW9uIHRvbyBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aCBcImZvbywuLi5cIlxuICAgIGNvbnN0IHdvcmRzID0gc3RyLnNwbGl0KHNlcCk7XG4gICAgY29uc3QgbWF4ID0gbGltaXQgLSB0cmFpbGluZy5sZW5ndGg7XG4gICAgbGV0IHRydW5jYXRlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgaWYgKHRydW5jYXRlZC5sZW5ndGggKyB3b3JkLmxlbmd0aCA+IG1heCB8fFxuICAgICAgICAoaSAhPT0gMCAmJiB0cnVuY2F0ZWQubGVuZ3RoICsgd29yZC5sZW5ndGggKyBzZXAubGVuZ3RoID4gbWF4KSkge1xuICAgICAgICB0cnVuY2F0ZWQgKz0gdHJhaWxpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cnVuY2F0ZWQgKz0gaSA9PT0gMCA/IHdvcmQgOiBzZXAgKyB3b3JkO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVuY2F0ZWQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlY3Rpb24gKi9cblxuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5pbXBvcnQgUmVzdWx0RmFjdG9yeSBmcm9tICcuL3Jlc3VsdGZhY3RvcnknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWN0aW9uIHtcbiAgY29uc3RydWN0b3IgKGRhdGEsIHVybCwgZm9ybWF0dGVycykge1xuICAgIHRoaXMuc2VhcmNoU3RhdGUgPSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFO1xuICAgIHRoaXMudmVydGljYWxDb25maWdJZCA9IGRhdGEudmVydGljYWxDb25maWdJZCB8fCBudWxsO1xuICAgIHRoaXMucmVzdWx0c0NvdW50ID0gZGF0YS5yZXN1bHRzQ291bnQgfHwgMDtcbiAgICB0aGlzLmVuY29kZWRTdGF0ZSA9IGRhdGEuZW5jb2RlZFN0YXRlIHx8ICcnO1xuICAgIHRoaXMuYXBwbGllZFF1ZXJ5RmlsdGVycyA9IEFwcGxpZWRRdWVyeUZpbHRlci5mcm9tKGRhdGEuYXBwbGllZFF1ZXJ5RmlsdGVycyk7XG4gICAgdGhpcy5mYWNldHMgPSBkYXRhLmZhY2V0cyB8fCBudWxsO1xuICAgIHRoaXMucmVzdWx0cyA9IFJlc3VsdEZhY3RvcnkuZnJvbShkYXRhLnJlc3VsdHMsIGZvcm1hdHRlcnMsIHRoaXMudmVydGljYWxDb25maWdJZCwgZGF0YS5zb3VyY2UpO1xuICAgIHRoaXMubWFwID0gU2VjdGlvbi5wYXJzZU1hcChkYXRhLnJlc3VsdHMpO1xuICAgIHRoaXMudmVydGljYWxVUkwgPSB1cmwgfHwgbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hcCAocmVzdWx0cykge1xuICAgIGxldCBtYXBNYXJrZXJzID0gW107XG5cbiAgICBsZXQgY2VudGVyQ29vcmRpbmF0ZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0cy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gVE9ETyhiaWxseSkgUmVtb3ZlIGxlZ2FjeSBmYWxsYmFjayBmcm9tIGFsbCBkYXRhIGZvcm1hdFxuICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbal0uZGF0YSB8fCByZXN1bHRzW2pdO1xuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlKSB7XG4gICAgICAgIGlmICghY2VudGVyQ29vcmRpbmF0ZXMubGF0aXR1ZGUpIHtcbiAgICAgICAgICBjZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxvbmdpdHVkZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWFwTWFya2Vycy5wdXNoKHtcbiAgICAgICAgICBpdGVtOiByZXN1bHQsXG4gICAgICAgICAgbGFiZWw6IG1hcE1hcmtlcnMubGVuZ3RoICsgMSxcbiAgICAgICAgICBsYXRpdHVkZTogcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZS5sYXRpdHVkZSxcbiAgICAgICAgICBsb25naXR1ZGU6IHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUubG9uZ2l0dWRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAnbWFwQ2VudGVyJzogY2VudGVyQ29vcmRpbmF0ZXMsXG4gICAgICAnbWFwTWFya2Vycyc6IG1hcE1hcmtlcnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlY3Rpb24gZnJvbSB0aGUgcHJvdmlkZWQgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbW9kdWxlcyBUaGUgcmVzdWx0IG1vZHVsZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVybHMgVGhlIHRhYiB1cmxzXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBGaWVsZCBmb3JtYXR0ZXJzIGZvciByZXN1bHRzXG4gICAqL1xuICBzdGF0aWMgZnJvbSAobW9kdWxlcywgdXJscywgZm9ybWF0dGVycykge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgcmV0dXJuIHNlY3Rpb25zO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWN0aW9uKG1vZHVsZXMsIG51bGwsIGZvcm1hdHRlcnMpO1xuICAgIH1cblxuICAgIC8vIE91ciBzZWN0aW9ucyBzaG91bGQgY29udGFpbiBhIHByb3BlcnR5IG9mIG1hcE1hcmtlciBvYmplY3RzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKFxuICAgICAgICBuZXcgU2VjdGlvbihcbiAgICAgICAgICBtb2R1bGVzW2ldLFxuICAgICAgICAgIHVybHNbbW9kdWxlc1tpXS52ZXJ0aWNhbENvbmZpZ0lkXSxcbiAgICAgICAgICBmb3JtYXR0ZXJzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zO1xuICB9XG59XG5cbmNsYXNzIEFwcGxpZWRRdWVyeUZpbHRlciB7XG4gIC8vIFN1cHBvcnQgbGVnYWN5IG1vZGVsIGFuZCBuZXcgbW9kZWwgdW50aWwgZnVsbHkgbWlncmF0ZWQuXG4gIC8vIFRPRE8oYmlsbHkpIFJlbW92ZSB0aGUgbGVmdCBleHByZXNzaW9uIGR1cmluZyBhc3NpZ25tZW50IHdoZW4gbWlncmF0ZWQuXG4gIGNvbnN0cnVjdG9yIChhcHBsaWVkUXVlcnlGaWx0ZXIpIHtcbiAgICB0aGlzLmtleSA9IGFwcGxpZWRRdWVyeUZpbHRlci5rZXkgfHwgYXBwbGllZFF1ZXJ5RmlsdGVyLmRpc3BsYXlLZXk7XG4gICAgdGhpcy52YWx1ZSA9IGFwcGxpZWRRdWVyeUZpbHRlci52YWx1ZSB8fCBhcHBsaWVkUXVlcnlGaWx0ZXIuZGlzcGxheVZhbHVlO1xuICB9XG5cbiAgc3RhdGljIGZyb20gKGFwcGxpZWRRdWVyeUZpbHRlcnMpIHtcbiAgICBsZXQgZmlsdGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXBwbGllZFF1ZXJ5RmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZmlsdGVycy5wdXNoKG5ldyBBcHBsaWVkUXVlcnlGaWx0ZXIoYXBwbGllZFF1ZXJ5RmlsdGVyc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVycztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVW5pdmVyc2FsUmVzdWx0cyAqL1xuXG5pbXBvcnQgU2VjdGlvbiBmcm9tICcuL3NlY3Rpb24nO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaXZlcnNhbFJlc3VsdHMge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMucXVlcnlJZCA9IGRhdGEucXVlcnlJZCB8fCBudWxsO1xuICAgIHRoaXMuc2VjdGlvbnMgPSBkYXRhLnNlY3Rpb25zIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNlYXJjaCwgdXNlZCB0byByZW5kZXIgZGlmZmVyZW50IHRlbXBsYXRlcyBiZWZvcmUsIGR1cmluZyxcbiAgICAgKiBhbmQgYWZ0ZXIgbG9hZGluZ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hTdGF0ZSA9IGRhdGEuc2VhcmNoU3RhdGUgfHwgU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdW5pdmVyc2FsIHJlc3VsdHMgZnJvbSBzZXJ2ZXIgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXJscyBUaGUgdGFiIHVybHNcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmaWVsZCBmb3JtYXR0ZXJzIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlLCB1cmxzLCBmb3JtYXR0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxSZXN1bHRzKHtcbiAgICAgIHF1ZXJ5SWQ6IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBzZWN0aW9uczogU2VjdGlvbi5mcm9tKHJlc3BvbnNlLm1vZHVsZXMsIHVybHMsIGZvcm1hdHRlcnMpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgVW5pdmVydmFsUmVzdWx0cyBvYmplY3QgcmVwcmVzZW50aW5nIGxvYWRpbmcgcmVzdWx0c1xuICAgKiBAcmV0dXJuIHtVbml2ZXJzYWxSZXN1bHRzfVxuICAgKi9cbiAgc3RhdGljIHNlYXJjaExvYWRpbmcgKCkge1xuICAgIHJldHVybiBuZXcgVW5pdmVyc2FsUmVzdWx0cyh7IHNlYXJjaFN0YXRlOiBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIERpcmVjdEFuc3dlciAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RBbnN3ZXIge1xuICBjb25zdHJ1Y3RvciAoZGlyZWN0QW5zd2VyID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRpcmVjdEFuc3dlcik7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEaXJlY3RBbnN3ZXIgbW9kZWwgZnJvbSB0aGUgZ2l2ZW4gc2VydmVyIGRhdGEgYW5kIGZvcm1hdHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgZGlyZWN0IGFuc3dlclxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZvcm1hdHRlcnMgdG8gYXBwbHkgdG8gdGhpcyBkaXJlY3QgYW5zd2VyXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UsIGZvcm1hdHRlcnMpIHtcbiAgICBjb25zdCBkYXRhID0geyAuLi5yZXNwb25zZSB9O1xuICAgIGNvbnN0IHsgYW5zd2VyLCByZWxhdGVkSXRlbSB9ID0gZGF0YTtcblxuICAgIGlmIChhbnN3ZXIgJiYgZm9ybWF0dGVyc1thbnN3ZXIuZmllbGRBcGlOYW1lXSkge1xuICAgICAgYW5zd2VyLnZhbHVlID0gZm9ybWF0dGVyc1thbnN3ZXIuZmllbGRBcGlOYW1lXShcbiAgICAgICAgYW5zd2VyLnZhbHVlLFxuICAgICAgICByZWxhdGVkSXRlbS5kYXRhLmZpZWxkVmFsdWVzLFxuICAgICAgICByZWxhdGVkSXRlbS52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgICB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERpcmVjdEFuc3dlcihkYXRhKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTmF2aWdhdGlvbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uIHtcbiAgY29uc3RydWN0b3IgKHRhYk9yZGVyKSB7XG4gICAgdGhpcy50YWJPcmRlciA9IHRhYk9yZGVyIHx8IFtdO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAobW9kdWxlcykge1xuICAgIGxldCBuYXYgPSBbXTtcbiAgICBpZiAoIW1vZHVsZXMgfHwgIUFycmF5LmlzQXJyYXkobW9kdWxlcykpIHtcbiAgICAgIHJldHVybiBuYXY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmF2LnB1c2gobW9kdWxlc1tpXS52ZXJ0aWNhbENvbmZpZ0lkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uKG5hdik7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdHNDb250ZXh0ICovXG5cbi8qKlxuICogUmVzdWx0c0NvbnRleHQgaXMgYW4gRU5VTSB0aGF0IHByb3ZpZGVzIGNvbnRleHRcbiAqIGZvciB0aGUgcmVzdWx0cyB0aGF0IHdlIGFyZSBzdG9yaW5nIGZyb20gc2VydmVyXG4gKiBkYXRhXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE5PUk1BTDogJ25vcm1hbCcsXG4gIE5PX1JFU1VMVFM6ICduby1yZXN1bHRzJ1xufTtcbiIsIi8qKiBAbW9kdWxlIFZlcnRpY2FsUmVzdWx0cyAqL1xuXG5pbXBvcnQgeyBBbnN3ZXJzQ29yZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgUmVzdWx0c0NvbnRleHQgZnJvbSAnLi4vc3RvcmFnZS9yZXN1bHRzY29udGV4dCc7XG5pbXBvcnQgU2VjdGlvbiBmcm9tICcuL3NlY3Rpb24nO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsUmVzdWx0cyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgc2VhcmNoU3RhdGU6IFNlYXJjaFN0YXRlcy5TRUFSQ0hfQ09NUExFVEUgfSwgZGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCBvZiB0aGUgcmVzdWx0cywgdXNlZCB0byBwcm92aWRlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2h5XG4gICAgICogdGhlc2Ugc3BlY2lmaWMgcmVzdWx0cyB3ZXJlIHJldHVybmVkLlxuICAgICAqIEB0eXBlIHtSZXN1bHRzQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdHNDb250ZXh0ID0gZGF0YS5yZXN1bHRzQ29udGV4dDtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwcm92aWRlZCByZXN1bHRzIHRvIHRoZSBjdXJyZW50IHJlc3VsdHNcbiAgICogQHBhcmFtIHtWZXJ0aWNhbFJlc3VsdHN9IHJlc3VsdHMgdGhlIHJlc3VsdHMgdG8gYXBwZW5kIHRvIHRoZSBjdXJyZW50IHJlc3VsdHNcbiAgICovXG4gIGFwcGVuZCAocmVzdWx0cykge1xuICAgIGlmIChyZXN1bHRzLnJlc3VsdHNDb250ZXh0ICE9PSB0aGlzLnJlc3VsdHNDb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignQ2Fubm90IG1lcmdlIHJlc3VsdHMgd2l0aCBkaWZmZXJlbnQgY29udGV4dHMnLCAnVmVydGljYWxSZXN1bHRzJyk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4udGhpcyB9O1xuICAgIG1lcmdlZC5yZXN1bHRzQ29udGV4dCA9IHRoaXMucmVzdWx0c0NvbnRleHQ7XG4gICAgbWVyZ2VkLnJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuY29uY2F0KHJlc3VsdHMucmVzdWx0cyk7XG4gICAgbWVyZ2VkLm1hcC5tYXBNYXJrZXJzID0gdGhpcy5tYXAubWFwTWFya2Vycy5jb25jYXQocmVzdWx0cy5tYXAubWFwTWFya2Vycyk7XG4gICAgcmV0dXJuIG5ldyBWZXJ0aWNhbFJlc3VsdHMobWVyZ2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtIHJlc3BvbnNlIGFzIGlmIHRoZSByZXN1bHRzIGZyb20gYGFsbFJlc3VsdHNGb3JWZXJ0aWNhbGAgd2VyZSB0aGUgYWN0dWFsXG4gICAqIHJlc3VsdHMgaW4gYHJlc3VsdHNgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgX2Zvcm1SZXNwb25zZUZyb21BbGxSZXN1bHRzRm9yVmVydGljYWwgKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyByZXN1bHRzLCByZXN1bHRzQ291bnQsIGZhY2V0cyB9ID0gcmVzcG9uc2UuYWxsUmVzdWx0c0ZvclZlcnRpY2FsIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMgfHwgW10sXG4gICAgICByZXN1bHRzQ291bnQ6IHJlc3VsdHNDb3VudCB8fCAwLFxuICAgICAgZmFjZXRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdmVydGljYWwgcmVzdWx0cyBmcm9tIHNlcnZlciBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBUaGUgZmllbGQgZm9ybWF0dGVycyB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSwgZm9ybWF0dGVycywgdmVydGljYWxLZXkpIHtcbiAgICBjb25zdCBoYXNSZXN1bHRzID0gcmVzcG9uc2UucmVzdWx0cyAmJiByZXNwb25zZS5yZXN1bHRzLmxlbmd0aCA+IDA7XG4gICAgaWYgKCFoYXNSZXN1bHRzKSB7XG4gICAgICBjb25zdCBkYXRhID0gU2VjdGlvbi5mcm9tKFZlcnRpY2FsUmVzdWx0cy5fZm9ybVJlc3BvbnNlRnJvbUFsbFJlc3VsdHNGb3JWZXJ0aWNhbChyZXNwb25zZSksIG51bGwsIGZvcm1hdHRlcnMpO1xuICAgICAgcmV0dXJuIG5ldyBWZXJ0aWNhbFJlc3VsdHMoeyAuLi5kYXRhLFxuICAgICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB2ZXJ0aWNhbEtleSxcbiAgICAgICAgcmVzdWx0c0NvbnRleHQ6IFJlc3VsdHNDb250ZXh0Lk5PX1JFU1VMVFNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYXRhID0gU2VjdGlvbi5mcm9tKHJlc3BvbnNlLCBudWxsLCBmb3JtYXR0ZXJzKTtcbiAgICAgIHJldHVybiBuZXcgVmVydGljYWxSZXN1bHRzKHsgLi4uZGF0YSxcbiAgICAgICAgdmVydGljYWxDb25maWdJZDogdmVydGljYWxLZXksXG4gICAgICAgIHJlc3VsdHNDb250ZXh0OiBSZXN1bHRzQ29udGV4dC5OT1JNQUxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBWZXJ0aWNhbFJlc3VsdHMgb2JqZWN0IHJlcHJlc2VudGluZyBsb2FkaW5nIHJlc3VsdHNcbiAgICogQHJldHVybiB7VmVydGljYWxSZXN1bHRzfVxuICAgKi9cbiAgc3RhdGljIHNlYXJjaExvYWRpbmcgKCkge1xuICAgIHJldHVybiBuZXcgVmVydGljYWxSZXN1bHRzKHsgc2VhcmNoU3RhdGU6IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTcGVsbENoZWNrICovXG5cbi8qKlxuICogU3BlbGxDaGVjayBpcyB0aGUgY29yZSBzdGF0ZSBtb2RlbFxuICogdG8gcG93ZXIgdGhlIFNwZWxsQ2hlY2sgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWxsQ2hlY2sge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IGRhdGEucXVlcnkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JyZWN0ZWQgcXVlcnlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29ycmVjdGVkUXVlcnkgPSBkYXRhLmNvcnJlY3RlZFF1ZXJ5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlbGwgY2hlY2sgdHlwZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gZGF0YS50eXBlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgc2hvdyBzcGVsbCBjaGVjayBvciBub3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZFNob3cgPSB0aGlzLmNvcnJlY3RlZFF1ZXJ5ICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNwZWxsIGNoZWNrIG1vZGVsIGZyb20gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzcGVsbCBjaGVjayByZXNwb25zZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3BlbGxDaGVjayh7XG4gICAgICBxdWVyeTogcmVzcG9uc2Uub3JpZ2luYWxRdWVyeSxcbiAgICAgIGNvcnJlY3RlZFF1ZXJ5OiByZXNwb25zZS5jb3JyZWN0ZWRRdWVyeSxcbiAgICAgIHR5cGU6IHJlc3BvbnNlLnR5cGVcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3RvcmFnZUtleXMgKi9cblxuLyoqXG4gKiBTdG9yYWdlS2V5cyBpcyBhbiBFTlVNIGFyZSBjb25zaWRlcmVkIHRoZSByb290IGNvbnRleHRcbiAqIGZvciBob3cgZGF0YSBpcyBzdG9yZWQgYW5kIHNjb3BlZCBpbiB0aGUgc3RvcmFnZS5cbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE5BVklHQVRJT046ICduYXZpZ2F0aW9uJyxcbiAgVU5JVkVSU0FMX1JFU1VMVFM6ICd1bml2ZXJzYWwtcmVzdWx0cycsXG4gIFZFUlRJQ0FMX1JFU1VMVFM6ICd2ZXJ0aWNhbC1yZXN1bHRzJyxcbiAgQUxURVJOQVRJVkVfVkVSVElDQUxTOiAnYWx0ZXJuYXRpdmUtdmVydGljYWxzJyxcbiAgQVVUT0NPTVBMRVRFOiAnYXV0b2NvbXBsZXRlJyxcbiAgRElSRUNUX0FOU1dFUjogJ2RpcmVjdC1hbnN3ZXInLFxuICBGSUxURVI6ICdmaWx0ZXInLFxuICBRVUVSWTogJ3F1ZXJ5JyxcbiAgUVVFUllfSUQ6ICdxdWVyeS1pZCcsXG4gIEZBQ0VUX0ZJTFRFUjogJ2ZhY2V0LWZpbHRlcicsXG4gIERZTkFNSUNfRklMVEVSUzogJ2R5bmFtaWMtZmlsdGVycycsXG4gIFBBUkFNUzogJ3BhcmFtcycsXG4gIEdFT0xPQ0FUSU9OOiAnZ2VvbG9jYXRpb24nLFxuICBJTlRFTlRTOiAnaW50ZW50cycsXG4gIFFVRVNUSU9OX1NVQk1JU1NJT046ICdxdWVzdGlvbi1zdWJtaXNzaW9uJyxcbiAgU0VBUkNIX0NPTkZJRzogJ3NlYXJjaC1jb25maWcnLFxuICBTRUFSQ0hfT0ZGU0VUOiAnc2VhcmNoLW9mZnNldCcsXG4gIFNQRUxMX0NIRUNLOiAnc3BlbGwtY2hlY2snLFxuICBMT0NBVElPTl9CSUFTOiAnbG9jYXRpb24tYmlhcycsXG4gIFNFU1NJT05TX09QVF9JTjogJ3Nlc3Npb25zLW9wdC1pbicsXG4gIFZFUlRJQ0FMX1BBR0VTX0NPTkZJRzogJ3ZlcnRpY2FsLXBhZ2VzLWNvbmZpZycsXG4gIExPQ0FMRTogJ2xvY2FsZScsXG4gIFNPUlRfQllTOiAnc29ydC1ieXMnLFxuICBOT19SRVNVTFRTX0NPTkZJRzogJ25vLXJlc3VsdHMtY29uZmlnJ1xufTtcbiIsIi8qKiBAbW9kdWxlIER5bmFtaWNGaWx0ZXJzICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgc2V0IG9mIGR5bmFtaWMgZmlsdGVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEeW5hbWljRmlsdGVycyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVycyB0aGlzIG1vZGVsIGhvbGRzXG4gICAgICogQHR5cGUge3tsYWJlbDogc3RyaW5nLCBmaWVsZElkOiBzdHJpbmcsIG9wdGlvbnM6IG9iamVjdFtdfX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcnMgPSBkYXRhLmZpbHRlcnMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcmdhbml6ZSAnZmFjZXRzJyBmcm9tIHRoZSBhcGkgcmVzcG9uc2UgaW50byBkeW5hbWljIGZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIGR5bmFtaWMgZmlsdGVyIHJlc3BvbnNlIGZyb20gdGhlIGFwaVxuICAgKiBAcmV0dXJucyB7RHluYW1pY0ZpbHRlcnN9XG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBjb25zdCBmYWNldHMgPSByZXNwb25zZS5yZXN1bHRzQ291bnQgPT09IDAgJiYgcmVzcG9uc2UuYWxsUmVzdWx0c0ZvclZlcnRpY2FsXG4gICAgICA/IHJlc3BvbnNlLmFsbFJlc3VsdHNGb3JWZXJ0aWNhbC5mYWNldHNcbiAgICAgIDogcmVzcG9uc2UuZmFjZXRzO1xuICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJzID0gZmFjZXRzLm1hcChmID0+ICh7XG4gICAgICBsYWJlbDogZlsnZGlzcGxheU5hbWUnXSxcbiAgICAgIGZpZWxkSWQ6IGZbJ2ZpZWxkSWQnXSxcbiAgICAgIG9wdGlvbnM6IGYub3B0aW9ucy5tYXAobyA9PiAoe1xuICAgICAgICBsYWJlbDogb1snZGlzcGxheU5hbWUnXSxcbiAgICAgICAgY291bnRMYWJlbDogb1snY291bnQnXSxcbiAgICAgICAgc2VsZWN0ZWQ6IG9bJ3NlbGVjdGVkJ10sXG4gICAgICAgIGZpbHRlcjogb1snZmlsdGVyJ11cbiAgICAgIH0pKVxuICAgIH0pKTtcblxuICAgIHJldHVybiBuZXcgRHluYW1pY0ZpbHRlcnMoeyBmaWx0ZXJzOiBkeW5hbWljRmlsdGVycyB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoSW50ZW50cyAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnRlbnRzIHtcbiAgY29uc3RydWN0b3IgKGludGVudHMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZW50IHRvIGZpbmQgcmVzdWx0cyBiYXNlZCBvbiB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uZWFyTWUgPSBpbnRlbnRzLm5lYXJNZTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIFNlYXJjaEludGVudHMgZnJvbSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgcmVzcG9uc2UgaW50ZW50c1xuICAgKiBAcmV0dXJucyB7U2VhcmNoSW50ZW50c31cbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGNvbnN0IGludGVudHMgPSByZXNwb25zZSB8fCBbXTtcblxuICAgIHJldHVybiBuZXcgU2VhcmNoSW50ZW50cyh7XG4gICAgICBuZWFyTWU6IGludGVudHMuaW5jbHVkZXMoJ05FQVJfTUUnKVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBMb2NhdGlvbkJpYXMgKi9cblxuLyoqXG4gKiBMb2NhdGlvbkJpYXMgaXMgdGhlIGNvcmUgc3RhdGUgbW9kZWxcbiAqIHRvIHBvd2VyIHRoZSBMb2NhdGlvbkJpYXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2F0aW9uQmlhcyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvY2F0aW9uIGJpYXMgYWNjdXJhY3kgd2hpY2ggYXJlIElQLCBERVZJQ0UgYW5kIFVOS05XT05cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYWNjdXJhY3kgPSBkYXRhLmFjY3VyYWN5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGF0aXR1ZGUgdXNlZCBmb3IgbG9jYXRpb24gYmlhc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXRpdHVkZSA9IGRhdGEubGF0aXR1ZGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUgdXNlZCBmb3IgbG9jYXRpb24gYmlhc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb25naXR1ZGUgPSBkYXRhLmxvbmdpdHVkZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2F0aW9uIGRpc3BsYXkgbmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sb2NhdGlvbkRpc3BsYXlOYW1lID0gZGF0YS5sb2NhdGlvbkRpc3BsYXlOYW1lIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9jYXRpb24gYmlhcyBtb2RlbCBmcm9tIHRoZSBwcm92aWRlZCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgbG9jYXRpb24gYmlhcyByZXNwb25zZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIG5ldyBMb2NhdGlvbkJpYXMoe1xuICAgICAgICBhY2N1cmFjeTogJ1VOS05PV04nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExvY2F0aW9uQmlhcyh7XG4gICAgICBhY2N1cmFjeTogcmVzcG9uc2UuYWNjdXJhY3ksXG4gICAgICBsYXRpdHVkZTogcmVzcG9uc2UubGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGU6IHJlc3BvbnNlLmxvbmdpdHVkZSxcbiAgICAgIGxvY2F0aW9uRGlzcGxheU5hbWU6IHJlc3BvbnNlLmxvY2F0aW9uRGlzcGxheU5hbWVcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQWx0ZXJuYXRpdmVWZXJ0aWNhbHMgKi9cblxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnLi9zZWN0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWx0ZXJuYXRpdmVWZXJ0aWNhbHMge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIEFsdGVybmF0aXZlIHZlcnRpY2FscyB0aGF0IGhhdmUgcmVzdWx0cyBmb3IgdGhlIGN1cnJlbnQgcXVlcnlcbiAgICAgKiBAdHlwZSB7U2VjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsdGVybmF0aXZlVmVydGljYWxzID0gZGF0YSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYWx0ZXJuYXRpdmUgdmVydGljYWxzIGZyb20gc2VydmVyIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmaWVsZCBmb3JtYXR0ZXJzIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlLCBmb3JtYXR0ZXJzKSB7XG4gICAgY29uc3QgYWx0ZXJuYXRpdmVWZXJ0aWNhbHMgPSByZXNwb25zZS5hbHRlcm5hdGl2ZVZlcnRpY2FscztcbiAgICBpZiAoIWFsdGVybmF0aXZlVmVydGljYWxzIHx8ICFhbHRlcm5hdGl2ZVZlcnRpY2Fscy5tb2R1bGVzKSB7XG4gICAgICByZXR1cm4gbmV3IEFsdGVybmF0aXZlVmVydGljYWxzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBbHRlcm5hdGl2ZVZlcnRpY2FscyhTZWN0aW9uLmZyb20oYWx0ZXJuYXRpdmVWZXJ0aWNhbHMubW9kdWxlcywge30sIGZvcm1hdHRlcnMpKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoRGF0YVRyYW5zZm9ybWVyICovXG5cbmltcG9ydCBVbml2ZXJzYWxSZXN1bHRzIGZyb20gJy4uL21vZGVscy91bml2ZXJzYWxyZXN1bHRzJztcbmltcG9ydCBEaXJlY3RBbnN3ZXIgZnJvbSAnLi4vbW9kZWxzL2RpcmVjdGFuc3dlcic7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuLi9tb2RlbHMvbmF2aWdhdGlvbic7XG5pbXBvcnQgVmVydGljYWxSZXN1bHRzIGZyb20gJy4uL21vZGVscy92ZXJ0aWNhbHJlc3VsdHMnO1xuaW1wb3J0IFNwZWxsQ2hlY2sgZnJvbSAnLi4vbW9kZWxzL3NwZWxsY2hlY2snO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IER5bmFtaWNGaWx0ZXJzIGZyb20gJy4uL21vZGVscy9keW5hbWljZmlsdGVycyc7XG5pbXBvcnQgU2VhcmNoSW50ZW50cyBmcm9tICcuLi9tb2RlbHMvc2VhcmNoaW50ZW50cyc7XG5pbXBvcnQgTG9jYXRpb25CaWFzIGZyb20gJy4uL21vZGVscy9sb2NhdGlvbmJpYXMnO1xuaW1wb3J0IEFsdGVybmF0aXZlVmVydGljYWxzIGZyb20gJy4uL21vZGVscy9hbHRlcm5hdGl2ZXZlcnRpY2Fscyc7XG5cbi8qKlxuICogQSBEYXRhIFRyYW5zZm9ybWVyIHRoYXQgdGFrZXMgdGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIGEgU2VhcmNoIHJlcXVlc3RcbiAqIEFuZCB0cmFuc2Zvcm1zIGluIHRvIGEgZnJvbnQtZW5kIG9yaWVudGVkIGRhdGEgc3RydWN0dXJlIHRoYXQgb3VyXG4gKiBjb21wb25lbnQgbGlicmFyeSBhbmQgY29yZSBzdG9yYWdlIHVuZGVyc3RhbmQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaERhdGFUcmFuc2Zvcm1lciB7XG4gIHN0YXRpYyB0cmFuc2Zvcm0gKGRhdGEsIHVybHMgPSB7fSwgZm9ybWF0dGVycykge1xuICAgIGxldCByZXNwb25zZSA9IGRhdGEucmVzcG9uc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTdG9yYWdlS2V5cy5RVUVSWV9JRF06IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBbU3RvcmFnZUtleXMuTkFWSUdBVElPTl06IE5hdmlnYXRpb24uZnJvbShyZXNwb25zZS5tb2R1bGVzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSXTogRGlyZWN0QW5zd2VyLmZyb20ocmVzcG9uc2UuZGlyZWN0QW5zd2VyLCBmb3JtYXR0ZXJzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU106IFVuaXZlcnNhbFJlc3VsdHMuZnJvbShyZXNwb25zZSwgdXJscywgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuSU5URU5UU106IFNlYXJjaEludGVudHMuZnJvbShyZXNwb25zZS5zZWFyY2hJbnRlbnRzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS106IFNwZWxsQ2hlY2suZnJvbShyZXNwb25zZS5zcGVsbENoZWNrKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXTogTG9jYXRpb25CaWFzLmZyb20ocmVzcG9uc2UubG9jYXRpb25CaWFzKVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdHJhbnNmb3JtVmVydGljYWwgKGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsS2V5KSB7XG4gICAgLy8gVE9ETyAodG1leWVyKTogU1BSLTE5MjMsIGNlbnRyYWxpemUgdGhlIGFsbFJlc3VsdHNGb3JWZXJ0aWNhbCBwYXJzaW5nIGhlcmUuXG4gICAgcmV0dXJuIHtcbiAgICAgIFtTdG9yYWdlS2V5cy5RVUVSWV9JRF06IGRhdGEucmVzcG9uc2UucXVlcnlJZCxcbiAgICAgIFtTdG9yYWdlS2V5cy5OQVZJR0FUSU9OXTogbmV3IE5hdmlnYXRpb24oKSwgLy8gVmVydGljYWwgZG9lc24ndCByZXNwb25kIHdpdGggb3JkZXJpbmcsIHNvIHVzZSBlbXB0eSBuYXYuXG4gICAgICBbU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUU106IFZlcnRpY2FsUmVzdWx0cy5mcm9tKGRhdGEucmVzcG9uc2UsIGZvcm1hdHRlcnMsIHZlcnRpY2FsS2V5KSxcbiAgICAgIFtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdOiBEeW5hbWljRmlsdGVycy5mcm9tKGRhdGEucmVzcG9uc2UpLFxuICAgICAgW1N0b3JhZ2VLZXlzLklOVEVOVFNdOiBTZWFyY2hJbnRlbnRzLmZyb20oZGF0YS5yZXNwb25zZS5zZWFyY2hJbnRlbnRzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS106IFNwZWxsQ2hlY2suZnJvbShkYXRhLnJlc3BvbnNlLnNwZWxsQ2hlY2spLFxuICAgICAgW1N0b3JhZ2VLZXlzLkFMVEVSTkFUSVZFX1ZFUlRJQ0FMU106IEFsdGVybmF0aXZlVmVydGljYWxzLmZyb20oZGF0YS5yZXNwb25zZSwgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuTE9DQVRJT05fQklBU106IExvY2F0aW9uQmlhcy5mcm9tKGRhdGEucmVzcG9uc2UubG9jYXRpb25CaWFzKVxuICAgIH07XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFF1ZXN0aW9uU3VibWlzc2lvbiAqL1xuXG4vKipcbiAqIFF1ZXN0aW9uU3VibWlzc2lvbiBpcyB0aGUgY29yZSBzdGF0ZSBtb2RlbFxuICogdG8gcG93ZXIgdGhlIFF1ZXN0aW9uU3VibWlzc2lvbiBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVlc3Rpb25TdWJtaXNzaW9uIHtcbiAgY29uc3RydWN0b3IgKHF1ZXN0aW9uID0ge30sIGVycm9ycykge1xuICAgIC8qKlxuICAgICAqIFRoZSBhdXRob3Igb2YgdGhlIHF1ZXN0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBxdWVzdGlvbi5uYW1lIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgcXVlc3Rpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZW1haWwgPSBxdWVzdGlvbi5lbWFpbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgcHJpdmFjeSBwb2xpY3kgd2FzIGFwcHJvdmVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wcml2YWN5UG9saWN5ID0gcXVlc3Rpb24ucHJpdmFjeVBvbGljeSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXN0aW9uIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvblRleHQgPSBxdWVzdGlvbi5xdWVzdGlvblRleHQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFsdGVybmF0aXZlIHF1ZXN0aW9uIG1ldGEgaW5mb3JtYXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucXVlc3Rpb25EZXNjcmlwdGlvbiA9IHF1ZXN0aW9uLnF1ZXN0aW9uRGVzY3JpcHRpb24gfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGZvcm0gaXMgZXhwYW5kZWQgb3Igbm90LiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqL1xuICAgIHRoaXMucXVlc3Rpb25FeHBhbmRlZCA9IHR5cGVvZiBxdWVzdGlvbi5leHBhbmRlZCAhPT0gJ2Jvb2xlYW4nIHx8IHF1ZXN0aW9uLmV4cGFuZGVkO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgYW55IGVycm9ycyBhYm91dCB0aGUgcXVlc3Rpb24gc3VibWlzc2lvblxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnMgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGZvcm0gaGFzIGJlZW4gc3VibWl0dGVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvblN1Ym1pdHRlZCA9IHF1ZXN0aW9uLnN1Ym1pdHRlZCB8fCBmYWxzZTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgc3VibWl0dGVkICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcXVlc3Rpb25TdWJtaXR0ZWQ6IHRydWUsXG4gICAgICBxdWVzdGlvbkV4cGFuZGVkOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBlcnJvcnMgKHF1ZXN0aW9uLCBlcnJvcnMpIHtcbiAgICByZXR1cm4gUXVlc3Rpb25TdWJtaXNzaW9uKHF1ZXN0aW9uLCBlcnJvcnMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXIgKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFwaSBmaWx0ZXIgYW5kIHByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBlYXNpbHkgY29uc3RydWN0aW5nIEZpbHRlcnMuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIueWV4dC5jb20vZG9jcy9hcGktcmVmZXJlbmNlLyNvcGVyYXRpb24vbGlzdEVudGl0aWVzIGZvciBzdHJ1Y3R1cmUgZGV0YWlsc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkYXRhKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgSlNPTiBmb3JtYXQgZmlsdGVyIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbnRvIGEgRmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gcmVzcG9uc2VGaWx0ZXIgQSBmaWx0ZXIgaW4gSlNPTiBmb3JtYXQgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZFxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGZyb21SZXNwb25zZSAocmVzcG9uc2VGaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihKU09OLnBhcnNlKHJlc3BvbnNlRmlsdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IEZpbHRlciByZXByZXNlbnRpbmcgdGhlIE9SIG9mIGFsbCBwcm92aWRlZCBmaWx0ZXJzXG4gICAqIEBwYXJhbSAgey4uLkZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBPUiB0b2dldGhlclxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIG9yICguLi5maWx0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoe1xuICAgICAgJyRvcic6IGZpbHRlcnNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgRmlsdGVyIHJlcHJlc2VudGluZyB0aGUgQU5EIG9mIGFsbCBwcm92aWRlZCBmaWx0ZXJzXG4gICAqIEBwYXJhbSAgey4uLkZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBBTkQgdG9nZXRoZXJcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBhbmQgKC4uLmZpbHRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICAnJGFuZCc6IGZpbHRlcnNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPUiBmaWx0ZXJzIHdpdGggdGhlIHNhbWUga2V5cywgdGhlbiBBTkQgdGhlIHJlc3VsdGluZyBncm91cHNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIGdyb3VwXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ3JvdXAgKC4uLmZpbHRlcnMpIHtcbiAgICBjb25zdCBncm91cHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhmaWx0ZXIpWzBdO1xuICAgICAgaWYgKCFncm91cHNba2V5XSkge1xuICAgICAgICBncm91cHNba2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JvdXBzW2tleV0ucHVzaChmaWx0ZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwRmlsdGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoZ3JvdXBzKSkge1xuICAgICAgZ3JvdXBGaWx0ZXJzLnB1c2goZ3JvdXBzW2ZpZWxkXS5sZW5ndGggPiAxID8gRmlsdGVyLm9yKC4uLmdyb3Vwc1tmaWVsZF0pIDogZ3JvdXBzW2ZpZWxkXVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwRmlsdGVycy5sZW5ndGggPiAxID8gRmlsdGVyLmFuZCguLi5ncm91cEZpbHRlcnMpIDogZ3JvdXBGaWx0ZXJzWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImVxdWFsIHRvXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZXF1YWwgdG9cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBlcXVhbCAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckZXEnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwibGVzcyB0aGFuXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgbGVzc1RoYW4gKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGx0JywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImxlc3MgdGhhbiBvciBlcXVhbCB0b1wiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGxlc3NUaGFuRXF1YWwgKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImdyZWF0ZXIgdGhhblwiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhblxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGdyZWF0ZXJUaGFuIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRndCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBncmVhdGVyVGhhbkVxdWFsIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRnZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5jbHVzaXZlIHJhbmdlIGZpbHRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IG1pbiBUaGUgbWluaW11bSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG1heCBUaGUgbWF4aW11bSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGluY2x1c2l2ZVJhbmdlIChmaWVsZCwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICBbZmllbGRdOiB7XG4gICAgICAgICckZ2UnOiBtaW4sXG4gICAgICAgICckbGUnOiBtYXhcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZXhjbHVzaXZlIHJhbmdlIGZpbHRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IG1pbiBUaGUgbWluaW11bSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG1heCBUaGUgbWF4aW11bSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGV4Y2x1c2l2ZVJhbmdlIChmaWVsZCwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICBbZmllbGRdOiB7XG4gICAgICAgICckZ3QnOiBtaW4sXG4gICAgICAgICckbHQnOiBtYXhcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcG9zaXRpb24gZmlsdGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIG9mIHRoZSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbG5nIFRoZSBsb25naXR1ZGUgb2YgdGhlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHNlYXJjaCByYWRpdXMgKGluIG1ldGVycylcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbiAobGF0LCBsbmcsIHJhZGl1cykge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKCdidWlsdGluLmxvY2F0aW9uJywgJyRuZWFyJywgeyBsYXQsIGxuZywgcmFkaXVzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmaWx0ZXIgd2l0aCB0aGUgZ2l2ZW4gbWF0Y2hlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hlciBUaGUgbWF0Y2hlciBmb3IgdGhlIGZpbGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIGZvciB0aGUgZmlsdGVyXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgX2Zyb21NYXRjaGVyIChmaWVsZCwgbWF0Y2hlciwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICBbZmllbGRdOiB7XG4gICAgICAgIFttYXRjaGVyXTogdmFsdWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQ29yZSAqL1xuXG5pbXBvcnQgU2VhcmNoRGF0YVRyYW5zZm9ybWVyIGZyb20gJy4vc2VhcmNoL3NlYXJjaGRhdGF0cmFuc2Zvcm1lcic7XG5cbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFZlcnRpY2FsUmVzdWx0cyBmcm9tICcuL21vZGVscy92ZXJ0aWNhbHJlc3VsdHMnO1xuaW1wb3J0IFVuaXZlcnNhbFJlc3VsdHMgZnJvbSAnLi9tb2RlbHMvdW5pdmVyc2FscmVzdWx0cyc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uIGZyb20gJy4vbW9kZWxzL3F1ZXN0aW9uc3VibWlzc2lvbic7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vbW9kZWxzL2ZpbHRlcic7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlcnZpY2VzL3NlYXJjaHNlcnZpY2UnKS5kZWZhdWx0fSBTZWFyY2hTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zZXJ2aWNlcy9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2VydmljZXMvcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJykuZGVmYXVsdH0gUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQ29yZSBpcyB0aGUgbWFpbiBhcHBsaWNhdGlvbiBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgbmV0d29yayBhbmQgc3RvcmFnZVxuICogcmVsYXRlZCBiZWhhdmlvcnMgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNsaWVudCBBUEkgS2V5IHVzZWQgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNsaWVudCBBbnN3ZXJzIEtleSB1c2VkIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuc3dlcnMgY29uZmlnIHZlcnNpb24gdG8gdXNlIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24gPSBjb25maWcuZXhwZXJpZW5jZVZlcnNpb247XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2xpZW50IGxvY2FsZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMuIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFwiZW5cIiAoZm9yXG4gICAgICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sb2NhbGUgPSBjb25maWcubG9jYWxlO1xuXG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgZmllbGQgZm9ybWF0dGVycyB1c2VkIHRvIGZvcm1hdCByZXN1bHRzLCBpZiBwcmVzZW50XG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZEZvcm1hdHRlcnMgPSBjb25maWcuZmllbGRGb3JtYXR0ZXJzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgZGF0YSBzdG9yYWdlIHRoYXQgcG93ZXJzIHRoZSBVSVxuICAgICAqIEB0eXBlIHtHbG9iYWxTdG9yYWdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlID0gY29uZmlnLmdsb2JhbFN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29yZSBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKiBAdHlwZSB7UGVyc2lzdGVudFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBlcnNpc3RlbnRTdG9yYWdlID0gY29uZmlnLnBlcnNpc3RlbnRTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWJzdHJhY3Rpb24gY29udGFpbmluZyB0aGUgaW50ZWdyYXRpb24gd2l0aCB0aGUgUkVTVGZ1bCBzZWFyY2ggQVBJXG4gICAgICogRm9yIGJvdGggdmVydGljYWwgYW5kIHVuaXZlcnNhbCBzZWFyY2hcbiAgICAgKiBAdHlwZSB7U2VhcmNoU2VydmljZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaGVyID0gY29uZmlnLnNlYXJjaFNlcnZpY2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiBjb250YWluaW5nIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBSRVNUZnVsIGF1dG9jb21wbGV0ZSBBUElcbiAgICAgKiBGb3IgZmlsdGVyIHNlYXJjaCwgdmVydGljYWwgYXV0b2NvbXBsZXRlLCBhbmQgdW5pdmVyc2FsIGF1dG9jb21wbGV0ZVxuICAgICAqIEB0eXBlIHtBdXRvQ29tcGxldGVTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYXV0b0NvbXBsZXRlID0gY29uZmlnLmF1dG9Db21wbGV0ZVNlcnZpY2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgUSZBIHJlc3QgaW50ZXJmYWNlXG4gICAgICogQHR5cGUge1F1ZXN0aW9uQW5zd2VyU2VydmljZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3F1ZXN0aW9uQW5zd2VyID0gY29uZmlnLnF1ZXN0aW9uQW5zd2VyU2VydmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggaW4gdGhlIGNvbnRleHQgb2YgYSB2ZXJ0aWNhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxLZXkgdmVydGljYWwgSUQgZm9yIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5IFRoZSBxdWVyeSBkZXRhaWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeS5pbnB1dCBUaGUgaW5wdXQgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkuZmlsdGVyIFRoZSBmaWx0ZXIgdG8gdXNlIGluIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmZhY2V0RmlsdGVyIFRoZSBmYWNldCBmaWx0ZXIgdG8gdXNlIGluIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1ZXJ5LmxpbWl0IFRoZSBtYXggbnVtYmVyIG9mIHJlc3VsdHMgdG8gaW5jbHVkZSwgbWF4IG9mIDUwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWVyeS5vZmZzZXQgVGhlIHJlc3VsdHMgb2Zmc2V0LCBmb3IgZmV0Y2hpbmcgbW9yZSByZXN1bHRzIG9mIHRoZSBzYW1lIHF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeS5pZCBUaGUgcXVlcnkgSUQgdG8gdXNlLiBJZiBwYWdpbmcgd2l0aGluIGEgcXVlcnksIHRoZSBzYW1lIElEIHNob3VsZCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVlcnkuYXBwZW5kIElmIHRydWUsIGFkZHMgdGhlIHJlc3VsdHMgb2YgdGhpcyBxdWVyeSB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlc3VsdHMsIGRlZmF1bHRzIGZhbHNlXG4gICAqL1xuICB2ZXJ0aWNhbFNlYXJjaCAodmVydGljYWxLZXksIHF1ZXJ5KSB7XG4gICAgaWYgKCFxdWVyeS5hcHBlbmQpIHtcbiAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgVmVydGljYWxSZXN1bHRzLnNlYXJjaExvYWRpbmcoKSk7XG4gICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCB7fSk7XG4gICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVMsIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoZXJcbiAgICAgIC52ZXJ0aWNhbFNlYXJjaCh2ZXJ0aWNhbEtleSwge1xuICAgICAgICBsaW1pdDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLmxpbWl0LFxuICAgICAgICBnZW9sb2NhdGlvbjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OKSxcbiAgICAgICAgLi4ucXVlcnksXG4gICAgICAgIGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkOiB0aGlzLl9pc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCxcbiAgICAgICAgc2tpcFNwZWxsQ2hlY2s6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSgnc2tpcFNwZWxsQ2hlY2snKSxcbiAgICAgICAgcXVlcnlUcmlnZ2VyOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3F1ZXJ5VHJpZ2dlcicpLFxuICAgICAgICBzZXNzaW9uVHJhY2tpbmdFbmFibGVkOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VTU0lPTlNfT1BUX0lOKSxcbiAgICAgICAgc29ydEJ5czogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNPUlRfQllTKVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IFNlYXJjaERhdGFUcmFuc2Zvcm1lci50cmFuc2Zvcm1WZXJ0aWNhbChyZXNwb25zZSwgdGhpcy5fZmllbGRGb3JtYXR0ZXJzLCB2ZXJ0aWNhbEtleSkpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWV9JRCwgZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV9JRF0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLk5BVklHQVRJT04sIGRhdGFbU3RvcmFnZUtleXMuTkFWSUdBVElPTl0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLklOVEVOVFMsIGRhdGFbU3RvcmFnZUtleXMuSU5URU5UU10pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkFMVEVSTkFUSVZFX1ZFUlRJQ0FMUywgZGF0YVtTdG9yYWdlS2V5cy5BTFRFUk5BVElWRV9WRVJUSUNBTFNdKTtcblxuICAgICAgICBpZiAocXVlcnkuYXBwZW5kKSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkUmVzdWx0cyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTKVxuICAgICAgICAgICAgLmFwcGVuZChkYXRhW1N0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFNdKTtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIG1lcmdlZFJlc3VsdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlMsIGRhdGFbU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TUEVMTF9DSEVDSywgZGF0YVtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCBkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdza2lwU3BlbGxDaGVjaycpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdxdWVyeVRyaWdnZXInKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhZ2Ugd2l0aGluIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSBUaGUgdmVydGljYWwga2V5IHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKi9cbiAgdmVydGljYWxQYWdlICh2ZXJ0aWNhbEtleSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgdGhpcy52ZXJ0aWNhbFNlYXJjaCh2ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSksXG4gICAgICBpZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZX0lEKSxcbiAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKSxcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG5cbiAgc2VhcmNoIChxdWVyeVN0cmluZywgdXJscykge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuRElSRUNUX0FOU1dFUiwge30pO1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFMsIFVuaXZlcnNhbFJlc3VsdHMuc2VhcmNoTG9hZGluZygpKTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT04sIHt9KTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCB7fSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCB7fSk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoZXJcbiAgICAgIC51bml2ZXJzYWxTZWFyY2gocXVlcnlTdHJpbmcsIHtcbiAgICAgICAgZ2VvbG9jYXRpb246IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiksXG4gICAgICAgIHNraXBTcGVsbENoZWNrOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3NraXBTcGVsbENoZWNrJyksXG4gICAgICAgIHF1ZXJ5VHJpZ2dlcjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdxdWVyeVRyaWdnZXInKSxcbiAgICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTilcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBTZWFyY2hEYXRhVHJhbnNmb3JtZXIudHJhbnNmb3JtKHJlc3BvbnNlLCB1cmxzLCB0aGlzLl9maWVsZEZvcm1hdHRlcnMpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIGRhdGFbU3RvcmFnZUtleXMuUVVFUllfSURdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OLCBkYXRhW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSLCBkYXRhW1N0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVJdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU10sIHVybHMpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLklOVEVOVFMsIGRhdGFbU3RvcmFnZUtleXMuSU5URU5UU10pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCBkYXRhW1N0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUywgZGF0YVtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3NraXBTcGVsbENoZWNrJyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3F1ZXJ5VHJpZ2dlcicpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHF1ZXJ5IGZvciBhIGxpc3Qgb2Ygc2ltaWxhciByZXN1bHRzIGFuZCBzZXQgaW50byBzdG9yYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAgICAgdGhlIHN0cmluZyB0byBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqL1xuICBhdXRvQ29tcGxldGVVbml2ZXJzYWwgKGlucHV0LCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlXG4gICAgICAucXVlcnlVbml2ZXJzYWwoaW5wdXQpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7bmFtZXNwYWNlfWAsIGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGlucHV0LCBxdWVyeSBmb3IgYSBsaXN0IG9mIHNpbWlsYXIgcmVzdWx0cyBpbiB0aGUgcHJvdmlkZWQgdmVydGljYWxcbiAgICogYW5kIHNldCBpbnRvIHN0b3JhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICAgICAgIHRoZSBzdHJpbmcgdG8gYXV0b2NvbXBsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBzdG9yYWdlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxLZXkgdGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIGV4cGVyaWVuY2VcbiAgICovXG4gIGF1dG9Db21wbGV0ZVZlcnRpY2FsIChpbnB1dCwgbmFtZXNwYWNlLCB2ZXJ0aWNhbEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvQ29tcGxldGVcbiAgICAgIC5xdWVyeVZlcnRpY2FsKGlucHV0LCB2ZXJ0aWNhbEtleSlcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHtuYW1lc3BhY2V9YCwgZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHByb3ZpZGUgYSBsaXN0IG9mIHN1aXRhYmxlIGZpbHRlcnMgZm9yIGF1dG9jb21wbGV0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAgdGhlIHN0cmluZyB0byBzZWFyY2ggZm9yIGZpbHRlcnMgd2l0aFxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnICB0aGUgY29uZmlnIHRvIHNlcmFjaCBmb3IgZmlsdGVycyB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcubmFtZXNwYWNlICB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcudmVydGljYWxLZXkgdGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIGNvbmZpZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnLnNlYXJjaFBhcmFtZXRlcnMgIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBmb3IgdGhlIGNvbmZpZyB2MlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9Db21wbGV0ZVxuICAgICAgLnF1ZXJ5RmlsdGVyKGlucHV0LCBjb25maWcpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7Y29uZmlnLm5hbWVzcGFjZX1gLCBkYXRhKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYSBxdWVzdGlvbiB0byB0aGUgc2VydmVyIGFuZCB1cGRhdGVzIHRoZSB1bmRlcmx5aW5nIHF1ZXN0aW9uIG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVzdGlvbiBUaGUgcXVlc3Rpb24gb2JqZWN0IHRvIHN1Ym1pdCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWVzdGlvbi5lbnRpdHlJZCBUaGUgZW50aXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBxdWVzdGlvbiAocmVxdWlyZWQpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVzdGlvbi5sYW51YWdlIFRoZSBsYW5ndWFnZSBvZiB0aGUgcXVlc3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnNpdGUgVGhlIFwicHVibGlzaGVyXCIgb2YgdGhlIChlLmcuICdGSVJTVF9QQVJUWScpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVzdGlvbi5uYW1lIFRoZSBuYW1lIG9mIHRoZSBhdXRob3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLmVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSBhdXRob3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCBUaGUgcXVlc3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnF1ZXN0aW9uRGVzY3JpcHRpb24gQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcXVlc3Rpb25cbiAgICovXG4gIHN1Ym1pdFF1ZXN0aW9uIChxdWVzdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9xdWVzdGlvbkFuc3dlclxuICAgICAgLnN1Ym1pdFF1ZXN0aW9uKHF1ZXN0aW9uKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoXG4gICAgICAgICAgU3RvcmFnZUtleXMuUVVFU1RJT05fU1VCTUlTU0lPTixcbiAgICAgICAgICBRdWVzdGlvblN1Ym1pc3Npb24uc3VibWl0dGVkKCkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBzb3J0QnkgaW50byBzdG9yYWdlLCB0byBiZSB1c2VkIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvcnRCeU9wdGlvbnNcbiAgICovXG4gIHNldFNvcnRCeXMgKC4uLnNvcnRCeU9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3J0QnlzID0gc29ydEJ5T3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IG9wdGlvbi50eXBlLFxuICAgICAgICBmaWVsZDogb3B0aW9uLmZpZWxkLFxuICAgICAgICBkaXJlY3Rpb246IG9wdGlvbi5kaXJlY3Rpb25cbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TT1JUX0JZUywgSlNPTi5zdHJpbmdpZnkoc29ydEJ5cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgc29ydEJ5cyBrZXkgaW4gZ2xvYmFsIHN0b3JhZ2UuXG4gICAqL1xuICBjbGVhclNvcnRCeXMgKCkge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU09SVF9CWVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gcXVlcnkgaW50byBzdG9yYWdlLCB0byBiZSB1c2VkIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBxdWVyeSB0byBzdG9yZVxuICAgKi9cbiAgc2V0UXVlcnkgKHF1ZXJ5KSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWSwgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgcXVlcnkgSUQsIHRvIGJlIHVzZWQgaW4gYW5hbHl0aWNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeUlkIFRoZSBxdWVyeSBpZCB0byBzdG9yZVxuICAgKi9cbiAgc2V0UXVlcnlJZCAocXVlcnlJZCkge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIHF1ZXJ5SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gZmlsdGVyIGludG8gc3RvcmFnZSwgdG8gYmUgdXNlZCBmb3IgdGhlIG5leHQgc2VhcmNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBzdG9yYWdlIGtleVxuICAgKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyICAgIHRoZSBmaWx0ZXIgdG8gc2V0XG4gICAqL1xuICBzZXRGaWx0ZXIgKG5hbWVzcGFjZSwgZmlsdGVyKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7bmFtZXNwYWNlfWAsIGZpbHRlcik7XG4gIH1cblxuICBzZXRGYWNldEZpbHRlciAobmFtZXNwYWNlLCBmaWx0ZXIpIHtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUn0uJHtuYW1lc3BhY2V9YCwgZmlsdGVyKTtcbiAgfVxuXG4gIGVuYWJsZUR5bmFtaWNGaWx0ZXJzICgpIHtcbiAgICB0aGlzLl9pc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBvbiAoZXZ0LCBtb2R1bGVJZCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxTdG9yYWdlLm9uKGV2dCwgbW9kdWxlSWQsIGNiKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRE9NICovXG5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCwgSFRNTERvY3VtZW50LCBXaW5kb3csIEV2ZW50LCBFbGVtZW50ICovXG5cbmxldCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuLyoqXG4gKiBTdGF0aWMgaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBET00gQVBJLlxuICogQG5hbWVzcGFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET00ge1xuICBzdGF0aWMgc2V0dXAgKGQsIHApIHtcbiAgICBkb2N1bWVudCA9IGQ7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGEgSFRNTEVsZW1lbnQgZnJvbSBhbmQgSFRNTCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIEhUTUwgdG8gcGFyc2UgdG8gYSBET00gbm9kZS5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlIChodG1sKSB7XG4gICAgaWYgKCdjcmVhdGVSYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgIC8vIHByZWZlciB0aGlzIGltcGxlbWVudGF0aW9uIGFzIGl0IGhhcyB3aWRlciBicm93c2VyIHN1cHBvcnRcbiAgICAgIC8vIGFuZCBpdCdzIGJldHRlciBwZXJmb3JtaW5nLlxuICAgICAgLy8gc2VlIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2NvbnZlcnQtaHRtbC1zdGluZ3MtZG9tLW5vZGVzXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuXG4gICAgLy8gZmFsbGJhY2sgdG8gdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIGpzZG9tIHRoYXQgY2F1c2VzIHRlc3RzIHRvIGZhaWxcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2RvbS9qc2RvbS9pc3N1ZXMvMzk5XG4gICAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpLmJvZHk7XG4gIH1cblxuICAvKipcbiAgICogcXVlcnkgdGhlIERPTSBmb3IgYSBnaXZlbiBjc3Mgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IE9wdGlvbmFsIGNvbnRleHQgdG8gdXNlIGZvciBhIHNlYXJjaC4gRGVmYXVsdHMgdG8gZG9jdW1lbnQgaWYgbm90IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgdGhlIENTUyBzZWxlY3RvciB0byBxdWVyeSBmb3JcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aGUgRklSU1Qgbm9kZSBpdCBmaW5kcywgaWYgYW55XG4gICAqL1xuICBzdGF0aWMgcXVlcnkgKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAvLyBGYWNhZGUsIHNoaWZ0aW5nIHRoZSBzZWxlY3RvciB0byB0aGUgcGFyZW50IGFyZ3VtZW50IGlmIG9ubHkgb25lXG4gICAgLy8gYXJndW1lbnQgaXMgcHJvdmlkZWRcbiAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZWN0b3IgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIFdpbmRvdyB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogcXVlcnkgdGhlIERPTSBmb3IgYSBnaXZlbiBjc3Mgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IE9wdGlvbmFsIGNvbnRleHQgdG8gdXNlIGZvciBhIHNlYXJjaC4gRGVmYXVsdHMgdG8gZG9jdW1lbnQgaWYgbm90IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgdGhlIENTUyBzZWxlY3RvciB0byBxdWVyeSBmb3JcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgRklSU1Qgbm9kZSBpdCBmaW5kcywgaWYgYW55XG4gICAqL1xuICBzdGF0aWMgcXVlcnlBbGwgKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAvLyBGYWNhZGUsIHNoaWZ0aW5nIHRoZSBzZWxlY3RvciB0byB0aGUgcGFyZW50IGFyZ3VtZW50IGlmIG9ubHkgb25lXG4gICAgLy8gYXJndW1lbnQgaXMgcHJvdmlkZWRcbiAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZWN0b3IgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgY2xpZW50IGNvZGUgaXMgdXNpbmcgYSBwb2ludGVyIHRvIGEgZG9tIG5vZGUgYW5kIGl0J3MgbnVsbCwgZS5nLiB0aGlzLl9jb250YWluZXJcbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgSFRNTERvY3VtZW50IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICByZXR1cm4gW3NlbGVjdG9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9XG5cbiAgc3RhdGljIG9uUmVhZHkgKGNiKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBET00ub24oZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZUVsZSB3aWxsIGNyZWF0ZSBhIHtIVE1MRWxlbWVudH0gYW5kIGFwcGx5IHRoZSBwcm9wZXJ0aWVzIGF0dHJpYnV0ZXMgdGhyb3VnaCBhbiBvYmplY3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbCBUaGUgZWxlbWVudCBgdGFnYCBuYW1lIHRvIGNvbnN0cnVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c19kYXRhIE9wdGlvbmFsIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIG5ldyBIVE1MRWxlbWVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUVsIChlbCwgb3B0c19kYXRhID0ge30pIHtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwpO1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5rZXlzKG9wdHNfZGF0YSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcHNbaV0gPT09ICdjbGFzcycpIHtcbiAgICAgICAgRE9NLmFkZENsYXNzKG5vZGUsIG9wdHNfZGF0YVtwcm9wc1tpXV0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZVtwcm9wc1tpXV0gPSBvcHRzX2RhdGFbcHJvcHNbaV1dO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc3RhdGljIGFwcGVuZCAocGFyZW50LCBub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyZW50ID0gRE9NLnF1ZXJ5KHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBIVE1MIGluamVjdGlvbiBhcyB3ZWxsIGFzIEhUTUxFbGVtZW50IGFwcGVuZHNcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlckJlZ2luJywgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWRkQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcsJyk7XG4gICAgbGV0IGxlbiA9IGNsYXNzZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBlbXB0eSAocGFyZW50KSB7XG4gICAgcGFyZW50LmlubmVySFRNTCA9ICcnO1xuICB9XG5cbiAgc3RhdGljIGNzcyAoc2VsZWN0b3IsIHN0eWxlcykge1xuICAgIGxldCBub2RlID0gRE9NLnF1ZXJ5KHNlbGVjdG9yKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICBub2RlLnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhdHRyIChzZWxlY3RvciwgYXR0ciwgdmFsKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgfVxuXG4gIHN0YXRpYyBhdHRyaWJ1dGVzIChzZWxlY3RvciwgYXR0cnMpIHtcbiAgICBPYmplY3QuZW50cmllcyhhdHRycylcbiAgICAgIC5mb3JFYWNoKChbYXR0ciwgdmFsXSkgPT4gdGhpcy5hdHRyKHNlbGVjdG9yLCBhdHRyLCB2YWwpKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmlnZ2VyIChzZWxlY3RvciwgZXZlbnQsIHNldHRpbmdzKSB7XG4gICAgbGV0IGUgPSBET00uX2N1c3RvbUV2ZW50KGV2ZW50LCBzZXR0aW5ncyk7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLy8gVE9ETyAoYWdyb3cpIGludmVzdGlnYXRlIHJlbW92aW5nIHRoaXNcbiAgLy8gRXZlbnQgY29uc3RydWN0b3IgcG9seWZpbGxcbiAgc3RhdGljIF9jdXN0b21FdmVudCAoZXZlbnQsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoZXZlbnQsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAnYnViYmxlcyc6IHRydWUsXG4gICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZVxuICAgICAgfSwgc2V0dGluZ3MgfHwge30pKTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IG51bGwgfTtcbiAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgc2V0dGluZ3MuYnViYmxlcywgc2V0dGluZ3MuY2FuY2VsYWJsZSwgc2V0dGluZ3MuZGV0YWlsKTtcbiAgICByZXR1cm4gZXZ0O1xuICB9XG5cbiAgc3RhdGljIG9uIChzZWxlY3RvciwgZXZ0LCBoYW5kbGVyKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcik7XG4gIH1cblxuICBzdGF0aWMgb25jZSAoc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIERPTS5xdWVyeShzZWxlY3RvcikuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHN0YXRpYyBvZmYgKHNlbGVjdG9yLCBldnQsIGhhbmRsZXIpIHtcbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWxlZ2F0ZSAoY3R4dCwgc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIGxldCBlbCA9IERPTS5xdWVyeShjdHh0KTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgd2hpbGUgKCF0YXJnZXQuaXNFcXVhbE5vZGUoZWwpKSB7XG4gICAgICAgIGlmIChET00ubWF0Y2hlcyh0YXJnZXQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHRhcmdldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPIChhZ3JvdykgaW52ZXN0aWdhdGUgcmVtb3ZpbmcgdGhpc1xuICAvLyBFbGVtZW50Lm1hdGNoZXMgcG9seWZpbGxcbiAgc3RhdGljIG1hdGNoZXMgKGVsZW1lbnQsIHBvdGVudGlhbE1hdGNoKSB7XG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMocG90ZW50aWFsTWF0Y2gpO1xuICAgIH1cbiAgICBpZiAoRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yKHBvdGVudGlhbE1hdGNoKTtcbiAgICB9XG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHBvdGVudGlhbE1hdGNoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaFBhcmFtcyAqL1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG5cbi8qKlxuICogU2VhcmNoUGFyYW1zIGlzIGEgY2xhc3MgdG8gZ2V0IHRoZSBzZWFyY2ggcGFyYW1zIGluIGEgVVJMLlxuICogSXQgaXMgYSByZXBsYWNlbWVudCBmb3IgVVJMLnNlYXJjaFBhcmFtcyBhbmQgVVJMU2VhcmNoUGFyYW1zIGZvciBicm93c2VycyBsaWtlIElFMTFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoUGFyYW1zIHtcbiAgY29uc3RydWN0b3IgKHVybCkge1xuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgb2YgYWxsIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIHVybCwgcXVlcnkgcGFyYW0gLT4gdmFsdWVcbiAgICAgKiBPbmx5IHVzZWQgaWYgVVJMU2VhcmNoUGFyYW1zIGRvZXMgbm90IGV4aXN0IGluIHRoZSB3aW5kb3dcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0ge307XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5VUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IHRoaXMucGFyc2UodXJsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgY3JlYXRlcyBhIG1hcHBpbmcgb2YgYWxsIHF1ZXJ5IHBhcmFtcyBpbiBhIGdpdmVuIHVybFxuICAgKiBUaGUgcXVlcnkgcGFyYW0gdmFsdWVzIGFyZSBkZWNvZGVkIGJlZm9yZSBiZWluZyBwdXQgaW4gdGhlIG1hcFxuICAgKiBUaHJlZSB0eXBlcyBvZiBpbnB1dCBhcmUgc3VwcG9ydGVkXG4gICAqICAgKDEpIGZ1bGwgVVJMIGUuZy4gaHR0cDovL3d3dy55ZXh0LmNvbS8/cT1oZWxsb1xuICAgKiAgICgyKSBwYXJhbXMgd2l0aCA/IGUuZy4gP3E9aGVsbG9cbiAgICogICAoMSkgcGFyYW1zIHdpdGhvdXQgPyBlLmcuIHE9aGVsbG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG1hcHBpbmcgZnJvbSBxdWVyeSBwYXJhbSAtPiB2YWx1ZSB3aGVyZSB2YWx1ZSBpcyAnJyBpZiBubyB2YWx1ZSBpcyBwcm92aWRlZFxuICAgKi9cbiAgcGFyc2UgKHVybCkge1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgc2VhcmNoID0gdXJsO1xuXG4gICAgaWYgKHNlYXJjaCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGFsbCB1cmwgaW5wdXRzIHRvIHN0cmluZyBvZiBxdWVyeSBwYXJhbXMgc2VwYXJhdGVkIGJ5ICZcbiAgICBpZiAodXJsLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICBzZWFyY2ggPSB1cmwuc2xpY2UodXJsLmluZGV4T2YoJz8nKSArIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBzZWFyY2guc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWRQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVZhbCA9IGVuY29kZWRQYXJhbXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChrZXlWYWwubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJhbXNba2V5VmFsWzBdXSA9IFNlYXJjaFBhcmFtcy5kZWNvZGUoa2V5VmFsWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtc1trZXlWYWxbMF1dID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHF1ZXJ5IHBhcmFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgcXVlcnkgcGFyYW0ga2V5IHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXJhbSB2YWx1ZSwgbnVsbCBvdGhlcndpc2VcbiAgICovXG4gIGdldCAocXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhcmFtc1tTdHJpbmcocXVlcnkpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zW3F1ZXJ5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBxdWVyeSBwYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcXVlcnkgcGFyYW0ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIHF1ZXJ5IHBhcmFtIHVwZGF0ZSB3aXRoXG4gICAqL1xuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fcGFyYW1zW1N0cmluZyhuYW1lKV0gPSBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhhcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBnaXZlbiBxdWVyeSBwYXJhbSBrZXkgZXhpc3RzIGluIHRoZSBwYXJhbXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgcXVlcnkgcGFyYW0gdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcXVlcnkgcGFyYW0gaXMgaW4gdGhlIHBhcmFtcyBvYmplY3QsIGZhbHNlIG8vd1xuICAgKi9cbiAgaGFzIChxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeSBpbiB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogZGVsZXRlIHJlbW92ZXMgdGhlIGdpdmVuIHF1ZXJ5IHBhcmFtIGFuZCBpdHMgYXNzb2NpYXRlZCB2YWx1ZSBmcm9tIHRoZSBwYXJhbXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBxdWVyeSBwYXJhbSBrZXlcbiAgICovXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9wYXJhbXNbU3RyaW5nKG5hbWUpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b1N0cmluZyByZXR1cm5zIGEgdXJsIHdpdGggYWxsIHRoZSBxdWVyeSBwYXJhbXMgaW4gdGhlIHBhcmFtcyBvYmplY3QgKHdpdGhvdXQgYSA/KVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IHN0cmluZyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9wYXJhbXMpIHtcbiAgICAgIHN0cmluZy5wdXNoKGAke2tleX09JHtTZWFyY2hQYXJhbXMuZW5jb2RlKHRoaXMuX3BhcmFtc1trZXldKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZy5qb2luKCcmJyk7XG4gIH1cblxuICBlbnRyaWVzICgpIHtcbiAgICBsZXQgZW50cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9wYXJhbXMpIHtcbiAgICAgIGVudHJpZXMucHVzaChba2V5LCB0aGlzLl9wYXJhbXNba2V5XV0pO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGUgcmV0dXJucyB0aGUgZGVjb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyB0byBkZWNvZGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJpbmcucmVwbGFjZSgvWyArXS9nLCAnJTIwJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZSByZXR1cm5zIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcgKGUuZy4gKyAtPiAlMkIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGVuY29kZSAoc3RyaW5nKSB7XG4gICAgbGV0IHJlcGxhY2UgPSB7XG4gICAgICAnISc6ICclMjEnLFxuICAgICAgXCInXCI6ICclMjcnLFxuICAgICAgJygnOiAnJTI4JyxcbiAgICAgICcpJzogJyUyOScsXG4gICAgICAnJTIwJzogJysnXG4gICAgfTtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykucmVwbGFjZSgvWyEnKCldfCUyMC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiByZXBsYWNlW21hdGNoXTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUmVuZGVyZXIgKi9cblxuLyoqXG4gKiBSZW5kZXJlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGFsbCBSZW5kZXJlcnMgc2hvdWxkIGV4dGVuZCBhbmQgaW1wbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIHJlbmRlciBpcyBhIGNvcmUgbWV0aG9kIGZvciBhbGwgcmVuZGVyZXJzLlxuICAgKiBBbGwgaW1wbGVtZW50YXRpb25zIHNob3VsZCBvdmVycmlkZSB0aGlzIGNsYXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgKi9cbiAgcmVuZGVyICh0ZW1wbGF0ZSwgZGF0YSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIHJlZ2lzdGVySGVscGVyIChuYW1lLCBjYikge1xuXG4gIH1cblxuICBjb21waWxlICh0ZW1wbGF0ZSkge1xuXG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNWR0ljb24ge1xuICAvKipcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcGFyYW0gY29uZmlnLm5hbWVcbiAgICogQHBhcmFtIGNvbmZpZy5wYXRoXG4gICAqIEBwYXJhbSBjb25maWcuY29tcGxleENvbnRlbnRzXG4gICAqIEBwYXJhbSBjb25maWcudmlld0JveFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgaWNvblxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIC8qKlxuICAgICAqIGFuIHN2ZyBwYXRoIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnBhdGggPSBjb25maWcucGF0aDtcbiAgICAvKipcbiAgICAgKiBpZiBub3QgdXNpbmcgYSBwYXRoLCBhIHRoZSBtYXJrdXAgZm9yIGEgY29tcGxleCBTVkdcbiAgICAgKi9cbiAgICB0aGlzLmNvbXBsZXhDb250ZW50cyA9IGNvbmZpZy5jb21wbGV4Q29udGVudHM7XG4gICAgLyoqXG4gICAgICogdGhlIHZpZXcgYm94IGRlZmluaXRpb24sIGRlZmF1bHRzIHRvIDI0eDI0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdCb3ggPSBjb25maWcudmlld0JveCB8fCAnMCAwIDI0IDI0JztcbiAgICAvKipcbiAgICAgKiBhY3R1YWwgY29udGVudHMgdXNlZFxuICAgICAqL1xuICAgIHRoaXMuY29udGVudHMgPSB0aGlzLnBhdGhEZWZpbml0aW9uKCk7XG4gIH1cblxuICBwYXRoRGVmaW5pdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY29tcGxleENvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV4Q29udGVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGA8cGF0aCBkPVwiJHt0aGlzLnBhdGh9XCI+PC9wYXRoPmA7XG4gIH1cblxuICBwYXJzZUNvbnRlbnRzIChjb21wbGV4Q29udGVudHNQYXJhbXMpIHtcbiAgICBsZXQgY29udGVudHMgPSB0aGlzLmNvbnRlbnRzO1xuICAgIGlmICh0eXBlb2YgY29udGVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnRzID0gY29udGVudHMoY29tcGxleENvbnRlbnRzUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGA8c3ZnIHZpZXdCb3g9XCIke3RoaXMudmlld0JveH1cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JHtjb250ZW50c308L3N2Zz5gO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHN2ZyBtYXJrdXBcbiAgICovXG4gIG1hcmt1cCAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY29tcGxleENvbnRlbnRzUGFyYW1zID0+IHRoaXMucGFyc2VDb250ZW50cyhjb21wbGV4Q29udGVudHNQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNvbnRlbnRzKCk7XG4gIH1cbn1cbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd0aHVtYicsXG4gIHZpZXdCb3g6ICcwIDAgMjQgMjInLFxuICBwYXRoOiAnTTE1LjI3MyAxSDUuNDU1Yy0uOTA2IDAtMS42OC41NS0yLjAwOCAxLjM0MkwuMTUzIDEwLjA5N0EyLjE5IDIuMTkgMCAwMDAgMTAuOXYyLjJjMCAxLjIxLjk4MiAyLjIgMi4xODIgMi4yaDYuODgzTDguMDMgMjAuMzI3bC0uMDMzLjM1MmMwIC40NTEuMTg2Ljg2OS40OCAxLjE2Nkw5LjYzMyAyM2w3LjE3OC03LjI0OWEyLjE2IDIuMTYgMCAwMC42NDQtMS41NTF2LTExYzAtMS4yMS0uOTgyLTIuMi0yLjE4Mi0yLjJ6bTAgMTMuMmwtNC43MzUgNC43NzRMMTEuNzUgMTMuMUgyLjE4MnYtMi4ybDMuMjczLTcuN2g5LjgxOHYxMXpNMTkuNjM2IDFIMjR2MTMuMmgtNC4zNjRWMXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdyZWNlaXB0JyxcbiAgcGF0aDogJ00xNC42MDYgOS41Yy0uNjcxLS41MTUtMS41OTEtLjgzMy0yLjYwNi0uODMzIDEuMDE1IDAgMS45MzUuMzE4IDIuNjA2LjgzM3ptLTcuOTg1IDBIMS42NTVBMS42NiAxLjY2IDAgMDEwIDcuODMzVjMuNjY3QzAgMi43NDcuNzQxIDIgMS42NTUgMmgyMC42OUExLjY2IDEuNjYgMCAwMTI0IDMuNjY3djQuMTY2QTEuNjYgMS42NiAwIDAxMjIuMzQ1IDkuNWgtNC45NjZWMjJINi42MjFWOS41aDIuNzczSDYuNjJ6bTEwLjc1OC0xLjY2N2g0Ljk2NlYzLjY2N0gxLjY1NXY0LjE2Nmg0Ljk2NnYtMi41aDEwLjc1OHYyLjV6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncGFudGhlb24nLFxuICBwYXRoOiAnTTkuOTQ3IDE2LjU5OGguMjUyVjkuNDEyaC0uMjUyYS40MzIuNDMyIDAgMDEtLjIzLS4wNjVjLS4wNy0uMDQzLS4xMDYtLjA5My0uMTA2LS4xNUw5LjE1IDcuODJ2LS4xNWMwLS4wNDQuMDI4LS4wOC4wODQtLjEwOWEuNjkxLjY5MSAwIDAxLjEwNS0uMDg2LjI1NC4yNTQgMCAwMS4xNDYtLjA0M0gxMy42Yy4wNTYgMCAuMTA0LjAxNS4xNDYuMDQzLjA0Mi4wMy4wOTEuMDU4LjE0Ny4wODZhLjI3MS4yNzEgMCAwMS4wNjMuMTA4Yy4wMTQuMDQzLjAwNy4wOTMtLjAyLjE1bC0uNDIgMS4zNzhhLjM3NC4zNzQgMCAwMS0uMTQ3LjE1LjM3LjM3IDAgMDEtLjE5LjA2NWgtLjI1MXY3LjE4NmguMjUyYS4zNy4zNyAwIDAxLjE4OS4wNjVjLjA3LjA0My4xMTkuMDkzLjE0Ny4xNWwuNDIgMS4zNzhjLjAyNy4wMjguMDM0LjA3MS4wMi4xMjlhLjI3NS4yNzUgMCAwMS0uMDYzLjEyOSAxLjM2NCAxLjM2NCAwIDAwLS4xNDcuMDg2LjI1NC4yNTQgMCAwMS0uMTQ2LjA0M0g5LjQ4NWEuMjU0LjI1NCAwIDAxLS4xNDYtLjA0My42OTEuNjkxIDAgMDEtLjEwNS0uMDg2Yy0uMDU2LS4wMjktLjA4NC0uMDcyLS4wODQtLjEzdi0uMTI4bC40NjEtMS4zNzdjMC0uMDU4LjAzNS0uMTA4LjEwNS0uMTUxYS40MzIuNDMyIDAgMDEuMjMxLS4wNjV6bTUuNzkyIDBoLjI1MlY5LjQxMmgtLjI1MmEuNDMyLjQzMiAwIDAxLS4yMy0uMDY1LjM3NC4zNzQgMCAwMS0uMTQ4LS4xNWwtLjQyLTEuMzc3Yy0uMDI3LS4wMjktLjAzNC0uMDcyLS4wMi0uMTNhLjI3NS4yNzUgMCAwMS4wNjMtLjEyOWMuMDU2LS4wMjguMTA1LS4wNTcuMTQ2LS4wODZhLjI1NC4yNTQgMCAwMS4xNDctLjA0M2g0LjExNGMuMDU1IDAgLjEwNC4wMTUuMTQ2LjA0M2EuNjkxLjY5MSAwIDAxLjEwNS4wODZjLjA1Ni4wMy4wODQuMDcyLjA4NC4xM3YuMTI5bC0uNDIgMS4zNzdhLjM3NC4zNzQgMCAwMS0uMTQ2LjE1LjQzMi40MzIgMCAwMS0uMjMxLjA2NWgtLjIxdjcuMTg2aC4yMWEuNDMuNDMgMCAwMS4yMy4wNjVjLjA3LjA0My4xMi4wOTMuMTQ4LjE1bC40MiAxLjM3OHYuMTVjMCAuMDQzLS4wMjkuMDgtLjA4NS4xMDhhLjY5MS42OTEgMCAwMS0uMTA1LjA4Ni4yNTQuMjU0IDAgMDEtLjE0Ni4wNDNoLTQuMTE0YS4yNTQuMjU0IDAgMDEtLjE0Ny0uMDQzIDEuMzY0IDEuMzY0IDAgMDAtLjE0Ni0uMDg2LjI3MS4yNzEgMCAwMS0uMDYzLS4xMDhjLS4wMTQtLjA0My0uMDA3LS4wOTMuMDItLjE1bC40Mi0xLjM3N2EuMzc0LjM3NCAwIDAxLjE0Ny0uMTUxLjQzMi40MzIgMCAwMS4yMzEtLjA2NXptLTExLjc5NC0uMDg2aC4yNTJWOS40OThoLS4yNTJhLjMzNC4zMzQgMCAwMS0uMjEtLjA2NS4zODYuMzg2IDAgMDEtLjEyNi0uMTkzbC0uNDItMS4zNzdhLjI0OC4yNDggMCAwMS0uMDItLjE3Mi44NTQuODU0IDAgMDEuMDYzLS4xNzNjLjAyOC0uMDU3LjA3LS4xLjEyNi0uMTI5YS4zNjUuMzY1IDAgMDEuMTY4LS4wNDNoNC4wN2MuMDU3IDAgLjExMy4wMTUuMTY5LjA0M2EuMjc4LjI3OCAwIDAxLjEyNi4xMy44NTQuODU0IDAgMDEuMDYyLjE3Mi4yNDguMjQ4IDAgMDEtLjAyLjE3MmwtLjQyIDEuMzc3YS4zODYuMzg2IDAgMDEtLjEyNi4xOTMuMzM0LjMzNCAwIDAxLS4yMS4wNjVoLS4yMXY3LjAxNGguMjFjLjA4NCAwIC4xNTQuMDI5LjIxLjA4NmEuNjczLjY3MyAwIDAxLjEyNi4xNzJsLjQyIDEuMzc4YS4yNDguMjQ4IDAgMDEuMDIuMTcyLjg1NC44NTQgMCAwMS0uMDYyLjE3Mi4yNzguMjc4IDAgMDEtLjEyNi4xMjkuMzY1LjM2NSAwIDAxLS4xNjguMDQzSDMuNTI2YS4zNjUuMzY1IDAgMDEtLjE2OC0uMDQzLjI3OC4yNzggMCAwMS0uMTI2LS4xMy44NTQuODU0IDAgMDEtLjA2My0uMTcxLjI0OC4yNDggMCAwMS4wMi0uMTcybC40Mi0xLjM3OGEuNjczLjY3MyAwIDAxLjEyNi0uMTcyLjI4MS4yODEgMCAwMS4yMS0uMDg2ek0xLjc2MyA2LjY1OGEuNzE3LjcxNyAwIDAxLS41MDQtLjE5NC42NDQuNjQ0IDAgMDEtLjIxLS40OTV2LS40M2EuNzMuNzMgMCAwMS4xMDUtLjM4Ny42OC42OCAwIDAxLjI3My0uMjU5QzQuMzA5IDMuNDAyIDYuNTQgMi4yNzYgOC4xMjEgMS41MTUgOS43MDIuNzU1IDEwLjQ5My4zNjEgMTAuNDkzLjMzMmMuNTMxLS4yNTguOTcyLS4zNjYgMS4zMjItLjMyMy4zNS4wNDMuNzM0LjE2NSAxLjE1NC4zNjZsOC4zMSA0LjUxOGMuMTQuMDU4LjI0NS4xNDQuMzE1LjI1OWEuNzMuNzMgMCAwMS4xMDUuMzg3di40M2MwIC4yMDEtLjA3LjM2Ni0uMjEuNDk1YS43MTcuNzE3IDAgMDEtLjUwNC4xOTRIMS43NjN6bS0uNzE0IDEzLjM0YS41NC41NCAwIDAxLjE2OC0uMzg3LjUxNi41MTYgMCAwMS4zNzgtLjE3MmgxOS42NDJjLjE2OCAwIC4zMDguMDU3LjQyLjE3MmEuNTQxLjU0MSAwIDAxLjE2OC4zODd2LjgxOGEuNTIyLjUyMiAwIDAxLS4xNjguNDA4LjYwNS42MDUgMCAwMS0uNDIuMTUxSDEuNTk1YS41NTEuNTUxIDAgMDEtLjM3OC0uMTUuNTIyLjUyMiAwIDAxLS4xNjgtLjQxdi0uODE3em0yMS40MDUgMi4wMjJjLjE0IDAgLjI2Ni4wNTguMzc4LjE3M2EuNTkyLjU5MiAwIDAxLjE2OC40M3YuODE4YS41NDEuNTQxIDAgMDEtLjE2OC4zODcuNTE2LjUxNiAwIDAxLS4zNzguMTcyTC41NDYgMjMuOTU3YS41MTYuNTE2IDAgMDEtLjM3OC0uMTcyLjU0MS41NDEgMCAwMS0uMTY4LS4zODd2LS44MThhLjU5LjU5IDAgMDEuMTY4LS40My41MTYuNTE2IDAgMDEuMzc4LS4xNzNsMjEuOTA4LjA0M3onXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdtaWMnLFxuICBwYXRoOiAnTTEyIDE1YzEuNjYgMCAyLjk5LTEuMzQgMi45OS0zTDE1IDZjMC0xLjY2LTEuMzQtMy0zLTNTOSA0LjM0IDkgNnY2YzAgMS42NiAxLjM0IDMgMyAzem01LjMtM2MwIDMtMi41NCA1LjEtNS4zIDUuMVM2LjcgMTUgNi43IDEySDVjMCAzLjQxIDIuNzIgNi4yMyA2IDYuNzJWMjJoMnYtMy4yOGMzLjI4LS40OCA2LTMuMyA2LTYuNzJoLTEuN3onXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdkaXJlY3Rpb25zJyxcbiAgcGF0aDogJ00yMy42NDkgMTEuMTU0TDEyLjg0Ni4zNWExLjE5NSAxLjE5NSAwIDAwLTEuNjkyIDBMLjM1IDExLjE1NGExLjE5NSAxLjE5NSAwIDAwMCAxLjY5MkwxMS4xNTQgMjMuNjVhMS4xOTUgMS4xOTUgMCAwMDEuNjkyIDBMMjMuNjUgMTIuODQ2Yy40NjgtLjQ1Ni40NjgtMS4yMTIgMC0xLjY5MnptLTkuMjU0IDMuODUzdi0zLjAwMUg5LjU5M3YzLjZoLTIuNHYtNC44YzAtLjY2LjU0LTEuMiAxLjItMS4yaDYuMDAyVjYuNjA0bDQuMiA0LjItNC4yIDQuMjAyeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2NhbGVuZGFyJyxcbiAgcGF0aDogJ00xOC4xMTEgMTMuMkgxMnY2aDYuMTExdi02ek0xNi44OSAwdjIuNEg3LjExVjBINC42Njd2Mi40SDMuNDQ0Yy0xLjM1NiAwLTIuNDMyIDEuMDgtMi40MzIgMi40TDEgMjEuNkMxIDIyLjkyIDIuMDg4IDI0IDMuNDQ0IDI0aDE3LjExMkMyMS45IDI0IDIzIDIyLjkyIDIzIDIxLjZWNC44YzAtMS4zMi0xLjEtMi40LTIuNDQ0LTIuNGgtMS4yMjNWMEgxNi44OXptMy42NjcgMjEuNkgzLjQ0NFY4LjRoMTcuMTEydjEzLjJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnY2FsbG91dCcsXG4gIHBhdGg6ICdNMjEuOTkgNGMwLTEuMS0uODktMi0xLjk5LTJINGMtMS4xIDAtMiAuOS0yIDJ2MTJjMCAxLjEuOSAyIDIgMmgxNGw0IDQtLjAxLTE4eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2luZm8nLFxuICBwYXRoOiAnTTEyIDguNEExLjIgMS4yIDAgMTAxMiA2YTEuMiAxLjIgMCAwMDAgMi40ek0xMiAwYzYuNjI0IDAgMTIgNS4zNzYgMTIgMTJzLTUuMzc2IDEyLTEyIDEyUzAgMTguNjI0IDAgMTIgNS4zNzYgMCAxMiAwem0wIDE4Yy42NiAwIDEuMi0uNTQgMS4yLTEuMlYxMmMwLS42Ni0uNTQtMS4yLTEuMi0xLjItLjY2IDAtMS4yLjU0LTEuMiAxLjJ2NC44YzAgLjY2LjU0IDEuMiAxLjIgMS4yeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2JyaWVmY2FzZScsXG4gIHBhdGg6ICdNMjAgN2gtNFY1YzAtMS4xMS0uODktMi0yLTJoLTRjLTEuMTEgMC0yIC44OS0yIDJ2Mkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAyMGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY5YzAtMS4xMS0uODktMi0yLTJ6bS02IDBoLTRWNWg0djJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAna2Fib2InLFxuICB2aWV3Qm94OiAnMCAwIDMgMTEnLFxuICBjb21wbGV4Q29udGVudHM6IGA8Y2lyY2xlIGN4PVwiMS41XCIgY3k9XCIxLjVcIiByPVwiMS41XCIvPjxjaXJjbGUgY3g9XCIxLjVcIiBjeT1cIjUuNVwiIHI9XCIxLjVcIi8+PGNpcmNsZSBjeD1cIjEuNVwiIGN5PVwiOS41XCIgcj1cIjEuNVwiLz5gXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwZXJzb24nLFxuICB2aWV3Qm94OiAnMCAwIDE4IDE4JyxcbiAgcGF0aDogJ005IDljMi40ODYgMCA0LjUtMi4wMTQgNC41LTQuNVMxMS40ODYgMCA5IDBhNC40OTkgNC40OTkgMCAwMC00LjUgNC41QzQuNSA2Ljk4NiA2LjUxNCA5IDkgOXptMCAyLjI1Yy0zLjAwNCAwLTkgMS41MDgtOSA0LjV2MS4xMjVDMCAxNy40OTQuNTA2IDE4IDEuMTI1IDE4aDE1Ljc1Yy42MTkgMCAxLjEyNS0uNTA2IDEuMTI1LTEuMTI1VjE1Ljc1YzAtMi45OTItNS45OTYtNC41LTktNC41eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ21hZ25pZnlpbmdfZ2xhc3MnLFxuICBwYXRoOiAnTTE2LjEyNCAxMy4wNTFhNS4xNTQgNS4xNTQgMCAxMTAtMTAuMzA4IDUuMTU0IDUuMTU0IDAgMDEwIDEwLjMwOE0xNi4xMTQgMGE3Ljg4NiA3Ljg4NiAwIDAwLTYuNDYgMTIuNDA3TDAgMjIuMDYgMS45NCAyNGw5LjY1My05LjY1M0E3Ljg4NiA3Ljg4NiAwIDEwMTYuMTEzIDAnXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdvZmZpY2UnLFxuICBwYXRoOiAnTTEyIDdWM0gydjE4aDIwVjdIMTJ6TTYgMTlINHYtMmgydjJ6bTAtNEg0di0yaDJ2MnptMC00SDRWOWgydjJ6bTAtNEg0VjVoMnYyem00IDEySDh2LTJoMnYyem0wLTRIOHYtMmgydjJ6bTAtNEg4VjloMnYyem0wLTRIOFY1aDJ2MnptMTAgMTJoLTh2LTJoMnYtMmgtMnYtMmgydi0yaC0yVjloOHYxMHptLTItOGgtMnYyaDJ2LTJ6bTAgNGgtMnYyaDJ2LTJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbGluaycsXG4gIHBhdGg6ICdNMi4yOCAxMkEzLjcyMyAzLjcyMyAwIDAxNiA4LjI4aDQuOFY2SDZjLTMuMzEyIDAtNiAyLjY4OC02IDZzMi42ODggNiA2IDZoNC44di0yLjI4SDZBMy43MjMgMy43MjMgMCAwMTIuMjggMTJ6bTQuOTIgMS4yaDkuNnYtMi40SDcuMnYyLjR6TTE4IDZoLTQuOHYyLjI4SDE4QTMuNzIzIDMuNzIzIDAgMDEyMS43MiAxMiAzLjcyMyAzLjcyMyAwIDAxMTggMTUuNzJoLTQuOFYxOEgxOGMzLjMxMiAwIDYtMi42ODggNi02cy0yLjY4OC02LTYtNnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd3aW5kb3cnLFxuICBwYXRoOiAnTTMgMTNoOFYzSDN2MTB6bTAgOGg4di02SDN2NnptMTAgMGg4VjExaC04djEwem0wLTE4djZoOFYzaC04eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3Bob25lJyxcbiAgcGF0aDogJ000LjgyNyAxMC4zODdhMjAuMTk4IDIwLjE5OCAwIDAwOC43ODYgOC43ODZsMi45MzQtMi45MzNjLjM2LS4zNi44OTMtLjQ4IDEuMzYtLjMyYTE1LjIxIDE1LjIxIDAgMDA0Ljc2Ljc2Yy43MzMgMCAxLjMzMy42IDEuMzMzIDEuMzMzdjQuNjU0QzI0IDIzLjQgMjMuNCAyNCAyMi42NjcgMjQgMTAuMTQ3IDI0IDAgMTMuODUzIDAgMS4zMzMgMCAuNi42IDAgMS4zMzMgMEg2Yy43MzMgMCAxLjMzMy42IDEuMzMzIDEuMzMzIDAgMS42NjcuMjY3IDMuMjY3Ljc2IDQuNzYuMTQ3LjQ2Ny4wNC45ODctLjMzMyAxLjM2bC0yLjkzMyAyLjkzNHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd0YWcnLFxuICB2aWV3Qm94OiAnMCAwIDE4IDE4JyxcbiAgcGF0aDogJ00xNy40NjkgOC42MjJsLTguMS04LjFBMS43ODkgMS43ODkgMCAwMDguMSAwSDEuOEMuODEgMCAwIC44MSAwIDEuOHY2LjNjMCAuNDk1LjE5OC45NDUuNTMxIDEuMjc4bDguMSA4LjFjLjMyNC4zMjQuNzc0LjUyMiAxLjI2OS41MjJhMS43NiAxLjc2IDAgMDAxLjI2OS0uNTMxbDYuMy02LjNBMS43NiAxLjc2IDAgMDAxOCA5LjljMC0uNDk1LS4yMDctLjk1NC0uNTMxLTEuMjc4ek0zLjE1IDQuNWMtLjc0NyAwLTEuMzUtLjYwMy0xLjM1LTEuMzUgMC0uNzQ3LjYwMy0xLjM1IDEuMzUtMS4zNS43NDcgMCAxLjM1LjYwMyAxLjM1IDEuMzUgMCAuNzQ3LS42MDMgMS4zNS0xLjM1IDEuMzV6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnZG9jdW1lbnQnLFxuICBwYXRoOiAnTTQgNkgydjE0YzAgMS4xLjkgMiAyIDJoMTR2LTJINFY2em0xNi00SDhjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTJjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnptLTEgOUg5VjloMTB2MnptLTQgNEg5di0yaDZ2MnptNC04SDlWNWgxMHYyeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2NoZXZyb24nLFxuICB2aWV3Qm94OiAnMCAwIDcgOScsXG4gIGNvbXBsZXhDb250ZW50czogYDxnIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTEgLTgpXCI+PHBhdGggZD1cIm0yLjY0MTcwMDQgOC0xLjE0MTcwMDQgMS4wNTc1IDMuNzA4NTAyMDIgMy40NDI1LTMuNzA4NTAyMDIgMy40NDI1IDEuMTQxNzAwNCAxLjA1NzUgNC44NTgyOTk2LTQuNXpcIi8+PC9nPmBcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3N1cHBvcnQnLFxuICBwYXRoOiAnTTEyLDAgQzUuMzc2LDAgMCw1LjM3NiAwLDEyIEMwLDE4LjYyNCA1LjM3NiwyNCAxMiwyNCBDMTguNjI0LDI0IDI0LDE4LjYyNCAyNCwxMiBDMjQsNS4zNzYgMTguNjI0LDAgMTIsMCBaIE0xMywxOSBMMTEsMTkgTDExLDE3IEwxMywxNyBMMTMsMTkgWiBNMTUuMDcsMTEuMjUgTDE0LjE3LDEyLjE3IEMxMy40NSwxMi45IDEzLDEzLjUgMTMsMTUgTDExLDE1IEwxMSwxNC41IEMxMSwxMy40IDExLjQ1LDEyLjQgMTIuMTcsMTEuNjcgTDEzLjQxLDEwLjQxIEMxMy43OCwxMC4wNSAxNCw5LjU1IDE0LDkgQzE0LDcuOSAxMy4xLDcgMTIsNyBDMTAuOSw3IDEwLDcuOSAxMCw5IEw4LDkgQzgsNi43OSA5Ljc5LDUgMTIsNSBDMTQuMjEsNSAxNiw2Ljc5IDE2LDkgQzE2LDkuODggMTUuNjQsMTAuNjggMTUuMDcsMTEuMjUgWidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3lleHQnLFxuICB2aWV3Qm94OiAnMCAwIDMwIDMwJyxcbiAgcGF0aDogJ00yNS41MTcgMjguMTQydi4wOTVoLS4yMDR2LjkwNWgtLjA2NnYtLjkwNWgtLjE5N3YtLjA5NWguNDY3em0uNjY3IDBoLjA2NnYxaC0uMDY2di0uODI1bC0uMjQuNTk1aC0uMDEzbC0uMjQtLjU5NXYuODI1aC0uMDY2di0xaC4wNjZsLjI0Ny42MS4yNDYtLjYxek0xNSAyOC44YzcuNjIyIDAgMTMuOC02LjE3OCAxMy44LTEzLjggMC03LjYyMi02LjE3OC0xMy44LTEzLjgtMTMuOEM3LjM3OCAxLjIgMS4yIDcuMzc4IDEuMiAxNWMwIDcuNjIyIDYuMTc4IDEzLjggMTMuOCAxMy44ek0xNSAwYzguMjg0IDAgMTUgNi43MTYgMTUgMTUgMCA4LjI4NC02LjcxNiAxNS0xNSAxNS04LjI4NCAwLTE1LTYuNzE2LTE1LTE1QzAgNi43MTYgNi43MTYgMCAxNSAwem0uNDUgMTYuNjV2LTEuMmg2LjZ2MS4yaC0yLjd2NS40aC0xLjJ2LTUuNGgtMi43em0tMS41OTktMS4zNWwuODQ5Ljg0OS0yLjYwMSAyLjYwMSAyLjYwMSAyLjYwMS0uODQ5Ljg0OS0yLjYwMS0yLjYwMUw4LjY0OSAyMi4ybC0uODQ5LS44NDkgMi42MDEtMi42MDFMNy44IDE2LjE0OWwuODQ5LS44NDkgMi42MDEgMi42MDEgMi42MDEtMi42MDF6TTE4LjY3NSA5YTIuMTc1IDIuMTc1IDAgMDAtMS44NDcgMy4zMjNsMi45OTUtMi45OTVBMi4xNjMgMi4xNjMgMCAwMDE4LjY3NSA5em0wIDUuNTVhMy4zNzUgMy4zNzUgMCAxMTIuODMzLTUuMjA5bC0zLjc4OSAzLjc4OGEyLjE3NSAyLjE3NSAwIDAwMy4xMy0xLjk1NGgxLjIwMWEzLjM3NSAzLjM3NSAwIDAxLTMuMzc1IDMuMzc1em0tNy40MjUtMy43MzRMMTMuNzggNy44bC45Mi43NzEtMi44NSAzLjM5N3YyLjU4MmgtMS4ydi0yLjU4Mkw3LjggOC41N2wuOTItLjc3MSAyLjUzIDMuMDE2eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3BpbicsXG4gIHZpZXdCb3g6ICc1IDAgOSAxOCcsXG4gIHBhdGg6ICdtOS4zNzUgMGMtMy41MjQ0NjQyOSAwLTYuMzc1IDIuODE3LTYuMzc1IDYuMyAwIDQuNzI1IDYuMzc1IDExLjcgNi4zNzUgMTEuN3M2LjM3NS02Ljk3NSA2LjM3NS0xMS43YzAtMy40ODMtMi44NTA1MzU3LTYuMy02LjM3NS02LjN6bS4wMDAwMDAxOCA4LjU1MDAwMDA3Yy0xLjI1Njc4NTc2IDAtMi4yNzY3ODU3OS0xLjAwOC0yLjI3Njc4NTc5LTIuMjVzMS4wMjAwMDAwMy0yLjI1IDIuMjc2Nzg1NzktMi4yNWMxLjI1Njc4NTcyIDAgMi4yNzY3ODU4MiAxLjAwOCAyLjI3Njc4NTgyIDIuMjVzLTEuMDIwMDAwMSAyLjI1LTIuMjc2Nzg1ODIgMi4yNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdnZWFyJyxcbiAgcGF0aDogJ00xMiAxMGMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTctN0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGEyIDIgMCAwMDItMlY1YTIgMiAwIDAwLTItMnptLTEuNzUgOWMwIC4yMy0uMDIuNDYtLjA1LjY4bDEuNDggMS4xNmMuMTMuMTEuMTcuMy4wOC40NWwtMS40IDIuNDJjLS4wOS4xNS0uMjcuMjEtLjQzLjE1bC0xLjc0LS43Yy0uMzYuMjgtLjc2LjUxLTEuMTguNjlsLS4yNiAxLjg1Yy0uMDMuMTctLjE4LjMtLjM1LjNoLTIuOGMtLjE3IDAtLjMyLS4xMy0uMzUtLjI5bC0uMjYtMS44NWMtLjQzLS4xOC0uODItLjQxLTEuMTgtLjY5bC0xLjc0LjdjLS4xNi4wNi0uMzQgMC0uNDMtLjE1bC0xLjQtMi40MmEuMzUzLjM1MyAwIDAxLjA4LS40NWwxLjQ4LTEuMTZjLS4wMy0uMjMtLjA1LS40Ni0uMDUtLjY5IDAtLjIzLjAyLS40Ni4wNS0uNjhsLTEuNDgtMS4xNmEuMzUzLjM1MyAwIDAxLS4wOC0uNDVsMS40LTIuNDJjLjA5LS4xNS4yNy0uMjEuNDMtLjE1bDEuNzQuN2MuMzYtLjI4Ljc2LS41MSAxLjE4LS42OWwuMjYtMS44NWMuMDMtLjE3LjE4LS4zLjM1LS4zaDIuOGMuMTcgMCAuMzIuMTMuMzUuMjlsLjI2IDEuODVjLjQzLjE4LjgyLjQxIDEuMTguNjlsMS43NC0uN2MuMTYtLjA2LjM0IDAgLjQzLjE1bDEuNCAyLjQyYy4wOS4xNS4wNS4zNC0uMDguNDVsLTEuNDggMS4xNmMuMDMuMjMuMDUuNDYuMDUuNjl6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbGlnaHRfYnVsYicsXG4gIHZpZXdCb3g6ICcwIDAgMzIgMzUnLFxuICBwYXRoOiAnTTExLjU4NSAzMS4wNTZsOC4zOC0uNDkzdi0uOTg2bC04LjM4LjQ5M3pNMTEuNTg1IDMzLjAyOEwxNS43NzUgMzVsNC4xOS0xLjk3MlYzMS41NWwtOC4zOC40OTN2Ljk4NnptNi45MjYtLjQwN2wtMi43MzYgMS4yOS0yLjEzLTEuMDA0IDQuODY2LS4yODZ6TTE1Ljc3NSA3LjM5NGMtNC42MyAwLTguMzggMy4yMDUtOC4zOCA4LjM4IDAgNS4xNzcgNC4xOSA2LjkwMiA0LjE5IDEyLjgxOHYuNDkzbDguMzgtLjQ5M2MwLTUuOTE2IDQuMTktOC4xODggNC4xOS0xMi44MTdhOC4zOCA4LjM4IDAgMDAtOC4zOC04LjM4em01LjYxNyAxMy40OGMtMS4wMjUgMS44MzctMi4xNzQgMy44OTItMi4zODEgNi43ODZsLTYuNDQuMzhjLS4xMjktMy4wMS0xLjI5LTUuMDIxLTIuMzItNi44MDgtLjQ5My0uOC0uOTI4LTEuNjM2LTEuMjk5LTIuNWgxMy41NTZjLS4zMjUuNzA4LS43MDQgMS40MDMtMS4xMTYgMi4xNDJ6bTEuNDc5LTMuMTI4SDguNjI3YTcuNzkzIDcuNzkzIDAgMDEtLjI0Ny0xLjk3MWMwLTQuMzUzIDMuMDQyLTcuMzk1IDcuMzk1LTcuMzk1YTcuMzk0IDcuMzk0IDAgMDE3LjM5NCA3LjM5NSA2LjczOSA2LjczOSAwIDAxLS4zIDEuOTcxaC4wMDJ6TTI2LjYyIDE1LjI4Mmg0LjkzdjFoLTQuOTN6TTIzLjA5NCA3Ljc1NmwyLjA5MS0yLjA5MS42OTguNjk3LTIuMDkyIDIuMDkyek0xNS4yODIgMGgxdjQuOTNoLTF6TTUuNjY2IDYuMzYybC42OTctLjY5NyAyLjA5MSAyLjA5MS0uNjk3LjY5N3pNMCAxNS4yODJoNC45M3YxSDB6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnc3RhcicsXG4gIHZpZXdCb3g6ICcwIDAgMTggMTgnLFxuICBwYXRoOiAnTTguOTkxIDBDNC4wMjMgMCAwIDQuMDMyIDAgOXM0LjAyMyA5IDguOTkxIDlDMTMuOTY4IDE4IDE4IDEzLjk2OCAxOCA5cy00LjAzMi05LTkuMDA5LTl6bTMuODE2IDE0LjRMOSAxMi4xMDUgNS4xOTMgMTQuNGwxLjAwOC00LjMyOS0zLjM1Ny0yLjkwNyA0LjQyOC0uMzc4TDkgMi43bDEuNzI4IDQuMDc3IDQuNDI4LjM3OC0zLjM1NyAyLjkwN3onXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjbG9zZScsXG4gIGNvbXBsZXhDb250ZW50czogYFxuICAgIDxwYXRoIGQ9XCJNNyA4bDkuNzE2IDkuNzE2bTAtOS43MTZMNyAxNy43MTZcIiBcbiAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBcbiAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCIvPlxuICBgXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdlbGVtZW50cycsXG4gIHBhdGg6ICdNMTMsMTUgTDEzLDE3IEwyMSwxNyBMMjEsMTkgTDEzLDE5IEwxMywyMSBMMTEsMjEgTDExLDE1IEwxMywxNSBaIE05LDE3IEw5LDE5IEwzLDE5IEwzLDE3IEw5LDE3IFogTTksMTUgTDcsMTUgTDcsMTMgTDMsMTMgTDMsMTEgTDcsMTEgTDcsOSBMOSw5IEw5LDE1IFogTTIxLDExIEwyMSwxMyBMMTEsMTMgTDExLDExIEwyMSwxMSBaIE0xNywzIEwxNyw1IEwyMSw1IEwyMSw3IEwxNyw3IEwxNyw5IEwxNSw5IEwxNSwzIEwxNywzIFogTTEzLDUgTDEzLDcgTDMsNyBMMyw1IEwxMyw1IFonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd5ZXh0X2FuaW1hdGVkX3JldmVyc2UnLFxuICB2aWV3Qm94OiAnMCAwIDcyIDcyJyxcbiAgY29tcGxleENvbnRlbnRzOiAocGFyYW1zID0ge30pID0+IHtcbiAgICBjb25zdCBpY29uUHJlZml4ID0gcGFyYW1zLmljb25QcmVmaXggfHwgJ3l4dCc7XG4gICAgcmV0dXJuIGA8ZGVmcz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMVwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTE0NC4zXCIgeT1cIjE0NC4zXCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNLTAuMyAuMWMwIDAgMS4zIDEuMiAxLjMgMS4yYzAgMCAuMy0xLjYgLjMtMS42YzAgMC0xLjYgLjQtMS42IC40XCIgLz5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTS4zIC43YzAgMC0wLjMgLjMtMC4zIC4zYzAgMCAwIDAgMCAwYzAgMCAuMy0wLjMgLjMtMC4zYzAgMCAwIDAgMCAwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0uMyAuN2MwIDAtMC4xIDAtMC4xIDBjMCAwIC4xIC4xIC4xIC4xYzAgMCAuMS0wLjEgLjEtMC4xYzAgMC0wLjEgMC0wLjEgMG0yMjIuOCA0NjkuMWMwIDAtNzAuNSA2OS40LTcwLjUgNjkuNGMwIDAgMzQuMSAzMy41IDM0LjEgMzMuNWMwIDAgNjctNzIuOSA2Ny03Mi45YzAgMC0zMC42LTMwLTMwLjYtMzBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0zXCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ4OS44IDI3Ny40YzAgMCA3OCAxOC44IDc4IDE4LjhjMCAwLTk2LjEgNjEuNS05Ni4xIDYxLjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMTMuOSAxNC0xMy45IDE0bS02Ny44LTEwOC4xYzAgMCA3My45IDEuMyA3My45IDEuM2MwIDAtMzMuOCA1NC41LTMzLjggNTQuNWMwIDAgMTguNi0zLjIgMTguNi0zLjJjMCAwIDM1LjQtMzYuNSAzNS40LTM2LjVjMCAwLTYyLTI1LjktNjItMjUuOWMwIDAtMzIuMSA5LjgtMzIuMSA5LjhcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay00XCI+XG4gICAgICAgIDxyZWN0IHg9XCItOTEuMVwiIHk9XCI5MS4xXCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNLTAuMyAuMWMwIDAgMS4zIDEuMiAxLjMgMS4yYzAgMCAuMy0xLjYgLjMtMS42YzAgMC0xLjYgLjQtMS42IC40XCIgLz5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTS4zIC43YzAgMC0wLjMgLjMtMC4zIC4zYzAgMCAwIDAgMCAwYzAgMCAuMy0wLjMgLjMtMC4zYzAgMCAwIDAgMCAwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0uMyAuN2MwIDAtMC4xIDAtMC4xIDBjMCAwIC4xIC4xIC4xIC4xYzAgMCAuMS0wLjEgLjEtMC4xYzAgMC0wLjEgMC0wLjEgMG0yMjIuOCA0NjkuMWMwIDAtNzAuNSA2OS40LTcwLjUgNjkuNGMwIDAgMzQuMSAzMy41IDM0LjEgMzMuNWMwIDAgNjctNzIuOSA2Ny03Mi45YzAgMC0zMC42LTMwLTMwLjYtMzBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay01XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ4OC40IDI5MS40YzAgMCA0MC41IDM5LjMgNDAuNSAzOS4zYzAgMC01Ny4yIDI3LTU3LjIgMjdjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMTUuMyAyOC0xNS4zIDI4bS05MC41LTk3LjRjMCAwIDUyLTExLjMgNTItMTEuM2MwIDAtNiA0NS4yLTYgNDUuMmMwIDAgMzYuOC02IDM2LjgtNmMwIDAgMzkuMy0zMS45IDM5LjMtMzEuOWMwIDAtNjUuOS0zMC41LTY1LjktMzAuNWMwIDAtNTYuMiAzNC41LTU2LjIgMzQuNVwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTZcIj5cbiAgICAgICAgPHJlY3QgeD1cIi02MS4zXCIgeT1cIjYxLjNcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stN1wiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00ODEuOCAyOTguNGMwIDAgMjcuNSAzOS44IDI3LjUgMzkuOGMwIDAtMzcuNiAxOS41LTM3LjYgMTkuNWMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC0yMS45IDM1LTIxLjkgMzVtLTEwOC4xLTc5LjdjMCAwIDMwLjItMjMuOCAzMC4yLTIzLjhjMCAwIDIxLjcgMzUuOSAyMS43IDM1LjljMCAwIDU1LjEtOC45IDU1LjEtOC45YzAgMCAzNS40LTM2LjUgMzUuNC0zNi41YzAgMC02Mi0yNS45LTYyLTI1LjljMCAwLTgwLjQgNTkuMi04MC40IDU5LjJcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay04XCI+XG4gICAgICAgIDxyZWN0IHg9XCItNDIuNlwiIHk9XCI0Mi42XCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTlcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDc1LjIgMzA1LjRjMCAwIDE0LjUgNDAuMyAxNC41IDQwLjNjMCAwLTE4IDEyLTE4IDEyYzAgMCA1OS42LTQxLjEgNTkuNi00MS4xYzAgMCAxMC42LTUzLjggMTAuNi01My44YzAgMC0zOC4yIC42LTM4LjIgLjZjMCAwLTI4LjUgNDItMjguNSA0Mm0tMTEzLjYtNzQuM2MwIDAgMTcuOS0xOC41IDE3LjktMTguNWMwIDAgMzYuNCAyNS4zIDM2LjQgMjUuM2MwIDAgNjQuOC0xNiA2NC44LTE2YzAgMCAzOS4zLTMxLjkgMzkuMy0zMS45YzAgMC02NS45LTMwLjUtNjUuOS0zMC41YzAgMC05Mi41IDcxLjYtOTIuNSA3MS42XCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMTBcIj5cbiAgICAgICAgPHJlY3QgeD1cIi0yOS42XCIgeT1cIjI5LjZcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMTFcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDY4LjYgMzEyLjRjMCAwIDEuNSA0MC44IDEuNSA0MC44YzAgMCAxLjYgNC41IDEuNiA0LjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMzUuMSA0OS0zNS4xIDQ5bS0xMDctODEuM2MwIDAgMTUuMSA0LjkgMTUuMSA0LjljMCAwIDM4LjIgMTMuMyAzOC4yIDEzLjNjMCAwIDY1LjgtMjcuNCA2NS44LTI3LjRjMCAwIDM5LjMtMjEuOSAzOS4zLTIxLjljMCAwLTY1LjktNDAuNS02NS45LTQwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xMlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTIwLjNcIiB5PVwiMjAuM1wiIGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xM1wiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00NTYuNiAzMTEuOWMwIDAtNyAzNS42LTcgMzUuNmMwIDAgMjIuMSAxMC4yIDIyLjEgMTAuMmMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC00Ny4xIDQ4LjUtNDcuMSA0OC41bS05NS04MC44YzAgMCAxMi4zIDI4LjMgMTIuMyAyOC4zYzAgMCAzOS45IDEuMyAzOS45IDEuM2MwIDAgNjYuOS0zOC44IDY2LjktMzguOGMwIDAgMzkuMy0yMS45IDM5LjMtMjEuOWMwIDAtNjUuOS00MC41LTY1LjktNDAuNWMwIDAtOTIuNSA3MS42LTkyLjUgNzEuNlwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTE0XCI+XG4gICAgICAgIDxyZWN0IHg9XCItMTMuNFwiIHk9XCIxMy40XCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTE1XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ0NC42IDMxMS40YzAgMC0xNS42IDMwLjUtMTUuNiAzMC41YzAgMCA0Mi43IDE1LjggNDIuNyAxNS44YzAgMCA1OS42LTQxLjEgNTkuNi00MS4xYzAgMCAxMC42LTUzLjggMTAuNi01My44YzAgMC0zOC4yIC42LTM4LjIgLjZjMCAwLTU5LjEgNDgtNTkuMSA0OG0tODMtODAuM2MwIDAgOS41IDUxLjcgOS41IDUxLjdjMCAwIDQxLjctMTAuOCA0MS43LTEwLjhjMCAwIDY3LjktNTAuMSA2Ny45LTUwLjFjMCAwIDUwLjYtMzEuOSA1MC42LTMxLjljMCAwLTc3LjItMzAuNS03Ny4yLTMwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xNlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTcuM1wiIHk9XCI3LjNcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMTdcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDMyLjYgMzEwLjljMCAwLTI0LjIgMjUuMy0yNC4yIDI1LjNjMCAwIDYzLjMgMjEuNSA2My4zIDIxLjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtNzEuMSA0Ny41LTcxLjEgNDcuNW0tNzEtNzkuOGMwIDAgMjAuMyA5MC40IDIwLjMgOTAuNGMwIDAgMjktMjkuNSAyOS0yOS41YzAgMCA2OS44LTcwLjEgNjkuOC03MC4xYzAgMCAzNS40LTM2LjUgMzUuNC0zNi41YzAgMC02Mi0yNS45LTYyLTI1LjljMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xOFwiPlxuICAgICAgICA8cmVjdCB4PVwiLTRcIiB5PVwiNFwiIGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xOVwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00MzIuNiAzMTAuOWMwIDAtMjQuMiAyNS4zLTI0LjIgMjUuM2MwIDAgNjMuMyAyMS41IDYzLjMgMjEuNWMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC03MS4xIDQ3LjUtNzEuMSA0Ny41bS03MS03OS44YzAgMCAyMC4zIDkwLjQgMjAuMyA5MC40YzAgMCAyOS0yOS41IDI5LTI5LjVjMCAwIDY5LjgtNzAuMSA2OS44LTcwLjFjMCAwIDM5LjMtMzEuOSAzOS4zLTMxLjljMCAwLTY1LjktMzAuNS02NS45LTMwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0yMFwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxjbGlwUGF0aCBpZD1cIiR7aWNvblByZWZpeH1fcmV2ZXJzZV9DbGlwUGF0aC0xXCI+XG4gICAgICAgIDxyZWN0IHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvY2xpcFBhdGg+XG4gICAgPC9kZWZzPlxuICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLDApIHNjYWxlKC4xLC4xKVwiPlxuICAgICAgPGcgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk0zNzcuNSAzOTUuM2MwIDAgNjQuOCAwIDY0LjggMGMwIDAgMCAxMjkuNiAwIDEyOS42YzAgMCAyOC44IDAgMjguOCAwYzAgMCAwLTEyOS42IDAtMTI5LjZjMCAwIDY0LjggMCA2NC44IDBjMCAwIDAtMjguOCAwLTI4LjhjMCAwLTE1OC40IDAtMTU4LjQgMGMwIDAgMCAyOC44IDAgMjguOFpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMzOC45IDM2My42YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMC0yMC40IDIwLjQtMjAuNCAyMC40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMCAyMC4zLTIwLjQgMjAuMy0yMC40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMC0yMC4zLTIwLjQtMjAuMy0yMC40WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDU0LjcgMzQ1LjhjNDQuOCAwIDgxLTM2LjMgODEtODFjMCAwLTI4LjggMC0yOC44IDBjMCAyOC44LTIzLjMgNTIuMi01Mi4yIDUyLjJjLTguMiAwLTE2LTEuOS0yMi45LTUuM2MwIDAgNjkuOC02OS45IDY5LjgtNjkuOWMwIDAgMjEuMS0yMSAyMS4xLTIxYy0xNC40LTIyLjMtMzkuNS0zNy02OC0zN2MtNDQuNyAwLTgxIDM2LjItODEgODFjMCA0NC43IDM2LjMgODEgODEgODFabTAtMTMzLjJjMTAuMiAwIDE5LjYgMi45IDI3LjYgNy45YzAgMC03MS45IDcxLjgtNzEuOSA3MS44Yy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtNjAuNy03Mi44LTYwLjctNzIuOGMwIDAtMjIuMSAxOC42LTIyLjEgMTguNmMwIDAgNjguNCA4MiA2OC40IDgyYzAgMCAwIDYyLjQgMCA2Mi40YzAgMCAyOC44IDAgMjguOCAwYzAgMCAwLTYyLjYgMC02Mi42YzAgMCA2OC40LTgxLjggNjguNC04MS44YzAgMC0yMi0xOC42LTIyLTE4LjZjMCAwLTYwLjggNzIuOC02MC44IDcyLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0zNTMuN2MxOTUuMiAwIDM1My43IDE1OC41IDM1My43IDM1My43YzAgMTk1LjItMTU4LjUgMzUzLjctMzUzLjcgMzUzLjdjLTE5NS4yIDAtMzUzLjctMTU4LjUtMzUzLjctMzUzLjdjMC0xOTUuMiAxNTguNS0zNTMuNyAzNTMuNy0zNTMuN1pcIiBmaWxsPVwibm9uZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzNTkuOCwzNjAuNCkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0yKVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNDQuMywtMTQ0LjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMzkwLjYgMzk1LjJjMCAwIDUxLjcgLjEgNTEuNyAuMWMwIDAgLjEgMTAzLjYgLjEgMTAzLjZjMCAwIDI4LjcgMCAyOC43IDBjMCAwIDAtMTAzLjYgMC0xMDMuNmMwIDAgNTItMC4xIDUyLTAuMWMwIDAgMC0yOC40IDAtMjguNGMwIDAtMTMyLjUgMC0xMzIuNSAwYzAgMCAwIDI4LjQgMCAyOC40WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMzI5IDM3My40YzAgLjEtNTIuNiA1Mi42LTUyLjYgNTIuNmMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAtMjAuNCAyMC40LTIwLjQgMjAuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAgMjAuMy0yMC40IDIwLjMtMjAuNGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAgNTIuNi01Mi42IDUyLjYtNTIuNmMwIDAtMjAuNC0yMC4zLTIwLjQtMjAuM1pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ1NC43IDM0NS44YzQ0LjggMCA4MS0zNi4zIDgxLTgxYzAgMC0yOC44IDAtMjguOCAwYzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNjMCAwIDY5LjgtNjkuOSA2OS44LTY5LjljMCAwIDIxLjEtMjEgMjEuMS0yMWMtMTQuNC0yMi4zLTM5LjUtMzctNjgtMzdjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxWm0wLTEzMy4yYzEwLjIgMCAxOS42IDIuOSAyNy42IDcuOWMwIDAtNzEuOSA3MS44LTcxLjkgNzEuOGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjc2LjQgMjU1LjljMCAwLTQ4LjctNTguMy00OC43LTU4LjNjMCAwLTIxLjEgMTktMjEuMSAxOWMwIDAgNTUuNSA2Ny4yIDU1LjUgNjcuMmMwIDAgLjMgNTAgLjMgNTBjMCAwIDI4LjQgMCAyOC40IDBjMCAwIDAtNTAuMyAwLTUwLjNjMCAwIDU1LjQtNjYuOSA1NS40LTY2LjljMCAwLTIxLTE4LjYtMjEtMTguNmMwIDAtNDguOCA1Ny45LTQ4LjggNTcuOVpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPHBhdGggc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjMwXCIgZD1cIk0wLTMzNi4yYzE4NS42IDAgMzM2LjIgMTUwLjYgMzM2LjIgMzM2LjJjMCAxODUuNi0xNTAuNiAzMzYuMi0zMzYuMiAzMzYuMmMtMTg1LjYgMC0zMzYuMi0xNTAuNi0zMzYuMi0zMzYuMmMwLTE4NS42IDE1MC42LTMzNi4yIDMzNi4yLTMzNi4yWlwiIGZpbGw9XCJub25lXCIgZGlzcGxheT1cImJsb2NrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM3MC44LDM0Ny41KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTQpXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDkxLjEsLTkxLjEpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTUpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDA5LjcgMzk1LjFjMCAwIDMyLjYgLjIgMzIuNiAuMmMwIDAgLjMgNjUuNSAuMyA2NS41YzAgMCAyOC41IDAgMjguNSAwYzAgMCAwLTY1LjUgMC02NS41YzAgMCAzMy4xLTAuMiAzMy4xLTAuMmMwIDAgMC0yNy44IDAtMjcuOGMwIDAtOTQuNSAwLTk0LjUgMGMwIDAgMCAyNy44IDAgMjcuOFpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMxOS43IDM4Mi44YzAgMC00My4zIDQzLjItNDMuMyA0My4yYzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMC0yMC40IDIwLjQtMjAuNCAyMC40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMCAyMC4zLTIwLjQgMjAuMy0yMC40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMCA0My40LTQzLjMgNDMuNC00My4zYzAgMC0yMC41LTIwLjMtMjAuNS0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLTE1LjgtNDguMS0xNS44Yy00NC43IDAtODEgMzYuMi04MSA4MWMwIDQ0LjcgMzYuMyA4MSA4MSA4MWM0NC44IDAgODEtMzYuMyA4MS04MWgtMjguOGMwIDI4LjgtMjMuMyA1Mi4yLTUyLjIgNTIuMmMtOC4yIDAtMTYtMS45LTIyLjktNS4zbDY5LjgtNjkuOWwuMy0wLjJsLTIwLjMtMjAuNGwtNzEuMiA3MS4xYy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJjMTAuMSAwIDE5LjQgMi44IDI3LjQgNy43WlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTI3Ni40IDI1NS45YzAgMC0zMS4xLTM3LTMxLjEtMzdjMCAwLTE5LjcgMTkuNS0xOS43IDE5LjVjMCAwIDM2LjcgNDUuNiAzNi43IDQ1LjZjMCAwIC43IDMxLjggLjcgMzEuOGMwIDAgMjcuNyAwIDI3LjcgMGMwIDAgMC0zMi40IDAtMzIuNGMwIDAgMzYuNS00NC45IDM2LjUtNDQuOWMwIDAtMTkuNi0xOC42LTE5LjYtMTguNmMwIDAtMzEuMiAzNi0zMS4yIDM2WlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8cGF0aCBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMzBcIiBkPVwiTTAtMzEwYzE3MS4xIDAgMzEwIDEzOC45IDMxMCAzMTBjMCAxNzEuMS0xMzguOSAzMTAtMzEwIDMxMGMtMTcxLjEgMC0zMTAtMTM4LjktMzEwLTMxMGMwLTE3MS4xIDEzOC45LTMxMCAzMTAtMzEwWlwiIGZpbGw9XCJub25lXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM4Ny44LDMyOC43KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTYpXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDYxLjMsLTYxLjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTcpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDIwLjQgMzk1YzAgMCAyMS45IC4zIDIxLjkgLjNjMCAwIC40IDQ0LjEgLjQgNDQuMWMwIDAgMjguNCAwIDI4LjQgMGMwIDAgMC00NC4xIDAtNDQuMWMwIDAgMjIuNi0wLjMgMjIuNi0wLjNjMCAwIDAtMjcuNSAwLTI3LjVjMCAwLTczLjMgMC03My4zIDBjMCAwIDAgMjcuNSAwIDI3LjVaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0zMTMuMiAzODkuMmMwIDAtMzYuOCAzNi44LTM2LjggMzYuOGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAtMjAuNCAyMC40LTIwLjQgMjAuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAgMjAuMy0yMC40IDIwLjMtMjAuNGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAgMzctMzYuOSAzNy0zNi45YzAgMC0yMC42LTIwLjMtMjAuNi0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAwIDIwMGMtMTMuNC05LjktMjcuMi0xNi4yLTQ1LjMtMTYuMmMtNDQuNyAwLTgxIDM2LjItODEgODFjMCA0NC43IDM2LjMgODEgODEgODFjNDQuOCAwIDgxLTM2LjMgODEtODFoLTI4LjhjMCAyOC44LTIzLjMgNTIuMi01Mi4yIDUyLjJjLTguMiAwLTE2LTEuOS0yMi45LTUuM2w1Ny43LTU3LjdsLTIwLjMtMjAuNGwtNTguOCA1OC43Yy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJjMTAuMSAwIDE5LjQgMi44IDI3LjQgNy43WlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTI3Ni40IDI1NS45YzAgMC0yMS4yLTI1LjEtMjEuMi0yNS4xYzAgMC0xOSAxOS44LTE5IDE5LjhjMCAwIDI2LjIgMzMuNSAyNi4yIDMzLjVjMCAwIDEgMjEuNiAxIDIxLjZjMCAwIDI3LjIgMCAyNy4yIDBjMCAwIDAtMjIuMyAwLTIyLjNjMCAwIDI1LjktMzIuNyAyNS45LTMyLjdjMCAwLTE4LjgtMTguNi0xOC44LTE4LjZjMCAwLTIxLjMgMjMuOC0yMS4zIDIzLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yOTQuM2MxNjIuNCAwIDI5NC4zIDEzMS45IDI5NC4zIDI5NC4zYzAgMTYyLjQtMTMxLjkgMjk0LjMtMjk0LjMgMjk0LjNjLTE2Mi40IDAtMjk0LjMtMTMxLjktMjk0LjMtMjk0LjNjMC0xNjIuNCAxMzEuOS0yOTQuMyAyOTQuMy0yOTQuM1pcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzOTguNywzMTguMikgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay04KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0Mi42LC00Mi42KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay05KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTQyNy4yIDM5NC45YzAgMCAxNS4xIC40IDE1LjEgLjRjMCAwIC40IDMwLjcgLjQgMzAuN2MwIDAgMjguNCAwIDI4LjQgMGMwIDAgMC0zMC43IDAtMzAuN2MwIDAgMTUuOS0wLjQgMTUuOS0wLjRjMCAwIDAtMjcuMiAwLTI3LjJjMCAwLTU5LjggMC01OS44IDBjMCAwIDAgMjcuMiAwIDI3LjJaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0zMDcuNCAzOTVjMCAwLTMxIDMxLTMxIDMxYzAgMC01My45LTU0LTUzLjktNTRjMCAwLTIwLjQgMjAuNC0yMC40IDIwLjRjMCAwIDU0IDU0IDU0IDU0YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA1NCA1NCA1NCA1NGMwIDAgMjAuNC0yMC4zIDIwLjQtMjAuM2MwIDAtNTQtNTQuMS01NC01NC4xYzAgMCAzMS4yLTMxLjEgMzEuMi0zMS4xYzAgMC0yMC42LTIwLjMtMjAuNi0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsNDUuNS00NS41bC0yMC40LTIwLjRsLTQ2LjUgNDYuNWMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtMTUtMTcuNi0xNS0xNy42YzAgMC0xOC40IDIwLTE4LjQgMjBjMCAwIDE5LjQgMjUuOCAxOS40IDI1LjhjMCAwIDEuMiAxNS4yIDEuMiAxNS4yYzAgMCAyNyAwIDI3IDBjMCAwIDAtMTUuOSAwLTE1LjljMCAwIDE5LjEtMjQuOSAxOS4xLTI0LjljMCAwLTE4LjItMTguNy0xOC4yLTE4LjdjMCAwLTE1LjEgMTYuMS0xNS4xIDE2LjFaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yODQuNGMxNTcgMCAyODQuNCAxMjcuNCAyODQuNCAyODQuNGMwIDE1Ny0xMjcuNCAyODQuNC0yODQuNCAyODQuNGMtMTU3IDAtMjg0LjQtMTI3LjQtMjg0LjQtMjg0LjRjMC0xNTcgMTI3LjQtMjg0LjQgMjg0LjQtMjg0LjRaXCIgZmlsbD1cIm5vbmVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDA2LjEsMzExLjYpIHNjYWxlKC45NzcsLjk3NylcIiAvPlxuICAgIDwvZz5cbiAgICA8ZyBvcGFjaXR5PVwiMFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLDApIHNjYWxlKC4xLC4xKVwiPlxuICAgICAgPGcgZGlzcGxheT1cImJsb2NrXCIgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMTApXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDI5LjYsLTI5LjYpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTExKVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTQzNiAzOTMuNWMwIDAgOC43IC40IDguNyAuNGMwIDAgLjQgMTcuOCAuNCAxNy44YzAgMCAyMy42IDAgMjMuNiAwYzAgMCAwLTE3LjggMC0xNy44YzAgMCA5LjQtMC40IDkuNC0wLjRjMCAwIDAtMjIuNiAwLTIyLjZjMCAwLTQyLjEgMC00Mi4xIDBjMCAwIDAgMjIuNiAwIDIyLjZaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yOTcuMiA0MDUuMmMwIDAtMjAuOCAyMC44LTIwLjggMjAuOGMwIDAtMzUuNC0zNS42LTM1LjQtMzUuNmMwIDAtMjAuMyAyMC41LTIwLjMgMjAuNWMwIDAgMzUuNCAzNS41IDM1LjQgMzUuNWMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgMzUuNiAzNS41IDM1LjYgMzUuNWMwIDAgMjAuMi0yMC4yIDIwLjItMjAuMmMwIDAtMzUuNC0zNS43LTM1LjQtMzUuN2MwIDAgMjEuMS0yMSAyMS4xLTIxYzAgMC0yMC43LTIwLjItMjAuNy0yMC4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMzMuNy0zMy43bC0yMC40LTIwLjNsLTM0LjcgMzQuNmMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtMTAuNy0xMi40LTEwLjctMTIuNGMwIDAtMTguMSAyMC4xLTE4LjEgMjAuMWMwIDAgMTQuOSAyMC42IDE0LjkgMjAuNmMwIDAgMS4yIDEwLjcgMS4yIDEwLjdjMCAwIDI2LjggMCAyNi44IDBjMCAwIDAtMTEuNSAwLTExLjVjMCAwIDE0LjYtMTkuNiAxNC42LTE5LjZjMCAwLTE3LjktMTguNi0xNy45LTE4LjZjMCAwLTEwLjggMTAuNy0xMC44IDEwLjdaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNzcuNWMxNTMuMSAwIDI3Ny41IDEyNC40IDI3Ny41IDI3Ny41YzAgMTUzLjEtMTI0LjQgMjc3LjUtMjc3LjUgMjc3LjVjLTE1My4xIDAtMjc3LjUtMTI0LjQtMjc3LjUtMjc3LjVjMC0xNTMuMSAxMjQuNC0yNzcuNSAyNzcuNS0yNzcuNVpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MTEuMiwzMDcuMSkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xMilcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMjAuMywtMjAuMylcIj5cbiAgICAgICAgPHBhdGggZD1cIk0yMjQuMiA0NzguM2MwIDAtMjEwLjYgMjEwLjUtMjEwLjYgMjEwLjVjMCAwIDIwLjQgMjAuNCAyMC40IDIwLjRjMCAwIDIxMC43LTIxMC43IDIxMC43LTIxMC43Yy0xMS43LTExLTUuOS02LTIwLjUtMjAuMlpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgZGlzcGxheT1cImJsb2NrXCIgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9yZXZlcnNlX01hc2stMTMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDQ2IDM5MC44YzAgMCAzLjUgLjIgMy41IC4yYzAgMCAuMiA3LjMgLjIgNy4zYy4xIDAgMTQuMiAwIDE0LjIgMGMwIDAgMC03LjMgMC03LjNjMCAwIDQtMC4yIDQtMC4yYzAgMCAwLTEzLjUgMC0xMy41YzAgMC0yMS45IDAtMjEuOSAwYzAgMCAwIDEzLjUgMCAxMy41WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjg3LjkgNDE0LjRjMCAwLTExLjUgMTEuNi0xMS41IDExLjZjMCAwLTE4LjUtMTguOC0xOC41LTE4LjhjMCAwLTIwLjMgMjAuNS0yMC4zIDIwLjVjMCAwIDE4LjUgMTguNyAxOC41IDE4LjdjMCAwLTYyLjUgNjIuNC02Mi41IDYyLjRjMCAwIDIwLjQgMjAuNCAyMC40IDIwLjRjMCAwIDYyLjQtNjIuNCA2Mi40LTYyLjRjMCAwIDE4LjcgMTguNyAxOC43IDE4LjdjMCAwIDIwLjItMjAgMjAuMi0yMGMwIDAtMTguNS0xOS4xLTE4LjUtMTkuMWMwIDAgMTEuOS0xMS44IDExLjktMTEuOGMwIDAtMjAuOC0yMC4yLTIwLjgtMjAuMlpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTUwMi44IDE5OS42Yy0xMy40LTEwLTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMjIuNC0yMi40bC0yMC40LTIwLjRsLTIzLjQgMjMuNGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTkuNGMwIDAtNC41LTUuMi00LjUtNS4yYzAgMC0xMC43IDEyLjEtMTAuNyAxMi4xYzAgMCA2LjkgMTAuMSA2LjkgMTAuMWMwIDAgLjggNC41IC44IDQuNWMwIDAgMTYgMCAxNiAwYzAgMCAwLTUgMC01YzAgMCA2LjctOS40IDYuNy05LjRjMCAwLTEwLjYtMTEuMi0xMC42LTExLjJjMCAwLTQuNiA0LjEtNC42IDQuMVpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPHBhdGggc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjMwXCIgZD1cIk0wLTI3Mi41YzE1MC40IDAgMjcyLjUgMTIyLjEgMjcyLjUgMjcyLjVjMCAxNTAuNC0xMjIuMSAyNzIuNS0yNzIuNSAyNzIuNWMtMTUwLjQgMC0yNzIuNS0xMjIuMS0yNzIuNS0yNzIuNWMwLTE1MC40IDEyMi4xLTI3Mi41IDI3Mi41LTI3Mi41WlwiIGZpbGw9XCJub25lXCIgZGlzcGxheT1cImJsb2NrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDQxNC45LDMwMy43KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTE0KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMy40LC0xMy40KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xNSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk00NTMuNiAzODguMWMwIDAgLjcgMCAuNyAwYzAgMCAuMSAxLjcgLjEgMS43YzAgMCA0LjcgMCA0LjcgMGMwIDAgMC0xLjcgMC0xLjdjMCAwIDEgMCAxIDBjMCAwIDAtNC41IDAtNC41YzAgMC02LjUgMC02LjUgMGMwIDAgMCA0LjUgMCA0LjVaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yODAuOCA0MjEuNWMwIDAtNC40IDQuNS00LjQgNC41YzAgMC01LjUtNS45LTUuNS01LjljMCAwLTIwLjMgMjAuNi0yMC4zIDIwLjZjMCAwIDUuNSA1LjcgNS41IDUuN2MwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNS44IDUuNyA1LjggNS43YzAgMCAyMC4xLTE5LjkgMjAuMS0xOS45YzAgMC01LjUtNi4yLTUuNS02LjJjMCAwIDQuOC00LjYgNC44LTQuNmMwIDAtMjAuOC0yMC4zLTIwLjgtMjAuM1pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTUwMi44IDE5OS42Yy0xMy40LTEwLTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMTEuOS0xMS45bC0yMC40LTIwLjNsLTEyLjkgMTIuOGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNjIuOWMwIDAtMS0xLjItMS0xLjJjMCAwLTMuNiA0LTMuNiA0YzAgMCAxLjkgMi44IDEuOSAyLjhjMCAwIC4yIDEuMSAuMiAxLjFjMCAwIDUuNCAwIDUuNCAwYzAgMCAwLTEuMiAwLTEuMmMwIDAgMS43LTIuNiAxLjctMi42YzAgMC0zLjUtMy43LTMuNS0zLjdjMCAwLTEuMSAuOC0xLjEgLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjguOGMxNDguNCAwIDI2OC44IDEyMC40IDI2OC44IDI2OC44YzAgMTQ4LjQtMTIwLjQgMjY4LjgtMjY4LjggMjY4LjhjLTE0OC40IDAtMjY4LjgtMTIwLjQtMjY4LjgtMjY4LjhjMC0xNDguNCAxMjAuNC0yNjguOCAyNjguOC0yNjguOFpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MTcuNiwzMDEuMykgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xNilcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNy4zLC03LjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTE3KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTI3NS40IDQyNi45YzAgMC0xOS4zIDE5LjUtMTkuMyAxOS41YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCAxOS45LTE5LjcgMTkuOS0xOS43YzAgMC0yMC45LTIwLjItMjAuOS0yMC4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDExLjQgMjkxLjNsMjAuNyAyMC43bC4xLTAuMWM2LjggMy4yIDE0LjUgNS4xIDIyLjUgNS4xYzI4LjkgMCA1Mi4yLTIzLjQgNTIuMi01Mi4yaDI4LjhjMCA0NC43LTM2LjIgODEtODEgODFjLTQ0LjcgMC04MS0zNi4zLTgxLTgxYzAtNDQuOCAzNi4zLTgxIDgxLTgxYzE4IDAgMjEuOSA2LjMgMzUuMyAxNi4ybC03LjkgMjAuM2MtOC00LjktMTcuMy03LjctMjcuNC03LjdjLTI4LjggMC01Mi4yIDIzLjMtNTIuMiA1Mi4yYzAgMTAuMSAyLjkgMTkuNSA3LjkgMjcuNVpcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjUuNmMxNDYuNiAwIDI2NS42IDExOSAyNjUuNiAyNjUuNmMwIDE0Ni42LTExOSAyNjUuNi0yNjUuNiAyNjUuNmMtMTQ2LjYgMC0yNjUuNi0xMTktMjY1LjYtMjY1LjZjMC0xNDYuNiAxMTktMjY1LjYgMjY1LjYtMjY1LjZaXCIgZmlsbD1cIm5vbmVcIiBkaXNwbGF5PVwiYmxvY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDIwLDI5OS4xKSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTE4KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0LC00KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X3JldmVyc2VfTWFzay0xOSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk0yNjUuNCA0MzcuMWMwIDAtOS4zIDkuMy05LjMgOS4zYzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA5LjgtOS42IDkuOC05LjZjMCAwLTIwLjgtMjAuMS0yMC44LTIwLjFaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00MDMgMjk5LjNsMjAuOSAyMC45bDguMy04LjNjNi44IDMuMiAxNC41IDUuMSAyMi41IDUuMWMyOC45IDAgNTIuMi0yMy40IDUyLjItNTIuMmgyOC44YzAgNDQuNy0zNi4yIDgxLTgxIDgxYy00NC43IDAtODEtMzYuMy04MS04MWMwLTQ0LjggMzYuMy04MSA4MS04MWMxOCAwIDM0LjYgNS44IDQ4LjEgMTUuOGwtMjAuNyAyMC43Yy04LTQuOS0xNy4zLTcuNy0yNy40LTcuN2MtMjguOCAwLTUyLjIgMjMuMy01Mi4yIDUyLjJjMCAxMCAyLjkgMTkuMyA3LjggMjcuM1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjMuOGMxNDUuNiAwIDI2My44IDExOC4yIDI2My44IDI2My44YzAgMTQ1LjYtMTE4LjIgMjYzLjgtMjYzLjggMjYzLjhjLTE0NS42IDAtMjYzLjgtMTE4LjItMjYzLjgtMjYzLjhjMC0xNDUuNiAxMTguMi0yNjMuOCAyNjMuOC0yNjMuOFpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MjEuMiwyOTcuOCkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIGNsaXAtcGF0aD1cInVybCgjJHtpY29uUHJlZml4fV9yZXZlcnNlX0NsaXBQYXRoLTEpXCIgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fcmV2ZXJzZV9NYXNrLTIwKVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8cGF0aCBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMzBcIiBkPVwiTTAtMjYxLjdjMTQ0LjQgMCAyNjEuNyAxMTcuMyAyNjEuNyAyNjEuN2MwIDE0NC40LTExNy4zIDI2MS43LTI2MS43IDI2MS43Yy0xNDQuNCAwLTI2MS43LTExNy4zLTI2MS43LTI2MS43YzAtMTQ0LjQgMTE3LjMtMjYxLjcgMjYxLjctMjYxLjdaXCIgZmlsbD1cIm5vbmVcIiBkaXNwbGF5PVwiYmxvY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDIyLjgsMjk2LjQpIHNjYWxlKC45NzcsLjk3NylcIiAvPlxuICAgIDwvZz5gO1xuICB9XG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd5ZXh0X2FuaW1hdGVkX2ZvcndhcmQnLFxuICB2aWV3Qm94OiAnMCAwIDcyIDcyJyxcbiAgY29tcGxleENvbnRlbnRzOiAocGFyYW1zID0ge30pID0+IHtcbiAgICBjb25zdCBpY29uUHJlZml4ID0gcGFyYW1zLmljb25QcmVmaXggfHwgJ3l4dCc7XG4gICAgcmV0dXJuIGA8ZGVmcz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMVwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTE0NC4zXCIgeT1cIjE0NC4zXCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNLTAuMyAuMWMwIDAgMS4zIDEuMiAxLjMgMS4yYzAgMCAuMy0xLjYgLjMtMS42YzAgMC0xLjYgLjQtMS42IC40XCIgLz5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTS4zIC43YzAgMC0wLjMgLjMtMC4zIC4zYzAgMCAwIDAgMCAwYzAgMCAuMy0wLjMgLjMtMC4zYzAgMCAwIDAgMCAwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0uMyAuN2MwIDAtMC4xIDAtMC4xIDBjMCAwIC4xIC4xIC4xIC4xYzAgMCAuMS0wLjEgLjEtMC4xYzAgMC0wLjEgMC0wLjEgMG0yMjIuOCA0NjkuMWMwIDAtNzAuNSA2OS40LTcwLjUgNjkuNGMwIDAgMzQuMSAzMy41IDM0LjEgMzMuNWMwIDAgNjctNzIuOSA2Ny03Mi45YzAgMC0zMC42LTMwLTMwLjYtMzBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0zXCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ4OS44IDI3Ny40YzAgMCA3OCAxOC44IDc4IDE4LjhjMCAwLTk2LjEgNjEuNS05Ni4xIDYxLjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMTMuOSAxNC0xMy45IDE0bS02Ny44LTEwOC4xYzAgMCA3My45IDEuMyA3My45IDEuM2MwIDAtMzMuOCA1NC41LTMzLjggNTQuNWMwIDAgMTguNi0zLjIgMTguNi0zLjJjMCAwIDM1LjQtMzYuNSAzNS40LTM2LjVjMCAwLTYyLTI1LjktNjItMjUuOWMwIDAtMzIuMSA5LjgtMzIuMSA5LjhcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay00XCI+XG4gICAgICAgIDxyZWN0IHg9XCItOTEuMVwiIHk9XCI5MS4xXCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNLTAuMyAuMWMwIDAgMS4zIDEuMiAxLjMgMS4yYzAgMCAuMy0xLjYgLjMtMS42YzAgMC0xLjYgLjQtMS42IC40XCIgLz5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTS4zIC43YzAgMC0wLjMgLjMtMC4zIC4zYzAgMCAwIDAgMCAwYzAgMCAuMy0wLjMgLjMtMC4zYzAgMCAwIDAgMCAwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0uMyAuN2MwIDAtMC4xIDAtMC4xIDBjMCAwIC4xIC4xIC4xIC4xYzAgMCAuMS0wLjEgLjEtMC4xYzAgMC0wLjEgMC0wLjEgMG0yMjIuOCA0NjkuMWMwIDAtNzAuNSA2OS40LTcwLjUgNjkuNGMwIDAgMzQuMSAzMy41IDM0LjEgMzMuNWMwIDAgNjctNzIuOSA2Ny03Mi45YzAgMC0zMC42LTMwLTMwLjYtMzBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay01XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ4OC40IDI5MS40YzAgMCA0MC41IDM5LjMgNDAuNSAzOS4zYzAgMC01Ny4yIDI3LTU3LjIgMjdjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMTUuMyAyOC0xNS4zIDI4bS05MC41LTk3LjRjMCAwIDUyLTExLjMgNTItMTEuM2MwIDAtNiA0NS4yLTYgNDUuMmMwIDAgMzYuOC02IDM2LjgtNmMwIDAgMzkuMy0zMS45IDM5LjMtMzEuOWMwIDAtNjUuOS0zMC41LTY1LjktMzAuNWMwIDAtNTYuMiAzNC41LTU2LjIgMzQuNVwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTZcIj5cbiAgICAgICAgPHJlY3QgeD1cIi02MS4zXCIgeT1cIjYxLjNcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stN1wiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00ODEuOCAyOTguNGMwIDAgMjcuNSAzOS44IDI3LjUgMzkuOGMwIDAtMzcuNiAxOS41LTM3LjYgMTkuNWMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC0yMS45IDM1LTIxLjkgMzVtLTEwOC4xLTc5LjdjMCAwIDMwLjItMjMuOCAzMC4yLTIzLjhjMCAwIDIxLjcgMzUuOSAyMS43IDM1LjljMCAwIDU1LjEtOC45IDU1LjEtOC45YzAgMCAzNS40LTM2LjUgMzUuNC0zNi41YzAgMC02Mi0yNS45LTYyLTI1LjljMCAwLTgwLjQgNTkuMi04MC40IDU5LjJcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay04XCI+XG4gICAgICAgIDxyZWN0IHg9XCItNDIuNlwiIHk9XCI0Mi42XCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTlcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDc1LjIgMzA1LjRjMCAwIDE0LjUgNDAuMyAxNC41IDQwLjNjMCAwLTE4IDEyLTE4IDEyYzAgMCA1OS42LTQxLjEgNTkuNi00MS4xYzAgMCAxMC42LTUzLjggMTAuNi01My44YzAgMC0zOC4yIC42LTM4LjIgLjZjMCAwLTI4LjUgNDItMjguNSA0Mm0tMTEzLjYtNzQuM2MwIDAgMTcuOS0xOC41IDE3LjktMTguNWMwIDAgMzYuNCAyNS4zIDM2LjQgMjUuM2MwIDAgNjQuOC0xNiA2NC44LTE2YzAgMCAzOS4zLTMxLjkgMzkuMy0zMS45YzAgMC02NS45LTMwLjUtNjUuOS0zMC41YzAgMC05Mi41IDcxLjYtOTIuNSA3MS42XCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMTBcIj5cbiAgICAgICAgPHJlY3QgeD1cIi0yOS42XCIgeT1cIjI5LjZcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMTFcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDY4LjYgMzEyLjRjMCAwIDEuNSA0MC44IDEuNSA0MC44YzAgMCAxLjYgNC41IDEuNiA0LjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtMzUuMSA0OS0zNS4xIDQ5bS0xMDctODEuM2MwIDAgMTUuMSA0LjkgMTUuMSA0LjljMCAwIDM4LjIgMTMuMyAzOC4yIDEzLjNjMCAwIDY1LjgtMjcuNCA2NS44LTI3LjRjMCAwIDM5LjMtMjEuOSAzOS4zLTIxLjljMCAwLTY1LjktNDAuNS02NS45LTQwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xMlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTIwLjNcIiB5PVwiMjAuM1wiIGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xM1wiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00NTYuNiAzMTEuOWMwIDAtNyAzNS42LTcgMzUuNmMwIDAgMjIuMSAxMC4yIDIyLjEgMTAuMmMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC00Ny4xIDQ4LjUtNDcuMSA0OC41bS05NS04MC44YzAgMCAxMi4zIDI4LjMgMTIuMyAyOC4zYzAgMCAzOS45IDEuMyAzOS45IDEuM2MwIDAgNjYuOS0zOC44IDY2LjktMzguOGMwIDAgMzkuMy0yMS45IDM5LjMtMjEuOWMwIDAtNjUuOS00MC41LTY1LjktNDAuNWMwIDAtOTIuNSA3MS42LTkyLjUgNzEuNlwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTE0XCI+XG4gICAgICAgIDxyZWN0IHg9XCItMTMuNFwiIHk9XCIxMy40XCIgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICA8L21hc2s+XG4gICAgICA8bWFzayBpZD1cIiR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTE1XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ0NC42IDMxMS40YzAgMC0xNS42IDMwLjUtMTUuNiAzMC41YzAgMCA0Mi43IDE1LjggNDIuNyAxNS44YzAgMCA1OS42LTQxLjEgNTkuNi00MS4xYzAgMCAxMC42LTUzLjggMTAuNi01My44YzAgMC0zOC4yIC42LTM4LjIgLjZjMCAwLTU5LjEgNDgtNTkuMSA0OG0tODMtODAuM2MwIDAgOS41IDUxLjcgOS41IDUxLjdjMCAwIDQxLjctMTAuOCA0MS43LTEwLjhjMCAwIDY3LjktNTAuMSA2Ny45LTUwLjFjMCAwIDUwLjYtMzEuOSA1MC42LTMxLjljMCAwLTc3LjItMzAuNS03Ny4yLTMwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xNlwiPlxuICAgICAgICA8cmVjdCB4PVwiLTcuM1wiIHk9XCI3LjNcIiBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxtYXNrIGlkPVwiJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMTdcIj5cbiAgICAgICAgPHJlY3QgZmlsbD1cIiNmZmZcIiB3aWR0aD1cIjcyMFwiIGhlaWdodD1cIjcyMFwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDMyLjYgMzEwLjljMCAwLTI0LjIgMjUuMy0yNC4yIDI1LjNjMCAwIDYzLjMgMjEuNSA2My4zIDIxLjVjMCAwIDU5LjYtNDEuMSA1OS42LTQxLjFjMCAwIDEwLjYtNTMuOCAxMC42LTUzLjhjMCAwLTM4LjIgLjYtMzguMiAuNmMwIDAtNzEuMSA0Ny41LTcxLjEgNDcuNW0tNzEtNzkuOGMwIDAgMjAuMyA5MC40IDIwLjMgOTAuNGMwIDAgMjktMjkuNSAyOS0yOS41YzAgMCA2OS44LTcwLjEgNjkuOC03MC4xYzAgMCAzNS40LTM2LjUgMzUuNC0zNi41YzAgMC02Mi0yNS45LTYyLTI1LjljMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xOFwiPlxuICAgICAgICA8cmVjdCB4PVwiLTRcIiB5PVwiNFwiIGZpbGw9XCIjZmZmXCIgd2lkdGg9XCI3MjBcIiBoZWlnaHQ9XCI3MjBcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xOVwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00MzIuNiAzMTAuOWMwIDAtMjQuMiAyNS4zLTI0LjIgMjUuM2MwIDAgNjMuMyAyMS41IDYzLjMgMjEuNWMwIDAgNTkuNi00MS4xIDU5LjYtNDEuMWMwIDAgMTAuNi01My44IDEwLjYtNTMuOGMwIDAtMzguMiAuNi0zOC4yIC42YzAgMC03MS4xIDQ3LjUtNzEuMSA0Ny41bS03MS03OS44YzAgMCAyMC4zIDkwLjQgMjAuMyA5MC40YzAgMCAyOS0yOS41IDI5LTI5LjVjMCAwIDY5LjgtNzAuMSA2OS44LTcwLjFjMCAwIDM5LjMtMzEuOSAzOS4zLTMxLjljMCAwLTY1LjktMzAuNS02NS45LTMwLjVjMCAwLTkyLjUgNzEuNi05Mi41IDcxLjZcIiAvPlxuICAgICAgPC9tYXNrPlxuICAgICAgPG1hc2sgaWQ9XCIke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0yMFwiPlxuICAgICAgICA8cmVjdCBmaWxsPVwiI2ZmZlwiIHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvbWFzaz5cbiAgICAgIDxjbGlwUGF0aCBpZD1cIiR7aWNvblByZWZpeH1fZm9yd2FyZF9DbGlwUGF0aC0xXCI+XG4gICAgICAgIDxyZWN0IHdpZHRoPVwiNzIwXCIgaGVpZ2h0PVwiNzIwXCIgLz5cbiAgICAgIDwvY2xpcFBhdGg+XG4gICAgPC9kZWZzPlxuICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLDApIHNjYWxlKC4xLC4xKVwiPlxuICAgICAgPGcgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk0zNzcuNSAzOTUuM2MwIDAgNjQuOCAwIDY0LjggMGMwIDAgMCAxMjkuNiAwIDEyOS42YzAgMCAyOC44IDAgMjguOCAwYzAgMCAwLTEyOS42IDAtMTI5LjZjMCAwIDY0LjggMCA2NC44IDBjMCAwIDAtMjguOCAwLTI4LjhjMCAwLTE1OC40IDAtMTU4LjQgMGMwIDAgMCAyOC44IDAgMjguOFpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMzOC45IDM2My42YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMC0yMC40IDIwLjQtMjAuNCAyMC40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMCAyMC4zLTIwLjQgMjAuMy0yMC40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMC0yMC4zLTIwLjQtMjAuMy0yMC40WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDU0LjcgMzQ1LjhjNDQuOCAwIDgxLTM2LjMgODEtODFjMCAwLTI4LjggMC0yOC44IDBjMCAyOC44LTIzLjMgNTIuMi01Mi4yIDUyLjJjLTguMiAwLTE2LTEuOS0yMi45LTUuM2MwIDAgNjkuOC02OS45IDY5LjgtNjkuOWMwIDAgMjEuMS0yMSAyMS4xLTIxYy0xNC40LTIyLjMtMzkuNS0zNy02OC0zN2MtNDQuNyAwLTgxIDM2LjItODEgODFjMCA0NC43IDM2LjMgODEgODEgODFabTAtMTMzLjJjMTAuMiAwIDE5LjYgMi45IDI3LjYgNy45YzAgMC03MS45IDcxLjgtNzEuOSA3MS44Yy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtNjAuNy03Mi44LTYwLjctNzIuOGMwIDAtMjIuMSAxOC42LTIyLjEgMTguNmMwIDAgNjguNCA4MiA2OC40IDgyYzAgMCAwIDYyLjQgMCA2Mi40YzAgMCAyOC44IDAgMjguOCAwYzAgMCAwLTYyLjYgMC02Mi42YzAgMCA2OC40LTgxLjggNjguNC04MS44YzAgMC0yMi0xOC42LTIyLTE4LjZjMCAwLTYwLjggNzIuOC02MC44IDcyLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0zNTMuN2MxOTUuMiAwIDM1My43IDE1OC41IDM1My43IDM1My43YzAgMTk1LjItMTU4LjUgMzUzLjctMzUzLjcgMzUzLjdjLTE5NS4yIDAtMzUzLjctMTU4LjUtMzUzLjctMzUzLjdjMC0xOTUuMiAxNTguNS0zNTMuNyAzNTMuNy0zNTMuN1pcIiBmaWxsPVwibm9uZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzNTkuOCwzNjAuNCkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0yKVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNDQuMywtMTQ0LjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMzkwLjYgMzk1LjJjMCAwIDUxLjcgLjEgNTEuNyAuMWMwIDAgLjEgMTAzLjYgLjEgMTAzLjZjMCAwIDI4LjcgMCAyOC43IDBjMCAwIDAtMTAzLjYgMC0xMDMuNmMwIDAgNTItMC4xIDUyLTAuMWMwIDAgMC0yOC40IDAtMjguNGMwIDAtMTMyLjUgMC0xMzIuNSAwYzAgMCAwIDI4LjQgMCAyOC40WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMzI5IDM3My40YzAgLjEtNTIuNiA1Mi42LTUyLjYgNTIuNmMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAtMjAuNCAyMC40LTIwLjQgMjAuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAgMjAuMy0yMC40IDIwLjMtMjAuNGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAgNTIuNi01Mi42IDUyLjYtNTIuNmMwIDAtMjAuNC0yMC4zLTIwLjQtMjAuM1pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTQ1NC43IDM0NS44YzQ0LjggMCA4MS0zNi4zIDgxLTgxYzAgMC0yOC44IDAtMjguOCAwYzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNjMCAwIDY5LjgtNjkuOSA2OS44LTY5LjljMCAwIDIxLjEtMjEgMjEuMS0yMWMtMTQuNC0yMi4zLTM5LjUtMzctNjgtMzdjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxWm0wLTEzMy4yYzEwLjIgMCAxOS42IDIuOSAyNy42IDcuOWMwIDAtNzEuOSA3MS44LTcxLjkgNzEuOGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjc2LjQgMjU1LjljMCAwLTQ4LjctNTguMy00OC43LTU4LjNjMCAwLTIxLjEgMTktMjEuMSAxOWMwIDAgNTUuNSA2Ny4yIDU1LjUgNjcuMmMwIDAgLjMgNTAgLjMgNTBjMCAwIDI4LjQgMCAyOC40IDBjMCAwIDAtNTAuMyAwLTUwLjNjMCAwIDU1LjQtNjYuOSA1NS40LTY2LjljMCAwLTIxLTE4LjYtMjEtMTguNmMwIDAtNDguOCA1Ny45LTQ4LjggNTcuOVpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPHBhdGggc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjMwXCIgZD1cIk0wLTMzNi4yYzE4NS42IDAgMzM2LjIgMTUwLjYgMzM2LjIgMzM2LjJjMCAxODUuNi0xNTAuNiAzMzYuMi0zMzYuMiAzMzYuMmMtMTg1LjYgMC0zMzYuMi0xNTAuNi0zMzYuMi0zMzYuMmMwLTE4NS42IDE1MC42LTMzNi4yIDMzNi4yLTMzNi4yWlwiIGZpbGw9XCJub25lXCIgZGlzcGxheT1cImJsb2NrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM3MC44LDM0Ny41KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTQpXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDkxLjEsLTkxLjEpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTUpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDA5LjcgMzk1LjFjMCAwIDMyLjYgLjIgMzIuNiAuMmMwIDAgLjMgNjUuNSAuMyA2NS41YzAgMCAyOC41IDAgMjguNSAwYzAgMCAwLTY1LjUgMC02NS41YzAgMCAzMy4xLTAuMiAzMy4xLTAuMmMwIDAgMC0yNy44IDAtMjcuOGMwIDAtOTQuNSAwLTk0LjUgMGMwIDAgMCAyNy44IDAgMjcuOFpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTMxOS43IDM4Mi44YzAgMC00My4zIDQzLjItNDMuMyA0My4yYzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMC0yMC40IDIwLjQtMjAuNCAyMC40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA2Mi41IDYyLjQgNjIuNSA2Mi40YzAgMCAyMC4zLTIwLjQgMjAuMy0yMC40YzAgMC02Mi40LTYyLjQtNjIuNC02Mi40YzAgMCA0My40LTQzLjMgNDMuNC00My4zYzAgMC0yMC41LTIwLjMtMjAuNS0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLTE1LjgtNDguMS0xNS44Yy00NC43IDAtODEgMzYuMi04MSA4MWMwIDQ0LjcgMzYuMyA4MSA4MSA4MWM0NC44IDAgODEtMzYuMyA4MS04MWgtMjguOGMwIDI4LjgtMjMuMyA1Mi4yLTUyLjIgNTIuMmMtOC4yIDAtMTYtMS45LTIyLjktNS4zbDY5LjgtNjkuOWwuMy0wLjJsLTIwLjMtMjAuNGwtNzEuMiA3MS4xYy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJjMTAuMSAwIDE5LjQgMi44IDI3LjQgNy43WlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTI3Ni40IDI1NS45YzAgMC0zMS4xLTM3LTMxLjEtMzdjMCAwLTE5LjcgMTkuNS0xOS43IDE5LjVjMCAwIDM2LjcgNDUuNiAzNi43IDQ1LjZjMCAwIC43IDMxLjggLjcgMzEuOGMwIDAgMjcuNyAwIDI3LjcgMGMwIDAgMC0zMi40IDAtMzIuNGMwIDAgMzYuNS00NC45IDM2LjUtNDQuOWMwIDAtMTkuNi0xOC42LTE5LjYtMTguNmMwIDAtMzEuMiAzNi0zMS4yIDM2WlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8cGF0aCBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMzBcIiBkPVwiTTAtMzEwYzE3MS4xIDAgMzEwIDEzOC45IDMxMCAzMTBjMCAxNzEuMS0xMzguOSAzMTAtMzEwIDMxMGMtMTcxLjEgMC0zMTAtMTM4LjktMzEwLTMxMGMwLTE3MS4xIDEzOC45LTMxMCAzMTAtMzEwWlwiIGZpbGw9XCJub25lXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDM4Ny44LDMyOC43KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTYpXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDYxLjMsLTYxLjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTcpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDIwLjQgMzk1YzAgMCAyMS45IC4zIDIxLjkgLjNjMCAwIC40IDQ0LjEgLjQgNDQuMWMwIDAgMjguNCAwIDI4LjQgMGMwIDAgMC00NC4xIDAtNDQuMWMwIDAgMjIuNi0wLjMgMjIuNi0wLjNjMCAwIDAtMjcuNSAwLTI3LjVjMCAwLTczLjMgMC03My4zIDBjMCAwIDAgMjcuNSAwIDI3LjVaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0zMTMuMiAzODkuMmMwIDAtMzYuOCAzNi44LTM2LjggMzYuOGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAtMjAuNCAyMC40LTIwLjQgMjAuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNjIuNSA2Mi40IDYyLjUgNjIuNGMwIDAgMjAuMy0yMC40IDIwLjMtMjAuNGMwIDAtNjIuNC02Mi40LTYyLjQtNjIuNGMwIDAgMzctMzYuOSAzNy0zNi45YzAgMC0yMC42LTIwLjMtMjAuNi0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAwIDIwMGMtMTMuNC05LjktMjcuMi0xNi4yLTQ1LjMtMTYuMmMtNDQuNyAwLTgxIDM2LjItODEgODFjMCA0NC43IDM2LjMgODEgODEgODFjNDQuOCAwIDgxLTM2LjMgODEtODFoLTI4LjhjMCAyOC44LTIzLjMgNTIuMi01Mi4yIDUyLjJjLTguMiAwLTE2LTEuOS0yMi45LTUuM2w1Ny43LTU3LjdsLTIwLjMtMjAuNGwtNTguOCA1OC43Yy01LTgtNy45LTE3LjQtNy45LTI3LjVjMC0yOC45IDIzLjQtNTIuMiA1Mi4yLTUyLjJjMTAuMSAwIDE5LjQgMi44IDI3LjQgNy43WlwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTI3Ni40IDI1NS45YzAgMC0yMS4yLTI1LjEtMjEuMi0yNS4xYzAgMC0xOSAxOS44LTE5IDE5LjhjMCAwIDI2LjIgMzMuNSAyNi4yIDMzLjVjMCAwIDEgMjEuNiAxIDIxLjZjMCAwIDI3LjIgMCAyNy4yIDBjMCAwIDAtMjIuMyAwLTIyLjNjMCAwIDI1LjktMzIuNyAyNS45LTMyLjdjMCAwLTE4LjgtMTguNi0xOC44LTE4LjZjMCAwLTIxLjMgMjMuOC0yMS4zIDIzLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yOTQuM2MxNjIuNCAwIDI5NC4zIDEzMS45IDI5NC4zIDI5NC4zYzAgMTYyLjQtMTMxLjkgMjk0LjMtMjk0LjMgMjk0LjNjLTE2Mi40IDAtMjk0LjMtMTMxLjktMjk0LjMtMjk0LjNjMC0xNjIuNCAxMzEuOS0yOTQuMyAyOTQuMy0yOTQuM1pcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzOTguNywzMTguMikgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay04KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0Mi42LC00Mi42KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay05KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTQyNy4yIDM5NC45YzAgMCAxNS4xIC40IDE1LjEgLjRjMCAwIC40IDMwLjcgLjQgMzAuN2MwIDAgMjguNCAwIDI4LjQgMGMwIDAgMC0zMC43IDAtMzAuN2MwIDAgMTUuOS0wLjQgMTUuOS0wLjRjMCAwIDAtMjcuMiAwLTI3LjJjMCAwLTU5LjggMC01OS44IDBjMCAwIDAgMjcuMiAwIDI3LjJaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0zMDcuNCAzOTVjMCAwLTMxIDMxLTMxIDMxYzAgMC01My45LTU0LTUzLjktNTRjMCAwLTIwLjQgMjAuNC0yMC40IDIwLjRjMCAwIDU0IDU0IDU0IDU0YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA1NCA1NCA1NCA1NGMwIDAgMjAuNC0yMC4zIDIwLjQtMjAuM2MwIDAtNTQtNTQuMS01NC01NC4xYzAgMCAzMS4yLTMxLjEgMzEuMi0zMS4xYzAgMC0yMC42LTIwLjMtMjAuNi0yMC4zWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsNDUuNS00NS41bC0yMC40LTIwLjRsLTQ2LjUgNDYuNWMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtMTUtMTcuNi0xNS0xNy42YzAgMC0xOC40IDIwLTE4LjQgMjBjMCAwIDE5LjQgMjUuOCAxOS40IDI1LjhjMCAwIDEuMiAxNS4yIDEuMiAxNS4yYzAgMCAyNyAwIDI3IDBjMCAwIDAtMTUuOSAwLTE1LjljMCAwIDE5LjEtMjQuOSAxOS4xLTI0LjljMCAwLTE4LjItMTguNy0xOC4yLTE4LjdjMCAwLTE1LjEgMTYuMS0xNS4xIDE2LjFaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yODQuNGMxNTcgMCAyODQuNCAxMjcuNCAyODQuNCAyODQuNGMwIDE1Ny0xMjcuNCAyODQuNC0yODQuNCAyODQuNGMtMTU3IDAtMjg0LjQtMTI3LjQtMjg0LjQtMjg0LjRjMC0xNTcgMTI3LjQtMjg0LjQgMjg0LjQtMjg0LjRaXCIgZmlsbD1cIm5vbmVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDA2LjEsMzExLjYpIHNjYWxlKC45NzcsLjk3NylcIiAvPlxuICAgIDwvZz5cbiAgICA8ZyBvcGFjaXR5PVwiMFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLDApIHNjYWxlKC4xLC4xKVwiPlxuICAgICAgPGcgZGlzcGxheT1cImJsb2NrXCIgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMTApXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDI5LjYsLTI5LjYpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTExKVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTQzNiAzOTMuNWMwIDAgOC43IC40IDguNyAuNGMwIDAgLjQgMTcuOCAuNCAxNy44YzAgMCAyMy42IDAgMjMuNiAwYzAgMCAwLTE3LjggMC0xNy44YzAgMCA5LjQtMC40IDkuNC0wLjRjMCAwIDAtMjIuNiAwLTIyLjZjMCAwLTQyLjEgMC00Mi4xIDBjMCAwIDAgMjIuNiAwIDIyLjZaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yOTcuMiA0MDUuMmMwIDAtMjAuOCAyMC44LTIwLjggMjAuOGMwIDAtMzUuNC0zNS42LTM1LjQtMzUuNmMwIDAtMjAuMyAyMC41LTIwLjMgMjAuNWMwIDAgMzUuNCAzNS41IDM1LjQgMzUuNWMwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgMzUuNiAzNS41IDM1LjYgMzUuNWMwIDAgMjAuMi0yMC4yIDIwLjItMjAuMmMwIDAtMzUuNC0zNS43LTM1LjQtMzUuN2MwIDAgMjEuMS0yMSAyMS4xLTIxYzAgMC0yMC43LTIwLjItMjAuNy0yMC4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNTAyLjggMTk5LjZjLTEzLjQtOS45LTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMzMuNy0zMy43bC0yMC40LTIwLjNsLTM0LjcgMzQuNmMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTUuOWMwIDAtMTAuNy0xMi40LTEwLjctMTIuNGMwIDAtMTguMSAyMC4xLTE4LjEgMjAuMWMwIDAgMTQuOSAyMC42IDE0LjkgMjAuNmMwIDAgMS4yIDEwLjcgMS4yIDEwLjdjMCAwIDI2LjggMCAyNi44IDBjMCAwIDAtMTEuNSAwLTExLjVjMCAwIDE0LjYtMTkuNiAxNC42LTE5LjZjMCAwLTE3LjktMTguNi0xNy45LTE4LjZjMCAwLTEwLjggMTAuNy0xMC44IDEwLjdaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNzcuNWMxNTMuMSAwIDI3Ny41IDEyNC40IDI3Ny41IDI3Ny41YzAgMTUzLjEtMTI0LjQgMjc3LjUtMjc3LjUgMjc3LjVjLTE1My4xIDAtMjc3LjUtMTI0LjQtMjc3LjUtMjc3LjVjMC0xNTMuMSAxMjQuNC0yNzcuNSAyNzcuNS0yNzcuNVpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MTEuMiwzMDcuMSkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xMilcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMjAuMywtMjAuMylcIj5cbiAgICAgICAgPHBhdGggZD1cIk0yMjQuMiA0NzguM2MwIDAtMjEwLjYgMjEwLjUtMjEwLjYgMjEwLjVjMCAwIDIwLjQgMjAuNCAyMC40IDIwLjRjMCAwIDIxMC43LTIxMC43IDIxMC43LTIxMC43Yy0xMS43LTExLTUuOS02LTIwLjUtMjAuMlpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgZGlzcGxheT1cImJsb2NrXCIgbWFzaz1cInVybCgjJHtpY29uUHJlZml4fV9mb3J3YXJkX01hc2stMTMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDQ2IDM5MC44YzAgMCAzLjUgLjIgMy41IC4yYzAgMCAuMiA3LjMgLjIgNy4zYy4xIDAgMTQuMiAwIDE0LjIgMGMwIDAgMC03LjMgMC03LjNjMCAwIDQtMC4yIDQtMC4yYzAgMCAwLTEzLjUgMC0xMy41YzAgMC0yMS45IDAtMjEuOSAwYzAgMCAwIDEzLjUgMCAxMy41WlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjg3LjkgNDE0LjRjMCAwLTExLjUgMTEuNi0xMS41IDExLjZjMCAwLTE4LjUtMTguOC0xOC41LTE4LjhjMCAwLTIwLjMgMjAuNS0yMC4zIDIwLjVjMCAwIDE4LjUgMTguNyAxOC41IDE4LjdjMCAwLTYyLjUgNjIuNC02Mi41IDYyLjRjMCAwIDIwLjQgMjAuNCAyMC40IDIwLjRjMCAwIDYyLjQtNjIuNCA2Mi40LTYyLjRjMCAwIDE4LjcgMTguNyAxOC43IDE4LjdjMCAwIDIwLjItMjAgMjAuMi0yMGMwIDAtMTguNS0xOS4xLTE4LjUtMTkuMWMwIDAgMTEuOS0xMS44IDExLjktMTEuOGMwIDAtMjAuOC0yMC4yLTIwLjgtMjAuMlpcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTUwMi44IDE5OS42Yy0xMy40LTEwLTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMjIuNC0yMi40bC0yMC40LTIwLjRsLTIzLjQgMjMuNGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNTkuNGMwIDAtNC41LTUuMi00LjUtNS4yYzAgMC0xMC43IDEyLjEtMTAuNyAxMi4xYzAgMCA2LjkgMTAuMSA2LjkgMTAuMWMwIDAgLjggNC41IC44IDQuNWMwIDAgMTYgMCAxNiAwYzAgMCAwLTUgMC01YzAgMCA2LjctOS40IDYuNy05LjRjMCAwLTEwLjYtMTEuMi0xMC42LTExLjJjMCAwLTQuNiA0LjEtNC42IDQuMVpcIiAvPlxuICAgICAgPC9nPlxuICAgICAgPHBhdGggc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjMwXCIgZD1cIk0wLTI3Mi41YzE1MC40IDAgMjcyLjUgMTIyLjEgMjcyLjUgMjcyLjVjMCAxNTAuNC0xMjIuMSAyNzIuNS0yNzIuNSAyNzIuNWMtMTUwLjQgMC0yNzIuNS0xMjIuMS0yNzIuNS0yNzIuNWMwLTE1MC40IDEyMi4xLTI3Mi41IDI3Mi41LTI3Mi41WlwiIGZpbGw9XCJub25lXCIgZGlzcGxheT1cImJsb2NrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDQxNC45LDMwMy43KSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTE0KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMy40LC0xMy40KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xNSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk00NTMuNiAzODguMWMwIDAgLjcgMCAuNyAwYzAgMCAuMSAxLjcgLjEgMS43YzAgMCA0LjcgMCA0LjcgMGMwIDAgMC0xLjcgMC0xLjdjMCAwIDEgMCAxIDBjMCAwIDAtNC41IDAtNC41YzAgMC02LjUgMC02LjUgMGMwIDAgMCA0LjUgMCA0LjVaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yODAuOCA0MjEuNWMwIDAtNC40IDQuNS00LjQgNC41YzAgMC01LjUtNS45LTUuNS01LjljMCAwLTIwLjMgMjAuNi0yMC4zIDIwLjZjMCAwIDUuNSA1LjcgNS41IDUuN2MwIDAtNjIuNSA2Mi40LTYyLjUgNjIuNGMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgNjIuNC02Mi40IDYyLjQtNjIuNGMwIDAgNS44IDUuNyA1LjggNS43YzAgMCAyMC4xLTE5LjkgMjAuMS0xOS45YzAgMC01LjUtNi4yLTUuNS02LjJjMCAwIDQuOC00LjYgNC44LTQuNmMwIDAtMjAuOC0yMC4zLTIwLjgtMjAuM1pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTUwMi44IDE5OS42Yy0xMy40LTEwLTMwLjEtMTUuOC00OC4xLTE1LjhjLTQ0LjcgMC04MSAzNi4yLTgxIDgxYzAgNDQuNyAzNi4zIDgxIDgxIDgxYzQ0LjggMCA4MS0zNi4zIDgxLTgxaC0yOC44YzAgMjguOC0yMy4zIDUyLjItNTIuMiA1Mi4yYy04LjIgMC0xNi0xLjktMjIuOS01LjNsMTEuOS0xMS45bC0yMC40LTIwLjNsLTEyLjkgMTIuOGMtNS04LTcuOS0xNy40LTcuOS0yNy41YzAtMjguOSAyMy40LTUyLjIgNTIuMi01Mi4yYzEwLjEgMCAxOS40IDIuOCAyNy40IDcuN1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNzYuNCAyNjIuOWMwIDAtMS0xLjItMS0xLjJjMCAwLTMuNiA0LTMuNiA0YzAgMCAxLjkgMi44IDEuOSAyLjhjMCAwIC4yIDEuMSAuMiAxLjFjMCAwIDUuNCAwIDUuNCAwYzAgMCAwLTEuMiAwLTEuMmMwIDAgMS43LTIuNiAxLjctMi42YzAgMC0zLjUtMy43LTMuNS0zLjdjMCAwLTEuMSAuOC0xLjEgLjhaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjguOGMxNDguNCAwIDI2OC44IDEyMC40IDI2OC44IDI2OC44YzAgMTQ4LjQtMTIwLjQgMjY4LjgtMjY4LjggMjY4LjhjLTE0OC40IDAtMjY4LjgtMTIwLjQtMjY4LjgtMjY4LjhjMC0xNDguNCAxMjAuNC0yNjguOCAyNjguOC0yNjguOFpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MTcuNiwzMDEuMykgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIG9wYWNpdHk9XCIwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsMCkgc2NhbGUoLjEsLjEpXCI+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xNilcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNy4zLC03LjMpXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjI0LjIgNDc4LjNjMCAwLTIxMC42IDIxMC41LTIxMC42IDIxMC41YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCAyMTAuNy0yMTAuNyAyMTAuNy0yMTAuN2MtMTEuNy0xMS01LjktNi0yMC41LTIwLjJaXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTE3KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTI3NS40IDQyNi45YzAgMC0xOS4zIDE5LjUtMTkuMyAxOS41YzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCAxOS45LTE5LjcgMTkuOS0xOS43YzAgMC0yMC45LTIwLjItMjAuOS0yMC4yWlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNNDExLjQgMjkxLjNsMjAuNyAyMC43bC4xLTAuMWM2LjggMy4yIDE0LjUgNS4xIDIyLjUgNS4xYzI4LjkgMCA1Mi4yLTIzLjQgNTIuMi01Mi4yaDI4LjhjMCA0NC43LTM2LjIgODEtODEgODFjLTQ0LjcgMC04MS0zNi4zLTgxLTgxYzAtNDQuOCAzNi4zLTgxIDgxLTgxYzE4IDAgMjEuOSA2LjMgMzUuMyAxNi4ybC03LjkgMjAuM2MtOC00LjktMTcuMy03LjctMjcuNC03LjdjLTI4LjggMC01Mi4yIDIzLjMtNTIuMiA1Mi4yYzAgMTAuMSAyLjkgMTkuNSA3LjkgMjcuNVpcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjUuNmMxNDYuNiAwIDI2NS42IDExOSAyNjUuNiAyNjUuNmMwIDE0Ni42LTExOSAyNjUuNi0yNjUuNiAyNjUuNmMtMTQ2LjYgMC0yNjUuNi0xMTktMjY1LjYtMjY1LjZjMC0xNDYuNiAxMTktMjY1LjYgMjY1LjYtMjY1LjZaXCIgZmlsbD1cIm5vbmVcIiBkaXNwbGF5PVwiYmxvY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDIwLDI5OS4xKSBzY2FsZSguOTc3LC45NzcpXCIgLz5cbiAgICA8L2c+XG4gICAgPGcgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTE4KVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0LC00KVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBkaXNwbGF5PVwiYmxvY2tcIiBtYXNrPVwidXJsKCMke2ljb25QcmVmaXh9X2ZvcndhcmRfTWFzay0xOSlcIj5cbiAgICAgICAgPHBhdGggZD1cIk0yNjUuNCA0MzcuMWMwIDAtOS4zIDkuMy05LjMgOS4zYzAgMC02Mi41IDYyLjQtNjIuNSA2Mi40YzAgMCAyMC40IDIwLjQgMjAuNCAyMC40YzAgMCA2Mi40LTYyLjQgNjIuNC02Mi40YzAgMCA5LjgtOS42IDkuOC05LjZjMCAwLTIwLjgtMjAuMS0yMC44LTIwLjFaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk00MDMgMjk5LjNsMjAuOSAyMC45bDguMy04LjNjNi44IDMuMiAxNC41IDUuMSAyMi41IDUuMWMyOC45IDAgNTIuMi0yMy40IDUyLjItNTIuMmgyOC44YzAgNDQuNy0zNi4yIDgxLTgxIDgxYy00NC43IDAtODEtMzYuMy04MS04MWMwLTQ0LjggMzYuMy04MSA4MS04MWMxOCAwIDM0LjYgNS44IDQ4LjEgMTUuOGwtMjAuNyAyMC43Yy04LTQuOS0xNy4zLTcuNy0yNy40LTcuN2MtMjguOCAwLTUyLjIgMjMuMy01Mi4yIDUyLjJjMCAxMCAyLjkgMTkuMyA3LjggMjcuM1pcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxwYXRoIHN0cm9rZT1cIiMwMDBcIiBzdHJva2Utd2lkdGg9XCIzMFwiIGQ9XCJNMC0yNjMuOGMxNDUuNiAwIDI2My44IDExOC4yIDI2My44IDI2My44YzAgMTQ1LjYtMTE4LjIgMjYzLjgtMjYzLjggMjYzLjhjLTE0NS42IDAtMjYzLjgtMTE4LjItMjYzLjgtMjYzLjhjMC0xNDUuNiAxMTguMi0yNjMuOCAyNjMuOC0yNjMuOFpcIiBmaWxsPVwibm9uZVwiIGRpc3BsYXk9XCJibG9ja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0MjEuMiwyOTcuOCkgc2NhbGUoLjk3NywuOTc3KVwiIC8+XG4gICAgPC9nPlxuICAgIDxnIGNsaXAtcGF0aD1cInVybCgjJHtpY29uUHJlZml4fV9mb3J3YXJkX0NsaXBQYXRoLTEpXCIgb3BhY2l0eT1cIjBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCwwKSBzY2FsZSguMSwuMSlcIj5cbiAgICAgIDxnIGRpc3BsYXk9XCJibG9ja1wiIG1hc2s9XCJ1cmwoIyR7aWNvblByZWZpeH1fZm9yd2FyZF9NYXNrLTIwKVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIyNC4yIDQ3OC4zYzAgMC0yMTAuNiAyMTAuNS0yMTAuNiAyMTAuNWMwIDAgMjAuNCAyMC40IDIwLjQgMjAuNGMwIDAgMjEwLjctMjEwLjcgMjEwLjctMjEwLjdjLTExLjctMTEtNS45LTYtMjAuNS0yMC4yWlwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8cGF0aCBzdHJva2U9XCIjMDAwXCIgc3Ryb2tlLXdpZHRoPVwiMzBcIiBkPVwiTTAtMjYxLjdjMTQ0LjQgMCAyNjEuNyAxMTcuMyAyNjEuNyAyNjEuN2MwIDE0NC40LTExNy4zIDI2MS43LTI2MS43IDI2MS43Yy0xNDQuNCAwLTI2MS43LTExNy4zLTI2MS43LTI2MS43YzAtMTQ0LjQgMTE3LjMtMjYxLjcgMjYxLjctMjYxLjdaXCIgZmlsbD1cIm5vbmVcIiBkaXNwbGF5PVwiYmxvY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDIyLjgsMjk2LjQpIHNjYWxlKC45NzcsLjk3NylcIiAvPlxuICAgIDwvZz5gO1xuICB9XG59KTtcbiIsImltcG9ydCB0aHVtYkljb24gZnJvbSAnLi90aHVtYi5qcyc7XG5pbXBvcnQgcmVjZWlwdEljb24gZnJvbSAnLi9yZWNlaXB0LmpzJztcbmltcG9ydCBwYW50aGVvbkljb24gZnJvbSAnLi9wYW50aGVvbi5qcyc7XG5pbXBvcnQgbWljSWNvbiBmcm9tICcuL21pYy5qcyc7XG5pbXBvcnQgZGlyZWN0aW9uc0ljb24gZnJvbSAnLi9kaXJlY3Rpb25zLmpzJztcbmltcG9ydCBjYWxlbmRhckljb24gZnJvbSAnLi9jYWxlbmRhci5qcyc7XG5pbXBvcnQgY2FsbG91dEljb24gZnJvbSAnLi9jYWxsb3V0LmpzJztcbmltcG9ydCBpbmZvSWNvbiBmcm9tICcuL2luZm8uanMnO1xuaW1wb3J0IGJyaWVmY2FzZUljb24gZnJvbSAnLi9icmllZmNhc2UuanMnO1xuaW1wb3J0IGthYm9iSWNvbiBmcm9tICcuL2thYm9iLmpzJztcbmltcG9ydCBwZXJzb25JY29uIGZyb20gJy4vcGVyc29uLmpzJztcbmltcG9ydCBtYWduaWZ5aW5nR2xhc3NJY29uIGZyb20gJy4vbWFnbmlmeWluZ19nbGFzcy5qcyc7XG5pbXBvcnQgb2ZmaWNlSWNvbiBmcm9tICcuL29mZmljZS5qcyc7XG5pbXBvcnQgbGlua0ljb24gZnJvbSAnLi9saW5rLmpzJztcbmltcG9ydCB3aW5kb3dJY29uIGZyb20gJy4vd2luZG93LmpzJztcbmltcG9ydCBwaG9uZUljb24gZnJvbSAnLi9waG9uZS5qcyc7XG5pbXBvcnQgdGFnSWNvbiBmcm9tICcuL3RhZy5qcyc7XG5pbXBvcnQgZG9jdW1lbnRJY29uIGZyb20gJy4vZG9jdW1lbnQuanMnO1xuaW1wb3J0IGNoZXZyb25JY29uIGZyb20gJy4vY2hldnJvbi5qcyc7XG5pbXBvcnQgc3VwcG9ydEljb24gZnJvbSAnLi9zdXBwb3J0LmpzJztcbmltcG9ydCB5ZXh0SWNvbiBmcm9tICcuL3lleHQuanMnO1xuaW1wb3J0IHBpbkljb24gZnJvbSAnLi9waW4uanMnO1xuaW1wb3J0IGdlYXJJY29uIGZyb20gJy4vZ2Vhci5qcyc7XG5pbXBvcnQgbGlnaHRCdWxiSWNvbiBmcm9tICcuL2xpZ2h0X2J1bGIuanMnO1xuaW1wb3J0IHN0YXJJY29uIGZyb20gJy4vc3Rhci5qcyc7XG5pbXBvcnQgY2xvc2UgZnJvbSAnLi9jbG9zZS5qcyc7XG5pbXBvcnQgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cyc7XG5pbXBvcnQgeWV4dEFuaW1hdGVkRm9yd2FyZCBmcm9tICcuL3lleHRfYW5pbWF0ZWRfcmV2ZXJzZSc7XG5pbXBvcnQgeWV4dEFuaW1hdGVkUmV2ZXJzZSBmcm9tICcuL3lleHRfYW5pbWF0ZWRfZm9yd2FyZCc7XG5cbmNvbnN0IGljb25zQXJyYXkgPSBbXG4gIHRodW1iSWNvbixcbiAgcmVjZWlwdEljb24sXG4gIHBhbnRoZW9uSWNvbixcbiAgbWljSWNvbixcbiAgZGlyZWN0aW9uc0ljb24sXG4gIGNhbGVuZGFySWNvbixcbiAgY2FsbG91dEljb24sXG4gIGluZm9JY29uLFxuICBicmllZmNhc2VJY29uLFxuICBrYWJvYkljb24sXG4gIHBlcnNvbkljb24sXG4gIG1hZ25pZnlpbmdHbGFzc0ljb24sXG4gIG9mZmljZUljb24sXG4gIGxpbmtJY29uLFxuICB3aW5kb3dJY29uLFxuICBwaG9uZUljb24sXG4gIHRhZ0ljb24sXG4gIGRvY3VtZW50SWNvbixcbiAgY2hldnJvbkljb24sXG4gIHN1cHBvcnRJY29uLFxuICB5ZXh0SWNvbixcbiAgcGluSWNvbixcbiAgZ2Vhckljb24sXG4gIGxpZ2h0QnVsYkljb24sXG4gIGVsZW1lbnRzLFxuICBjbG9zZSxcbiAgeWV4dEFuaW1hdGVkRm9yd2FyZCxcbiAgeWV4dEFuaW1hdGVkUmV2ZXJzZSxcbiAgc3Rhckljb25cbl07XG5cbmNvbnN0IEljb25zID0ge307XG5cbmljb25zQXJyYXkuZm9yRWFjaChpY29uID0+IHtcbiAgSWNvbnNbaWNvbi5uYW1lXSA9IGljb24ubWFya3VwKCk7XG59KTtcblxuSWNvbnMuZGVmYXVsdCA9IHN0YXJJY29uLm1hcmt1cCgpO1xuXG5leHBvcnQgZGVmYXVsdCBJY29ucztcbiIsIi8qKiBAbW9kdWxlIEhhbmRsZWJhcnNSZW5kZXJlciAqL1xuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcic7XG5pbXBvcnQgSWNvbnMgZnJvbSAnLi4vaWNvbnMnO1xuaW1wb3J0IEhpZ2hsaWdodGVkVmFsdWUgZnJvbSAnLi4vLi4vY29yZS9tb2RlbHMvaGlnaGxpZ2h0ZWR2YWx1ZSc7XG5cbi8qKlxuICogSGFuZGxlYmFyc1JlbmRlcmVyIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2YXRlIGhhbmRsZWJhcnMgcmVuZGVyZXIuXG4gKiBAZXh0ZW5kcyBSZW5kZXJlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIYW5kbGViYXJzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yICh0ZW1wbGF0ZXMgPSB7fSwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBoYW5kbGViYXJzIGNvbXBpbGVyXG4gICAgICogQHR5cGUge0hhbmRsZWJhcnN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oYW5kbGViYXJzID0gdGVtcGxhdGVzLl9oYiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIHByZS1jb21waWxlZCBoYW5kbGViYXJzIHRlbXBsYXRlc1xuICAgICAqIEB0eXBlIHtIYW5kbGViYXJzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGVzID0gdGVtcGxhdGVzIHx8IHt9O1xuICB9XG5cbiAgaW5pdCAodGVtcGxhdGVzKSB7XG4gICAgLy8gQXNzaWduIHRoZSBoYW5kbGViYXJzIGNvbXBpbGVyIGFuZCB0ZW1wbGF0ZXMgYmFzZWQgb25cbiAgICAvLyBpbmZvcm1hdGlvbiBwcm92aWRlZCBmcm9tIGV4dGVybmFsIGRlcCAoaW4gZGVmYXVsdCBjYXNlLCBpdCBjb21lcyBmcm9tIGV4dGVybmFsIHNlcnZlciByZXF1ZXN0KVxuICAgIHRoaXMuX2hhbmRsZWJhcnMgPSB0ZW1wbGF0ZXMuX2hiO1xuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHRlbXBsYXRlcztcblxuICAgIC8vIFRPRE8oYmlsbHkpIE9uY2Ugd2UgcmUtd3JpdGUgdGVtcGxhdGVzIHVzaW5nIHRoZSBuZXcgaGVscGVycyBsaWJyYXJ5XG4gICAgLy8gd2UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0aGVzZSBjdXN0b20gaGVscGVycyBhbnltb3JlXG4gICAgdGhpcy5fcmVnaXN0ZXJDdXN0b21IZWxwZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogcmVnaXN0ZXJIZWxwZXIgaXMgYSBwdWJsaWMgaW50ZXJmYWNlIGZvciBleHRlcm5hbCBkZXBlbmRlbmNpZXMgdG9cbiAgICogcmVnaXN0ZXIgdGhlaXIgb3duIGN1c3RvbSBoZWxwZXJzIHRvIG91ciBpbnRlcm5hbCBIYW5kbGViYXJzIENvbXBpbGVyXG4gICAqL1xuICByZWdpc3RlckhlbHBlciAobmFtZSwgY2IpIHtcbiAgICB0aGlzLl9oYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKG5hbWUsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlU3RyaW5nIGlzIGEgcHVibGljIGludGVyZmFjZSBmb3IgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIHRvXG4gICAqIG1hcmsgYSBzdHJpbmcgYXMgJ3NhZmUnLiBIYW5kbGViYXJzIHdpbGwgbm90IGVzY2FwZSBhIFNhZmVTdHJpbmdcbiAgICovXG4gIFNhZmVTdHJpbmcgKHN0cmluZykge1xuICAgIHJldHVybiBuZXcgdGhpcy5faGFuZGxlYmFycy5TYWZlU3RyaW5nKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlRXhwcmVzc2lvbiBpcyBhIHB1YmxpYyBpbnRlcmZhY2UgZm9yIGV4dGVybmFsIGRlcGVuZGVuY2llcyB0b1xuICAgKiBlc2NhcGUgYSBzdHJpbmdcbiAgICovXG4gIGVzY2FwZUV4cHJlc3Npb24gKHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9oYW5kbGViYXJzLmVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb21waWxlIGEgaGFuZGxlYmFycyB0ZW1wbGF0ZSBzbyB0aGF0IGl0IGNhbiBiZSByZW5kZXJlZCxcbiAgICogdXNpbmcgdGhlIHtIYW5kbGViYXJzfSBjb21waWxlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGhlIHRlbXBsYXRlIHN0cmluZyB0byBjb21waWxlXG4gICAqL1xuICBjb21waWxlICh0ZW1wbGF0ZSkge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oYW5kbGViYXJzLmNvbXBpbGUodGVtcGxhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbmRlciB3aWxsIHJlbmRlciBhIHRlbXBsYXRlIHdpdGggZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFByb3ZpZGUgZWl0aGVyIGEgdGVtcGxhdGVOYW1lIG9yIGEgcHJlLWNvbXBpbGVkIHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIHByb3ZpZGUgdG8gdGhlIHRlbXBsYXRlXG4gICAqL1xuICByZW5kZXIgKGNvbmZpZywgZGF0YSkge1xuICAgIC8vIElmIGEgY3VzdG9tIHRlbXBsYXRlIGlzIHByb3ZpZGVkLCB1c2UgaXQsXG4gICAgLy8gb3RoZXJ3aXNlIGZhbGwgYmFjayB0byB0aGUgdGVtcGxhdGUgbmFtZVxuICAgIC8vIFRPRE8oYmlsbHkpIFRoaXMgaW50ZXJmYWNlIHNob3VsZCBwcm9iYWJseSBiZSBsZXNzIHVnbHlcbiAgICBpZiAoY29uZmlnLnRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnRlbXBsYXRlKGRhdGEpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzW2NvbmZpZy50ZW1wbGF0ZU5hbWVdKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBmaW5kL3JlbmRlciB0ZW1wbGF0ZTogJyArIGNvbmZpZy50ZW1wbGF0ZU5hbWUsIGUpO1xuICAgIH1cbiAgfVxuXG4gIF9yZWdpc3RlckN1c3RvbUhlbHBlcnMgKCkge1xuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2lmZXEnLCBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIChhcmcxID09PSBhcmcyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdpZm5vdGVxJywgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoYXJnMSAhPT0gYXJnMikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignZm9ybWF0UGhvbmVOdW1iZXInLCBmdW5jdGlvbiAocGhvbmVOdW1iZXJTdHJpbmcpIHtcbiAgICAgIHZhciBjbGVhbmVkID0gKCcnICsgcGhvbmVOdW1iZXJTdHJpbmcpLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICB2YXIgbWF0Y2ggPSBjbGVhbmVkLm1hdGNoKC9eKDF8KT8oXFxkezN9KShcXGR7M30pKFxcZHs0fSkkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGludGxDb2RlID0gKG1hdGNoWzFdID8gJysxICcgOiAnJyk7XG4gICAgICAgIHJldHVybiBbaW50bENvZGUsICcoJywgbWF0Y2hbMl0sICcpICcsIG1hdGNoWzNdLCAnLScsIG1hdGNoWzRdXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignYXNzaWduJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBsZXQgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICghb3B0aW9ucy5kYXRhLnJvb3QpIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhLnJvb3QgPSB7fTtcbiAgICAgIH1cblxuICAgICAgbGV0IHYgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdiA9IHYgKyBhcmdzW2ldO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmRhdGEucm9vdFtuYW1lXSA9IHY7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdqc29uJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gJydcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ3BsdXJhbCcsIGZ1bmN0aW9uIChudW1iZXIsIHNpbmd1bGFyVGV4dCwgcGx1cmFsVGV4dCkge1xuICAgICAgcmV0dXJuIG51bWJlciA9PT0gMVxuICAgICAgICA/IHNpbmd1bGFyVGV4dFxuICAgICAgICA6IHBsdXJhbFRleHQ7XG4gICAgfSk7XG5cbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5yZWdpc3RlckhlbHBlcignaWNvbicsIGZ1bmN0aW9uIChuYW1lLCBjb21wbGV4Q29udGVudHNQYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgIGxldCBpY29uID0gSWNvbnMuZGVmYXVsdDtcbiAgICAgIGlmICghSWNvbnNbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuU2FmZVN0cmluZyhpY29uKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgSWNvbnNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWNvbiA9IEljb25zW25hbWVdKGNvbXBsZXhDb250ZW50c1BhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpY29uID0gSWNvbnNbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5TYWZlU3RyaW5nKGljb24pO1xuICAgIH0pO1xuXG4gICAgc2VsZi5yZWdpc3RlckhlbHBlcignaGlnaGxpZ2h0VmFsdWUnLCBmdW5jdGlvbiAodmFsdWUsIGdldEludmVydGVkKSB7XG4gICAgICBjb25zdCBlc2NhcGVkSW5wdXQgPSBzZWxmLmVzY2FwZUV4cHJlc3Npb24odmFsdWUudmFsdWUgfHwgdmFsdWUuc2hvcnRWYWx1ZSk7XG5cbiAgICAgIGNvbnN0IGhpZ2hsaWdodGVkVmFsID0gbmV3IEhpZ2hsaWdodGVkVmFsdWUoe1xuICAgICAgICB2YWx1ZTogZXNjYXBlZElucHV0LFxuICAgICAgICBtYXRjaGVkU3Vic3RyaW5nczogdmFsdWUubWF0Y2hlZFN1YnN0cmluZ3NcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ2V0SW52ZXJ0ZWQgPyBzZWxmLlNhZmVTdHJpbmcoaGlnaGxpZ2h0ZWRWYWwuZ2V0SW52ZXJ0ZWQoKSlcbiAgICAgICAgOiBzZWxmLlNhZmVTdHJpbmcoaGlnaGxpZ2h0ZWRWYWwuZ2V0KCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcic7XG5pbXBvcnQgSGFuZGxlYmFyc1JlbmRlcmVyIGZyb20gJy4vaGFuZGxlYmFyc3JlbmRlcmVyJztcblxuLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyB3aWxsIGNvbnRhaW4gYWxsIGRpZmZlcmVudCB0eXBlcyBvZiByZW5kZXJlcnNcbi8vIEUuZy4gTXVzdGFjaGUsIFNPWSwgSGFuZGxlQmFycywgUmVhY3QsIGV0Yy5cbmV4cG9ydCBjb25zdCBSZW5kZXJlcnMgPSB7XG4gIFNPWTogUmVuZGVyZXIsXG4gIEhhbmRsZWJhcnM6IEhhbmRsZWJhcnNSZW5kZXJlclxufTtcbiIsIi8qKiBAbW9kdWxlICovXG5cbi8qKiBUaGUgY3VycmVudCBsaWIgdmVyc2lvbiwgcmVwb3J0ZWQgd2l0aCBlcnJvcnMgYW5kIGFuYWx5dGljcyAqL1xuZXhwb3J0IGNvbnN0IExJQl9WRVJTSU9OID0gJ3YwLjEzLjEnO1xuXG4vKiogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQgKi9cbmV4cG9ydCBjb25zdCBQUk9EVUNUSU9OID0gJ3Byb2R1Y3Rpb24nO1xuXG4vKiogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHNhbmRib3ggZW52aXJvbm1lbnQgKi9cbmV4cG9ydCBjb25zdCBTQU5EQk9YID0gJ3NhbmRib3gnO1xuXG4vKiogVGhlIGRlZmF1bHQgdXJsIGZvciBjb21waWxlZCBjb21wb25lbnQgdGVtcGxhdGVzICovXG5leHBvcnQgY29uc3QgQ09NUElMRURfVEVNUExBVEVTX1VSTCA9IGBodHRwczovL2Fzc2V0cy5zaXRlc2Nkbi5uZXQvYW5zd2Vycy8ke0xJQl9WRVJTSU9OfS9hbnN3ZXJzdGVtcGxhdGVzLmNvbXBpbGVkLm1pbi5qc2A7XG4iLCIvKiogQG1vZHVsZSBEZWZhdWx0VGVtcGxhdGVzTG9hZGVyICovXG5cbmltcG9ydCBET00gZnJvbSAnLi4vZG9tL2RvbSc7XG5pbXBvcnQgeyBDT01QSUxFRF9URU1QTEFURVNfVVJMIH0gZnJvbSAnLi4vLi4vY29yZS9jb25zdGFudHMnO1xuXG4vKipcbiAqIERlZmF1bHRUZW1wbGF0ZXNMb2FkZXIgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIGxvYWRpbmcgdGhlIGRlZmF1bHQgc2V0IG9mIGNvbXBpbGVkIHRlbXBsYXRlc1xuICogYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgc2VydmVyLiBOb3RlIHRoYXQgdGhpcyBjbGFzcyBjYW5ub3QgYmUgcmVwdXJwb3NlZCB0byBmZXRjaCBjdXN0b21cbiAqIHRlbXBsYXRlcyBob3N0ZWQgYnkgYSBjbGllbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRUZW1wbGF0ZXNMb2FkZXIge1xuICBjb25zdHJ1Y3RvciAob25Mb2FkZWQpIHtcbiAgICBpZiAoIURlZmF1bHRUZW1wbGF0ZXNMb2FkZXIuc2V0SW5zdGFuY2UodGhpcykpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VGVtcGxhdGVzTG9hZGVyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHt9O1xuICAgIHRoaXMuX29uTG9hZGVkID0gb25Mb2FkZWQgfHwgZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5fZmV0Y2hUZW1wbGF0ZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRJbnN0YW5jZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgX2ZldGNoVGVtcGxhdGVzICgpIHtcbiAgICAvLyBJZiB0ZW1wbGF0ZSBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQsIGRvIG5vdGhpbmdcbiAgICBsZXQgbm9kZSA9IERPTS5xdWVyeSgnI3lleHQtYW5zd2Vycy10ZW1wbGF0ZXMnKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhIHNjcmlwdCB0byBmZXRjaCB0aGUgY29tcGlsZWQgdGVtcGxhdGVzLFxuICAgIC8vIHdyYXBwaW5nIGl0IGEgUHJvbWlzZSBmb3IgY2xlYW5saW5lc3NcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHNjcmlwdCA9IERPTS5jcmVhdGVFbCgnc2NyaXB0Jywge1xuICAgICAgICBpZDogJ3lleHQtYW5zd2Vycy10ZW1wbGF0ZXMnLFxuICAgICAgICBvbmxvYWQ6IHJlc29sdmUsXG4gICAgICAgIG9uZXJyb3I6IHJlamVjdCxcbiAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgIHNyYzogQ09NUElMRURfVEVNUExBVEVTX1VSTFxuICAgICAgfSk7XG4gICAgICBET00uYXBwZW5kKCdib2R5Jywgc2NyaXB0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWdpc3RlciB0aGUgdGVtcGxhdGVzIGludGVybmFsbHkgc28gdGhhdCB0aGV5IGNhbiBiZSBsYXRlciBjb25zdW1lZFxuICAgKiAoZS5nLiBieSBjb21wb25lbnRzIGFuZCByZW5kZXJlcnMpIHdpdGggY29udmllbmllbmNlLlxuICAgKlxuICAgKiBgZmV0Y2hUZW1wbGF0ZXNgIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHRoaXMsIHByb3ZpZGluZyB0aGUgY29tcGlsZWQgdGVtcGxhdGVzIGZyb20gdGhlIHNlcnZlci5cbiAgICovXG4gIHJlZ2lzdGVyICh0ZW1wbGF0ZXMpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG5cbiAgICAvLyBOb3RpZnkgb3VyIGNvbnN1bWVycyB0aGF0IHRoZSB0ZW1wbGF0ZXMgYXJlIGhlcmUgOilcbiAgICB0aGlzLl9vbkxvYWRlZCh0aGlzLl90ZW1wbGF0ZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0ICh0ZW1wbGF0ZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBUaGUgaW50ZXJuYWwgdGVtcGxhdGUgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0VGVtcGxhdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIERPTSB9IGZyb20gJy4vZG9tL2RvbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vZG9tL3NlYXJjaHBhcmFtcyc7XG5cbmV4cG9ydCB7IFJlbmRlcmVycyB9IGZyb20gJy4vcmVuZGVyaW5nL2NvbnN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGVmYXVsdFRlbXBsYXRlc0xvYWRlciB9IGZyb20gJy4vcmVuZGVyaW5nL2RlZmF1bHR0ZW1wbGF0ZXNsb2FkZXInO1xuIiwiLyoqIEBtb2R1bGUgRXZlbnRFbWl0dGVyICovXG5cbi8qKlxuICogRXZlbnRFbWl0dGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgYW55IG9iamVjdCB0aGF0IHdhbnRzIHRvIGV4cG9zZVxuICogYSBwdWIvc3ViIGludGVyZmFjZSwgZm9yIGVtaXR0aW5nIG1lc3NhZ2VzIGFuZCBwcm92aWRpbmcgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN1YnNjcmliZXJzIG9mIG1lc3NhZ2VzXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cblxuICAvKipcbiAgICogb24gaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIHN1YnNjcmliaW5nIGV2ZW50cyB0aGF0IGFyZSBlbWl0dGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IHRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIHtldnR9IGlzIGVtaXR0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIE9wdGlvbmFsIHZhbHVlIHdoaWNoIHdpbGwgb25seSBoYW5kbGUgdGhlIG1lc3NhZ2Ugb25jZVxuICAgKi9cbiAgb24gKGV2dCwgY2IsIG9uY2UpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGhhbmRsZXIgc2hvdWxkIGJlIG9mIHR5cGUge2Z1bmN0aW9ufScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2dCxcbiAgICAgIGNiOiBjYixcbiAgICAgIG9uY2U6IG9uY2UgfHwgZmFsc2VcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uY2UgaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIHN1YnNjcmliaW5nIGV2ZW50cyB0aGF0IGFyZSBlbWl0dGVkLlxuICAgKiBUaGUgaGFuZGxlciB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIG9uY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUge2V2dH0gaXMgZW1pdHRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgT3B0aW9uYWwgdmFsdWUgd2hpY2ggd2lsbCBvbmx5IGhhbmRsZSB0aGUgbWVzc2FnZSBvbmNlXG4gICAqL1xuICBvbmNlIChldnQsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZ0LCBjYiwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogb2ZmIGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCB0aGUgZXZlbnQgbmFtZSB0byB1bnN1YnNjcmliZSBmcm9tXG4gICAqL1xuICBvZmYgKGV2dCkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBlbWl0IGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciBicm9hZGNhc3RpbmcgbWVzc2FnZXMvZXZlbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gcHVibGlzaCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHNlbmQgYWxvbmcgdG8gdGhlIHN1YnNjcmliZXJzXG4gICAqL1xuICBlbWl0IChldnQsIGRhdGEpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIGVhY2ggb2YgYWxsIHRoZSBsaXN0ZW5lciBoYW5kbGVycyBhbmQgcmVtb3ZlIHRoZSBvbmVzIHRoYXQgc2hvdWxkIGZpcmUgb25seSBvbmNlLlxuICAgIGxldCBrZWVwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5jYihkYXRhKTtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5zdGVhZCBvZiBoYXZpbmcgYSAnZGlydHknIGFycmF5IHdpdGggZGVsZXRlZCBvciAndW5kZWZpbmVkJyBlbnRyaWVzLFxuICAgICAgLy8gd2UganVzdCBjcmVhdGUgYSBicmFuZCBuZXcgYXJyYXkgd2l0aG91dCB0aGUgbGlzdGVuZXJzIHRoYXQgd2VyZSByZW1vdmVkXG4gICAgICBrZWVwLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgb3VyIG9sZCBsaXN0IG9mIGxpc3RlbmVycyB0byB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxuICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0ga2VlcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3RhdGUgKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi9jb3JlL2V2ZW50ZW1pdHRlci9ldmVudGVtaXR0ZXInO1xuXG4vKipcbiAqIFN0YXRlIGNvbnRhaW5zIHRoZSBkYXRhIGZvciB0aGUgY29tcG9uZW50XG4gKiBhbmQgZXhwb3NlcyBhbiB7RXZlbnRFbWl0dGVyfSBpbnRlcmZhY2Ugc28gdGhhdCBleHRlcm5hbFxuICogZGVwZW5kZW5jaWVzIGNhbiBsaXN0ZW4vaG9vayBzdWJzY3JpYmUgdG8gbWVzc2FnZXMvdXBkYXRlcy5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhdGUgPSBkYXRhIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBOT1RFKGJpbGx5KTogRG9lcyBub3QgZmlyZSBhbiB1cGRhdGUgbWVzc2FnZVxuICAgKi9cbiAgaW5pdCAocHJvcCwgb3B0VmFsKSB7XG4gICAgdGhpcy5fc2V0KHByb3AsIG9wdFZhbCk7XG4gIH1cblxuICAvKipcbiAgICogc2V0dGVyIGZvciB0aGUgc3RhdGVcbiAgICogQHBhcmFtIHByb3Age3N0cmluZ3xPYmplY3R9IFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIG9wdFZhbCBPcHRpb25hbCwgaWYgcHJvcCBpcyBhIHtzdHJpbmd9LCBpdCB3aWxsIGFzc2lnbiB0aGUgdmFsdWUgdG8gdGhhdCBwcm9wZXJ0eVxuICAgKi9cbiAgc2V0IChwcm9wLCBvcHRWYWwpIHtcbiAgICB0aGlzLl9zZXQocHJvcCwgb3B0VmFsKTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldHRlciBmb3IgdGhlIHN0YXRlIGVuYWJsZXMgeW91IHRvIHVwZGF0ZSBhIHNpbmdsZSBwcm9wZXJ0eSwgb3IgY29tcGxldGUgc3RhdGVcbiAgICogZGVwZW5kaW5nIG9uIHRoZSBhcmd1bWVudHMgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBwcm9wIHtzdHJpbmd8T2JqZWN0fSBUaGUgcHJvcGVydHkgdG8gc2V0XG4gICAqIEBwYXJhbSBvcHRWYWwgSWYgcHJvcCBpcyBhIHtzdHJpbmd9LCBwcm92aWRlIGl0cyB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldCAocHJvcCwgb3B0VmFsKSB7XG4gICAgaWYgKG9wdFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlW3Byb3BdID0gb3B0VmFsO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSAoZGF0YSkge1xuICAgIHRoaXMuX3N0YXRlID0gZGF0YTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgcHJvcGVydGllcyB2YWx1ZSBmcm9tIHRoZSBzdGF0ZVxuICAgKiBJZiBubyBwcm9wZXJ0eSBwcm92aWRlZCwgcmV0dXJuIHRoZSBmdWxsIHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRQcm9wIG9wdGlvbmFsIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqL1xuICBnZXQgKG9wdFByb3ApIHtcbiAgICBpZiAob3B0UHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZVtvcHRQcm9wXTtcbiAgfVxuXG4gIGhhcyAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXNKU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbn1cbiIsInZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge31cblxuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICB9XG4gIGJvZHkuYm9keVVzZWQgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICB9XG4gICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWxcbiAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgfVxuXG4gIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJ1xuICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIH1cbiAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsXG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICBpZiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICB9XG5cbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICB9XG5cbiAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgfSlcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFzZWxmLmZldGNoKSB7XG4gIHNlbGYuZmV0Y2ggPSBmZXRjaFxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iLCIvKiogQG1vZHVsZSBIdHRwUmVxdWVzdGVyICovXG5cbi8qIGdsb2JhbCBmZXRjaCwgWE1MSHR0cFJlcXVlc3QsIEFjdGl2ZVhPYmplY3QgKi9cblxuaW1wb3J0IHsgZmV0Y2ggYXMgZmV0Y2hQb2x5ZmlsbCB9IGZyb20gJ3doYXR3Zy1mZXRjaCc7XG5cbi8qKlxuICogVHlwZXMgb2YgSFRUUCByZXF1ZXN0c1xuICovXG5jb25zdCBNZXRob2RzID0ge1xuICBHRVQ6ICdnZXQnLFxuICBQT1NUOiAncG9zdCcsXG4gIFBVVDogJ3B1dCcsXG4gIERFTEVURTogJ2RlbGV0ZSdcbn07XG5cbi8qKlxuICogSHR0cFJlcXVlc3RlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQUpBWFxuICogcmVsYXRlZCBtYXR0ZXJzLiBJdCdzIHVzZWQgdG8gbWFrZSBhbGwgdHlwZXMgb2YgbmV0d29yayByZXF1ZXN0c1xuICogYW5kIGV4cG9zZXMgYSBwcm9taXNlIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHR0cFJlcXVlc3RlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBHRVQgSFRUUCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBwcm92aWRlIChnZXRzIGVuY29kZWQgaW50byB0aGUgVVJMKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgKi9cbiAgZ2V0ICh1cmwsIGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE1ldGhvZHMuR0VULCB0aGlzLmVuY29kZVBhcmFtcyh1cmwsIGRhdGEpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBQT1NUIEhUVFAgcmVxdWVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHVybFBhcmFtcyBUaGUgcGFyYW1zIHRvIGVuY29kZSBpbnRvIHRoZSBVUkxcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb25Cb2R5IFRoZSByZXF1ZXN0IGJvZHkgKGpzb24pIHRvIHByb3ZpZGUgd2l0aCB0aGUgUE9TVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0Q29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAqL1xuICBwb3N0ICh1cmwsIHVybFBhcmFtcywganNvbkJvZHksIHJlcXVlc3RDb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgTWV0aG9kcy5QT1NULFxuICAgICAgdGhpcy5lbmNvZGVQYXJhbXModXJsLCB1cmxQYXJhbXMpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uQm9keSksXG4gICAgICAgIGNyZWRlbnRpYWxzOiB1bmRlZmluZWRcbiAgICAgIH0sIHJlcXVlc3RDb25maWcpXG4gICAgKTtcbiAgfVxuXG4gIHJlcXVlc3QgKG1ldGhvZCwgdXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVxQXJncyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICdtZXRob2QnOiBtZXRob2QsXG4gICAgICAnY3JlZGVudGlhbHMnOiAnaW5jbHVkZSdcbiAgICB9LCBvcHRzKTtcblxuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwsIHJlcUFyZ3MpO1xuICB9XG5cbiAgLy8gVE9ETyAoYWdyb3cpIGludmVzdGlnYXRlIHJlbW92aW5nIHRoaXNcbiAgLy8gVXNlIGltcG9ydGVkIGZldGNoUG9seWZpbGwgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBvbiB3aW5kb3dcbiAgX2ZldGNoICh1cmwsIHJlcUFyZ3MpIHtcbiAgICBpZiAoIXdpbmRvdy5mZXRjaCkge1xuICAgICAgcmV0dXJuIGZldGNoUG9seWZpbGwodXJsLCByZXFBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoKHVybCwgcmVxQXJncyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGJlYWNvbiB0byB0aGUgcHJvdmlkZWQgdXJsIHdoaWNoIHdpbGwgc2VuZCBhIG5vbi1ibG9ja2luZyByZXF1ZXN0XG4gICAqIHRvIHRoZSBzZXJ2ZXIgdGhhdCBpcyBndWFyYW50ZWVkIHRvIHNlbmQgYmVmb3JlIHBhZ2UgbG9hZC4gTm8gcmVzcG9uc2UgaXMgcmV0dXJuZWQsXG4gICAqIHNvIGJlYWNvbnMgYXJlIHByaW1hcmlseSB1c2VkIGZvciBhbmFseXRpY3MgcmVwb3J0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gc2VuZCB0aGUgYmVhY29uIHRvXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBkYXRhIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgYmVhY29uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHF1ZXVlZFxuICAgKi9cbiAgYmVhY29uICh1cmwsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZEJlYWNvbih1cmwsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgfVxuXG4gIC8vIFRPRE8gKGFncm93KSBpbnZlc3RpZ2F0ZSByZW1vdmluZyB0aGlzXG4gIC8vIE5hdmlnYXRvci5zZW5kQmVhY29uIHBvbHlmaWxsXG4gIC8vIENvbWJpbmF0aW9uIG9mIHRoZSBjb21wYWN0IEZpbmFuY2lhbCBUaW1lcyBwb2x5ZmlsbDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1saWJyYXJ5L2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9uYXZpZ2F0b3Ivc2VuZEJlYWNvbi9wb2x5ZmlsbC5qc1xuICAvLyB3aXRoIHRoZSBhc3luYy1ieS1kZWZhdWx0IGJlaGF2aW9yIG9mIE1pZ3VlbCBNb3RhJ3MgcG9seWZpbGw6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL05hdmlnYXRvci5zZW5kQmVhY29uL2Jsb2IvbWFzdGVyL3NlbmRiZWFjb24uanNcbiAgX3NlbmRCZWFjb24gKHVybCwgZGF0YSkge1xuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3Iuc2VuZEJlYWNvbikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3Iuc2VuZEJlYWNvbih1cmwsIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBldmVudCA9IHdpbmRvdy5ldmVudCAmJiB3aW5kb3cuZXZlbnQudHlwZTtcbiAgICB2YXIgc3luYyA9IGV2ZW50ID09PSAndW5sb2FkJyB8fCBldmVudCA9PT0gJ2JlZm9yZXVubG9hZCc7XG4gICAgdmFyIHhociA9ICgnWE1MSHR0cFJlcXVlc3QnIGluIHdpbmRvdykgPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCAhc3luYyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgIGlmIChkYXRhLnR5cGUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGRhdGEudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHhoci5zZW5kKGRhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZW5jb2RlUGFyYW1zICh1cmwsIHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNQYXJhbSA9IHVybC5pbmRleE9mKCc/JykgPiAtMTtcblxuICAgIGxldCBzZWFyY2hRdWVyeSA9ICcnO1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmICghaGFzUGFyYW0pIHtcbiAgICAgICAgaGFzUGFyYW0gPSB0cnVlO1xuICAgICAgICBzZWFyY2hRdWVyeSArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2hRdWVyeSArPSAnJic7XG4gICAgICB9XG5cbiAgICAgIHNlYXJjaFF1ZXJ5ICs9IGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB1cmwgKyBzZWFyY2hRdWVyeTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUFJPRFVDVElPTiwgU0FOREJPWCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL3VpL2RvbS9zZWFyY2hwYXJhbXMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdXJsIGZvciB0aGUgbGl2ZSBhcGkgYmFja2VuZCBpbiB0aGUgZGVzaXJlZCBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnYgVGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXZlQXBpVXJsIChlbnYgPSBQUk9EVUNUSU9OKSB7XG4gIHJldHVybiBlbnYgPT09IFNBTkRCT1ggPyAnaHR0cHM6Ly9saXZlYXBpLXNhbmRib3gueWV4dC5jb20nIDogJ2h0dHBzOi8vbGl2ZWFwaS55ZXh0LmNvbSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSB1cmwgZm9yIHRoZSBsaXZlIGFwaSBiYWNrZW5kIGluIHRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGVudiBUaGUgZGVzaXJlZCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlZExpdmVBcGlVcmwgKGVudiA9IFBST0RVQ1RJT04pIHtcbiAgcmV0dXJuIGVudiA9PT0gU0FOREJPWCA/ICdodHRwczovL2xpdmVhcGktc2FuZGJveC55ZXh0LmNvbScgOiAnaHR0cHM6Ly9saXZlYXBpLWNhY2hlZC55ZXh0LmNvbSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSB1cmwgZm9yIHRoZSBrbm93bGVkZ2UgYXBpIGJhY2tlbmQgaW4gdGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52IFRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S25vd2xlZGdlQXBpVXJsIChlbnYgPSBQUk9EVUNUSU9OKSB7XG4gIHJldHVybiBlbnYgPT09IFNBTkRCT1ggPyAnaHR0cHM6Ly9hcGktc2FuZGJveC55ZXh0LmNvbScgOiAnaHR0cHM6Ly9hcGkueWV4dC5jb20nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdXJsIGZvciB0aGUgYW5hbHl0aWNzIGJhY2tlbmQgaW4gdGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52IFRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtib29sZWFufSBjb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIElmIGNvbnZlcnNpb24gdHJhY2tpbmcgaGFzIGJlZW4gb3B0ZWQgaW50by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFuYWx5dGljc1VybCAoZW52ID0gUFJPRFVDVElPTiwgY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCA9IGZhbHNlKSB7XG4gIGlmIChjb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkKSB7XG4gICAgcmV0dXJuIGVudiA9PT0gU0FOREJPWFxuICAgICAgPyAnaHR0cHM6Ly9zYW5kYm94LXJlYWx0aW1lYW5hbHl0aWNzLnlleHQuY29tJ1xuICAgICAgOiAnaHR0cHM6Ly9yZWFsdGltZWFuYWx5dGljcy55ZXh0LmNvbSc7XG4gIH1cbiAgcmV0dXJuIGVudiA9PT0gU0FOREJPWFxuICAgID8gJ2h0dHBzOi8vc2FuZGJveC1hbnN3ZXJzLnlleHQtcGl4ZWwuY29tJ1xuICAgIDogJ2h0dHBzOi8vYW5zd2Vycy55ZXh0LXBpeGVsLmNvbSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFzc2VkIGluIHVybCB3aXRoIHRoZSBxdWVyeSBhcHBlbmRlZCB0byBpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7cGFyYW1zfSBPYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQYXJhbXNUb1VybCAodXJsLCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgZm9yIChjb25zdCBwYXJhbUtleSBpbiBwYXJhbXMpIHtcbiAgICB1cmxQYXJhbXMuc2V0KHBhcmFtS2V5LCBwYXJhbXNbcGFyYW1LZXldKTtcbiAgfVxuICByZXR1cm4gdXJsLnNwbGl0KCc/JylbMF0gKyAnPycgKyB1cmxQYXJhbXM7XG59XG4iLCIvKiogQG1vZHVsZSBBcGlSZXF1ZXN0ICovXG5cbmltcG9ydCBIdHRwUmVxdWVzdGVyIGZyb20gJy4vaHR0cHJlcXVlc3Rlcic7XG5pbXBvcnQgeyBMSUJfVkVSU0lPTiwgUFJPRFVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL3VpL2RvbS9zZWFyY2hwYXJhbXMnOyAvLyBUT0RPIGlkZWFsbHkgdGhpcyB3b3VsZCBiZSBwYXNzZWQgaW4gYXMgYSBwYXJhbVxuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCB7IGdldExpdmVBcGlVcmwgfSBmcm9tICcuLi91dGlscy91cmx1dGlscyc7XG5cbi8qKlxuICogQXBpUmVxdWVzdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEFQSSByZXF1ZXN0cy5cbiAqIEl0IGRlZmluZXMgYWxsIG9mIHRoZSBjb3JlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gbWFrZSBhIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBpUmVxdWVzdCB7XG4gIC8vIFRPRE8gKHRtZXllcik6IENyZWF0ZSBhbiBBcGlTZXJ2aWNlIGludGVyZmFjZSBhbmQgcGFzcyBhbiBpbXBsZW1lbnRhdGlvbiB0byB0aGUgY3VycmVudFxuICAvLyBjb25zdW1lcnMgb2YgQXBpUmVxdWVzdCBhcyBhIGRlcGVuZGVuY3kuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiB1c2VkIGZvciBtYWtpbmcgbmV0d29yayByZXF1ZXN0IGFuZCBoYW5kbGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7SHR0cFJlcXVlc3Rlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlcXVlc3RlciA9IG5ldyBIdHRwUmVxdWVzdGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIG1hZGUgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW52aXJvbm1lbnQgPSBvcHRzLmVudmlyb25tZW50IHx8IFBST0RVQ1RJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZVVybCB0byB1c2UgZm9yIG1ha2luZyBhIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IG9wdHMuYmFzZVVybCB8fCBnZXRMaXZlQXBpVXJsKHRoaXMuX2Vudmlyb25tZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmRwb2ludCB0byB1c2UgaW4gdGhlIHVybCAoYXBwZW5kZWQgdG8gdGhlIHtiYXNlVXJsfSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW5kcG9pbnQgPSBvcHRzLmVuZHBvaW50IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IG9wdHMuYXBpS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgQVBJIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSBvcHRzLnZlcnNpb24gfHwgMjAxOTAxMDE7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGRhdGEgcGFyYW1zIHRoYXQgYXJlIHNlbnQgYWxvbmcgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBvcHRzLnBhcmFtcyB8fCB7fTtcblxuICAgIGlmICghZ2xvYmFsU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdNdXN0IGluY2x1ZGUgZ2xvYmFsIHN0b3JhZ2UnLCAnQXBpUmVxdWVzdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R2xvYmFsU3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBjcmVhdGVzIGEgbmV3IGBHRVRgIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBjbGFzc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAqL1xuICBnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0ZXIuZ2V0KFxuICAgICAgdGhpcy5fYmFzZVVybCArIHRoaXMuX2VuZHBvaW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUGFyYW1zKCksIHRoaXMuc2FuaXRpemVQYXJhbXModGhpcy5fcGFyYW1zKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICovXG4gIHBvc3QgKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdGVyLnBvc3QoXG4gICAgICB0aGlzLl9iYXNlVXJsICsgdGhpcy5fZW5kcG9pbnQsXG4gICAgICB0aGlzLmJhc2VQYXJhbXMoKSAvKiB1cmxQYXJhbXMgKi8sXG4gICAgICB0aGlzLnNhbml0aXplUGFyYW1zKHRoaXMuX3BhcmFtcykgLyoganNvbkJvZHkgKi8sXG4gICAgICBvcHRzIC8qIHJlcXVlc3RDb25maWcgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiYXNlUGFyYW1zICgpIHtcbiAgICBsZXQgYmFzZVBhcmFtcyA9IHtcbiAgICAgICd2JzogdGhpcy5fdmVyc2lvbixcbiAgICAgICdhcGlfa2V5JzogdGhpcy5fYXBpS2V5LFxuICAgICAgJ2pzTGliVmVyc2lvbic6IExJQl9WRVJTSU9OLFxuICAgICAgJ3Nlc3Npb25UcmFja2luZ0VuYWJsZWQnOiB0aGlzLl9nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTilcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKHVybFBhcmFtcy5oYXMoJ2JldGEnKSkge1xuICAgICAgYmFzZVBhcmFtc1snYmV0YSddID0gdXJsUGFyYW1zLmdldCgnYmV0YScpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlUGFyYW1zO1xuICB9XG5cbiAgc2FuaXRpemVQYXJhbXMgKHBhcmFtcyA9IHt9KSB7XG4gICAgLy8gUmVtb3ZlIGFueSBwYXJhbWF0ZXJzIHdob3MgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgLy9cbiAgICAvLyBOT1RFKGJpbGx5KSBQcm9iYWJseSBiZXR0ZXIgdG8gYmUgZXhwbGljaXQgYWJvdXQgaG93IHRvIGhhbmRsZSB0aGlzIGF0IHRoZSByZXF1ZXN0IGJ1aWxkaW5nIGxldmVsLFxuICAgIC8vIGJ1dCBJIGNhbid0IHNlZSBhbnkgY2FzZXMgd2hlcmUgd2UnZCBldmVyIHdhbnQgdG8gc2VuZCAndW5kZWZpbmVkJyBhcyBhIHZhbHVlIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gU28gaXQncyBwcm9iYWJseSBmaW5lIHRvICdjbGVhbicgdGhlIHBhcmFtcyBvYmplY3QgaGVyZVxuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHBhcmFtc1trZXldID09PSB1bmRlZmluZWQgfHwgcGFyYW1zW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHBhcmFtc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoQXBpICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlYXJjaHNlcnZpY2UnKS5kZWZhdWx0fSBTZWFyY2hTZXJ2aWNlICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBBbnN3ZXJzQmFzaWNFcnJvciwgQW5zd2Vyc0NvcmVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKipcbiAqIFNlYXJjaEFwaSBpcyB0aGUgQVBJIGZvciBkb2luZyB2YXJpb3VzIHR5cGVzIG9mIHNlYXJjaFxuICogb3ZlciB0aGUgbmV0d29yayAoZS5nLiB2ZXJ0aWNhbCBvciB1bml2ZXJzYWwpXG4gKlxuICogQGltcGxlbWVudHMge1NlYXJjaFNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEFwaSB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBBUEkgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0FwaSBLZXkgaXMgcmVxdWlyZWQnLCAnU2VhcmNoJyk7XG4gICAgfVxuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgQW5zd2VycyBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5leHBlcmllbmNlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0Fuc3dlcnMgS2V5IGlzIHJlcXVpcmVkJywgJ1NlYXJjaCcpO1xuICAgIH1cbiAgICB0aGlzLl9leHBlcmllbmNlS2V5ID0gY29uZmlnLmV4cGVyaWVuY2VLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBBUEkgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uIHx8IDIwMTkwMTAxIHx8IDIwMTkwMzAxO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGxvY2FsZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmxvY2FsZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdMb2NhbGUgaXMgcmVxdWlyZWQnLCAnU2VhcmNoJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIEFuc3dlcnMgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2ZXJ0aWNhbFNlYXJjaCAodmVydGljYWxLZXksIHsgaW5wdXQsIGZpbHRlciwgZmFjZXRGaWx0ZXIsIGxpbWl0LCBvZmZzZXQsIGlkLCBnZW9sb2NhdGlvbiwgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQsIHNraXBTcGVsbENoZWNrLCBxdWVyeVRyaWdnZXIsIHNlc3Npb25UcmFja2luZ0VuYWJsZWQsIHNvcnRCeXMgfSkge1xuICAgIGlmIChsaW1pdCA+IDUwKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignUHJvdmlkZWQgc2VhcmNoIGxpbWl0IHVuc3VwcG9ydGVkJywgJ1NlYXJjaEFwaScpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9xdWVyeScsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBlbnZpcm9ubWVudDogdGhpcy5fZW52aXJvbm1lbnQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogaW5wdXQsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2ZpbHRlcnMnOiBmaWx0ZXIsXG4gICAgICAgICdmYWNldEZpbHRlcnMnOiBmYWNldEZpbHRlcixcbiAgICAgICAgJ3ZlcnRpY2FsS2V5JzogdmVydGljYWxLZXksXG4gICAgICAgICdsaW1pdCc6IGxpbWl0LFxuICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0LFxuICAgICAgICAnbG9jYXRpb24nOiBnZW9sb2NhdGlvbiA/IGAke2dlb2xvY2F0aW9uLmxhdH0sJHtnZW9sb2NhdGlvbi5sbmd9YCA6IG51bGwsXG4gICAgICAgICdyYWRpdXMnOiBnZW9sb2NhdGlvbiA/IGdlb2xvY2F0aW9uLnJhZGl1cyA6IG51bGwsXG4gICAgICAgICdxdWVyeUlkJzogaWQsXG4gICAgICAgICdyZXRyaWV2ZUZhY2V0cyc6IGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkLFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2tpcFNwZWxsQ2hlY2snOiBza2lwU3BlbGxDaGVjayxcbiAgICAgICAgJ3F1ZXJ5VHJpZ2dlcic6IHF1ZXJ5VHJpZ2dlcixcbiAgICAgICAgJ3Nlc3Npb25UcmFja2luZ0VuYWJsZWQnOiBzZXNzaW9uVHJhY2tpbmdFbmFibGVkLFxuICAgICAgICAnc29ydEJ5cyc6IHNvcnRCeXNcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgeyBnZXRTdGF0ZTogKCkgPT4gc2Vzc2lvblRyYWNraW5nRW5hYmxlZCB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHVuaXZlcnNhbFNlYXJjaCAocXVlcnlTdHJpbmcsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB7XG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9hbnN3ZXJzL3F1ZXJ5JyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBxdWVyeVN0cmluZyxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAnbG9jYXRpb24nOiBwYXJhbXMuZ2VvbG9jYXRpb24gPyBgJHtwYXJhbXMuZ2VvbG9jYXRpb24ubGF0fSwke3BhcmFtcy5nZW9sb2NhdGlvbi5sbmd9YCA6IG51bGwsXG4gICAgICAgICdyYWRpdXMnOiBwYXJhbXMuZ2VvbG9jYXRpb24gPyBwYXJhbXMuZ2VvbG9jYXRpb24ucmFkaXVzIDogbnVsbCxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgJ3NraXBTcGVsbENoZWNrJzogcGFyYW1zLnNraXBTcGVsbENoZWNrLFxuICAgICAgICAncXVlcnlUcmlnZ2VyJzogcGFyYW1zLnF1ZXJ5VHJpZ2dlclxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB7IGdldFN0YXRlOiAoKSA9PiBwYXJhbXMuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIE1vZGVsIGZvciB0aGUgYW5hbHl0aWNzIGV2ZW50IHR5cGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5hbHl0aWNzRXZlbnQge1xuICBjb25zdHJ1Y3RvciAodHlwZSwgbGFiZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBldmVudCB0byByZXBvcnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRUeXBlID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gYmUgcHJvdmlkZWQgZm9yIHRoZSBldmVudFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHByb3ZpZGVkIG9wdGlvbnMgdG8gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGV2ZW50XG4gICAqL1xuICBhZGRPcHRpb25zIChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGV2ZW50IGluIHRoZSBhcGkgZm9ybWF0LCB0eXBpY2FsbHkgZm9yIHJlcG9ydGluZyB0byB0aGUgYXBpXG4gICAqL1xuICB0b0FwaUV2ZW50ICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFuYWx5dGljc1JlcG9ydGVyICovXG5cbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCB7IEFuc3dlcnNBbmFseXRpY3NFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IHsgUFJPRFVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgSHR0cFJlcXVlc3RlciBmcm9tICcuLi9odHRwL2h0dHByZXF1ZXN0ZXInO1xuaW1wb3J0IHsgZ2V0QW5hbHl0aWNzVXJsIH0gZnJvbSAnLi4vdXRpbHMvdXJsdXRpbHMnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvYW5hbHl0aWNzcmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gQW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcG9ydGluZyBhbmFseXRpY3MgZXZlbnRzIHRvIHRoZSBzZXJ2ZXIgdmlhIEhUVFBcbiAqXG4gKiBAaW1wbGVtZW50cyB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmFseXRpY3NSZXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBjb3JlLFxuICAgIGV4cGVyaWVuY2VLZXksXG4gICAgZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgYnVzaW5lc3NJZCxcbiAgICBnbG9iYWxPcHRpb25zID0ge30sXG4gICAgZW52aXJvbm1lbnQgPSBQUk9EVUNUSU9OKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGJ1c2luZXNzIGlkZW50aWZpZXIgdXNlZCBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9idXNpbmVzc0lkID0gYnVzaW5lc3NJZDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IGFuYWx5dGljIGV2ZW50IHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGdsb2JhbE9wdGlvbnMsIHsgZXhwZXJpZW5jZUtleSB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgQW5zd2VycyBleHBlcmllbmNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Vudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIFVSTCBmb3IgdGhlIGFuYWx5dGljcyBBUElcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IGdldEFuYWx5dGljc1VybCh0aGlzLl9lbnZpcm9ubWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBCb29sZWFuIGluZGljYXRpbmcgaWYgb3B0ZWQgaW4gb3Igb3V0IG9mIGNvbnZlcnNpb24gdHJhY2tpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChleHBlcmllbmNlVmVyc2lvbikge1xuICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5leHBlcmllbmNlVmVyc2lvbiA9IGV4cGVyaWVuY2VWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbiB0byBxdWVyeSBpZCB1cGRhdGVzXG4gICAgY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5RVUVSWV9JRCwgaWQgPT4gdGhpcy5zZXRRdWVyeUlkKGlkKSk7XG4gIH1cblxuICBzZXRRdWVyeUlkIChxdWVyeUlkKSB7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5xdWVyeUlkID0gcXVlcnlJZDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGV2ZW50KSB7XG4gICAgbGV0IGNvb2tpZURhdGEgPSB7fTtcbiAgICBpZiAodGhpcy5fY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCAmJiB0eXBlb2YgeXRhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgeXRhZygnb3B0aW4nLCB0cnVlKTtcbiAgICAgIGNvb2tpZURhdGEgPSB5dGFnKCd5ZnBjJywgbnVsbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0FuYWx5dGljc0Vycm9yKCdUcmllZCB0byBlbmFibGUgY29udmVyc2lvbiB0cmFja2luZyB3aXRob3V0IGluY2x1ZGluZyB5dGFnJyk7XG4gICAgfVxuXG4gICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBBbmFseXRpY3NFdmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IoJ1RyaWVkIHRvIHNlbmQgaW52YWxpZCBhbmFseXRpY3MgZXZlbnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgZXZlbnQuYWRkT3B0aW9ucyh0aGlzLl9nbG9iYWxPcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgSHR0cFJlcXVlc3RlcigpLmJlYWNvbihcbiAgICAgIGAke3RoaXMuX2Jhc2VVcmx9L3JlYWx0aW1lYW5hbHl0aWNzL2RhdGEvYW5zd2Vycy8ke3RoaXMuX2J1c2luZXNzSWR9YCxcbiAgICAgIHsgZGF0YTogZXZlbnQudG9BcGlFdmVudCgpLCAuLi5jb29raWVEYXRhIH1cbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgKGlzRW5hYmxlZCkge1xuICAgIHRoaXMuX2NvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgdGhpcy5fYmFzZVVybCA9IGdldEFuYWx5dGljc1VybCh0aGlzLl9lbnZpcm9ubWVudCwgaXNFbmFibGVkKTtcbiAgfVxufVxuIiwiLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2FuYWx5dGljc3JlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEFuYWx5dGljc1JlcG9ydGVyU2VydmljZSAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtBbmFseXRpY3NSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vb3BBbmFseXRpY3NSZXBvcnRlciB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc2V0Q29udmVyc2lvblRyYWNraW5nRW5hYmxlZCAoaXNFbmFibGVkKSB7fVxufVxuIiwiLyoqIEBtb2R1bGUgTW9kdWxlRGF0YSAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2V2ZW50ZW1pdHRlci9ldmVudGVtaXR0ZXInO1xuXG4vKipcbiAqIE1vZHVsZURhdGEgaXMgdXNlZCBhcyBhIGdlbmVyaWMgbW9kZWwgZm9yIFN0b3JhZ2UuXG4gKiBUeXBpY2FsbHkgYW4gaW5zdGFuY2Ugb2YgTW9kdWxlRGF0YSBwb3dlcnMgYSBzaW5nbGUgY29tcG9uZW50LlxuXG4gKiBBIGRhdGEgbW9kZWwgdGhhdCBleHBvc2VzIGFuIGV2ZW50IGVtaXR0ZXIgaW50ZXJmYWNlLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZHVsZURhdGEgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaWQsIGRhdGEgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9pZCA9IGlkO1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBsYWNlcyB0aGUgY3VycmVudGx5IGhlbGQgZGF0YSB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSB0aGUgZGF0YSB0byByZXBsYWNlIHRoZSBjdXJyZW50IGRhdGFcbiAgICovXG4gIHNldCAoZGF0YSkge1xuICAgIHRoaXMuY2FwdHVyZVByZXZpb3VzKCk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl9kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3Igc2hhbGxvdyBlcXVhbGl0eVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YVtrZXldICE9PSBkYXRhW2tleV0pIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5fZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYXB0dXJlUHJldmlvdXMgKCkge1xuICAgIGlmICh0aGlzLl9oaXN0b3J5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faGlzdG9yeS5sZW5ndGggKyAxID4gNSkge1xuICAgICAgdGhpcy5faGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIElmIGRhdGEgaXMgZXZlciB1bmRlZmluZWQsIHdlIGRlZmF1bHQgdG8gZW1wdHkgb2JqZWN0XG4gICAgdGhpcy5faGlzdG9yeS5wdXNoKEpTT04uc3RyaW5naWZ5KHRoaXMuX2RhdGEgfHwge30pKTtcbiAgfVxuXG4gIHVuZG8gKCkge1xuICAgIGxldCBwcmV2aW91cyA9IHt9O1xuICAgIGlmICh0aGlzLl9wcmV2aW91cy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmV2aW91cyA9IEpTT04ucGFyc2UodGhpcy5fcHJldmlvdXMucG9wKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEuc2V0KHByZXZpb3VzKTtcbiAgfVxuXG4gIHJhdyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdsb2JhbFN0b3JhZ2UgKi9cblxuaW1wb3J0IE1vZHVsZURhdGEgZnJvbSAnLi9tb2R1bGVkYXRhJztcbmltcG9ydCB7IEFuc3dlcnNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuL3N0b3JhZ2VrZXlzJztcblxuLyoqXG4gKiBTdG9yYWdlIGlzIGEgY29udGFpbmVyIGFyb3VuZCBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAqIEl0IGV4cG9zZXMgYW4gaW50ZXJmYWNlIGZvciBDUlVEIG9wZXJhdGlvbnMgYXMgd2VsbCBhcyBsaXN0ZW5pbmdcbiAqIGZvciBzdGF0ZWZ1bCBjaGFuZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbG9iYWxTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXIgPSB7fTtcbiAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRhdGEgaW4gc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBrZXkgdG8gdGhlIHByb3ZpZGVkIGRhdGEsXG4gICAqIGNvbXBsZXRlbHkgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHN0b3JhZ2Uga2V5IHRvIHNldFxuICAgKiBAcGFyYW0geyp9IGRhdGEgdGhlIGRhdGEgdG8gc2V0XG4gICAqL1xuICBzZXQgKGtleSwgZGF0YSkge1xuICAgIHRoaXMuX2luaXREYXRhQ29udGFpbmVyKGtleSwgZGF0YSk7XG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldLnNldChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgcHJvdmlkZWQgbWFwIHRvIHRoZSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUga2V5L3ZhbHVlIHBhaXJzIHRvIHNldCBpbiB0aGUgc3RvcmFnZVxuICAgKi9cbiAgc2V0QWxsIChkYXRhKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICBpZiAoa2V5ID09PSBTdG9yYWdlS2V5cy5RVUVSWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgcXVlcnkgbGFzdCBzaW5jZSBpdCB0cmlnZ2VycyBhIHNlYXJjaFxuICAgIC8vIFRPRE86IG1vdmUgbGlzdGVuZXJzIHVwIHNvIGFsbCBvZiBzdG9yYWdlIGNhbiBiZSB1cGRhdGVkIGF0IHRoZSBzYW1lIHRpbWVcbiAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV0pIHtcbiAgICAgIHRoaXMuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCBkYXRhW1N0b3JhZ2VLZXlzLlFVRVJZXSk7XG4gICAgfVxuICB9XG5cbiAgX2luaXREYXRhQ29udGFpbmVyIChrZXksIGRhdGEpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignSW52YWxpZCBzdG9yYWdlIGtleSBwcm92aWRlZCcsIGtleSwgZGF0YSk7XG4gICAgfVxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNTdG9yYWdlRXJyb3IoJ05vIGRhdGEgcHJvdmlkZWQnLCBrZXksIGRhdGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldID0gbmV3IE1vZHVsZURhdGEoa2V5KTtcbiAgICAgIHRoaXMuX2FwcGx5RnV0dXJlTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdGUgKG1vZHVsZUlkKSB7XG4gICAgaWYgKHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0ucmF3KCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0QWxsIChrZXkpIHtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChjb25zdCBkYXRhS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX21vZHVsZURhdGFDb250YWluZXIpKSB7XG4gICAgICBpZiAoZGF0YUtleS5zdGFydHNXaXRoKGtleSkgJiYgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltkYXRhS2V5XS5yYXcoKSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLnB1c2godGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltkYXRhS2V5XS5yYXcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGF0YSBpbiBzdG9yYWdlIHdpdGggdGhlIGdpdmVuIGtleSB0byB0aGUgcHJvdmlkZWQgZGF0YSxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgc3RvcmFnZSBrZXkgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUgKGtleSkge1xuICAgIC8vIE5vdGU6IERvIHdlIG5lZWQgdG8gY2xlYW4gdXAgbGlzdGVuZXJzIGhlcmU/XG4gICAgZGVsZXRlIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJba2V5XTtcbiAgfVxuXG4gIG9uIChldnQsIG1vZHVsZUlkLCBjYikge1xuICAgIGxldCBtb2R1bGVEYXRhID0gdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF07XG4gICAgaWYgKG1vZHVsZURhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0ucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldnQsXG4gICAgICAgIGNiOiBjYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXS5vbihldnQsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZiAoZXZ0LCBtb2R1bGVJZCwgY2IpIHtcbiAgICBsZXQgbW9kdWxlRGF0YSA9IHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdO1xuICAgIGlmIChtb2R1bGVEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0ub2ZmKGV2dCwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2FwcGx5RnV0dXJlTGlzdGVuZXJzIChtb2R1bGVJZCkge1xuICAgIGxldCBmdXR1cmVzID0gdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXTtcbiAgICBpZiAoIWZ1dHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBmdXR1cmUgPSBmdXR1cmVzW2ldO1xuICAgICAgdGhpcy5vbihmdXR1cmUuZXZlbnQsIG1vZHVsZUlkLCBmdXR1cmUuY2IpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2hBcGkgfSBmcm9tICcuL3NlYXJjaC9zZWFyY2hhcGknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBbmFseXRpY3NSZXBvcnRlciB9IGZyb20gJy4vYW5hbHl0aWNzL2FuYWx5dGljc3JlcG9ydGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9vcEFuYWx5dGljc1JlcG9ydGVyIH0gZnJvbSAnLi9hbmFseXRpY3Mvbm9vcGFuYWx5dGljc3JlcG9ydGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9kdWxlRGF0YSB9IGZyb20gJy4vc3RvcmFnZS9tb2R1bGVkYXRhJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RvcmFnZSB9IGZyb20gJy4vc3RvcmFnZS9nbG9iYWxzdG9yYWdlJztcbiIsIi8qKiBAbW9kdWxlIENvbXBvbmVudCAqL1xuXG5pbXBvcnQgeyBSZW5kZXJlcnMgfSBmcm9tICcuLi9yZW5kZXJpbmcvY29uc3QnO1xuXG5pbXBvcnQgRE9NIGZyb20gJy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0YXRlIGZyb20gJy4vc3RhdGUnO1xuaW1wb3J0IHsgQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuLi8uLi9jb3JlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5cbi8qKlxuICogQ29tcG9uZW50IGlzIGFuIGFic3RyYWN0aW9uIHRoYXQgZW5jYXBzdWxhdGVzIHN0YXRlLCBiZWhhdmlvcixcbiAqIGFuZCB2aWV3IGZvciBhIHBhcnRpY3VsYXIgY2h1bmsgb2YgZnVuY3Rpb25hbGl0eSBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgQVBJIGV4cG9zZXMgZXZlbnQgbGlmZSBjeWNsZSBob29rcyBmb3Igd2hlbiB0aGluZ3MgYXJlIHJlbmRlcmVkLFxuICogbW91bnRlZCwgY3JlYXRlZCwgZXRjLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5tb2R1bGVJZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAqIFVzZWQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBvdGhlciBjb21wb25lbnRzIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IudHlwZTtcblxuICAgIC8qKlxuICAgICAqIENhY2hlIHRoZSBvcHRpb25zIHNvIHRoYXQgd2UgY2FuIHByb3BvZ2F0ZSBwcm9wZXJseSB0byBjaGlsZCBjb21wb25lbnRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyIHVzZWQgdG8gY2xhc3NpZnkgdGhlIHR5cGUgb2YgY29tcG9uZW50LlxuICAgICAqIFRoZSBjb21wb25lbnQgbWFuYWdlciB1c2VzIHRoaXMgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gcGVyc2lzdCBhbmQgb3JnYW5pemUgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtzdHJpbmd8Q29tcG9uZW50VHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLl90eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb21wb25lbnQsIGlmIGV4aXN0c1xuICAgICAqIEB0eXBlIHtDb21wb25lbnR9XG4gICAgICovXG4gICAgdGhpcy5fcGFyZW50Q29udGFpbmVyID0gY29uZmlnLnBhcmVudENvbnRhaW5lciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBjb250YWluZXIgZm9yIGFsbCB0aGUgY2hpbGQgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtDb21wb25lbnRbXX1cbiAgICAgKi9cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXRlIChkYXRhKSBvZiB0aGUgY29tcG9uZW50IHRvIGJlIHByb3ZpZGVkIHRvIHRoZSB0ZW1wbGF0ZSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTdGF0ZShjb25maWcuc3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETyhiaWxseSkgVGhpcyBzaG91bGQgYmUgJ3NlcnZpY2VzJ1xuICAgICAqL1xuICAgIHRoaXMuY29yZSA9IHN5c3RlbUNvbmZpZy5jb3JlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50IG1hbmFnZXIsIHdoaWNoIGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tcG9uZW50IGNsYXNzZXNcbiAgICAgKiBlbGlnaWJsZSB0byBiZSBjcmVhdGVkXG4gICAgICogQHR5cGUge0NvbXBvbmVudE1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyID0gc3lzdGVtQ29uZmlnLmNvbXBvbmVudE1hbmFnZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBhbmFseXRpY3MgcmVwb3J0ZXIsIHVzZWQgdG8gcmVwb3J0IGV2ZW50cyBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7QW5hbHl0aWNzUmVwb3J0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlciA9IHN5c3RlbUNvbmZpZy5hbmFseXRpY3NSZXBvcnRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyB0byBpbmNsdWRlIHdpdGggYWxsIGFuYWx5dGljIGV2ZW50cyBzZW50IGJ5IHRoaXMgY29tcG9uZW50XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FuYWx5dGljc09wdGlvbnMgPSBjb25maWcuYW5hbHl0aWNzT3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBET00gbm9kZSB0aGF0IHRoZSBjb21wb25lbnQgd2lsbCBiZSBhcHBlbmRlZCB0byB3aGVuIG1vdW50ZWQvcmVuZGVyZWQuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGlmICh0aGlzLl9wYXJlbnRDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLnF1ZXJ5KGNvbmZpZy5jb250YWluZXIpIHx8IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNvbnRhaW5lciBET00gbm9kZTogJyArIGNvbmZpZy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIGNvbmZpZy5jb250YWluZXIpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGFyZW50LCBhbmQgdGhlIGNvbnRhaW5lciBpcyBtaXNzaW5nIGZyb20gdGhlIERPTSxcbiAgICAgIC8vIHdlIGNvbnN0cnVjdCB0aGUgY29udGFpbmVyIGFuZCBhcHBlbmQgaXQgdG8gdGhlIHBhcmVudFxuICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogY29uZmlnLmNvbnRhaW5lci5zdWJzdHJpbmcoMSwgY29uZmlnLmNvbnRhaW5lci5sZW5ndGgpXG4gICAgICAgIH0pO1xuICAgICAgICBET00uYXBwZW5kKHRoaXMuX3BhcmVudENvbnRhaW5lciwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSBjbGFzcyB0byBiZSBhcHBsaWVkIHRvIHt0aGlzLl9jb250YWluZXJ9IG5vZGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNvbmZpZy5jbGFzcyB8fCAnY29tcG9uZW50JztcblxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyID0gY29uZmlnLnJlbmRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQge1JlbmRlcmVyfSB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJlciA9IHN5c3RlbUNvbmZpZy5yZW5kZXJlciB8fCBSZW5kZXJlcnMuSGFuZGxlYmFycztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBzdHJpbmcgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudFxuICAgICAqIElmIHRoaXMgaXMgbGVmdCBlbXB0eSwgd2UgbG9va3VwIHRoZSB0ZW1wbGF0ZSB0aGUgYmFzZSB0ZW1wbGF0ZXMgdXNpbmcgdGhlIHRlbXBsYXRlTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGUgPSBjb25maWcudGVtcGxhdGUgPyB0aGlzLl9yZW5kZXJlci5jb21waWxlKGNvbmZpZy50ZW1wbGF0ZSkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlTmFtZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIFRoaXMgaXMgb25seSB1c2VkIGlmIF90ZW1wbGF0ZSBpcyBlbXB0eS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGNvbmZpZy50ZW1wbGF0ZU5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0VGVtcGxhdGVOYW1lKGNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBzdGF0ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2ssIHRoYXRzIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBpbnRlcm5hbCBkYXRhXG4gICAgICogbW9kZWxzIG9mIHRoZSBjb21wb25lbnRzLCBiZWZvcmUgaXQgZ2V0cyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQgc3RhdGUuXG4gICAgICogQnkgZGVmYXVsdCwgbm8gdHJhbnNmb3JtYXRpb24gaGFwcGVucy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1EYXRhID0gY29uZmlnLnRyYW5zZm9ybURhdGEgfHwgdGhpcy50cmFuc2Zvcm1EYXRhIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIGNyZWF0ZWQuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25DcmVhdGUgPSBjb25maWcub25DcmVhdGVPdmVycmlkZSB8fCB0aGlzLm9uQ3JlYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMub25DcmVhdGUgPSB0aGlzLm9uQ3JlYXRlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgTW91bnRlZC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbk1vdW50ID0gY29uZmlnLm9uTW91bnRPdmVycmlkZSB8fCB0aGlzLm9uTW91bnQgfHwgZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5vbk1vdW50ID0gdGhpcy5vbk1vdW50LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBjb21wb25lbnRzIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBjb25maWcub25VcGRhdGVPdmVycmlkZSB8fCB0aGlzLm9uVXBkYXRlIHx8IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB0aGlzLm9uVXBkYXRlID0gdGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uQ3JlYXRlIGNhbGxiYWNrXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXNlck9uQ3JlYXRlID0gY29uZmlnLm9uQ3JlYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uTW91bnQgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy51c2VyT25Nb3VudCA9IGNvbmZpZy5vbk1vdW50IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uVXBkYXRlIGNhbGxiYWNrXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXNlck9uVXBkYXRlID0gY29uZmlnLm9uVXBkYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0JztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdDb21wb25lbnQnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaW5pdCAob3B0cykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnNldFN0YXRlKG9wdHMuZGF0YSB8fCBvcHRzLnN0YXRlIHx8IHt9KTtcbiAgICAgIHRoaXMub25DcmVhdGUoKTtcbiAgICAgIHRoaXMudXNlck9uQ3JlYXRlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ0Vycm9yIGluaXRpYWxpemluZyBjb21wb25lbnQnLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnR5cGUsXG4gICAgICAgIGUpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgICAgIHRoaXMudXNlck9uVXBkYXRlKCk7XG4gICAgICAgIHRoaXMudW5Nb3VudCgpO1xuICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIHVwZGF0aW5nIGNvbXBvbmVudCcsXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci50eXBlLFxuICAgICAgICAgIGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRE9NLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB7IF9jb25maWc6IHRoaXMuX2NvbmZpZyB9LCBkYXRhKTtcbiAgICB0aGlzLl9zdGF0ZS5zZXQobmV3U3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0U3RhdGUgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0KHByb3ApO1xuICB9XG5cbiAgaGFzU3RhdGUgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaGFzKHByb3ApO1xuICB9XG5cbiAgdHJhbnNmb3JtRGF0YSAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgYWRkQ2hpbGQgKGRhdGEsIHR5cGUsIG9wdHMpIHtcbiAgICBsZXQgY2hpbGRDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKFxuICAgICAgdHlwZSxcbiAgICAgIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCBvcHRzIHx8IHt9LCB7XG4gICAgICAgIF9wYXJlbnRPcHRzOiB0aGlzLl9jb25maWdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGRDb21wb25lbnQpO1xuICAgIHJldHVybiBjaGlsZENvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50IGFuZCByZW1vdmUgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbiBmcm9tIHRoZSBsaXN0XG4gICAqIG9mIGFjdGl2ZSBjb21wb25lbnRzXG4gICAqL1xuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goYyA9PiBjLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVtb3ZlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyIG1ldGhvZCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW5kZXJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc2V0UmVuZGVyIChyZW5kZXIpIHtcbiAgICB0aGlzLl9yZW5kZXIgPSByZW5kZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZW5kZXJlciBmb3IgdGhlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1JlbmRlcmVyVHlwZX0gcmVuZGVyZXJcbiAgICovXG4gIHNldFJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gUmVuZGVyZXJzW3JlbmRlcmVyXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGNvbXBvbmVudCB0byB1c2Ugd2hlbiByZW5kZXJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXRUZW1wbGF0ZSAodGVtcGxhdGUpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRoaXMuX3JlbmRlcmVyLmNvbXBpbGUodGVtcGxhdGUpO1xuICB9XG5cbiAgdW5Nb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQudW5Nb3VudCgpO1xuICAgIH0pO1xuXG4gICAgRE9NLmVtcHR5KHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5vblVuTW91bnQoKTtcbiAgfVxuXG4gIG1vdW50IChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJlZm9yZU1vdW50KCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBET00uYXBwZW5kKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5yZW5kZXIodGhpcy5fc3RhdGUuYXNKU09OKCkpKTtcblxuICAgIC8vIFByb2Nlc3MgdGhlIERPTSB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGNyZWF0ZVxuICAgIC8vIGluLW1lbW9yeSBzdWItY29tcG9uZW50cyBmb3IgcmVuZGVyaW5nXG4gICAgY29uc3QgZG9tQ29tcG9uZW50cyA9IERPTS5xdWVyeUFsbCh0aGlzLl9jb250YWluZXIsICdbZGF0YS1jb21wb25lbnRdOm5vdChbZGF0YS1pcy1jb21wb25lbnQtbW91bnRlZF0pJyk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudHJhbnNmb3JtRGF0YShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX3N0YXRlLmdldCgpKSkpO1xuICAgIGRvbUNvbXBvbmVudHMuZm9yRWFjaChjID0+IHRoaXMuX2NyZWF0ZVN1YmNvbXBvbmVudChjLCBkYXRhKSk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICAvLyBBdHRhY2ggYW5hbHl0aWNzIGhvb2tzIGFzIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLmFuYWx5dGljc1JlcG9ydGVyKSB7XG4gICAgICBsZXQgZG9tSG9va3MgPSBET00ucXVlcnlBbGwodGhpcy5fY29udGFpbmVyLCAnW2RhdGEtZXZlbnR0eXBlXTpub3QoW2RhdGEtaXMtYW5hbHl0aWNzLWF0dGFjaGVkXSknKTtcbiAgICAgIGRvbUhvb2tzLmZvckVhY2godGhpcy5fY3JlYXRlQW5hbHl0aWNzSG9vay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIHRoaXMub25Nb3VudCh0aGlzKTtcbiAgICB0aGlzLnVzZXJPbk1vdW50KHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogcmVuZGVyIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUge1JlbmRlcmVyfSB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0ZW1wbGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICByZW5kZXIgKGRhdGEgPSB0aGlzLl9zdGF0ZS5nZXQoKSkge1xuICAgIHRoaXMuYmVmb3JlUmVuZGVyKCk7XG4gICAgLy8gVGVtcG9yYXJ5IGZpeCBmb3IgcGFzc2luZyBpbW11dGFibGUgZGF0YSB0byB0cmFuc2Zvcm1EYXRhKCkuXG4gICAgZGF0YSA9IHRoaXMudHJhbnNmb3JtRGF0YShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG5cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIC8vIFVzZSBlaXRoZXIgdGhlIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gb3IgdGhlIGludGVybmFsIHJlbmRlcmVyXG4gICAgLy8gZGVwZW5kYW50IG9uIHRoZSBjb21wb25lbnQgY29uZmlndXJhdGlvblxuICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBodG1sID0gdGhpcy5fcmVuZGVyKGRhdGEpO1xuICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlciBtZXRob2QgbXVzdCByZXR1cm4gSFRNTCBhcyB0eXBlIHtzdHJpbmd9Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlciB0aGUgZXhpc3RpbmcgdGVtcGxhdGVzIGFzIGEgc3RyaW5nXG4gICAgICBodG1sID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyKHtcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICB0ZW1wbGF0ZU5hbWU6IHRoaXMuX3RlbXBsYXRlTmFtZVxuICAgICAgfSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gV2UgY3JlYXRlIGFuIEhUTUwgRG9jdW1lbnQgZnJhZ21lbnQgd2l0aCB0aGUgcmVuZGVyZWQgc3RyaW5nXG4gICAgLy8gU28gdGhhdCB3ZSBjYW4gcXVlcnkgaXQgZm9yIHByb2Nlc3Npbmcgb2Ygc3ViIGNvbXBvbmVudHNcbiAgICBsZXQgZWwgPSBET00uY3JlYXRlKGh0bWwpO1xuXG4gICAgdGhpcy5hZnRlclJlbmRlcigpO1xuICAgIHJldHVybiBlbC5pbm5lckhUTUw7XG4gIH1cblxuICBfY3JlYXRlU3ViY29tcG9uZW50IChkb21Db21wb25lbnQsIGRhdGEpIHtcbiAgICBkb21Db21wb25lbnQuZGF0YXNldC5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBkb21Db21wb25lbnQuZGF0YXNldDtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC5jb21wb25lbnQ7XG4gICAgY29uc3QgcHJvcCA9IGRhdGFzZXQucHJvcDtcbiAgICBsZXQgb3B0cyA9IGRhdGFzZXQub3B0cyA/IEpTT04ucGFyc2UoZGF0YXNldC5vcHRzKSA6IHt9O1xuXG4gICAgbGV0IGNoaWxkRGF0YSA9IGRhdGFbcHJvcF0gfHwge307XG5cbiAgICBvcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbnRhaW5lcjogZG9tQ29tcG9uZW50XG4gICAgfTtcblxuICAgIC8vIFRPRE8oYmlsbHkpIFJpZ2h0IG5vdywgaWYgd2UgcHJvdmlkZSBhbiBhcnJheSBhcyB0aGUgZGF0YSBwcm9wLFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBjcmVhdGUgbWFueSBjb21wb25lbnRzIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgIC8vIFRIQVQgaW50ZXJmYWNlIFNIT1VMRCBjaGFuZ2UgdG8gdXNlIGEgZGlmZmVyZW50IHByb3BlcnR5IHRoYXQgZGVmaW5lc1xuICAgIC8vIHdoZXRoZXIgdG8gYXJyYXkgZGF0YSBzaG91bGQgYmUgdXNlZCBmb3IgYSBzaW5nbGUgY29tcG9uZW50IG9yXG4gICAgLy8gdG8gY3JlYXRlIG1hbnkgY29tcG9uZW50cyBmb3IgZWFjaCBpdGVtLlxuICAgIC8vIE92ZXJsb2FkaW5nIGFuZCBoYXZpbmcgdGhpcyBzaWRlIGVmZmVjdCBpcyB1bmludHVpdGl2ZSBhbmQgV1JPTkdcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGREYXRhKSkge1xuICAgICAgLy8gUmVuZGVyaW5nIGEgc3ViIGNvbXBvbmVudCBzaG91bGQgYmUgd2l0aGluIHRoZSBjb250ZXh0LFxuICAgICAgLy8gb2YgdGhlIG5vZGUgdGhhdCB3ZSBwcm9jZXNzZWQgaXQgZnJvbVxuICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZERhdGEsIHR5cGUsIG9wdHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNoaWxkRGF0YS5yZXZlcnNlKCk7XG4gICAgY2hpbGREYXRhLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICB0aGlzLmFkZENoaWxkKGRhdGEsIHR5cGUsIG9wdHMpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUFuYWx5dGljc0hvb2sgKGRvbUNvbXBvbmVudCkge1xuICAgIGRvbUNvbXBvbmVudC5kYXRhc2V0LmlzQW5hbHl0aWNzQXR0YWNoZWQgPSB0cnVlO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBkb21Db21wb25lbnQuZGF0YXNldDtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC5ldmVudHR5cGU7XG4gICAgY29uc3QgbGFiZWwgPSBkYXRhc2V0LmV2ZW50bGFiZWw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRhdGFzZXQuZXZlbnRvcHRpb25zID8gSlNPTi5wYXJzZShkYXRhc2V0LmV2ZW50b3B0aW9ucykgOiB7fTtcblxuICAgIERPTS5vbihkb21Db21wb25lbnQsICdjbGljaycsIGUgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQW5hbHl0aWNzRXZlbnQodHlwZSwgbGFiZWwpO1xuICAgICAgZXZlbnQuYWRkT3B0aW9ucyh0aGlzLl9hbmFseXRpY3NPcHRpb25zKTtcbiAgICAgIGV2ZW50LmFkZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogb25DcmVhdGUgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjb25zdHJ1Y3RlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25DcmVhdGUgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvblVwZGF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvblVwZGF0ZSAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGJlZm9yZVJlbmRlciBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIGJlZm9yZVJlbmRlciAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGFmdGVyUmVuZGVyIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBhZnRlclJlbmRlciAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIG9uTW91bnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhcHBlbmRlZCB0byB0aGUgRE9NXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvbk1vdW50IChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25Vbk1vdW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uVW5Nb3VudCAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGJlZm9yZU1vdW50IGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHRvIHRoZSBET01cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIGJlZm9yZU1vdW50IChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25EZXN0cm95IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvbkRlc3Ryb3kgKGNiKSB7XG5cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRXJyb3JSZXBvcnRlciAqL1xuXG5pbXBvcnQgeyBBbnN3ZXJzQmFzZUVycm9yLCBBbnN3ZXJzQmFzaWNFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuaW1wb3J0IEFwaVJlcXVlc3QgZnJvbSAnLi4vaHR0cC9hcGlyZXF1ZXN0JztcbmltcG9ydCB7IExJQl9WRVJTSU9OIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBFcnJvclJlcG9ydGVyIGlzIHVzZWQgZm9yIHJlcG9ydGluZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUgYW5kIEFQSVxuICpcbiAqIEBpbXBsZW1lbnRzIHtFcnJvclJlcG9ydGVyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JSZXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcsIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXBpS2V5IHRvIHVzZSBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXhwZXJpZW5jZUtleSB0byB1c2Ugd2hlbiByZXBvcnRpbmdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuc3dlcnMgY29uZmlnIHZlcnNpb24gdXNlZCBmb3IgYXBpIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbiB8fCAnY29uZmlnMS4wJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHByaW50IGVudGlyZSBlcnJvciBvYmplY3RzIHRvIHRoZSBjb25zb2xlIGZvciBpbnNwZWN0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wcmludFZlcmJvc2UgPSBjb25maWcucHJpbnRWZXJib3NlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmVwb3J0IHRoZSBlcnJvciB0aGUgc2VydmVyIGZvciBsb2dnaW5nIGFuZCBtb25pdG9yaW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZW5kVG9TZXJ2ZXIgPSBjb25maWcuc2VuZFRvU2VydmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzdG9yYWdlIGluc3RhbmNlIG9mIHRoZSBleHBlcmllbmNlXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICovXG4gICAgaWYgKHRoaXMuc2VuZFRvU2VydmVyICYmICFnbG9iYWxTdG9yYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoXG4gICAgICAgICdNdXN0IGluY2x1ZGUgZ2xvYmFsU3RvcmFnZSB0byBzZW5kIGVycm9ycyB0byBzZXJ2ZXInLFxuICAgICAgICAnRXJyb3JSZXBvcnRlcicpO1xuICAgIH1cbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBBbnN3ZXJzIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudDtcblxuICAgIC8vIEF0dGFjaCByZXBvcnRpbmcgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGUgPT4gdGhpcy5yZXBvcnQoZS5lcnJvcikpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBlID0+IHRoaXMucmVwb3J0KGUuZXJyb3IpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBvcnQgcHJldHR5IHByaW50cyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG9wdGlvbmFsbHlcbiAgICogcHJpbnRzIHRoZSBlbnRpcmUgZXJyb3IgaWYgYHByaW50VmVyYm9zZWAgaXMgdHJ1ZSwgYW5kIHNlbmRzIHRoZVxuICAgKiBlcnJvciB0byB0aGUgc2VydmVyIHRvIGJlIGxvZ2dlZCBpZiBgc2VuZFRvU2VydmVyYCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSByZXBvcnRlZFxuICAgKiBAcmV0dXJucyB7QW5zd2Vyc0Jhc2VFcnJvcn0gVGhlIHJlcG9ydGVkIGVycm9yXG4gICAqL1xuICByZXBvcnQgKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3IpIHx8IGVyci5yZXBvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVyci5yZXBvcnRlZCA9IHRydWU7XG5cbiAgICB0aGlzLnByaW50RXJyb3IoZXJyKTtcblxuICAgIGlmICh0aGlzLnNlbmRUb1NlcnZlcikge1xuICAgICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9lcnJvcnMnLFxuICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICB2ZXJzaW9uOiAyMDE5MDMwMSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICdsaWJWZXJzaW9uJzogTElCX1ZFUlNJT04sXG4gICAgICAgICAgJ2V4cGVyaWVuY2VWZXJzaW9uJzogdGhpcy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuZXhwZXJpZW5jZUtleSxcbiAgICAgICAgICAnZXJyb3InOiBlcnIudG9Kc29uKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLmdsb2JhbFN0b3JhZ2UpO1xuXG4gICAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IFdlIHNob3VsZCBwcm9iYWJseSBjaGFuZ2UgdGhpcyBlbmRwb2ludCB0byBQT1NULFxuICAgICAgLy8gaWRlYWxseSB1c2luZyB0aGUgYmVhY29uIEFQSS4gU3RhY2sgdHJhY2VzIHdpbGwgbGlrZWx5IGVhc2lseSBoaXQgVVJMXG4gICAgICAvLyBsZW5ndGggbGltaXRzLlxuICAgICAgcmVxdWVzdC5nZXQoKVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnI7XG4gIH1cblxuICAvKipcbiAgICogcHJpbnRzIHRoZSBnaXZlbiBlcnJvciB0byB0aGUgYnJvd3NlciBjb25zb2xlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSBwcmludGVkXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICBpZiAodGhpcy5wcmludFZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYGVycm9yOiAke2Vyci5lcnJvck1lc3NhZ2V9XG5jb2RlOiAke2Vyci5lcnJvckNvZGV9XG5ib3VuZGFyeTogJHtlcnIuYm91bmRhcnl9XG5zdGFjazogJHtlcnIuc3RhY2t9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RXJyb3JSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnNvbGVFcnJvclJlcG9ydGVyIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlcG9ydCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgeyBBbnN3ZXJzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcblxuLyoqIEBtb2R1bGUgUGVyc2lzdGVudFN0b3JhZ2UgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc2lzdGVudFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwYXJhbXMgbW9kZWxcbiAgICAgKiBAdHlwZSB7U2VhcmNoUGFyYW1zfVxuICAgICAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgaGlzdG9yeSBlZGl0IHRpbWVyLCBpZiBhbnlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2hpc3RvcnlUaW1lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBsaXN0ZW5lcnMgdG8gZXZlcnkgc3RvcmFnZSB1cGRhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVMaXN0ZW5lciA9IGNvbmZpZy51cGRhdGVMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGxpc3RlbmVycyB0byBzdG9yYWdlIHJlc2V0c1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbltdfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc2V0TGlzdGVuZXIgPSBjb25maWcucmVzZXRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICB0aGlzLl9jYWxsTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgdGhpcy5fY2FsbExpc3RlbmVyKHRoaXMuX3Jlc2V0TGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBnaXZlbiBrZXkvdmFsdWUgcGFpciBpbnRvIHN0b3JhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGluc2VydCB0aGUgZGF0YSBpblxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSBoaXN0b3J5IGluc3RlYWQgb2YgcHVzaGluZyBuZXcgc3RhdGVcbiAgICovXG4gIHNldCAoa2V5LCBkYXRhLCByZXBsYWNlSGlzdG9yeSA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignU3RvcmFnZSBkYXRhIGtleSBtdXN0IGJlIGEgc3RyaW5nJywga2V5LCBkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3RGF0YSA9IGRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgbmV3RGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9wYXJhbXMuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBnaXZlbiBrZXkgZnJvbSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBkZWxldGVcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIGhpc3RvcnkgaW5zdGVhZCBvZiBwdXNoaW5nIG5ldyBzdGF0ZVxuICAgKi9cbiAgZGVsZXRlIChrZXksIHJlcGxhY2VIaXN0b3J5ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICBfdXBkYXRlSGlzdG9yeSAocmVwbGFjZUhpc3RvcnkgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9oaXN0b3J5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaXN0b3J5VGltZXIpO1xuICAgIH1cblxuICAgIC8vIGJhdGNoIHVwZGF0ZSBjYWxscyBhY3Jvc3MgY29tcG9uZW50cyB0byBhdm9pZCB1cGRhdGluZyB0aGUgdXJsIHRvbyBtdWNoXG4gICAgdGhpcy5faGlzdG9yeVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcGxhY2VIaXN0b3J5KSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIGA/JHt0aGlzLl9wYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgYD8ke3RoaXMuX3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGxpc3Qgb2YgY2FsbGJhY2tzIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBkYXRhXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gbGlzdGVuZXJzIFRoZSBjYWxsYmFja3MgdG8gaW52b2tlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsbExpc3RlbmVyIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKHRoaXMuZ2V0QWxsKCksIHRoaXMuX3BhcmFtcy50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBrZXkvdmFsdWUgcGFpcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgZ2V0QWxsICgpIHtcbiAgICBjb25zdCBhbGxQYXJhbXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fcGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgYWxsUGFyYW1zW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBhbGxQYXJhbXM7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFuc3dlcnNDb25maWdFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKiogQG1vZHVsZSBTZWFyY2hDb25maWcgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heCByZXN1bHRzIHBlciBzZWFyY2guXG4gICAgICogQWxzbyBkZWZpbmVzIHRoZSBudW1iZXIgb2YgcmVzdWx0cyBwZXIgcGFnZSwgaWYgcGFnaW5hdGlvbiBpcyBlbmFibGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbWl0ID0gY29uZmlnLmxpbWl0IHx8IDIwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2UgZm9yIGFsbCBzZWFyY2hlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHNlYXJjaCB0byB1c2Ugb24gaW5pdGlhbGl6YXRpb24gZm9yIHZlcnRpY2FsIHNlYXJjaGVycywgd2hlbiB0aGUgdXNlciBoYXMndCBwcm92aWRlZCBhIHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRJbml0aWFsU2VhcmNoID0gY29uZmlnLmRlZmF1bHRJbml0aWFsU2VhcmNoO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpbWl0ICE9PSAnbnVtYmVyJyB8fCB0aGlzLmxpbWl0IDwgMSB8fCB0aGlzLmxpbWl0ID4gNTApIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IoJ1NlYXJjaCBMaW1pdCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAnLCAnU2VhcmNoQ29uZmlnJyk7XG4gICAgfVxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVEYXRhICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZURhdGEge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgdGhpcy5xdWVyeUlkID0gZGF0YS5xdWVyeUlkIHx8ICcnO1xuICAgIHRoaXMuaW5wdXRJbnRlbnRzID0gZGF0YS5pbnB1dEludGVudHMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGxldCBzZWN0aW9ucztcbiAgICBpZiAocmVzcG9uc2Uuc2VjdGlvbnMpIHtcbiAgICAgIHNlY3Rpb25zID0gcmVzcG9uc2Uuc2VjdGlvbnMubWFwKHMgPT4gKHtcbiAgICAgICAgbGFiZWw6IHMubGFiZWwsXG4gICAgICAgIHJlc3VsdHM6IHMucmVzdWx0cy5tYXAociA9PiBuZXcgQXV0b0NvbXBsZXRlUmVzdWx0KHIpKVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWN0aW9ucyA9IFt7IHJlc3VsdHM6IHJlc3BvbnNlLnJlc3VsdHMubWFwKHIgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdChyKSkgfV07XG4gICAgfVxuICAgIGxldCBpbnB1dEludGVudHMgPSByZXNwb25zZS5pbnB1dCA/IHJlc3BvbnNlLmlucHV0LnF1ZXJ5SW50ZW50cyA6IFtdO1xuICAgIHJldHVybiBuZXcgQXV0b0NvbXBsZXRlRGF0YSh7XG4gICAgICBzZWN0aW9ucyxcbiAgICAgIHF1ZXJ5SWQ6IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBpbnB1dEludGVudHMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dG9Db21wbGV0ZVJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICB0aGlzLmZpbHRlciA9IGRhdGEuZmlsdGVyIHx8IHt9O1xuICAgIHRoaXMua2V5ID0gZGF0YS5rZXkgfHwgJyc7XG4gICAgdGhpcy5tYXRjaGVkU3Vic3RyaW5ncyA9IGRhdGEubWF0Y2hlZFN1YnN0cmluZ3MgfHwgW107XG4gICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWUgfHwgJyc7XG4gICAgdGhpcy5zaG9ydFZhbHVlID0gZGF0YS5zaG9ydFZhbHVlIHx8IHRoaXMudmFsdWU7XG4gICAgdGhpcy5pbnRlbnRzID0gZGF0YS5xdWVyeUludGVudHMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyICovXG5cbmltcG9ydCBBdXRvQ29tcGxldGVEYXRhIGZyb20gJy4uL21vZGVscy9hdXRvY29tcGxldGVkYXRhJztcblxuLyoqXG4gKiBBIERhdGEgVHJhbnNmb3JtZXIgdGhhdCB0YWtlcyB0aGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gYSBBdXRvQ29tcGxldGUgcmVxdWVzdFxuICogQW5kIHRyYW5zZm9ybXMgaW4gdG8gYSBmcm9udC1lbmQgb3JpZW50ZWQgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBvdXJcbiAqIGNvbXBvbmVudCBsaWJyYXJ5IGFuZCBjb3JlIHN0b3JhZ2UgdW5kZXJzdGFuZC5cbiAqXG4gKiBUT0RPKGJpbGx5KSBDcmVhdGUgb3VyIG93biBmcm9udC1lbmQgZGF0YSBtb2RlbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIHtcbiAgc3RhdGljIGNsZWFuIChtb2R1bGVJZCwgZGF0YSkge1xuICAgIGlmIChkYXRhLnNlY3Rpb25zICYmIGRhdGEuc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgZGF0YS5zZWN0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zZWN0aW9ucyAmJiBkYXRhLnNlY3Rpb25zLmxlbmd0aCA9PT0gMSAmJiBkYXRhLnNlY3Rpb25zWzBdLnJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgZGF0YS5zZWN0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgW21vZHVsZUlkXTogZGF0YVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdW5pdmVyc2FsIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBdXRvQ29tcGxldGVEYXRhLmZyb20ocmVzcG9uc2UpO1xuICB9XG5cbiAgc3RhdGljIGZpbHRlciAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXV0b0NvbXBsZXRlRGF0YS5mcm9tKHJlc3BvbnNlKTtcbiAgfVxuXG4gIHN0YXRpYyB2ZXJ0aWNhbCAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXV0b0NvbXBsZXRlRGF0YS5mcm9tKHJlc3BvbnNlKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlQXBpICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIGZyb20gJy4vYXV0b2NvbXBsZXRlZGF0YXRyYW5zZm9ybWVyJztcbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yLCBBbnN3ZXJzRW5kcG9pbnRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0Q2FjaGVkTGl2ZUFwaVVybCB9IGZyb20gJy4uL3V0aWxzL3VybHV0aWxzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vYXV0b2NvbXBsZXRlc2VydmljZScpLmRlZmF1bHR9IEF1dG9Db21wbGV0ZVNlcnZpY2UgKi9cblxuLyoqXG4gKiBBdXRvQ29tcGxldGVBcGkgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIG5ldHdvcmsgcmVsYXRlZCBtYXR0ZXJzXG4gKiBmb3IgYWxsIHRoZSBhdXRvY29tcGxldGUgZW5kcG9pbnRzLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtBdXRvQ29tcGxldGVTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVBcGkge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBcGkgS2V5IGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIEFuc3dlcnMgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuZXhwZXJpZW5jZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBbnN3ZXJzIEtleSBpcyByZXF1aXJlZCcsICdBdXRvQ29tcGxldGUnKTtcbiAgICB9XG4gICAgdGhpcy5fZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIEFQSSB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gfHwgMjAxOTAxMDEgfHwgMjAxOTAzMDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignTG9jYWxlIGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBjb25maWcubG9jYWxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzdG9yYWdlIGluc3RhbmNlIG9mIHRoZSBleHBlcmllbmNlXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWdsb2JhbFN0b3JhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignR2xvYmFsIHN0b3JhZ2UgaXMgcmVxdWlyZWQnLCAnQXV0b0NvbXBsZXRlJyk7XG4gICAgfVxuICAgIHRoaXMuX2dsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBBbnN3ZXJzIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW52aXJvbm1lbnQgPSBjb25maWcuZW52aXJvbm1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB1cmwgZm9yIHRoZSBhdXRvY29tcGxldGUgQVBJIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IGdldENhY2hlZExpdmVBcGlVcmwodGhpcy5fZW52aXJvbm1lbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5RmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvZmlsdGVyc2VhcmNoJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBpbnB1dCxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAndmVydGljYWxLZXknOiBjb25maWcudmVydGljYWxLZXksXG4gICAgICAgICdsb2NhbGUnOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICdzZWFyY2hfcGFyYW1ldGVycyc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLl9nbG9iYWxTdG9yYWdlKTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIuZmlsdGVyKHJlc3BvbnNlLnJlc3BvbnNlKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcignRmlsdGVyIHNlYXJjaCByZXF1ZXN0IGZhaWxlZCcsICdBdXRvQ29tcGxldGUnLCBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVZlcnRpY2FsIChpbnB1dCwgdmVydGljYWxLZXkpIHtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9hdXRvY29tcGxldGUnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuX2Vudmlyb25tZW50LFxuICAgICAgYmFzZVVybDogdGhpcy5fYmFzZVVybCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBpbnB1dCxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAndmVydGljYWxLZXknOiB2ZXJ0aWNhbEtleSxcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLl9nbG9iYWxTdG9yYWdlKTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIudmVydGljYWwocmVzcG9uc2UucmVzcG9uc2UpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNFbmRwb2ludEVycm9yKCdWZXJ0aWNhbCBzZWFyY2ggcmVxdWVzdCBmYWlsZWQnLCAnQXV0b0NvbXBsZXRlJywgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlVbml2ZXJzYWwgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvYXV0b2NvbXBsZXRlJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIGJhc2VVcmw6IHRoaXMuX2Jhc2VVcmwsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogcXVlcnlTdHJpbmcsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLl9nbG9iYWxTdG9yYWdlKTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldChxdWVyeVN0cmluZylcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lci51bml2ZXJzYWwocmVzcG9uc2UucmVzcG9uc2UpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNFbmRwb2ludEVycm9yKCdVbml2ZXJzYWwgc2VhcmNoIHJlcXVlc3QgZmFpbGVkJywgJ0F1dG9Db21wbGV0ZScsIGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgQXV0b0NvbXBsZXRlRGF0YSwgeyBBdXRvQ29tcGxldGVSZXN1bHQgfSBmcm9tICcuLi9tb2RlbHMvYXV0b2NvbXBsZXRlZGF0YSc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuXG5jb25zdCB1bml2ZXJzYWxPcHRpb25zID0gW1xuICAnd2hhdCBpcyB5ZXh0JyxcbiAgJ3dobyBpcyB0aGUgY2VvIG9mIHlleHQnXG5dO1xuXG5jb25zdCB2ZXJ0aWNhbE9wdGlvbnMgPSBbXG4gICduZWFyIG1lJyxcbiAgJ2luIG5ldyB5b3JrJyxcbiAgJ2F2YWlsYWJsZSBub3cnXG5dO1xuXG4vKipcbiAqIE1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIHNlcnZlcyBhdXRvY29tcGxldGUgcXVlcmllcyB3aXRoIG1vY2sgZGF0YVxuICpcbiAqIEBpbXBsZW1lbnRzIHtBdXRvQ29tcGxldGVTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2NrQXV0b0NvbXBsZXRlU2VydmljZSB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeUZpbHRlciAoaW5wdXQsIGNvbmZpZykge1xuICAgIC8vIFRPRE8oYW11bGxpbmdzKTogU2ltdWxhdGUgZmlsdGVyIHNlYXJjaCwgd2l0aCBzZWN0aW9uc1xuICAgIHJldHVybiBlbXB0eVJlc3VsdHMoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVZlcnRpY2FsIChpbnB1dCwgdmVydGljYWxLZXkpIHtcbiAgICByZXR1cm4gZmlsdGVyT3B0aW9ucyhpbnB1dCwgdmVydGljYWxPcHRpb25zXG4gICAgICAubWFwKG9wdCA9PiBgJHt2ZXJ0aWNhbEtleX0gJHtvcHR9YClcbiAgICAgIC5jb25jYXQodW5pdmVyc2FsT3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5VW5pdmVyc2FsIChpbnB1dCkge1xuICAgIHJldHVybiBmaWx0ZXJPcHRpb25zKGlucHV0LCB1bml2ZXJzYWxPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBRdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnMgSGFyZGNvZGVkIGF1dG9jb21wbGV0ZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRvQ29tcGxldGVEYXRhPn1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBlbXB0eVJlc3VsdHMoKTtcbiAgfVxuXG4gIGNvbnN0IGxvd2VyY2FzZSA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHJlc3VsdHMgPSBvcHRpb25zXG4gICAgLmZpbHRlcihvcHQgPT4gb3B0LmluY2x1ZGVzKGxvd2VyY2FzZSkpXG4gICAgLm1hcChvcHQgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdCh7XG4gICAgICB2YWx1ZTogb3B0LFxuICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAgICAgIG9mZnNldDogb3B0LmluZGV4T2YobG93ZXJjYXNlKSxcbiAgICAgICAgbGVuZ3RoOiBsb3dlcmNhc2UubGVuZ3RoXG4gICAgICB9XVxuICAgIH0pKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXV0b0NvbXBsZXRlRGF0YSh7XG4gICAgc2VjdGlvbnM6IFt7IHJlc3VsdHMgfV0sXG4gICAgcXVlcnlJZDogcmFuZG9tU3RyaW5nKClcbiAgfSkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPEF1dG9Db21wbGV0ZURhdGE+fVxuICovXG5mdW5jdGlvbiBlbXB0eVJlc3VsdHMgKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBdXRvQ29tcGxldGVEYXRhKHtcbiAgICBzZWN0aW9uczogW3t9XSxcbiAgICBxdWVyeUlkOiByYW5kb21TdHJpbmcoKVxuICB9KSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmFuZG9tU3RyaW5nICgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cbiIsIi8qKiBAbW9kdWxlIFF1ZXN0aW9uQW5zd2VyQXBpICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBQUk9EVUNUSU9OIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yLCBBbnN3ZXJzRW5kcG9pbnRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0S25vd2xlZGdlQXBpVXJsIH0gZnJvbSAnLi4vdXRpbHMvdXJsdXRpbHMnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBRdWVzdGlvbkFuc3dlckFwaSBzdWJtaXRzIHF1ZXN0aW9ucyB2aWEgdGhlIFEmQSBSRVNUIEFQSVxuICpcbiAqIEBpbXBsZW1lbnRzIHtRdWVzdGlvbkFuc3dlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXN0aW9uQW5zd2VyQXBpIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBnbG9iYWxTdG9yYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIEFQSSBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignQXBpIEtleSBpcyByZXF1aXJlZCcsICdRdWVzdGlvbkFuc3dlckFwaScpO1xuICAgIH1cbiAgICB0aGlzLl9hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzdG9yYWdlIGluc3RhbmNlIG9mIHRoZSBleHBlcmllbmNlXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWdsb2JhbFN0b3JhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignR2xvYmFsIHN0b3JhZ2UgaXMgcmVxdWlyZWQnLCAnUXVlc3Rpb25BbnN3ZXJBcGknKTtcbiAgICB9XG4gICAgdGhpcy5fZ2xvYmFsU3RvcmFnZSA9IGdsb2JhbFN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIEFuc3dlcnMgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudCB8fCBQUk9EVUNUSU9OO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHN1Ym1pdFF1ZXN0aW9uIChxdWVzdGlvbikge1xuICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB7XG4gICAgICBiYXNlVXJsOiBnZXRLbm93bGVkZ2VBcGlVcmwodGhpcy5fZW52aXJvbm1lbnQpLFxuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvY3JlYXRlUXVlc3Rpb24nLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2VudGl0eUlkJzogcXVlc3Rpb24uZW50aXR5SWQsXG4gICAgICAgICdzaXRlJzogcXVlc3Rpb24uc2l0ZSxcbiAgICAgICAgJ25hbWUnOiBxdWVzdGlvbi5uYW1lLFxuICAgICAgICAnZW1haWwnOiBxdWVzdGlvbi5lbWFpbCxcbiAgICAgICAgJ3F1ZXN0aW9uVGV4dCc6IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCxcbiAgICAgICAgJ3F1ZXN0aW9uRGVzY3JpcHRpb24nOiBxdWVzdGlvbi5xdWVzdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgICAncXVlc3Rpb25MYW5ndWFnZSc6IHF1ZXN0aW9uLnF1ZXN0aW9uTGFuZ3VhZ2VcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5fZ2xvYmFsU3RvcmFnZSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5wb3N0KHtcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0VuZHBvaW50RXJyb3IoXG4gICAgICAgICAgJ1F1ZXN0aW9uIHN1Ym1pdCBmYWlsZWQnLFxuICAgICAgICAgICdRdWVzdGlvbkFuc3dlckFwaScsXG4gICAgICAgICAgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtRdWVzdGlvbkFuc3dlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2Uge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgLy8gVE9ETyhhbXVsbGluZ3MpOiBNYWtlIGFjdHVhbCByZXNwb25zZSBvYmplY3Qgb25jZSB3ZSdyZSB1c2luZyBpdCBmb3JcbiAgICAvLyBzb21ldGhpbmdcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgfVxufVxuIiwiLyogZ2xvYmFsIGZldGNoICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbHMvc2VjdGlvbicpLmRlZmF1bHR9IFNlY3Rpb24gKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlc3VsdERhdGFcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZyB9IGh0bWxUaXRsZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlc3VsdHNNb2RpZmllclxuICogQHBhcmFtIHtSZXN1bHREYXRhW119IHJlc3VsdHNcbiAqIEByZXR1cm5zIHtSZXN1bHREYXRhW119XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTW9ja0RhdGFDb25zdW1lclxuICogQHBhcmFtIHtTZWN0aW9uW119IHNlY3Rpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5cbmNvbnN0IEFSQklUUkFSWV9CVVNJTkVTU19JRCA9IDkxOTg3MTtcblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7U2VhcmNoU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9ja1NlYXJjaFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dldE1vY2tEYXRhSnNvbiA9IGZldGNoKCdodHRwczovL2Fzc2V0cy5zaXRlc2Nkbi5uZXQvYW5zd2Vycy90ZXN0ZGF0YS9zZWFyY2gvbW9ja2RhdGFfdjEuanNvbicpXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AudGV4dCgpKVxuICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZlcnRpY2FsU2VhcmNoICh2ZXJ0aWNhbEtleSwgeyBpbnB1dCwgZmlsdGVyLCBmYWNldEZpbHRlciwgbGltaXQsIG9mZnNldCwgaWQsIGdlb2xvY2F0aW9uLCBpc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCwgc2tpcFNwZWxsQ2hlY2ssIHF1ZXJ5VHJpZ2dlciB9KSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTW9ja0RhdGEoc2VjdGlvbnMgPT4ge1xuICAgICAgaWYgKGlucHV0ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKGNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2Uoe1xuICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgIGFwcGxpZWRRdWVyeUZpbHRlcnM6IFtdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIGZpbmQgYSBzZWN0aW9uIHdpdGggbWF0Y2hpbmcgSUQsIG9yIHBpY2sgb25lIGF0IHJhbmRvbVxuICAgICAgbGV0IHNlY3Rpb24gPSBzZWN0aW9ucy5maW5kKFxuICAgICAgICB2ZXJ0aWNhbE1vZHVsZSA9PiB2ZXJ0aWNhbEtleSA9PT0gdmVydGljYWxNb2R1bGVbJ3ZlcnRpY2FsQ29uZmlnSWQnXVxuICAgICAgKTtcbiAgICAgIGlmIChzZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNlY3Rpb25zLmxlbmd0aCldO1xuICAgICAgfVxuXG4gICAgICBtb2RpZnlSZXN1bHRzKHNlY3Rpb24sIGdldFJlc3VsdHNGaWx0ZXJlcihpbnB1dCkpO1xuICAgICAgaWYgKG9mZnNldCAhPSBudWxsICYmIGxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgbW9kaWZ5UmVzdWx0cyhzZWN0aW9uLCBmdW5jdGlvbiBsaW1pdCAocmVzdWx0cykge1xuICAgICAgICAgIHJldHVybiByZXN1bHRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcCA9IGNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2Uoc2VjdGlvbik7XG4gICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKHJlc3ApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHVuaXZlcnNhbFNlYXJjaCAocXVlcnlTdHJpbmcsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnVzZU1vY2tEYXRhKHNlY3Rpb25zID0+IHtcbiAgICAgIGlmIChxdWVyeVN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRSZXNwb25zZShjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZShbXSkpO1xuICAgICAgfVxuXG4gICAgICBzZWN0aW9ucy5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuICAgICAgICBtb2RpZnlSZXN1bHRzKHNlY3Rpb24sIGdldFJlc3VsdHNGaWx0ZXJlcihxdWVyeVN0cmluZykpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlY3Rpb25zID0gc2VjdGlvbnMuZmlsdGVyKHNlY3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5yZXN1bHRzLmxlbmd0aCA+IDA7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcCA9IGNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlKHNlY3Rpb25zKTtcbiAgICAgIHJldHVybiBkZWxheWVkUmVzcG9uc2UocmVzcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2NrRGF0YUNvbnN1bWVyfSBjb25zdW1lclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXNlTW9ja0RhdGEgKGNvbnN1bWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1vY2tEYXRhSnNvbi50aGVuKEpTT04ucGFyc2UpLnRoZW4oY29uc3VtZXIpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyaW5nXG4gKiBAcmV0dXJuIHtSZXN1bHRzTW9kaWZpZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VsdHNGaWx0ZXJlciAocXVlcnlTdHJpbmcpIHtcbiAgcmV0dXJuIHJlc3VsdHMgPT4gcmVzdWx0cy5maWx0ZXIocmVzdWx0ID0+IHtcbiAgICBpZiAocmVzdWx0Lmh0bWxUaXRsZSAmJiByZXN1bHQuaHRtbFRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnlTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHJlc3VsdC5kYXRhKSB7XG4gICAgICBjb25zdCB2YWwgPSByZXN1bHQuZGF0YVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWN0aW9ufSBzZWN0aW9uXG4gKiBAcGFyYW0ge1Jlc3VsdHNNb2RpZmllcn0gbW9kaWZ5Rm5cbiAqL1xuZnVuY3Rpb24gbW9kaWZ5UmVzdWx0cyAoc2VjdGlvbiwgbW9kaWZ5Rm4pIHtcbiAgc2VjdGlvbi5yZXN1bHRzID0gbW9kaWZ5Rm4oc2VjdGlvbi5yZXN1bHRzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb25bXX0gc2VjdGlvbnMgQSBsaXN0IG9mIG1vY2sgc2VjdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1vY2sgQW5zd2Vyc0FwaSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZSAoc2VjdGlvbnMpIHtcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBzcGVsbGNoZWNrLCBnZW8sIGZpbHRlcnNcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBGYWtlIGVuY29kZWRTdGF0ZSBvbmNlIHRoZSBTREsgdXNlcyBpdFxuICBzZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmaWxsU2VjdGlvbkZpZWxkcyk7XG4gIHJldHVybiB7XG4gICAgbWV0YToge1xuICAgICAgdXVpZDogdXVpZFY0KCksXG4gICAgICBlcnJvcnM6IFtdXG4gICAgfSxcbiAgICByZXNwb25zZToge1xuICAgICAgYnVzaW5lc3NJZDogQVJCSVRSQVJZX0JVU0lORVNTX0lELFxuICAgICAgbW9kdWxlczogc2VjdGlvbnMsXG4gICAgICBmYWlsZWRWZXJ0aWNhbHM6IFtdLFxuICAgICAgcXVlcnlJZDogdXVpZFY0KCksXG4gICAgICBzZWFyY2hJbnRlbnRzOiBbXVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb259IHNlY3Rpb24gQSBtb2NrIHNlY3Rpb24gZGF0YVxuICogQHJldHVybnMge09iamVjdH0gQSBtb2NrIEFuc3dlcnNBcGkgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0VmVydGljYWxSZXNwb25zZSAoc2VjdGlvbikge1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IHNwZWxsY2hlY2ssIGdlbywgZmlsdGVyc1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IEZha2UgZW5jb2RlZFN0YXRlIG9uY2UgdGhlIFNESyB1c2VzIGl0XG4gIHNlY3Rpb24gPSBmaWxsU2VjdGlvbkZpZWxkcyhzZWN0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBtZXRhOiB7XG4gICAgICB1dWlkOiB1dWlkVjQoKSxcbiAgICAgIGVycm9yczogW11cbiAgICB9LFxuICAgIHJlc3BvbnNlOiBPYmplY3QuYXNzaWduKHNlY3Rpb24sIHtcbiAgICAgIGJ1c2luZXNzSWQ6IEFSQklUUkFSWV9CVVNJTkVTU19JRCxcbiAgICAgIHF1ZXJ5SWQ6IHV1aWRWNCgpLFxuICAgICAgc2VhcmNoSW50ZW50czogW11cbiAgICB9KVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VjdGlvbn1cbiAqIEByZXR1cm5zIHtTZWN0aW9ufVxuICovXG5mdW5jdGlvbiBmaWxsU2VjdGlvbkZpZWxkcyAoc2VjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHNlY3Rpb24udmVydGljYWxDb25maWdJZCxcbiAgICByZXN1bHRzQ291bnQ6IHNlY3Rpb24ucmVzdWx0cy5sZW5ndGgsXG4gICAgZW5jb2RlZFN0YXRlOiAnJyxcbiAgICByZXN1bHRzOiBzZWN0aW9uLnJlc3VsdHMsXG4gICAgYXBwbGllZFF1ZXJ5RmlsdGVyczogc2VjdGlvbi5hcHBsaWVkUXVlcnlGaWx0ZXJzLFxuICAgIHF1ZXJ5RHVyYXRpb25NaWxsaXM6IHJhbmRvbUludCg1MCwgMTAwMCksXG4gICAgZmFjZXRzOiBzZWN0aW9uLmZhY2V0cyxcbiAgICBzb3VyY2U6IHNlY3Rpb24uc291cmNlXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmZ1bmN0aW9uIGRlbGF5ZWRSZXNwb25zZSAocmVzcCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHJlc3ApO1xuICAgIH0sIHJhbmRvbUludCgyNTAsIDEwMDApKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29kZS1nb2xmLXkgYnV0IGxlZ2l0IGJhc2ljIFVVSUQgdjQgaW1wbGVtZW50YXRpb24uIE5vdCBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUuXG4gKiBGcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgdjQtY29tcGxpYW50IFVVSURcbiAqL1xuZnVuY3Rpb24gdXVpZFY0ICgpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBiIChhKSB7IHJldHVybiBhID8gKGEgXiBNYXRoLnJhbmRvbSgpICogMTYgPj4gYSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBiKTsgfSkoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBleGNsdXNpdmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgaW4gdGhlIHNwZWNpZmllZCByYW5nZVxuICovXG5mdW5jdGlvbiByYW5kb21JbnQgKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XG59XG4iLCIvKiogQG1vZHVsZSBOYXZpZ2F0aW9uQ29tcG9uZW50ICovXG5cbi8qIGdsb2JhbCBOb2RlICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG4vKipcbiAqIFRoZSBkZWJvdW5jZSBkdXJhdGlvbiBmb3IgcmVzaXplIGV2ZW50c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgUkVTSVpFX0RFQk9VTkNFID0gMTAwO1xuXG4vKipcbiAqIFRoZSBicmVha3BvaW50IGZvciBtb2JpbGVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1PQklMRV9CUkVBS1BPSU5UID0gNzY3O1xuXG4vKipcbiAqIEVudW0gb3B0aW9ucyBmb3IgbW9iaWxlIG92ZXJmbG93IGJlYWh2aW9yXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmNvbnN0IE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04gPSB7XG4gIENPTExBUFNFOiAnQ09MTEFQU0UnLFxuICBJTk5FUlNDUk9MTDogJ0lOTkVSU0NST0xMJ1xufTtcblxuLyoqXG4gKiBUaGUgVGFiIGlzIGEgbW9kZWwgdGhhdCBpcyB1c2VkIHRvIHBvd2VyIHRoZSBOYXZpZ2F0aW9uIHRhYnMgaW4gdGhlIHZpZXcuXG4gKiBJdCdzIGluaXRpYWxpemVkIHRocm91Z2ggdGhlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhYiB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGFiIHRoYXQgaXMgZXhwb3NlZCBmb3IgdGhlIGxpbmtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBjb25maWcubGFiZWw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcignbGFiZWwgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgdGFiLicsICdOYXZpZ2F0aW9uQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBsZXRlIFVSTCwgaW5jbHVkaW5nIHRoZSBwYXJhbXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcbiAgICBpZiAodHlwZW9mIHRoaXMudXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcigndXJsIGlzIGEgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBvcHRpb24gZm9yIHRhYi4nLCAnTmF2aWdhdGlvbkNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXJzaWRlIHZlcnRpY2FsIGNvbmZpZyBpZCB0aGF0IHRoaXMgaXMgcmVmZXJlbmNlZCB0by5cbiAgICAgKiBCeSBwcm92aWRpbmcgdGhpcywgZW5hYmxlcyBkeW5hbWljIHNvcnRpbmcgYmFzZWQgb24gcmVzdWx0cy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIFVSTCB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgdGhlIFVSTCB3aXRoIHBhcmFtc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gY29uZmlnLnVybDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IHRoaXMgdGFiIGZpcnN0IGluIHRoZSBvcmRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNGaXJzdCA9IGNvbmZpZy5pc0ZpcnN0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBhcHBseSBhIHNwZWNpYWwgY2xhc3MgdG8gdGhlXG4gICAgICogbWFya3VwIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIGFjdGl2ZSB0YWJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQWN0aXZlID0gY29uZmlnLmlzQWN0aXZlIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIGZyb20gd2lsbCBjb25zdHJ1Y3QgYSBtYXAgb2YgdmVydGljYWxLZXkgdG8ge1RhYn0gZnJvbVxuICAgKiBhIGNvbmZpZ3VyYXRpb24gZmlsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdGFic0NvbmZpZyB0aGUgY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBmcm9tICh0YWJzQ29uZmlnKSB7XG4gICAgbGV0IHRhYnMgPSB7fTtcbiAgICAvLyBQYXJzZSB0aGUgb3B0aW9ucyBhbmQgYnVpbGQgb3V0IG91ciB0YWJzIGFuZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFic0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRhYiA9IHsgLi4udGFic0NvbmZpZ1tpXSB9O1xuXG4gICAgICAvLyBJZiBhIHRhYiBpcyBjb25maWd1cmVkIHRvIGJlIGhpZGRlbiBpbiB0aGlzIGNvbXBvbmVudCxcbiAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGl0XG4gICAgICBpZiAodGFiLmhpZGVJbk5hdmlnYXRpb24pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciB0YWJzIHdpdGhvdXQgY29uZmlnIGlkcywgbWFwIHRoZWlyIFVSTCB0byB0aGUgY29uZmlnSURcbiAgICAgIC8vIHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIHJlbmRlcnNcbiAgICAgIGlmICh0YWIudmVydGljYWxLZXkgPT09IG51bGwgJiYgdGFic1t0YWIudmVydGljYWxLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFiLnZlcnRpY2FsS2V5ID0gdGFiLnVybDtcbiAgICAgIH1cblxuICAgICAgdGFic1t0YWIudmVydGljYWxLZXldID0gbmV3IFRhYih0YWIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFicztcbiAgfVxufVxuXG4vKipcbiAqIE5hdmlnYXRpb25Db21wb25lbnQgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIGJ1aWxkaW5nIGEgZHluYW1pY1xuICogbmF2aWdhdGlvbiB0aGF0IGlzIHBvd2VyZWQgYnkgdW5pdmVyc2FsIHNlYXJjaCB1cGRhdGVzLlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgb24gdGhlIGRyb3Bkb3duIG1lbnUgYnV0dG9uIHdoZW4gb3ZlcmZsb3dcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dMYWJlbCA9IGNvbmZpZy5vdmVyZmxvd0xhYmVsIHx8ICdNb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBpY29uIHRvIHNob3cgb24gdGhlIGRyb3Bkb3duIG1lbnUgYnV0dG9uIHdoZW4gb3ZlcmZsb3dcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dJY29uID0gY29uZmlnLm92ZXJmbG93SWNvbiB8fCAna2Fib2InO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZSBrZXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5OQVZJR0FUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGFicyBjb25maWcgZnJvbSBnbG9iYWwgbmF2aWdhdGlvbiBjb25maWdcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90YWJzQ29uZmlnID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuVkVSVElDQUxfUEFHRVNfQ09ORklHKS5nZXQoKTtcblxuICAgIC8qKlxuICAgICAqIFVub3JkZXJlZCBtYXAgb2YgZWFjaCB0YWIsIGtleWVkIGJ5IFZTIHZlcnRpY2FsS2V5XG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBPYmplY3Q+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGFicyA9IFRhYi5mcm9tKHRoaXMuX3RhYnNDb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSB0YWJzLCBwYXJzZWQgZnJvbSBjb25maWd1cmF0aW9uIG9yIFVSTC5cbiAgICAgKiBUaGlzIGdldHMgdXBkYXRlZCBiYXNlZCBvbiB0aGUgc2VydmVyIHJlc3VsdHNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59IFRoZSBsaXN0IG9mIFZTIHZlcnRpY2FsS2V5c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGFiT3JkZXIgPSB0aGlzLmdldERlZmF1bHRUYWJPcmRlcih0aGlzLl90YWJzQ29uZmlnLCB0aGlzLmdldFVybFBhcmFtcygpKTtcblxuICAgIC8qKlxuICAgICAqIEJyZWFrcG9pbnRzIGF0IHdoaWNoIG5hdmlnYXRpb24gaXRlbXMgbW92ZSB0byB0aGUgXCJtb3JlXCIgZHJvcGRvd25cbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9uYXZCcmVha3BvaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBtb2JpbGUgb3ZlcmZsb3cgYmVoYXZpb3IgY29uZmlnXG4gICAgICogIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fbW9iaWxlT3ZlcmZsb3dCZWhhdmlvciA9IGNvbmZpZy5tb2JpbGVPdmVyZmxvd0JlaGF2aW9yIHx8IE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04uQ09MTEFQU0U7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIEFSSUEgbGFiZWxcbiAgICAgKiAgQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9hcmlhTGFiZWwgPSBjb25maWcuYXJpYUxhYmVsIHx8ICdTZWFyY2ggUGFnZSBOYXZpZ2F0aW9uJztcblxuICAgIHRoaXMuY2hlY2tPdXRzaWRlQ2xpY2sgPSB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IgPSB0aGlzLmNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ05hdmlnYXRpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICduYXZpZ2F0aW9uL25hdmlnYXRpb24nO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIC8vIFRPRE86IFJlLXJlbmRlcmluZyBhbmQgcmUtbW91bnRpbmcgdGhlIGNvbXBvbmVudCBldmVyeSB0aW0gZSB0aGUgd2luZG93IGNoYW5nZXMgc2l6ZVxuICAgIC8vIGlzIG5vdCBncmVhdC5cbiAgICBET00ub24od2luZG93LCAncmVzaXplJywgdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IpO1xuICB9XG5cbiAgb25EZXN0cm95ICgpIHtcbiAgICBET00ub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLnNob3VsZENvbGxhcHNlKCkpIHtcbiAgICAgIHRoaXMuX25hdkJyZWFrcG9pbnRzID0gW107XG4gICAgICB0aGlzLmJpbmRPdmVyZmxvd0hhbmRsZXJzKCk7XG4gICAgICB0aGlzLnJlZml0TmF2KCk7XG4gICAgICBET00ub24oRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKSwgJ2NsaWNrJywgdGhpcy50b2dnbGVNb3JlRHJvcGRvd24uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgb25Vbk1vdW50ICgpIHtcbiAgICB0aGlzLnVuYmluZE92ZXJmbG93SGFuZGxlcnMoKTtcbiAgfVxuXG4gIGJpbmRPdmVyZmxvd0hhbmRsZXJzICgpIHtcbiAgICBET00ub24od2luZG93LCAnY2xpY2snLCB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrKTtcbiAgfVxuXG4gIHVuYmluZE92ZXJmbG93SGFuZGxlcnMgKCkge1xuICAgIERPTS5vZmYod2luZG93LCAnY2xpY2snLCB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrKTtcbiAgfVxuXG4gIHJlZml0TmF2ICgpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtY29udGFpbmVyJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgY29uc3QgbWFpbkxpbmtzID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LWV4cGFuZGVkJyk7XG4gICAgY29uc3QgY29sbGFwc2VkTGlua3MgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcblxuICAgIGNvbnN0IG5hdldpZHRoID0gbW9yZUJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3l4dC1OYXYtaXRlbS0tbW9yZScpXG4gICAgICA/IGNvbnRhaW5lci5vZmZzZXRXaWR0aFxuICAgICAgOiBjb250YWluZXIub2Zmc2V0V2lkdGggLSBtb3JlQnV0dG9uLm9mZnNldFdpZHRoO1xuICAgIGxldCBudW1CcmVha3BvaW50cyA9IHRoaXMuX25hdkJyZWFrcG9pbnRzLmxlbmd0aDtcblxuICAgIC8vIHN1bSBjaGlsZCB3aWR0aHMgaW5zdGVhZCBvZiB1c2luZyBwYXJlbnQncyB3aWR0aCB0byBhdm9pZFxuICAgIC8vIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAgbGV0IG1haW5MaW5rc1dpZHRoID0gMDtcbiAgICBmb3IgKGxldCBlbCBvZiBtYWluTGlua3MuY2hpbGRyZW4pIHtcbiAgICAgIG1haW5MaW5rc1dpZHRoICs9IGVsLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChtYWluTGlua3NXaWR0aCA+IG5hdldpZHRoKSB7XG4gICAgICB0aGlzLl9uYXZCcmVha3BvaW50cy5wdXNoKG1haW5MaW5rc1dpZHRoKTtcbiAgICAgIGNvbnN0IGxhc3RMaW5rID0gbWFpbkxpbmtzLmNoaWxkcmVuLml0ZW0obWFpbkxpbmtzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGxhc3RMaW5rID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByZXBlbmQoY29sbGFwc2VkTGlua3MsIGxhc3RMaW5rKTtcblxuICAgICAgaWYgKG1vcmVCdXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCd5eHQtTmF2LWl0ZW0tLW1vcmUnKSkge1xuICAgICAgICBtb3JlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3l4dC1OYXYtaXRlbS0tbW9yZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobnVtQnJlYWtwb2ludHMgJiYgbmF2V2lkdGggPiB0aGlzLl9uYXZCcmVha3BvaW50c1tudW1CcmVha3BvaW50cyAtIDFdKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TGluayA9IGNvbGxhcHNlZExpbmtzLmNoaWxkcmVuLml0ZW0oMCk7XG4gICAgICAgIGlmIChmaXJzdExpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFpbkxpbmtzLmFwcGVuZChmaXJzdExpbmspO1xuICAgICAgICB0aGlzLl9uYXZCcmVha3BvaW50cy5wb3AoKTtcbiAgICAgICAgbnVtQnJlYWtwb2ludHMtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbGxhcHNlZExpbmtzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBtb3JlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1OYXYtaXRlbS0tbW9yZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2xvc2VNb3JlRHJvcGRvd24oKTtcbiAgICBpZiAobWFpbkxpbmtzV2lkdGggPiBuYXZXaWR0aCB8fFxuICAgICAgKG51bUJyZWFrcG9pbnRzID4gMCAmJiBuYXZXaWR0aCA+IHRoaXMuX25hdkJyZWFrcG9pbnRzW251bUJyZWFrcG9pbnRzIC0gMV0pKSB7XG4gICAgICB0aGlzLnJlZml0TmF2KCk7XG4gICAgfVxuICB9XG5cbiAgY2xvc2VNb3JlRHJvcGRvd24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuICAgIGNvbGxhcHNlZC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBtb3JlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIG9wZW5Nb3JlRHJvcGRvd24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuICAgIGNvbGxhcHNlZC5jbGFzc0xpc3QuYWRkKCdpcy1hY3RpdmUnKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBtb3JlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICB9XG5cbiAgdG9nZ2xlTW9yZURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjb2xsYXBzZWQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcbiAgICBjb2xsYXBzZWQuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgbW9yZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBjb2xsYXBzZWQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1hY3RpdmUnKSk7XG4gIH1cblxuICBjaGVja091dHNpZGVDbGljayAoZSkge1xuICAgIGlmICh0aGlzLl9jbG9zZXN0KGUudGFyZ2V0LCAnLnl4dC1OYXYtY29udGFpbmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlTW9yZURyb3Bkb3duKCk7XG4gIH1cblxuICBjaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IgKCkge1xuICAgIGlmICh0aGlzLl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lciA9IHNldFRpbWVvdXQodGhpcy5zZXRTdGF0ZS5iaW5kKHRoaXMpLCBSRVNJWkVfREVCT1VOQ0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbmNlIHRoZSBzZXJ2ZXIgZGF0YSBvbmx5IHByb3ZpZGVzIGEgbGlzdCBvZlxuICAgKiBWUyB2ZXJ0aWNhbEtleXMsIHdlIG5lZWQgdG8gY29tcHV0ZSBhbmQgdHJhbnNmb3JtXG4gICAqIHRoZSBkYXRhIGludG8gdGhlIHByb3BlciBmb3JtYXQgZm9yIHJlbmRlcmluZy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSA9IHt9KSB7XG4gICAgaWYgKGRhdGEudGFiT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fdGFiT3JkZXIgPSB0aGlzLm1lcmdlVGFiT3JkZXIoZGF0YS50YWJPcmRlciwgdGhpcy5fdGFiT3JkZXIpO1xuICAgIH1cblxuICAgIC8vIFNpbmNlIHRoZSB0YWIgb3JkZXJpbmcgY2FuIGNoYW5nZSBiYXNlZCBvbiB0aGUgc2VydmVyIGRhdGFcbiAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSBlYWNoIHRhYnMgVVJMIHRvIGluY2x1ZGUgdGhlIG9yZGVyIGFzIHBhcnQgb2YgdGhlaXIgcGFyYW1zLlxuICAgIC8vIFRoaXMgaGVscHMgd2l0aCBwZXJzaXN0aW5nIHN0YXRlIGFjcm9zcyB2ZXJ0aWNhbHMuXG4gICAgbGV0IHRhYnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhYk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGFiID0gdGhpcy5fdGFic1t0aGlzLl90YWJPcmRlcltpXV07XG4gICAgICBpZiAodGFiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFiLnVybCA9IHRoaXMuZ2VuZXJhdGVUYWJVcmwodGFiLmJhc2VVcmwsIHRoaXMuZ2V0VXJsUGFyYW1zKCkpO1xuICAgICAgICB0YWJzLnB1c2godGFiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgdGFiczogdGFicyxcbiAgICAgIG92ZXJmbG93TGFiZWw6IHRoaXMub3ZlcmZsb3dMYWJlbCxcbiAgICAgIG92ZXJmbG93SWNvbjogdGhpcy5vdmVyZmxvd0ljb24sXG4gICAgICBzaG93Q29sbGFwc2U6IHRoaXMuc2hvdWxkQ29sbGFwc2UoKSxcbiAgICAgIGFyaWFMYWJlbDogdGhpcy5fYXJpYUxhYmVsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPIChhZ3JvdykgaW52ZXN0aWdhdGUgcmVtb3ZpbmcgdGhpc1xuICAvLyBQYXJlbnROb2RlLnByZXBlbmQgcG9seWZpbGxcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BhcmVudE5vZGUvcHJlcGVuZCNQb2x5ZmlsbFxuICBfcHJlcGVuZCAoY29sbGFwc2VkTGlua3MsIGxhc3RMaW5rKSB7XG4gICAgaWYgKCFjb2xsYXBzZWRMaW5rcy5oYXNPd25Qcm9wZXJ0eSgncHJlcGVuZCcpKSB7XG4gICAgICBsZXQgZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGxldCBpc05vZGUgPSBsYXN0TGluayBpbnN0YW5jZW9mIE5vZGU7XG4gICAgICBkb2NGcmFnLmFwcGVuZENoaWxkKGlzTm9kZSA/IGxhc3RMaW5rIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGxhc3RMaW5rKSkpO1xuXG4gICAgICBjb2xsYXBzZWRMaW5rcy5pbnNlcnRCZWZvcmUoZG9jRnJhZywgY29sbGFwc2VkTGlua3MuZmlyc3RDaGlsZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29sbGFwc2VkTGlua3MucHJlcGVuZChsYXN0TGluayk7XG4gIH1cblxuICAvLyBUT0RPIChhZ3JvdykgaW52ZXN0aWdhdGUgcmVtb3ZpbmcgdGhpc1xuICAvLyBBZGFwdGVkIGZyb20gRWxlbWVudC5jbG9zZXN0IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3QjUG9seWZpbGxcbiAgX2Nsb3Nlc3QgKGVsLCBjbG9zZXN0RWxTZWxlY3Rvcikge1xuICAgIGlmICghZWwuaGFzT3duUHJvcGVydHkoJ2Nsb3Nlc3QnKSkge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoRE9NLm1hdGNoZXMoZWwsIGNsb3Nlc3RFbFNlbGVjdG9yKSkgcmV0dXJuIGVsO1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZTtcbiAgICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWwuY2xvc2VzdChjbG9zZXN0RWxTZWxlY3Rvcik7XG4gIH1cblxuICBnZXRVcmxQYXJhbXMgKCkge1xuICAgIHJldHVybiBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgfVxuXG4gIHNob3VsZENvbGxhcHNlICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX21vYmlsZU92ZXJmbG93QmVoYXZpb3IpIHtcbiAgICAgIGNhc2UgTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTi5DT0xMQVBTRTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04uSU5ORVJTQ1JPTEw6XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1jb250YWluZXInKSB8fCB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG5hdldpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgICByZXR1cm4gbmF2V2lkdGggPiBNT0JJTEVfQlJFQUtQT0lOVDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0RGVmYXVsdFRhYk9yZGVyIHdpbGwgY29tcHV0ZSB0aGUgaW5pdGlhbCB0YWIgb3JkZXJpbmcgYmFzZWRcbiAgICogb24gYSBjb21iaW5hdGlvbiBvZiB0aGUgY29uZmlndXJhdGlvbiBwcm92aWRlZCBkaXJlY3RseSB0byB0aGUgY29tcG9uZW50XG4gICAqIGFuZCB0aGUgdXJsIHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gdGFic0NvbmZpZ1xuICAgKiBAcGFyYW0ge1NlYXJjaFBhcmFtc31cbiAgICovXG4gIGdldERlZmF1bHRUYWJPcmRlciAodGFic0NvbmZpZywgdXJsUGFyYW1zKSB7XG4gICAgbGV0IHRhYk9yZGVyID0gW107XG5cbiAgICAvLyBVc2UgdGhlIG9yZGVyaW5nIGZyb20gdGhlIFVSTCBhcyB0aGUgcHJpbWFyeSBjb25maWd1cmF0aW9uXG4gICAgLy8gQW5kIHRoZW4gbWVyZ2UgaXQgd2l0aCB0aGUgbG9jYWwgY29uZmlndXJhdGlvbiwgaWYgcHJvdmlkZWQuXG4gICAgaWYgKHVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKCd0YWJPcmRlcicpKSB7XG4gICAgICB0YWJPcmRlciA9IHVybFBhcmFtcy5nZXQoJ3RhYk9yZGVyJykuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhYiA9IHRhYnNDb25maWdbaV07XG4gICAgICAvLyBTb21lIHRhYnMgZG9uJ3QgaGF2ZSB2ZXJ0aWNhbEtleSwgc28gd2UgbWFwIGl0IGZyb20gVVJMXG4gICAgICBpZiAoIXRhYi52ZXJ0aWNhbEtleSkge1xuICAgICAgICB0YWIudmVydGljYWxLZXkgPSB0YWIudXJsO1xuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCBkdXBsaWNhdGVzIGlmIGNvbmZpZyB3YXMgcHJvdmlkZWQgZnJvbSBVUkxcbiAgICAgIGlmICh0YWJPcmRlci5pbmNsdWRlcyh0YWIudmVydGljYWxLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpc0ZpcnN0IHNob3VsZCBhbHdheXMgYmUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAgICAgIGlmICh0YWIuaXNGaXJzdCkge1xuICAgICAgICB0YWJPcmRlci51bnNoaWZ0KHRhYi52ZXJ0aWNhbEtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJPcmRlci5wdXNoKHRhYi52ZXJ0aWNhbEtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYk9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIG1lcmdlVGFiT3JkZXIgbWVyZ2VzIHR3byBhcnJheXMgaW50byBvbmVcbiAgICogYnkgYXBwZW5kaW5nIGFkZGl0aW9uYWwgdGFicyB0byB0aGUgZW5kIG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YWJPcmRlciBUYWIgb3JkZXIgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvdGhlclRhYk9yZGVyIFRhYiBvcmRlciBwcm92aWRlZCBieSBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgKi9cbiAgbWVyZ2VUYWJPcmRlciAodGFiT3JkZXIsIG90aGVyVGFiT3JkZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyVGFiT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhYkNvbmZpZyA9IG90aGVyVGFiT3JkZXJbaV07XG4gICAgICBpZiAodGFiT3JkZXIuaW5jbHVkZXModGFiQ29uZmlnKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXNGaXJzdCBzaG91bGQgYmUgYW4gb3ZlcnJpZGUgdG8gZHluYW1pYyB0YWIgb3JkZXJpbmcuXG4gICAgICBpZiAodGhpcy5fdGFic1t0YWJDb25maWddICYmIHRoaXMuX3RhYnNbdGFiQ29uZmlnXS5pc0ZpcnN0KSB7XG4gICAgICAgIHRhYk9yZGVyLnVuc2hpZnQodGFiQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYk9yZGVyLnB1c2godGFiQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFiT3JkZXI7XG4gIH1cblxuICBnZW5lcmF0ZVRhYlVybCAoYmFzZVVybCwgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpKSB7XG4gICAgLy8gV2Ugd2FudCB0byBwZXJzaXN0IHRoZSBwYXJhbXMgZnJvbSB0aGUgZXhpc3RpbmcgVVJMIHRvIHRoZSBuZXdcbiAgICAvLyBVUkxTIHdlIGNyZWF0ZS5cbiAgICBwYXJhbXMuc2V0KCd0YWJPcmRlcicsIHRoaXMuX3RhYk9yZGVyKTtcbiAgICByZXR1cm4gYmFzZVVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcblxuY29uc3QgSWNvblN0YXRlID0ge1xuICAnWUVYVCc6IDAsXG4gICdNQUdOSUZZSU5HX0dMQVNTJzogMVxufTtcblxuLyoqXG4gKiBTZWFyY2hDb21wb25lbnQgZXhwb3NlcyBhbiBpbnRlcmZhY2UgaW4gb3JkZXIgdG8gY3JlYXRlXG4gKiBhIFVJIFNlYXJjaCBleHBlcmllbmNlIGZvciB2ZXJ0aWNhbCBhbmQgdW5pdmVyc2FsIHNlYXJjaC5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCB2ZXJ0aWNhbCBrZXkgZm9yIHZlcnRpY2FsIHNlYXJjaCBjb25maWd1cmF0aW9uXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCBhdXRvLWNvbXBsZXRlIGFuZCBzZWFyY2ggd2lsbCBiZSBiYXNlZCBvbiB1bml2ZXJzYWxcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBzdWJtaXNzaW9uIGlzIGJhc2VkIG9uIGEgZm9ybSBhcyBjb250ZXh0LlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0cyB0byBuYXRpdmUgZm9ybSBub2RlIHdpdGhpbiBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9mb3JtRWwgPSBjb25maWcuZm9ybVNlbGVjdG9yIHx8ICdmb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgZm9yIHNlYXJjaGluZyBhbmQgd2lyZXMgdXAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9uXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9pbnB1dEVsID0gY29uZmlnLmlucHV0RWwgfHwgJy5qcy15ZXh0LXF1ZXJ5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB1c2VkLCBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUgYXMgYSBkYXRhIHBvaW50XG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC4gSWYgbm90IHByb3ZpZGVkLCBubyB0aXRsZSB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IGNvbmZpZy50aXRsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0ZXh0IGlzIHVzZWQgZm9yIGxhYmVsaW5nIHRoZSBpbnB1dCBib3gsIGFsc28gcHJvdmlkZWQgdG8gdGVtcGxhdGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbFRleHQgPSBjb25maWcubGFiZWxUZXh0IHx8ICdDb25kdWN0IGEgc2VhcmNoJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdWJtaXQgdGV4dCBpcyB1c2VkIGZvciBsYWJlbGluZyB0aGUgc3VibWl0IGJ1dHRvbiwgYWxzbyBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN1Ym1pdFRleHQgPSBjb25maWcuc3VibWl0VGV4dCB8fCAnU3VibWl0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGVhciB0ZXh0IGlzIHVzZWQgZm9yIGxhYmVsaW5nIHRoZSBjbGVhciBidXR0b24sIGFsc28gcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jbGVhclRleHQgPSBjb25maWcuY2xlYXJUZXh0IHx8ICdDbGVhcic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VibWl0IGljb24gaXMgYW4gaWNvbiBmb3IgdGhlIHN1Ym1pdCBidXR0b24sIGlmIHByb3ZpZGVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFuZCB0aGVcbiAgICAgKiBzdWJtaXQgdGV4dCB3aWxsIGJlIHVzZWQgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN1Ym1pdEljb24gPSBjb25maWcuc3VibWl0SWNvbiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHRleHQgdG8gc2hvdyBhcyB0aGUgZmlyc3QgaXRlbSBmb3IgYXV0byBjb21wbGV0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb21wdEhlYWRlciA9IGNvbmZpZy5wcm9tcHRIZWFkZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF1dG8gZm9jdXNlcyB0aGUgaW5wdXQgYm94IGlmIHNldCB0byB0cnVlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b0ZvY3VzID0gY29uZmlnLmF1dG9Gb2N1cyA9PT0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYW4gXCJ4XCIgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gY2xlYXIgdGhlIGN1cnJlbnRcbiAgICAgKiBxdWVyeVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJCdXR0b24gPSBjb25maWcuY2xlYXJCdXR0b24gPT09IHVuZGVmaW5lZFxuICAgICAgPyB0cnVlXG4gICAgICA6IGNvbmZpZy5jbGVhckJ1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYXV0b2ZvY3VzaW5nIG9uIGxvYWQsIG9wdGlvbmFsbHkgb3BlbiB0aGUgYXV0b2NvbXBsZXRlXG4gICAgICogKHByZXNldCBwcm9tcHRzKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b2NvbXBsZXRlT25Mb2FkID0gY29uZmlnLmF1dG9jb21wbGV0ZU9uTG9hZCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHN1Ym1pdFVSTCB3aWxsIGZvcmNlIHRoZSBzZWFyY2ggcXVlcnkgc3VibWlzc2lvbiB0byBnZXRcbiAgICAgKiByZWRpcmVjdGVkIHRvIHRoZSBVUkwgcHJvdmlkZWQuXG4gICAgICogT3B0aW9uYWwsIGRlZmF1bHRzIHRvIG51bGwuXG4gICAgICpcbiAgICAgKiBJZiBubyByZWRpcmVjdFVybCBwcm92aWRlZCwgd2Uga2VlcCB0aGUgcGFnZSBhcyBhIHNpbmdsZSBwYWdlIGFwcC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVkaXJlY3RVcmwgPSBjb25maWcucmVkaXJlY3RVcmwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlcmUgaXMgYW5vdGhlciBzZWFyY2ggYmFyIHByZXNlbnQgb24gdGhlIHBhZ2UuXG4gICAgICogVHdpbnMgb25seSB1cGRhdGUgdGhlIHF1ZXJ5LCBhbmQgZG8gbm90IHNlYXJjaFxuICAgICAqL1xuICAgIHRoaXMuX2lzVHdpbiA9IGNvbmZpZy5pc1R3aW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMucXVlcnkgPSBjb25maWcucXVlcnkgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5RVUVSWSwgcSA9PiB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcTtcbiAgICAgIGlmICh0aGlzLnF1ZXJ5RWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeUVsLnZhbHVlID0gcTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVib3VuY2VkU2VhcmNoKHEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdGltZSBhbGxvd2VkIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHNlYXJjaGVzIHRvIHByZXZlbnRcbiAgICAgKiBtYW55IGR1cGxpY2F0ZSBzZWFyY2hlcyBiYWNrLXRvLWJhY2tcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoQ29vbGRvd24gPSBjb25maWcuc2VhcmNoQ29vbGRvd24gfHwgMzAwO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIGFuZCBcIm5lYXIgbWVcIiBpbnRlbnQgaXMgZXhwcmVzc2VkLCBwcm9tcHQgdGhlIHVzZXIgZm9yIHRoZWlyIGdlb2xvY2F0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcm9tcHRGb3JMb2NhdGlvbiA9IGNvbmZpZy5wcm9tcHRGb3JMb2NhdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHRydWVcbiAgICAgIDogQm9vbGVhbihjb25maWcucHJvbXB0Rm9yTG9jYXRpb24pO1xuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBzZWFyY2ggY2xlYXIgYnV0dG9uXG4gICAgICovXG4gICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdGhpcy5jbGVhckJ1dHRvbiAmJiB0aGlzLnF1ZXJ5O1xuXG4gICAgLyoqXG4gICAgICogRm9yIHZlcnRpY2FsIHNlYXJjaCBiYXJzLCB3aGV0aGVyIG9yIG5vdCB0byBhbGxvdyBlbXB0eSBzZWFyY2hlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FsbG93RW1wdHlTZWFyY2ggPSAhIWNvbmZpZy5hbGxvd0VtcHR5U2VhcmNoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNoaWxkIEF1dG9Db21wbGV0ZSBjb21wb25lbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9Db21wbGV0ZU5hbWUgPSBgJHt0aGlzLm5hbWV9LmF1dG9jb21wbGV0ZWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU2VhcmNoQmFyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnc2VhcmNoL3NlYXJjaCc7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMucXVlcnkgIT0gbnVsbCAmJiAhdGhpcy5yZWRpcmVjdFVybCkge1xuICAgICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHRoaXMucXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIHRoaXMucXVlcnlFbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyAmJiAhdGhpcy5xdWVyeSAmJiAhdGhpcy5hdXRvY29tcGxldGVPbkxvYWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzVXNpbmdZZXh0QW5pbWF0ZWRJY29uID0gIXRoaXMuX2NvbmZpZy5jdXN0b21JY29uVXJsICYmICF0aGlzLnN1Ym1pdEljb247XG4gICAgaWYgKHRoaXMuaXNVc2luZ1lleHRBbmltYXRlZEljb24pIHtcbiAgICAgIHRoaXMuaW5pdEFuaW1hdGVkSWNvbigpO1xuICAgIH1cblxuICAgIC8vIFdpcmUgdXAgb3VyIHNlYXJjaCBoYW5kbGluZyBhbmQgYXV0byBjb21wbGV0ZVxuICAgIHRoaXMuaW5pdFNlYXJjaCh0aGlzLl9mb3JtRWwpO1xuICAgIHRoaXMuaW5pdEF1dG9Db21wbGV0ZSh0aGlzLl9pbnB1dEVsKTtcblxuICAgIGlmICh0aGlzLmNsZWFyQnV0dG9uKSB7XG4gICAgICB0aGlzLmluaXRDbGVhckJ1dHRvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyAmJiAhdGhpcy5xdWVyeSAmJiB0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCkge1xuICAgICAgdGhpcy5mb2N1c0lucHV0RWxlbWVudCgpO1xuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RJY29uQW5pbWF0aW9uRnJhbWUgKGljb25TdGF0ZSkge1xuICAgIGlmICh0aGlzLmljb25TdGF0ZSA9PT0gaWNvblN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaWNvblN0YXRlID0gaWNvblN0YXRlO1xuICAgIGlmICghdGhpcy5pc1JlcXVlc3RpbmdBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy5pc1JlcXVlc3RpbmdBbmltYXRpb25GcmFtZSA9IHRydWU7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5mb3J3YXJkSWNvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLUFuaW1hdGVkSWNvbi0tcGF1c2VkJyk7XG4gICAgICAgIHRoaXMucmV2ZXJzZUljb24uY2xhc3NMaXN0LnJlbW92ZSgneXh0LVNlYXJjaEJhci1BbmltYXRlZEljb24tLXBhdXNlZCcpO1xuICAgICAgICBpZiAodGhpcy5pY29uU3RhdGUgPT09IEljb25TdGF0ZS5NQUdOSUZZSU5HX0dMQVNTKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkSWNvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLUFuaW1hdGVkSWNvbi0taW5hY3RpdmUnKTtcbiAgICAgICAgICB0aGlzLnJldmVyc2VJY29uLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItQW5pbWF0ZWRJY29uLS1pbmFjdGl2ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWNvblN0YXRlID09PSBJY29uU3RhdGUuWUVYVCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZEljb24uY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci1BbmltYXRlZEljb24tLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5yZXZlcnNlSWNvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLUFuaW1hdGVkSWNvbi0taW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVxdWVzdGluZ0FuaW1hdGlvbkZyYW1lID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhbmltYXRlSWNvblRvTWFnbmlmeWluZ0dsYXNzICgpIHtcbiAgICBpZiAodGhpcy5pY29uSXNGcm96ZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0SWNvbkFuaW1hdGlvbkZyYW1lKEljb25TdGF0ZS5NQUdOSUZZSU5HX0dMQVNTKTtcbiAgfVxuXG4gIGFuaW1hdGVJY29uVG9ZZXh0IChlKSB7XG4gICAgbGV0IGZvY3VzU3RpbGxJblNlYXJjaGJhciA9IGZhbHNlO1xuICAgIGlmIChlICYmIGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgZm9jdXNTdGlsbEluU2VhcmNoYmFyID0gdGhpcy5fY29udGFpbmVyLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25Jc0Zyb3plbiB8fCBmb2N1c1N0aWxsSW5TZWFyY2hiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0SWNvbkFuaW1hdGlvbkZyYW1lKEljb25TdGF0ZS5ZRVhUKTtcbiAgfVxuXG4gIGluaXRBbmltYXRlZEljb24gKCkge1xuICAgIHRoaXMuaWNvblN0YXRlID0gKHRoaXMuYXV0b0ZvY3VzICYmICF0aGlzLnF1ZXJ5KSA/IEljb25TdGF0ZS5NQUdOSUZZSU5HX0dMQVNTIDogSWNvblN0YXRlLllFWFQ7XG4gICAgdGhpcy5mb3J3YXJkSWNvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LUFuaW1hdGVkRm9yd2FyZCcpO1xuICAgIHRoaXMucmV2ZXJzZUljb24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1BbmltYXRlZFJldmVyc2UnKTtcbiAgICBjb25zdCBjbGlja2FibGVFbGVtZW50U2VsZWN0b3JzID0gWycuanMteWV4dC1zdWJtaXQnLCAnLmpzLXl4dC1TZWFyY2hCYXItY2xlYXInXTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIGNsaWNrYWJsZUVsZW1lbnRTZWxlY3RvcnMpIHtcbiAgICAgIGNvbnN0IGNsaWNrYWJsZUVsID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgc2VsZWN0b3IpO1xuICAgICAgaWYgKGNsaWNrYWJsZUVsKSB7XG4gICAgICAgIERPTS5vbihjbGlja2FibGVFbCwgJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmljb25Jc0Zyb3plbiA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBET00ub24oY2xpY2thYmxlRWwsICdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaWNvbklzRnJvemVuID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBET00ub24odGhpcy5xdWVyeUVsLCAnZm9jdXMnLCAoKSA9PiB7XG4gICAgICB0aGlzLmFuaW1hdGVJY29uVG9NYWduaWZ5aW5nR2xhc3MoKTtcbiAgICB9KTtcbiAgICBET00ub24odGhpcy5fY29udGFpbmVyLCAnZm9jdXNvdXQnLCBlID0+IHtcbiAgICAgIHRoaXMuYW5pbWF0ZUljb25Ub1lleHQoZSk7XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIGluaXRDbGVhckJ1dHRvbiAoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtU2VhcmNoQmFyLWNsZWFyJyk7XG4gICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdGhpcy5fc2hvd0NsZWFyQnV0dG9uIHx8IHRoaXMucXVlcnk7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicsICF0aGlzLl9zaG93Q2xlYXJCdXR0b24pO1xuXG4gICAgRE9NLm9uKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gZmFsc2U7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci0taGlkZGVuJyk7XG4gICAgICB0aGlzLnF1ZXJ5RWwudmFsdWUgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCB0aGlzLnF1ZXJ5KTtcbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuc2V0UXVlcnkodGhpcy5xdWVyeSk7XG5cbiAgICAgIC8vIEZvY3VzIHRoZSBpbnB1dCBlbGVtZW50IGFmdGVyIGNsZWFyaW5nIHRoZSBxdWVyeSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyXG4gICAgICAvLyBvciBub3QgdGhlIGF1dG9Gb2N1cyBvcHRpb24gaXMgZW5hYmxlZC5cbiAgICAgIC8vIE5PVEUoYW11bGxpbmdzKTogVGhpcyBkZXBlbmRzIGhlYXZpbHkgb24gdGhlIGZhY3QgdGhhdCB0aGUgcmUtcmVuZGVyc1xuICAgICAgLy8gdHJpZ2dlcmVkIGJ5IHNldFN0YXRlIGFuZCBjb3JlLnNldFF1ZXJ5IGhhcHBlbiBzeW5jaHJvbm91c2x5OyBpZiB0aGlzXG4gICAgICAvLyBzdG9wcyBiZWluZyB0aGUgY2FzZSBhdCBzb21lIHBvaW50LCB3ZSdsbCBuZWVkIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uXG4gICAgICB0aGlzLmZvY3VzSW5wdXRFbGVtZW50KCk7XG4gICAgfSk7XG5cbiAgICBET00ub24odGhpcy5xdWVyeUVsLCAnaW5wdXQnLCBlID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICB0aGlzLnF1ZXJ5ID0gaW5wdXQ7XG4gICAgICBpZiAoIXRoaXMuX3Nob3dDbGVhckJ1dHRvbiAmJiBpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3Nob3dDbGVhckJ1dHRvbiA9IHRydWU7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hvd0NsZWFyQnV0dG9uICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB1c2UgZm9yIHdpcmluZyB1cCBzZWFyY2hpbmcgb24gZm9ybSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtU2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIHN1Ym1pdCBoYW5kbGluZyB0b1xuICAgKi9cbiAgaW5pdFNlYXJjaCAoZm9ybVNlbGVjdG9yKSB7XG4gICAgdGhpcy5fZm9ybUVsID0gZm9ybVNlbGVjdG9yO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItd3JhcHBlcicpO1xuXG4gICAgbGV0IGZvcm0gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBmb3JtU2VsZWN0b3IpO1xuICAgIGlmICghZm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBTZWFyY2hCYXI7IENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9mb3JtRWwsICdgLicpO1xuICAgIH1cblxuICAgIERPTS5vbihmb3JtLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gVE9ETyhvc2hpKSB3ZSBzaG91bGQgbm90IHVzZSB0aGUgc2FtZSBjc3Mgc2VsZWN0b3IgKHRoaXMuX2lucHV0RWwpXG4gICAgICAvLyBGb3IgYm90aCB0aGUgYXV0b2NvbXBsZXRlIEFORCB0aGUgc2VhcmNoIGJhciBpbnB1dFxuICAgICAgLy8gVGhpcyBpcyBpbmNyZWRpYmx5IGNvbmZ1c2luZywgYW5kIGFsc28gbWFrZXMgdGhlIGZpcnN0IERPTS5xdWVyeVxuICAgICAgLy8gUmVseSBvbiB0aGUgb3JkZXIgb2YgdGhlIGlucHV0IGVsIGFuZCBhdXRvY29tcGxldGUgaW4gdGhlIHRlbXBsYXRlXG4gICAgICBjb25zdCBpbnB1dEVsID0gZm9ybS5xdWVyeVNlbGVjdG9yKHRoaXMuX2lucHV0RWwpO1xuICAgICAgY29uc3QgcXVlcnkgPSBpbnB1dEVsLnZhbHVlO1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlZGlyZWN0VXJsLCB3ZSB3YW50IHRoZSBmb3JtIHRvIGJlXG4gICAgICAvLyBzZXJpYWxpemVkIGFuZCBzdWJtaXR0ZWQuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucmVkaXJlY3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5yZWRpcmVjdFVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlucHV0RWwuYmx1cigpO1xuICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15ZXh0LXN1Ym1pdCcpLmJsdXIoKTtcbiAgICAgIC8vIFRPRE86IG1vdmUgdGhpcyBpbnRvIGluaXRDbGVhckJ1dHRvblxuICAgICAgaWYgKHRoaXMuY2xlYXJCdXR0b24pIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtU2VhcmNoQmFyLWNsZWFyJyk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgneXh0LVNlYXJjaEJhci0taGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gZmFsc2U7XG4gICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1VzaW5nWWV4dEFuaW1hdGVkSWNvbikge1xuICAgICAgICB0aGlzLmFuaW1hdGVJY29uVG9ZZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUlksIHF1ZXJ5KTtcbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuc2V0UXVlcnkocXVlcnkpO1xuICAgICAgdGhpcy5kZWJvdW5jZWRTZWFyY2gocXVlcnkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB3aXJlIHVwIG91ciBhdXRvIGNvbXBsZXRlIG9uIGFuIGlucHV0IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFNlbGVjdG9yIENTUyBzZWxlY3RvciB0byBiaW5kIG91ciBhdXRvIGNvbXBsZXRlIGNvbXBvbmVudCB0b1xuICAgKi9cbiAgaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIHRoaXMuX2lucHV0RWwgPSBpbnB1dFNlbGVjdG9yO1xuXG4gICAgaWYgKHRoaXMuX2F1dG9jb21wbGV0ZSkge1xuICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dG9jb21wbGV0ZSA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoJ0F1dG9Db21wbGV0ZScsIHtcbiAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgbmFtZTogdGhpcy5fYXV0b0NvbXBsZXRlTmFtZSxcbiAgICAgIGNvbnRhaW5lcjogJy55eHQtU2VhcmNoQmFyLWF1dG9jb21wbGV0ZScsXG4gICAgICBhdXRvRm9jdXM6IHRoaXMuYXV0b0ZvY3VzICYmICF0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCxcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5wcm9tcHRIZWFkZXIsXG4gICAgICBvcmlnaW5hbFF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgaW5wdXRFbDogaW5wdXRTZWxlY3RvcixcbiAgICAgIG9uU3VibWl0OiAoKSA9PiB7XG4gICAgICAgIERPTS50cmlnZ2VyKERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2Zvcm1FbCksICdzdWJtaXQnKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICBET00udHJpZ2dlcihET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBpbnB1dFNlbGVjdG9yKSwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBkZWJvdW5jZWQgcXVlcnkgdXNpbmcgdGhlIHByb3ZpZGVkIHN0cmluZyBpbnB1dC4gU3BlY2lmaWNhbGx5LCBhIG5ldyBzZWFyY2ggaXMgbm90XG4gICAqIHBlcmZvcm1lZCBpZiB3ZSByZWNlbnRseSBzZWFyY2hlZCwgaWYgdGhlcmUncyBubyBxdWVyeSBmb3IgdW5pdmVyc2FsIHNlYXJjaCwgb3IgaWYgdGhpc1xuICAgKiBpcyBhIHR3aW4gc2VhcmNoYmFyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHN0cmluZyB0byBxdWVyeSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBwZXJmb3JtIHRoZSBxdWVyeSBhbmQgdXBkYXRlIGdsb2JhbFN0b3JhZ2UgYWNjb3JkaW5nbHkuXG4gICAqL1xuICBkZWJvdW5jZWRTZWFyY2ggKHF1ZXJ5KSB7XG4gICAgaWYgKHRoaXMuX3Rocm90dGxlZCB8fFxuICAgICAgKCFxdWVyeSAmJiAhdGhpcy5fdmVydGljYWxLZXkpIHx8XG4gICAgICAoIXF1ZXJ5ICYmIHRoaXMuX3ZlcnRpY2FsS2V5ICYmICF0aGlzLl9hbGxvd0VtcHR5U2VhcmNoKSB8fFxuICAgICAgdGhpcy5faXNUd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdGhyb3R0bGVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fdGhyb3R0bGVkID0gZmFsc2U7IH0sIHRoaXMuX3NlYXJjaENvb2xkb3duKTtcblxuICAgIC8vIElmIF9wcm9tcHRGb3JMb2NhdGlvbiBpcyBlbmFibGVkLCB3ZSB3aWxsIGNvbXB1dGUgdGhlIHF1ZXJ5J3MgaW50ZW50IGFuZCwgZnJvbSB0aGVyZSxcbiAgICAvLyBkZXRlcm1pbmUgaWYgaXQncyBuZWNlc3NhcnkgdG8gcHJvbXB0IHRoZSB1c2VyIGZvciB0aGVpciBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gSXQgd2lsbFxuICAgIC8vIGJlIHVubmVjZXNzYXJ5IGlmIHRoZSBxdWVyeSBkb2VzIG5vdCBoYXZlIG5lYXIgbWUgaW50ZW50IG9yIHdlIGFscmVhZHkgaGF2ZSB0aGVpciBsb2NhdGlvblxuICAgIC8vIHN0b3JlZC5cbiAgICBpZiAodGhpcy5fcHJvbXB0Rm9yTG9jYXRpb24pIHtcbiAgICAgIHRoaXMuZmV0Y2hRdWVyeUludGVudHMocXVlcnkpXG4gICAgICAgIC50aGVuKHF1ZXJ5SW50ZW50cyA9PiBxdWVyeUludGVudHMuaW5jbHVkZXMoJ05FQVJfTUUnKSlcbiAgICAgICAgLnRoZW4ocXVlcnlIYXNOZWFyTWVJbnRlbnQgPT4ge1xuICAgICAgICAgIGlmIChxdWVyeUhhc05lYXJNZUludGVudCAmJiAhdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3lcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNlYXJjaChxdWVyeSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZSh0aGlzLnNlYXJjaChxdWVyeSkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHF1ZXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHF1ZXJ5IHVzaW5nIHRoZSBwcm92aWRlZCBzdHJpbmcgaW5wdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBUaGUgc3RyaW5nIHRvIHF1ZXJ5IGFnYWluc3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIHBlcmZvcm0gdGhlIHF1ZXJ5IGFuZCB1cGRhdGUgZ2xvYmFsU3RvcmFnZSBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNlYXJjaCAocXVlcnkpIHtcbiAgICBpZiAodGhpcy5fdmVydGljYWxLZXkpIHtcbiAgICAgIGNvbnN0IGFsbEZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGlucHV0OiBxdWVyeSxcbiAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICAgIG9mZnNldDogdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5PVEUoYmlsbHkpIFRlbXBvcmFyeSBoYWNrIGZvciBERU1PXG4gICAgICAvLyBSZW1vdmUgbWUgYWZ0ZXIgdGhlIGRlbW9cbiAgICAgIGxldCBuYXYgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXJcbiAgICAgICAgLmdldEFjdGl2ZUNvbXBvbmVudCgnTmF2aWdhdGlvbicpO1xuXG4gICAgICBpZiAobmF2KSB7XG4gICAgICAgIGxldCB0YWJzID0gbmF2LmdldFN0YXRlKCd0YWJzJyk7XG4gICAgICAgIGxldCB1cmxzID0ge307XG5cbiAgICAgICAgaWYgKHRhYnMgJiYgQXJyYXkuaXNBcnJheSh0YWJzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXModGFic1tpXS51cmwuc3BsaXQoJz8nKVsxXSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgICAgICAgbGV0IHVybCA9IHRhYnNbaV0uYmFzZVVybDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudG9TdHJpbmcoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHVybCArPSAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHNbdGFic1tpXS5jb25maWdJZF0gPSB1cmw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcmUuc2VhcmNoKHF1ZXJ5LCB1cmxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBjb21wdXRlcyB0aGUgaW50ZW50cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkuIElmIHRoZSBxdWVyeSB3YXMgZW50ZXJlZFxuICAgKiBtYW51YWxseSBpbnRvIHRoZSBzZWFyY2ggYmFyIG9yIHNlbGVjdGVkIHZpYSBhdXRvY29tcGxldGUsIGl0cyBpbnRlbnRzIHdpbGwgaGF2ZSBiZWVuIHN0b3JlZFxuICAgKiBhbHJlYWR5IGluIGdsb2JhbFN0b3JhZ2UuIE90aGVyd2lzZSwgYSBuZXcgQVBJIGNhbGwgd2lsbCBoYXZlIHRvIGJlIGlzc3VlZCB0byBkZXRlcm1pbmVcbiAgICogaW50ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIGludGVudCBpcyBuZWVkZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgY29udGFpbmluZyB0aGUgaW50ZW50cyBvZiB0aGUgcXVlcnkuXG4gICAqL1xuICBmZXRjaFF1ZXJ5SW50ZW50cyAocXVlcnkpIHtcbiAgICBjb25zdCBhdXRvY29tcGxldGVEYXRhID1cbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHt0aGlzLl9hdXRvQ29tcGxldGVOYW1lfWApO1xuICAgIGlmICghYXV0b2NvbXBsZXRlRGF0YSkge1xuICAgICAgY29uc3QgYXV0b2NvbXBsZXRlUmVxdWVzdCA9IHRoaXMuX3ZlcnRpY2FsS2V5XG4gICAgICAgID8gdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVZlcnRpY2FsKFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZU5hbWUsXG4gICAgICAgICAgdGhpcy5fdmVydGljYWxLZXkpXG4gICAgICAgIDogdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVVuaXZlcnNhbChxdWVyeSwgdGhpcy5fYXV0b0NvbXBsZXRlTmFtZSk7XG4gICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUmVxdWVzdC50aGVuKGRhdGEgPT4gZGF0YS5pbnB1dEludGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBhcmUgdHdvIGFsdGVybmF0aXZlcyB0byBjb25zaWRlciBoZXJlLiBUaGUgdXNlciBjb3VsZCBoYXZlIHNlbGVjdGVkIHRoZSBxdWVyeVxuICAgICAgLy8gYXMgYW4gYXV0b2NvbXBsZXRlIG9wdGlvbiBvciBtYW51YWxseSBpbnB1dCBpdCB0aGVtc2VsdmVzLiBJZiB0aGUgZm9ybWVyLCB1c2UgdGhlIGludGVudHNcbiAgICAgIC8vIG9mIHRoZSBjb3JyZXNwb25kaW5nIGF1dG9jb21wbGV0ZSBvcHRpb24uIElmIHRoZSBsYXR0ZXIsIHVzZSB0aGUgaW5wdXRJbnRlbnRzIG9mIHRoZVxuICAgICAgLy8gYXV0b2NvbXBsZXRlRGF0YS5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhdXRvY29tcGxldGVEYXRhLnNlY3Rpb25zLmZsYXRNYXAoc2VjdGlvbiA9PiBzZWN0aW9uLnJlc3VsdHMpO1xuICAgICAgY29uc3QgbWF0Y2hpbmdSZXN1bHQgPSByZXN1bHRzLmZpbmQocmVzdWx0ID0+IHJlc3VsdC52YWx1ZSA9PT0gcXVlcnkpO1xuICAgICAgY29uc3QgcXVlcnlJbnRlbnRzID0gbWF0Y2hpbmdSZXN1bHQgPyBtYXRjaGluZ1Jlc3VsdC5pbnRlbnRzIDogYXV0b2NvbXBsZXRlRGF0YS5pbnB1dEludGVudHM7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5SW50ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGNvbnN0cnVjdHMgdGhlIG1ldGEgaW5mb3JtYXRpb24gbmVlZGVkIGJ5IHRoZSBTRUFSQ0hfQ0xFQVJfQlVUVE9OXG4gICAqIGFuYWx5dGljcyBldmVudC5cbiAgICovXG4gIGV2ZW50T3B0aW9ucyAoKSB7XG4gICAgY29uc3QgcXVlcnlJZCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZX0lEKTtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgcXVlcnlJZCAmJiB7IHF1ZXJ5SWQgfSxcbiAgICAgIHRoaXMuX3ZlcnRpY2FsS2V5ICYmIHsgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5IH1cbiAgICApO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgY29uc3QgZm9yd2FyZEljb25PcHRzID0ge1xuICAgICAgaWNvbk5hbWU6ICd5ZXh0X2FuaW1hdGVkX2ZvcndhcmQnLFxuICAgICAgY2xhc3NOYW1lczogJ0ljb24tLWxnJyxcbiAgICAgIGNvbXBsZXhDb250ZW50c1BhcmFtczoge1xuICAgICAgICBpY29uUHJlZml4OiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJldmVyc2VJY29uT3B0cyA9IHtcbiAgICAgIGljb25OYW1lOiAneWV4dF9hbmltYXRlZF9yZXZlcnNlJyxcbiAgICAgIGNsYXNzTmFtZXM6ICdJY29uLS1sZycsXG4gICAgICBjb21wbGV4Q29udGVudHNQYXJhbXM6IHtcbiAgICAgICAgaWNvblByZWZpeDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7XG4gICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgIGxhYmVsVGV4dDogdGhpcy5sYWJlbFRleHQsXG4gICAgICBzdWJtaXRJY29uOiB0aGlzLnN1Ym1pdEljb24sXG4gICAgICBzdWJtaXRUZXh0OiB0aGlzLnN1Ym1pdFRleHQsXG4gICAgICBjbGVhclRleHQ6IHRoaXMuY2xlYXJUZXh0LFxuICAgICAgc2hvd0NsZWFyQnV0dG9uOiB0aGlzLl9zaG93Q2xlYXJCdXR0b24sXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSB8fCAnJyxcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5ldmVudE9wdGlvbnMoKSxcbiAgICAgIGljb25JZDogdGhpcy5uYW1lLFxuICAgICAgZm9yd2FyZEljb25PcHRzOiBmb3J3YXJkSWNvbk9wdHMsXG4gICAgICByZXZlcnNlSWNvbk9wdHM6IHJldmVyc2VJY29uT3B0cyxcbiAgICAgIGF1dG9Gb2N1czogdGhpcy5hdXRvRm9jdXMgJiYgIXRoaXMucXVlcnlcbiAgICB9LCBkYXRhKSk7XG4gIH1cblxuICBmb2N1c0lucHV0RWxlbWVudCAoKSB7XG4gICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCkuZm9jdXMoKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoUGFyYW1zUGFyc2VyICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoUGFyYW1ldGVycyAoc2VhcmNoUGFyYW1ldGVyQ29uZmlncykge1xuICBsZXQgc2VhcmNoUGFyYW1ldGVycyA9IHtcbiAgICBzZWN0aW9uZWQ6IGZhbHNlLFxuICAgIGZpZWxkczogW11cbiAgfTtcbiAgaWYgKHNlYXJjaFBhcmFtZXRlckNvbmZpZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xuICB9XG4gIGlmIChzZWFyY2hQYXJhbWV0ZXJDb25maWdzLnNlY3Rpb25lZCkge1xuICAgIHNlYXJjaFBhcmFtZXRlcnMuc2VjdGlvbmVkID0gc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5zZWN0aW9uZWQ7XG4gIH1cbiAgc2VhcmNoUGFyYW1ldGVycy5maWVsZHMgPSBidWlsZEZpZWxkcyhzZWFyY2hQYXJhbWV0ZXJDb25maWdzLmZpZWxkcyk7XG4gIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xufVxuXG5mdW5jdGlvbiBidWlsZEZpZWxkcyAoZmllbGRDb25maWdzKSB7XG4gIGlmIChmaWVsZENvbmZpZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBmaWVsZENvbmZpZ3MubWFwKGZjID0+ICh7IGZldGNoRW50aXRpZXM6IGZhbHNlLCAuLi5mYyB9KSk7XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXJTZWFyY2hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcbmltcG9ydCBidWlsZFNlYXJjaFBhcmFtZXRlcnMgZnJvbSAnLi4vLi4vdG9vbHMvc2VhcmNocGFyYW1zcGFyc2VyJztcblxuLyoqXG4gKiBGaWx0ZXJTZWFyY2hDb21wb25lbnQgaXMgdXNlZCBmb3IgYXV0b2NvbXBsZXRlIHVzaW5nIHRoZSBGaWx0ZXJTZWFyY2ggYmFja2VuZC5cbiAqIEl0J2xsIGFsbG93IHlvdSB0byBwaWNrIHByZS1zZXQgZmlsdGVycyB0aGF0IGFyZSBzZXR1cCBvbiB0aGUgYmFja2VuZCB3aXRoaW5cbiAqIGEgdmVydGljYWwgc2VhcmNoIGNvbnRleHQuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlclNlYXJjaENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlIHRoZSBmaWx0ZXIgdmFsdWUgYnV0IGRvIG5vdCBzZWFyY2ggb24gY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBzdWJtaXNzaW9uIGlzIGJhc2VkIG9uIGEgZm9ybSBhcyBjb250ZXh0LlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0cyB0byBuYXRpdmUgZm9ybSBub2RlIHdpdGhpbiBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9mb3JtRWwgPSBjb25maWcuZm9ybVNlbGVjdG9yIHx8ICdmb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgZm9yIHNlYXJjaGluZyBhbmQgd2lyZXMgdXAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9uXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9pbnB1dEVsID0gY29uZmlnLmlucHV0RWwgfHwgJy5qcy15ZXh0LXF1ZXJ5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB1c2VkLCBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUgYXMgYSBkYXRhIHBvaW50XG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VhcmNoIHRleHQgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGlucHV0IGJveCwgYWxzbyBwcm92aWRlZCB0byB0ZW1wbGF0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaFRleHQgPSBjb25maWcuc2VhcmNoVGV4dCB8fCAnV2hhdCBhcmUgeW91IGludGVyZXN0ZWQgaW4/JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSB0ZXh0IHRvIHNob3cgYXMgdGhlIGZpcnN0IGl0ZW0gZm9yIGF1dG8gY29tcGxldGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9tcHRIZWFkZXIgPSBjb25maWcucHJvbXB0SGVhZGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBdXRvIGZvY3VzZXMgdGhlIGlucHV0IGJveCBpZiBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9Gb2N1cyA9IGNvbmZpZy5hdXRvRm9jdXMgPT09IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBzdWJtaXRVUkwgd2lsbCBmb3JjZSB0aGUgc2VhcmNoIHF1ZXJ5IHN1Ym1pc3Npb24gdG8gZ2V0XG4gICAgICogcmVkaXJlY3RlZCB0byB0aGUgVVJMIHByb3ZpZGVkLlxuICAgICAqIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBudWxsLlxuICAgICAqXG4gICAgICogSWYgbm8gcmVkaXJlY3RVcmwgcHJvdmlkZWQsIHdlIGtlZXAgdGhlIHBhZ2UgYXMgYSBzaW5nbGUgcGFnZSBhcHAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZGlyZWN0VXJsID0gY29uZmlnLnJlZGlyZWN0VXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gY29uZmlnLnF1ZXJ5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNlYXJjaCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpbHRlciBzdHJpbmcgdG8gdXNlIGZvciB0aGUgcHJvdmlkZWQgcXVlcnlcbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlciA9IGNvbmZpZy5maWx0ZXIgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBKU09OLnBhcnNlKHRoaXMuZmlsdGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hQYXJhbWV0ZXJzID0gYnVpbGRTZWFyY2hQYXJhbWV0ZXJzKGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKTtcblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIGYgPT4geyB0aGlzLmZpbHRlciA9IGY7IH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlclNlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9maWx0ZXJzZWFyY2gnO1xuICB9XG5cbiAgLy8gVE9ETyhvc2hpKTogU1BSLTE5MjUgY2hlY2sgdGhhdCBpdCBpcyBzYWZlIHRvIHJlbW92ZSB0aGlzLCBpdCBydW5zIGFuIGV4dHJhIHNlYXJjaFxuICAvLyBGb3Igbm8gb2J2aW91cyByZWFzb25zXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBpZiAodGhpcy5xdWVyeSAmJiB0aGlzLmZpbHRlcikge1xuICAgICAgdGhpcy5zZWFyY2goKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBXaXJlIHVwIG91ciBzZWFyY2ggaGFuZGxpbmcgYW5kIGF1dG8gY29tcGxldGVcbiAgICB0aGlzLmluaXRBdXRvQ29tcGxldGUodGhpcy5faW5wdXRFbCk7XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMgPT09IHRydWUgJiYgdGhpcy5xdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2lucHV0RWwpLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB3aXJlIHVwIG91ciBhdXRvIGNvbXBsZXRlIG9uIGFuIGlucHV0IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFNlbGVjdG9yIENTUyBzZWxlY3RvciB0byBiaW5kIG91ciBhdXRvIGNvbXBsZXRlIGNvbXBvbmVudCB0b1xuICAgKi9cbiAgaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIHRoaXMuX2lucHV0RWwgPSBpbnB1dFNlbGVjdG9yO1xuXG4gICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZSgnQXV0b0NvbXBsZXRlJywge1xuICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICBuYW1lOiBgJHt0aGlzLm5hbWV9LmF1dG9jb21wbGV0ZWAsXG4gICAgICBpc0ZpbHRlclNlYXJjaDogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogJy55eHQtU2VhcmNoQmFyLWF1dG9jb21wbGV0ZScsXG4gICAgICBwcm9tcHRIZWFkZXI6IHRoaXMucHJvbXB0SGVhZGVyLFxuICAgICAgb3JpZ2luYWxRdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIG9yaWdpbmFsRmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgIGlucHV0RWw6IGlucHV0U2VsZWN0b3IsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBzZWFyY2hQYXJhbWV0ZXJzOiB0aGlzLnNlYXJjaFBhcmFtZXRlcnMsXG4gICAgICBvblN1Ym1pdDogKHF1ZXJ5LCBmaWx0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIHBhcmFtcy5zZXQoYCR7dGhpcy5uYW1lfS5xdWVyeWAsIHF1ZXJ5KTtcbiAgICAgICAgcGFyYW1zLnNldChgJHt0aGlzLm5hbWV9LmZpbHRlcmAsIGZpbHRlcik7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlZGlyZWN0VXJsLCB3ZSB3YW50IHRoZSBwYXJhbXMgdG8gYmVcbiAgICAgICAgLy8gc2VyaWFsaXplZCBhbmQgc3VibWl0dGVkLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVkaXJlY3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnJlZGlyZWN0VXJsICsgJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgZmlsdGVyIHRvIHN0b3JhZ2UgZm9yIHRoZSBuZXh0IHNlYXJjaFxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gRmlsdGVyLmZyb21SZXNwb25zZShmaWx0ZXIpO1xuICAgICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gLCB0aGlzLnF1ZXJ5KTtcbiAgICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5zZWFyY2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSB2ZXJ0aWNhbCBzZWFyY2ggd2l0aCBhbGwgc2F2ZWQgZmlsdGVycyBhbmQgcXVlcnksXG4gICAqIG9wdGlvbmFsbHkgcmVkaXJlY3RpbmcgYmFzZWQgb24gY29uZmlnXG4gICAqL1xuICBzZWFyY2ggKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGxldCB0b3RhbEZpbHRlciA9IGZpbHRlcnNbMF07XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgdG90YWxGaWx0ZXIgPSBGaWx0ZXIuYW5kKC4uLmZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBzZWFyY2hRdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSB8fCAnJztcbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuXG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICBpbnB1dDogc2VhcmNoUXVlcnksXG4gICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBzZWFyY2hUZXh0OiB0aGlzLnNlYXJjaFRleHQsXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICB9LCBkYXRhKSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEF1dG9Db21wbGV0ZUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmNvbnN0IEtleXMgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQ0FQRTogMjcsXG5cbiAgTEVGVDogMzcsXG4gIFJJR0hUOiAzOSxcbiAgVVA6IDM4LFxuXG4gIERFTEVURTogNDYsXG4gIERPV046IDQwLFxuICBMRUZUX09TX0tFWTogOTEsXG4gIFJJR0hUX09TX0tFWTogOTIsXG4gIFNFTEVDVF9LRVk6IDkzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXV0b2NvbXBsZXRlIGlzIHNpbXBsZSBvciBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRmlsdGVyU2VhcmNoID0gb3B0cy5pc0ZpbHRlclNlYXJjaCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdmVydGljYWxLZXlgIG9mIHRoZSB2ZXJ0aWNhbCBzZWFyY2ggdG8gdXNlIGZvciBhdXRvLWNvbXBsZXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IG9wdHMudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dCBlbCBzZWxlY3RvciBmb3IgYXV0byBjb21wbGV0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5faW5wdXRFbCA9IG9wdHMuaW5wdXRFbCB8fCAnLmpzLXlleHQtcXVlcnknO1xuXG4gICAgLyoqXG4gICAgICogQSBzZWxlY3RvciBmb3IgdGhlIGF1dG9jb21wbGV0ZSBlbGVtZW50ZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9jb21wbGV0ZUVscyA9IG9wdHMuYXV0b0NvbXBsZXRlRWxzIHx8ICcuanMteWV4dC1hdXRvY29tcGxldGUtb3B0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSBmb3IgdGhlIGRhdGEtc3RvcmFnZSB0byBsaXN0ZW4gZm9yIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gYCR7U3RvcmFnZUtleXMuQVVUT0NPTVBMRVRFfS4ke3RoaXMubmFtZX1gO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHR5cGluZy5cbiAgICAgKiBXZSB1c2UgdGhpcyBmb3IgcmVzZXR0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgdmFsdWUgd2hlbiBvdGhlciBpbnRlcmFjdGlvbnMgKGUuZy4gcmVzdWx0IG5hdmlnYXRpb24pXG4gICAgICogY2hhbmdlIGJhc2VkIG9uIGludGVyYWN0aW9ucy4gRm9yIGluc3RhbmNlLCBoaXR0aW5nIGVzY2FwZSBzaG91bGQgcmVzZXQgdGhlIHZhbHVlIHRvIHRoZSBvcmlnaW5hbCB0eXBlZCBxdWVyeS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSBvcHRzLm9yaWdpbmFsUXVlcnkgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIHRocm91Z2ggcmVzdWx0cy5cbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgc2VjdGlvbiB3ZSdyZSBuYXZpZ2F0aW5nIGluLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24gdGhyb3VnaCByZXN1bHRzLlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZXN1bHQgaW5kZXggd2UncmUgbmF2aWdhdGluZyBvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgdGV4dCB0byBzaG93IGFzIHRoZSBmaXJzdCBpdGVtIGZvciBhdXRvIGNvbXBsZXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvbXB0SGVhZGVyID0gb3B0cy5wcm9tcHRIZWFkZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGF1dG9jb21hdGljYWxseSBmb2N1c2VkIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IG9wdHMuYXV0b0ZvY3VzIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSBgRW50ZXJgIGtleSBpcyBwcmVzc2VkIG9uIGF1dG8gY29tcGxldGUuXG4gICAgICovXG4gICAgdGhpcy5fb25TdWJtaXQgPSBvcHRzLm9uU3VibWl0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgYXV0byBjb21wbGV0ZS4gTm90ZSB0aGF0IHRoaXMgaXNcbiAgICAgKiBub3QgY2FsbGVkIHdoZW4gZWl0aGVyIHRoZSBgRW50ZXJgIGtleSBpcyBwcmVzc2VkIG9yIHRoZSBtb3VzZSBpcyB1c2VkIHRvIHNlbGVjdCBhblxuICAgICAqIGF1dG9jb21wbGV0ZSBvcHRpb24uXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBvcHRzLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5fc2VhcmNoUGFyYW1ldGVycyA9IG9wdHMuc2VhcmNoUGFyYW1ldGVycyB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhbGlhc2VkIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBtYW5hZ2VyIGZvciBjcmVhdGlvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdBdXRvQ29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvYXV0b2NvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZSBpcyBvdmVycmlkZGVuIHNvIHRoYXQgd2UgY2FuIHByb3ZpZGUgYWRkaXRpb25hbCBtZXRhIGRhdGFcbiAgICogdG8gdGhlIHRlbXBsYXRlIChlLmcuIHRoZSBzZWN0aW9uSW5kZXggYW5kIHJlc3VsdEluZGV4KSwgc2luY2VcbiAgICogdGhvc2UgYXJlIGNsaWVudC1pbnRlcmFjdGlvbiBzcGVjaWZpYyB2YWx1ZXMgYW5kIGFyZW4ndCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGlmICghdGhpcy5pc1F1ZXJ5SW5wdXRGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IDA7XG4gICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IC0xO1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBoYXNSZXN1bHRzOiB0aGlzLmhhc1Jlc3VsdHMoZGF0YSksXG4gICAgICBzZWN0aW9uSW5kZXg6IHRoaXMuX3NlY3Rpb25JbmRleCxcbiAgICAgIHJlc3VsdEluZGV4OiB0aGlzLl9yZXN1bHRJbmRleCxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5fb3JpZ2luYWxRdWVyeS5sZW5ndGggPT09IDAgPyB0aGlzLnByb21wdEhlYWRlciA6IG51bGxcbiAgICB9KSk7XG4gIH1cblxuICBpc1F1ZXJ5SW5wdXRGb2N1c2VkICgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc05hbWUuaW5jbHVkZXModGhpcy5faW5wdXRFbC5zdWJzdHJpbmcoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGlzIGEgaGVscGVyIHRvIGFwcGx5IHRoZSBjdXJyZW50IHN0YXRlIHdpdGggbmV3IGNsaWVudC1zdGF0ZS5cbiAgICovXG4gIHVwZGF0ZVN0YXRlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuX3N0YXRlLmdldCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbkNyZWF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIGZyYW1ld29yay5cbiAgICogT25jZSB3ZSdyZSBpbml0YWxpemVkLCB3ZSB3aXJlIHVwIGFsbCBvZiBvdXIgdXNlciBpbnRlcmFjdGlvbnNcbiAgICovXG4gIG9uQ3JlYXRlICgpIHtcbiAgICAvLyBVc2UgdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gZmluZCB0aGUgaW5wdXQgbm9kZS5cbiAgICBsZXQgcXVlcnlJbnB1dCA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIGlmICghcXVlcnlJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBBdXRvQ29tcGxldGUuIENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9pbnB1dEVsLCAnYC4nKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIHRoZSBuYXRpdmUgYXV0b2NvbXBsZXRlLCBhdXRvY29ycmVjdCAmIHNwZWxsY2hlY2tcbiAgICBET00uYXR0cmlidXRlcyhxdWVyeUlucHV0LCB7XG4gICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJ1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHVzZXIgZXhpdHMgdGhlIGlucHV0LCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzdGF0ZSBhbmQgY2xvc2VcbiAgICAvLyB0aGUgYXV0byBjb21wbGV0ZVxuICAgIC8vIFRPRE8oamRlbGVybWUpOiBDbG9zZSBsb2dpYyB0byBiZSBtb3ZlZCB0byBwYXJlbnRcbiAgICBET00ub24oZG9jdW1lbnQsICdjbGljaycsIGUgPT4ge1xuICAgICAgaWYgKERPTS5tYXRjaGVzKGUudGFyZ2V0LCAnLmpzLXl4dC1BdXRvQ29tcGxldGUtd3JhcHBlciAqJykgfHwgRE9NLm1hdGNoZXMoZS50YXJnZXQsIHRoaXMuX2lucHV0RWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gYSB1c2VyIGZvY3VzZXMgdGhlIGlucHV0LCB3ZSBzaG91bGQgcG9wdWxhdGUgdGhlIGF1dG9jb21wbGV0ZSBiYXNlZFxuICAgIC8vIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgRE9NLm9uKHF1ZXJ5SW5wdXQsICdmb2N1cycsICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuYXV0b0NvbXBsZXRlKHF1ZXJ5SW5wdXQudmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbmF2aWdhdGUgYmV0d2VlbiB0aGUgcmVzdWx0cyB1c2luZyB0aGUga2V5Ym9hcmRcbiAgICBET00ub24ocXVlcnlJbnB1dCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVOYXZpZ2F0ZVJlc3VsdHMoZS5rZXlDb2RlLCBlKTtcbiAgICAgIHRoaXMuaGFuZGxlU3VibWl0UmVzdWx0KGUua2V5Q29kZSwgcXVlcnlJbnB1dC52YWx1ZSwgZSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fYXV0b0ZvY3VzKSB7XG4gICAgICBET00ub25jZShxdWVyeUlucHV0LCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlKHF1ZXJ5SW5wdXQudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gc2VsZWN0IGEgcmVzdWx0IHdpdGggdGhlIG1vdXNlXG4gICAgRE9NLmRlbGVnYXRlKHRoaXMuX2NvbnRhaW5lciwgJy5qcy15ZXh0LWF1dG9jb21wbGV0ZS1vcHRpb24nLCAnY2xpY2snLCAoZXZ0LCB0YXJnZXQpID0+IHtcbiAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmRhdGFzZXQ7XG4gICAgICBsZXQgdmFsID0gZGF0YS5zaG9ydDtcblxuICAgICAgdGhpcy51cGRhdGVRdWVyeSh2YWwpO1xuICAgICAgdGhpcy5fb25TdWJtaXQodmFsLCBkYXRhLmZpbHRlcik7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHRoZSB1c2VyIGlzIHR5cGluZyBpbiB0aGUgaW5wdXQsIHByb2Nlc3MgdGhlIGF1dG8gY29tcGxldGUuXG4gICAgRE9NLm9uKHF1ZXJ5SW5wdXQsICdrZXl1cCcsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVR5cGluZyhlLmtleUNvZGUsIHF1ZXJ5SW5wdXQudmFsdWUsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGNsb3NlIHdpbGwgaGlkZSB0aGUgYXV0byBjb21wbGV0ZSByZXN1bHRzIGFuZCByZXNldCB0aGUgc3RhdGUuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc2V0cyB0aGUgY2xpZW50IHN0YXRlIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlcyBhbmQgdHJpZ2dlcnNcbiAgICogYSB0ZW1wbGF0ZS1yZXJlbmRlciB2aWEgdXBkYXRlU3RhdGVcbiAgICovXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLl9zZWN0aW9uSW5kZXggPSAwO1xuICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gLTE7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB0ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRWYWx1ZSBPcHRpb24gdmFsdWUgcHJvdmlkZWQuXG4gICAqIElmIG5vIHZhbHVlIHByb3ZpZGVkLCB3ZSdsbCB0cnkgdG8gZmluZCBpdCBiYXNlZCBvbiB0aGUgc2VsZWN0aW9uIGluZGV4ZXMuXG4gICAqL1xuICB1cGRhdGVRdWVyeSAob3B0VmFsdWUpIHtcbiAgICAvLyBPbmx5IHdhbnQgdG8gdXBkYXRlIHRoZSBxdWVyeSBzdHJpbmcgaWYgdGhlcmVzIGEgdmFsdWUuXG4gICAgLy8gSWYgb25lIGlzIHByb3ZpZGVkLCBncmVhdC5cbiAgICAvLyBPdGhlcndpc2UsIGxldHMgdHJ5IHRvIGZpbmQgaXQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIHJlc3VsdHMuXG4gICAgaWYgKG9wdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuX3N0YXRlLmdldCgnc2VjdGlvbnMnKTtcblxuICAgICAgbGV0IHJlc3VsdHMgPSBzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHM7XG4gICAgICBvcHRWYWx1ZSA9IHJlc3VsdHNbdGhpcy5fcmVzdWx0SW5kZXhdLnNob3J0VmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5RWwgPSBET00ucXVlcnkodGhpcy5fcGFyZW50Q29udGFpbmVyLCB0aGlzLl9pbnB1dEVsKTtcbiAgICBxdWVyeUVsLnZhbHVlID0gb3B0VmFsdWU7XG4gIH1cblxuICBoYW5kbGVUeXBpbmcgKGtleSwgdmFsdWUsIGUpIHtcbiAgICBsZXQgaWdub3JlZEtleXMgPSBbXG4gICAgICBLZXlzLkRPV04sXG4gICAgICBLZXlzLlVQLFxuICAgICAgS2V5cy5DVFJMLFxuICAgICAgS2V5cy5BTFQsXG4gICAgICBLZXlzLlNISUZULFxuICAgICAgS2V5cy5MRUZULFxuICAgICAgS2V5cy5SSUdIVCxcbiAgICAgIEtleXMuTEVGVF9PU19LRVksXG4gICAgICBLZXlzLlJJR0hUX09TX0tFWSxcbiAgICAgIEtleXMuRU5URVIsXG4gICAgICBLZXlzLlRBQixcbiAgICAgIEtleXMuU0VMRUNUX0tFWVxuICAgIF07XG5cbiAgICBpZiAoaWdub3JlZEtleXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVc2VyIGVzY2FwZXMgb3V0IG9mIGF1dG8gY29tcGxldGUsIHNvIHdlIHJlc2V0IGl0IHRvIHRoZSBvcmlnaW5hbCBpbnB1dFxuICAgIGlmIChrZXkgPT09IEtleXMuRVNDQVBFKSB7XG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHRoaXMuX29yaWdpbmFsUXVlcnkpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgb3JpZ2luYWwgdmFsdWUgYmFzZWQgb24gdGhlIHVzZXIgaW5wdXRcbiAgICB0aGlzLl9vcmlnaW5hbFF1ZXJ5ID0gdmFsdWU7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5hdXRvQ29tcGxldGUodmFsdWUpO1xuICB9XG5cbiAgYXV0b0NvbXBsZXRlIChpbnB1dCkge1xuICAgIGlmICh0aGlzLmlzRmlsdGVyU2VhcmNoKSB7XG4gICAgICB0aGlzLmNvcmUuYXV0b0NvbXBsZXRlRmlsdGVyKGlucHV0LCB7XG4gICAgICAgIG5hbWVzcGFjZTogdGhpcy5uYW1lLFxuICAgICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IHRoaXMuX3NlYXJjaFBhcmFtZXRlcnNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdmVydGljYWxLZXkpIHtcbiAgICAgIHRoaXMuY29yZS5hdXRvQ29tcGxldGVWZXJ0aWNhbChpbnB1dCwgdGhpcy5uYW1lLCB0aGlzLl92ZXJ0aWNhbEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29yZS5hdXRvQ29tcGxldGVVbml2ZXJzYWwoaW5wdXQsIHRoaXMubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSBpZiB3ZSBoYXZlIHJlc3VsdHMgaW4gYW55IHNlY3Rpb25cbiAgICogQHJldHVybnMgYm9vbGVhblxuICAgKi9cbiAgaGFzUmVzdWx0cyAoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc2VjdGlvbnMgPSBkYXRhWydzZWN0aW9ucyddO1xuICAgIGlmICghc2VjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gc2VjdGlvbnNbaV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHRzID0gZGF0YS5yZXN1bHRzO1xuICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZU5hdmlnYXRlUmVzdWx0cyAoa2V5LCBlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gdGhpcy5fc3RhdGUuZ2V0KCdzZWN0aW9ucycpO1xuICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHNlY3Rpb25zLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGFiYmluZyBvdXQgb3IgZW50ZXIgc2hvdWxkIGNsb3NlIHRoZSBhdXRvIGNvbXBsZXRlLlxuICAgIGlmIChrZXkgPT09IEtleXMuVEFCKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdHMgPSBzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHM7XG4gICAgaWYgKGtleSA9PT0gS2V5cy5VUCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuX3Jlc3VsdEluZGV4IDw9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25JbmRleCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9zZWN0aW9uSW5kZXgtLTtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0cy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBkYXRlUXVlcnkodGhpcy5fb3JpZ2luYWxRdWVyeSk7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXN1bHRJbmRleC0tO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IEtleXMuRE9XTikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuX3Jlc3VsdEluZGV4ID49IHJlc3VsdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbkluZGV4IDwgc2VjdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCsrO1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXN1bHRJbmRleCsrO1xuICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN1Ym1pdFJlc3VsdCAoa2V5LCB2YWx1ZSwgZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuX3N0YXRlLmdldCgnc2VjdGlvbnMnKTtcbiAgICBpZiAoc2VjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWN0aW9ucy5sZW5ndGggPD0gMCkge1xuICAgICAgaWYgKHRoaXMuaXNGaWx0ZXJTZWFyY2gpIHtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN1Ym1pdCB0aGUgc2VhcmNoIG9uIGVudGVyXG4gICAgaWYgKGtleSA9PT0gS2V5cy5FTlRFUikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlclNlYXJjaCAmJiB0aGlzLl9yZXN1bHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZmlsdGVyID0gJyc7XG4gICAgICBpZiAodGhpcy5fc2VjdGlvbkluZGV4ID49IDAgJiYgdGhpcy5fcmVzdWx0SW5kZXggPj0gMCkge1xuICAgICAgICBmaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHNbdGhpcy5fcmVzdWx0SW5kZXhdLmZpbHRlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUXVlcnkodmFsdWUpO1xuICAgICAgdGhpcy5fb3JpZ2luYWxRdWVyeSA9IHZhbHVlO1xuICAgICAgdGhpcy5fb25TdWJtaXQodmFsdWUsIGZpbHRlcik7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTcGVsbENoZWNrQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIHN1Z2dlc3Rpb25IZWxwVGV4dDogJ0RpZCB5b3UgbWVhbjonXG59O1xuXG4vKipcbiAqIFNwZWxsQ2hlY2tDb21wb25lbnQgd2lsbCBzdXBwb3J0IGRpc3BsYXlpbmcgc3VnZ2VzdGlvbiwgYXV0b2NvcnJlY3QgYW5kIGNvbWJpbmVkKG1heWJlIGluIHRoZSBmdXR1cmUpXG4gKiBwcm92aWRlZCBmcm9tIHNwZWxsaW5nIGNvcnJlY3Rpb24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWxsQ2hlY2tDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoeyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0sIHN5c3RlbUNvbmZpZyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0s7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU3BlbGxDaGVjayc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvc3BlbGxjaGVjayc7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZSgnc2tpcFNwZWxsQ2hlY2snLCB0cnVlKTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKCdxdWVyeVRyaWdnZXInLCB0cnVlKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgc2hvdWxkU2hvdzogZGF0YS5jb3JyZWN0ZWRRdWVyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgY29ycmVjdGVkUXVlcnlVcmw6IHRoaXMuX2J1aWxkUmVkaXJlY3RRdWVyeVVybChkYXRhLmNvcnJlY3RlZFF1ZXJ5LCBkYXRhLnR5cGUpLFxuICAgICAgaGVscFRleHQ6IHRoaXMuX2dldEhlbHBUZXh0KGRhdGEudHlwZSlcbiAgICB9LCB2YWwpKTtcbiAgfVxuXG4gIF9idWlsZFJlZGlyZWN0UXVlcnlVcmwgKHF1ZXJ5LCB0eXBlKSB7XG4gICAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgIHBhcmFtcy5zZXQoJ3F1ZXJ5JywgcXVlcnkudmFsdWUpO1xuICAgIHBhcmFtcy5zZXQoJ3NraXBTcGVsbENoZWNrJywgdHJ1ZSk7XG4gICAgcGFyYW1zLnNldCgncXVlcnlUcmlnZ2VyJywgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH1cblxuICBfZ2V0SGVscFRleHQgKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1NVR0dFU1QnOlxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnN1Z2dlc3Rpb25IZWxwVGV4dDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIGlwQWNjdXJhY3lIZWxwVGV4dDogJ2Jhc2VkIG9uIHlvdXIgaW50ZXJuZXQgYWRkcmVzcycsXG4gIGRldmljZUFjY3VyYWN5SGVscFRleHQ6ICdiYXNlZCBvbiB5b3VyIGRldmljZScsXG4gIHVwZGF0ZUxvY2F0aW9uQnV0dG9uVGV4dDogJ1VwZGF0ZSB5b3VyIGxvY2F0aW9uJ1xufTtcblxuLyoqXG4gKiBMb2NhdGlvbkJpYXNDb21wb25lbnQgd2lsbCBzaG93IHRoZSB1c2VyIHdoZXJlIGlzIHVzZWQgZm9yIGxvY2F0aW9uIGJpYXMgYW5kIGFsbG93IHVzZXIgdG9cbiAqIGltcHJvdmUgYWNjdXJhY3kgd2l0aCBIVE1MNSBnZW9sb2NhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25CaWFzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9LCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjaWV2ZSB1cGRhdGVzIGZyb20gc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGluZGV4XG4gICAgICogQHR5cGUge1N0b3JhZ2VLZXl9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgd2hlbiBsb2NhdGlvbiB1cGRhdGVkLFxuICAgICAqIGEgdW5pdmVyc2FsIHNlYXJjaCB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIC8vIFRPRE86IFJlbW92ZSBjb25maWcudmVydGljYWxLZXlcbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHKS52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdXNlZCBmb3IgdXBkYXRpbmcgbG9jYXRpb25cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgICAqL1xuICAgIHRoaXMuX3VwZGF0ZUxvY2F0aW9uRWwgPSBjb25maWcudXBkYXRlTG9jYXRpb25FbCB8fCAnLmpzLWxvY2F0aW9uQmlhcy11cGRhdGUtbG9jYXRpb24nO1xuXG4gICAgdGhpcy5fbG9jYXRpb25EaXNwbGF5TmFtZSA9ICcnO1xuXG4gICAgdGhpcy5fYWNjdXJhY3kgPSAnJztcblxuICAgIHRoaXMuX2FsbG93VXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdMb2NhdGlvbkJpYXMnO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnc2VhcmNoL2xvY2F0aW9uYmlhcyc7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAoIXRoaXMuX2FsbG93VXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQoKTtcbiAgICBET00ub24odGhpcy5fdXBkYXRlTG9jYXRpb25FbCwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmICgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikge1xuICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiwge1xuICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgICAgICByYWRpdXM6IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2RvU2VhcmNoKCk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdGhyb3cgZXJyb3Igb3Igd2FybmluZyBoZXJlIGlmIG5vIGdlb2xvY2F0aW9uP1xuICAgIH0pO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIHRoaXMuX2xvY2F0aW9uRGlzcGxheU5hbWUgPSBkYXRhLmxvY2F0aW9uRGlzcGxheU5hbWU7XG4gICAgdGhpcy5fYWNjdXJhY3kgPSBkYXRhLmFjY3VyYWN5O1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBsb2NhdGlvbkRpc3BsYXlOYW1lOiB0aGlzLl9nZXRMb2NhdGlvbkRpc3BsYXlOYW1lKGRhdGEpLFxuICAgICAgYWNjdXJhY3lUZXh0OiB0aGlzLl9nZXRBY2N1cmFjeUhlbHBUZXh0KGRhdGEuYWNjdXJhY3kpLFxuICAgICAgaXNQcmVjaXNlTG9jYXRpb246IGRhdGEuYWNjdXJhY3kgPT09ICdERVZJQ0UnICYmIHRoaXMuX2FsbG93VXBkYXRlLFxuICAgICAgaXNVbmtub3duTG9jYXRpb246IGRhdGEuYWNjdXJhY3kgPT09ICdVTktOT1dOJyxcbiAgICAgIHNob3VsZFNob3c6IGRhdGEuYWNjdXJhY3kgIT09IHVuZGVmaW5lZCxcbiAgICAgIGFsbG93VXBkYXRlOiB0aGlzLl9hbGxvd1VwZGF0ZVxuICAgIH0sIHZhbCkpO1xuICB9XG5cbiAgX2dldExvY2F0aW9uRGlzcGxheU5hbWUgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5hY2N1cmFjeSA9PT0gJ1VOS05PV04nKSB7XG4gICAgICByZXR1cm4gJ1Vua25vd24gTG9jYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5sb2NhdGlvbkRpc3BsYXlOYW1lO1xuICB9XG5cbiAgX2dldEFjY3VyYWN5SGVscFRleHQgKGFjY3VyYWN5KSB7XG4gICAgYWNjdXJhY3kgPSAnREVWSUNFJztcbiAgICBzd2l0Y2ggKGFjY3VyYWN5KSB7XG4gICAgICBjYXNlICdJUCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuaXBBY2N1cmFjeUhlbHBUZXh0O1xuICAgICAgY2FzZSAnREVWSUNFJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kZXZpY2VBY2N1cmFjeUhlbHBUZXh0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIF9kb1NlYXJjaCAoKSB7XG4gICAgbGV0IHF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuICAgIGlmICh0aGlzLl92ZXJ0aWNhbEtleSkge1xuICAgICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgICAgY29uc3QgdG90YWxGaWx0ZXIgPSBhbGxGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICAgIDogYWxsRmlsdGVyc1swXTtcbiAgICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgICB0aGlzLmNvcmUudmVydGljYWxTZWFyY2godGhpcy5fdmVydGljYWxLZXksIHtcbiAgICAgICAgaW5wdXQ6IHF1ZXJ5LFxuICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwLFxuICAgICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3JlLnNlYXJjaChxdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQgKCkge1xuICAgIGlmICgncGVybWlzc2lvbnMnIGluIG5hdmlnYXRvcikge1xuICAgICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ2dlb2xvY2F0aW9uJyB9KVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSAoKSB7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OKTtcbiAgICB0aGlzLl9hbGxvd1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbG9jYXRpb25EaXNwbGF5TmFtZTogdGhpcy5fbG9jYXRpb25EaXNwbGF5TmFtZSxcbiAgICAgIGFjY3VyYWN5OiB0aGlzLl9hY2N1cmFjeVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGYWNldCAqL1xuXG4vKipcbiAqIE1vZGVsIHJlcHJlc2VudGluZyBhIGZhY2V0IGZpbHRlciB3aXRoIHRoZSBmb3JtYXQgb2ZcbiAqIHtcbiAqICAgXCJmaWVsZF9uYW1lXCI6IFsgRmlsdGVycy4uLiBdLFxuICogICAuLi5cbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBGaWx0ZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY2V0IHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGF0YSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmYWNldCBmaWx0ZXIgZnJvbSBhIGxpc3Qgb2YgRmlsdGVyc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gdXNlIGluIHRoaXMgZmFjZXRcbiAgICogQHJldHVybnMge0ZhY2V0fVxuICAgKi9cbiAgc3RhdGljIGZyb21GaWx0ZXJzIChhdmFpbGFibGVGaWVsZElkcywgLi4uZmlsdGVycykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGF2YWlsYWJsZUZpZWxkSWRzLmZvckVhY2goZmllbGRJZCA9PiB7XG4gICAgICBncm91cHNbZmllbGRJZF0gPSBbXTtcbiAgICB9KTtcbiAgICBjb25zdCBmbGF0RmlsdGVycyA9IGZpbHRlcnMuZmxhdE1hcChmID0+IGYuJG9yIHx8IGYpO1xuICAgIGZsYXRGaWx0ZXJzLmZvckVhY2goZiA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhmKVswXTtcbiAgICAgIGlmICghZ3JvdXBzW2tleV0pIHtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1trZXldLnB1c2goZik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEZhY2V0KGdyb3Vwcyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlckJveENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IEZhY2V0IGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZhY2V0JztcblxuY2xhc3MgRmlsdGVyQm94Q29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGFib3ZlIHRoZSBjb250cm9sc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IGNvbmZpZy50aXRsZSB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgcmVzdWx0cyBuZXh0IHRvIGVhY2ggZmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dDb3VudCA9IGNvbmZpZy5zaG93Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0NvdW50O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdHJpZ2dlciBhIHNlYXJjaCBvbiBlYWNoIGNoYW5nZSB0byBhIGZpbHRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoT25DaGFuZ2UgPSBjb25maWcuc2VhcmNoT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgYnV0dG9uIHRvIHJlc2V0IGZvciBlYWNoIGZhY2V0IGdyb3VwXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlciA9IGNvbmZpZy5yZXNldEZhY2V0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSByZXNldCBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXJMYWJlbCA9IGNvbmZpZy5yZXNldEZhY2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBcInJlc2V0IGFsbFwiIGJ1dHRvbiB0byByZXNldCBhbGwgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlcnMgPSBjb25maWcucmVzZXRGYWNldHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucmVzZXRGYWNldHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIFwicmVzZXQgYWxsXCIgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmlsdGVyc0xhYmVsID0gY29uZmlnLnJlc2V0RmFjZXRzTGFiZWwgfHwgJ3Jlc2V0IGFsbCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG51bWJlciBvZiBmYWNldHMgdG8gc2hvdyBiZWZvcmUgZGlzcGxheWluZyBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IGNvbmZpZy5zaG93TW9yZUxpbWl0IHx8IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ3Nob3cgbW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBsZXNzIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TGVzc0xhYmVsID0gY29uZmlnLnNob3dMZXNzTGFiZWwgfHwgJ3Nob3cgbGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBlbmFibGUgaGlkaW5nIGV4Y2VzcyBmYWNldHMgaW4gZWFjaCBncm91cCB3aXRoIGEgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmUgPSBjb25maWcuc2hvd01vcmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd01vcmU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvdyBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmcgZWFjaCBncm91cCBvZiBmYWNldHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGFuZCA9IGNvbmZpZy5leHBhbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuZXhwYW5kO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheSB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhcHBsaWVkIGZpbHRlcnMgd2hlbiBjb2xsYXBzZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dOdW1iZXJBcHBsaWVkID0gY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkO1xuXG4gICAgLyoqXG4gICAgICogVGV4dCB0byBkaXNwbGF5IG9uIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlMYWJlbCA9IGNvbmZpZy5hcHBseUxhYmVsIHx8ICdhcHBseSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3Igb2YgdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcHBseUJ1dHRvblNlbGVjdG9yID0gY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IgfHwgJy5qcy15ZXh0LWZpbHRlcmJveC1hcHBseSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBmaWx0ZXJzIHRvIGRpc3BsYXkgYW5kIGNvbnRyb2wsIGlnbm9yaW5nIGVtcHR5IHNlY3Rpb25zXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyQ29uZmlncyA9IGNvbmZpZy5maWx0ZXJzLmZpbHRlcihmID0+IGYub3B0aW9ucy5sZW5ndGggIT09IDApO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyBmaWx0ZXJib3ggY29udGFpbnMgZmFjZXRzLiBUaGlzIGFmZmVjdHMgdGhlXG4gICAgICogdGhlIHdheSB0aGUgZmlsdGVycyBhcmUgdXNlZCBpbiB0aGUgc2VhcmNoXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0R5bmFtaWMgPSBjb25maWcuaXNEeW5hbWljIHx8IGZhbHNlO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHNldCBvZiBmaWx0ZXJzLCBhbmQgc2VhcmNoZXMgd2l0aCB0aGVtIHdoZW4gYXBwbGllZC5cbiAqIE11bHRpcGxlIEZpbHRlckJveCBjb21wb25lbnRzIHdpbGwgQU5EIHRvZ2V0aGVyIGJ1dCB3aWxsIG5vdCBzaGFyZSBzdGF0ZS5cbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJCb3hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgdGhpcy5jb25maWcgPSBuZXcgRmlsdGVyQm94Q29uZmlnKGNvbmZpZyk7XG5cbiAgICBpZiAoIWNvbmZpZy5maWx0ZXJzIHx8ICEoY29uZmlnLmZpbHRlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICdGaWx0ZXJCb3ggcmVxdWlyZXMgZmlsdGVycyB0byBiZSBwcm92aWRlZCBhcyBhbiBhcnJheScsXG4gICAgICAgICdGaWx0ZXJCb3gnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB0aGUgc2VhcmNoXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50cyBjcmVhdGVkIGZvciBlYWNoIGZpbHRlciBjb25maWdcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50W119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmlsdGVyIGNvbXBvbmVudHMgaW4gdGhlIGJveFxuICAgICAqIEB0eXBlIHtGaWx0ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJzID0gW107XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLnNob3dDb3VudCkge1xuICAgICAgdGhpcy5jb25maWcuZmlsdGVyQ29uZmlncy5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgIGNvbmZpZy5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICBvcHRpb24uY291bnRMYWJlbCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlckJveCc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdmaWx0ZXJzL2ZpbHRlcmJveCc7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHRoaXMuY29uZmlnLCB7XG4gICAgICBzaG93UmVzZXQ6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVycyxcbiAgICAgIHJlc2V0TGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVyc0xhYmVsLFxuICAgICAgc2hvd0FwcGx5QnV0dG9uOiAhdGhpcy5jb25maWcuc2VhcmNoT25DaGFuZ2VcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyQ29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMuZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cyA9IFtdO1xuICAgICAgdGhpcy5fZmlsdGVycyA9IFtdO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgZmlsdGVycyBmcm9tIGNvbmZpZ3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3NbaV07XG4gICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKGNvbmZpZy50eXBlLCBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICAgICAgbmFtZTogYCR7dGhpcy5uYW1lfS5maWx0ZXIke2l9YCxcbiAgICAgICAgICBzdG9yZU9uQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICBjb250YWluZXI6IGAuanMteWV4dC1maWx0ZXJib3gtZmlsdGVyJHtpfWAsXG4gICAgICAgICAgc2hvd1Jlc2V0OiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlcixcbiAgICAgICAgICByZXNldExhYmVsOiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlckxhYmVsLFxuICAgICAgICAgIHNob3dFeHBhbmQ6IHRoaXMuY29uZmlnLmV4cGFuZCxcbiAgICAgICAgICBvbkNoYW5nZTogKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZShpLCBmaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgY29tcG9uZW50Lm1vdW50KCk7XG4gICAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2ZpbHRlcnNbaV0gPSBjb21wb25lbnQuZ2V0RmlsdGVyKCk7XG4gICAgICB0aGlzLl9zYXZlRmlsdGVyc1RvU3RvcmFnZSgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgYXBwbHkgYnV0dG9uXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5jb25maWcuYXBwbHlCdXR0b25TZWxlY3Rvcik7XG5cbiAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgRE9NLm9uKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NhdmVGaWx0ZXJzVG9TdG9yYWdlKCk7XG4gICAgICAgICAgdGhpcy5fc2VhcmNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcmVzZXQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnJlc2V0RmlsdGVycykge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1GaWx0ZXJCb3gtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5yZXNldEZpbHRlcnMuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRGaWx0ZXJzICgpIHtcbiAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLmZvckVhY2goZmlsdGVyID0+IGZpbHRlci5jbGVhck9wdGlvbnMoKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgdG8gY2hpbGQgZmlsdGVyIGNvbXBvbmVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hhbmdlZCBmaWx0ZXJcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlciBUaGUgbmV3IGZpbHRlclxuICAgKi9cbiAgb25GaWx0ZXJDaGFuZ2UgKGluZGV4LCBmaWx0ZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJzW2luZGV4XSA9IGZpbHRlcjtcbiAgICBpZiAodGhpcy5jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3NhdmVGaWx0ZXJzVG9TdG9yYWdlKCk7XG4gICAgICB0aGlzLl9zZWFyY2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmaWx0ZXIgY29tcG9uZW50cyBhbG9uZyB3aXRoIHRoaXMgY29tcG9uZW50XG4gICAqL1xuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMuZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCBmaWx0ZXJzIHRvIHN0b3JhZ2UgdG8gYmUgdXNlZCBpbiB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlRmlsdGVyc1RvU3RvcmFnZSAoKSB7XG4gICAgY29uc3QgdmFsaWRGaWx0ZXJzID0gdGhpcy5fZmlsdGVycy5maWx0ZXIoZiA9PlxuICAgICAgZiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBmICE9PSBudWxsICYmXG4gICAgICBPYmplY3Qua2V5cyhmKS5sZW5ndGggPiAwKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5pc0R5bmFtaWMpIHtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZUZpZWxkSWRzID0gdGhpcy5jb25maWcuZmlsdGVyQ29uZmlncy5tYXAoY29uZmlnID0+IGNvbmZpZy5maWVsZElkKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkRmlsdGVyID0gRmFjZXQuZnJvbUZpbHRlcnMoYXZhaWxhYmxlRmllbGRJZHMsIC4uLnZhbGlkRmlsdGVycyk7XG4gICAgICB0aGlzLmNvcmUuc2V0RmFjZXRGaWx0ZXIodGhpcy5uYW1lLCBjb21iaW5lZEZpbHRlciB8fCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkRmlsdGVyID0gdmFsaWRGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgPyBGaWx0ZXIuYW5kKC4uLnZhbGlkRmlsdGVycylcbiAgICAgICAgOiB2YWxpZEZpbHRlcnNbMF07XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgY29tYmluZWRGaWx0ZXIgfHwge30pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2VhcmNoIHdpdGggYWxsIGZpbHRlcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgX3NlYXJjaCAoKSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgIDogYWxsRmlsdGVyc1swXTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuXG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcblxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl92ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHF1ZXJ5LFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlck9wdGlvbnNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBzdXBwb3J0ZWQgY29udHJvbHNcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgU1VQUE9SVEVEX0NPTlRST0xTID0gW1xuICAnc2luZ2xlb3B0aW9uJyxcbiAgJ211bHRpb3B0aW9uJ1xuXTtcblxuY2xhc3MgRmlsdGVyT3B0aW9uc0NvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBjb250cm9sIHRvIGRpc3BsYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbCA9IGNvbmZpZy5jb250cm9sO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVyIG9wdGlvbnMgdG8gZGlzcGxheSB3aXRoIGNoZWNrZWQgc3RhdHVzXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIGJlIHVzZWQgaW4gdGhlIGxlZ2VuZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGNoYW5nZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbkNoYW5nZSA9IGNvbmZpZy5vbkNoYW5nZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlcyB0aGUgZmlsdGVyIHRvIHN0b3JhZ2Ugb24gZWFjaCBjaGFuZ2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnN0b3JlT25DaGFuZ2UgPSBjb25maWcuc3RvcmVPbkNoYW5nZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zdG9yZU9uQ2hhbmdlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIGJ1dHRvbiB0byByZXNldCB0aGUgY3VycmVudCBmaWx0ZXIgc2VsZWN0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93UmVzZXQgPSBjb25maWcuc2hvd1Jlc2V0ICYmIHRoaXMub3B0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSByZXNldCBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRMYWJlbCA9IGNvbmZpZy5yZXNldExhYmVsIHx8ICdyZXNldCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG51bWJlciBvZiBmYWNldHMgdG8gc2hvdyBiZWZvcmUgZGlzcGxheWluZyBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IGNvbmZpZy5zaG93TW9yZUxpbWl0IHx8IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ3Nob3cgbW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBsZXNzIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TGVzc0xhYmVsID0gY29uZmlnLnNob3dMZXNzTGFiZWwgfHwgJ3Nob3cgbGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBlbmFibGUgaGlkaW5nIGV4Y2VzcyBmYWNldHMgd2l0aCBhIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlID0gY29uZmlnLnNob3dNb3JlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dNb3JlO1xuICAgIHRoaXMuc2hvd01vcmUgPSB0aGlzLnNob3dNb3JlICYmIHRoaXMub3B0aW9ucy5sZW5ndGggPiB0aGlzLnNob3dNb3JlTGltaXQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvdyBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmcgdGhlIGdyb3VwIG9mIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0V4cGFuZCA9IGNvbmZpZy5zaG93RXhwYW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dFeHBhbmQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFwcGxpZWQgZmlsdGVycyB3aGVuIGNvbGxhcHNlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd051bWJlckFwcGxpZWQgPSBjb25maWcuc2hvd051bWJlckFwcGxpZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd051bWJlckFwcGxpZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3IgdXNlZCBmb3Igb3B0aW9ucyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uU2VsZWN0b3IgPSBjb25maWcub3B0aW9uU2VsZWN0b3IgfHwgJy5qcy15ZXh0LWZpbHRlci1vcHRpb24nO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBjb25maWcucHJldmlvdXNPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnLnByZXZpb3VzT3B0aW9ucyA9IEpTT04ucGFyc2UoY29uZmlnLnByZXZpb3VzT3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbmZpZy5wcmV2aW91c09wdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbGVjdGVkT3B0aW9ucyA9IGNvbmZpZy5wcmV2aW91c09wdGlvbnMgfHwgW107XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5zZXREZWZhdWx0U2VsZWN0ZWRWYWx1ZXModGhpcy5vcHRpb25zLCBzZWxlY3RlZE9wdGlvbnMpO1xuICB9XG5cbiAgc2V0RGVmYXVsdFNlbGVjdGVkVmFsdWVzIChvcHRpb25zLCBzZWxlY3RlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5tYXAobyA9PiAoe1xuICAgICAgLi4ubyxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoXG4gICAgICAgID8gc2VsZWN0ZWRPcHRpb25zLmluY2x1ZGVzKG8ubGFiZWwpXG4gICAgICAgIDogby5zZWxlY3RlZFxuICAgIH0pKTtcbiAgfVxuXG4gIGdldFNlbGVjdGVkQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVkdWNlKFxuICAgICAgKG51bVNlbGVjdGVkLCBvcHRpb24pID0+IG9wdGlvbi5zZWxlY3RlZCA/IG51bVNlbGVjdGVkICsgMSA6IG51bVNlbGVjdGVkLFxuICAgICAgMCk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wgfHwgIVNVUFBPUlRFRF9DT05UUk9MUy5pbmNsdWRlcyh0aGlzLmNvbnRyb2wpKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRmlsdGVyT3B0aW9ucyByZXF1aXJlcyBhIHZhbGlkIFwiY29udHJvbFwiIHRvIGJlIHByb3ZpZGVkJyxcbiAgICAgICAgJ0ZpbHRlck9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ0ZpbHRlck9wdGlvbnMgY29tcG9uZW50IHJlcXVpcmVzIG9wdGlvbnMgdG8gYmUgcHJvdmlkZWQnLFxuICAgICAgICAnRmlsdGVyT3B0aW9ucycpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBzZXQgb2Ygb3B0aW9ucywgZWFjaCBvbmUgcmVwcmVzZW50aW5nIGEgZmlsdGVyIGluIGEgc2VhcmNoLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJPcHRpb25zQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIGxldCBwcmV2aW91c09wdGlvbnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSh0aGlzLm5hbWUpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZSh0aGlzLm5hbWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBjb25maWdcbiAgICAgKiBAdHlwZSB7RmlsdGVyT3B0aW9uc0NvbmZpZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBGaWx0ZXJPcHRpb25zQ29uZmlnKHtcbiAgICAgIHByZXZpb3VzT3B0aW9ucyxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IHRoaXMuY29uZmlnLmdldFNlbGVjdGVkQ291bnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIG9wdGlvbiBsaXN0IGlzIGV4cGFuZGVkIGFuZCB2aXNpYmxlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHBhbmRlZCA9IHRoaXMuY29uZmlnLnNob3dFeHBhbmQgPyBzZWxlY3RlZENvdW50ID4gMCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGFsbCBvcHRpb25zIGFyZSBzaG93biwgZmFsc2UgaWYgc29tZSBhcmUgaGlkZGVuIGJhc2VkIG9uIGNvbmZpZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWxsU2hvd24gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdGaWx0ZXJPcHRpb25zJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyLCBiYXNlZCBvbiB0aGUgY29udHJvbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gYGNvbnRyb2xzL2ZpbHRlcm9wdGlvbnNgO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dNb3JlICYmICF0aGlzLmFsbFNob3duKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucy5zbGljZSgwLCB0aGlzLmNvbmZpZy5zaG93TW9yZUxpbWl0KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IHRoaXMuY29uZmlnLmdldFNlbGVjdGVkQ291bnQoKTtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgc2hvd1Jlc2V0OiB0aGlzLmNvbmZpZy5zaG93UmVzZXQgJiYgc2VsZWN0ZWRDb3VudCA+IDAsXG4gICAgICBleHBhbmRlZDogdGhpcy5leHBhbmRlZCxcbiAgICAgIGFsbFNob3duOiB0aGlzLmFsbFNob3duLFxuICAgICAgc2VsZWN0ZWRDb3VudCxcbiAgICAgIGlzU2luZ2xlT3B0aW9uOiB0aGlzLmNvbmZpZy5jb250cm9sID09PSAnc2luZ2xlb3B0aW9uJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBET00uZGVsZWdhdGUoXG4gICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBgLnl4dC1GaWx0ZXJPcHRpb25zLW9wdGlvbnNgKSxcbiAgICAgIHRoaXMuY29uZmlnLm9wdGlvblNlbGVjdG9yLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3B0aW9uKHBhcnNlSW50KGV2ZW50LnRhcmdldC5kYXRhc2V0LmluZGV4KSwgZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuXG4gICAgLy8gcmVzZXQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dSZXNldCAmJiBzZWxlY3RlZENvdW50ID4gMCkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLXJlc2V0JyksXG4gICAgICAgICdjbGljaycsXG4gICAgICAgIHRoaXMuY2xlYXJPcHRpb25zLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIHNob3cgbW9yZS9sZXNzIGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zaG93TW9yZSkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLXNob3dUb2dnbGUnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWxsU2hvd24gPSAhdGhpcy5hbGxTaG93bjtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBidXR0b25cbiAgICBpZiAodGhpcy5jb25maWcuc2hvd0V4cGFuZCkge1xuICAgICAgY29uc3QgbGVnZW5kID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtRmlsdGVyT3B0aW9ucy1jbGlja2FibGVMZWdlbmQnKTtcbiAgICAgIERPTS5vbihcbiAgICAgICAgbGVnZW5kLFxuICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgY2xpY2sgPT4ge1xuICAgICAgICAgIGlmIChjbGljay5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICBET00ub24oXG4gICAgICAgIGxlZ2VuZCxcbiAgICAgICAgJ2tleWRvd24nLFxuICAgICAgICBrZXkgPT4ge1xuICAgICAgICAgIGlmIChrZXkua2V5ID09PSAnICcgfHwga2V5LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAga2V5LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjbGVhck9wdGlvbnMgKCkge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zLm1hcChvID0+IE9iamVjdC5hc3NpZ24oe30sIG8sIHsgc2VsZWN0ZWQ6IGZhbHNlIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZUxpc3RlbmVycyAoKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5fYnVpbGRGaWx0ZXIoKTtcbiAgICBpZiAodGhpcy5jb25maWcuc3RvcmVPbkNoYW5nZSkge1xuICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIGZpbHRlcik7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcub25DaGFuZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIF91cGRhdGVPcHRpb24gKGluZGV4LCBzZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5jb250cm9sID09PSAnc2luZ2xlb3B0aW9uJykge1xuICAgICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnMubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnLm9wdGlvbnNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcub3B0aW9uc1tpbmRleF0sIHsgc2VsZWN0ZWQgfSk7XG4gICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBvcHRpb25zXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBET00ucXVlcnlBbGwodGhpcy5fY29udGFpbmVyLCB0aGlzLmNvbmZpZy5vcHRpb25TZWxlY3Rvcik7XG4gICAgZWxlbWVudHMuZm9yRWFjaChlID0+IGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2ZhbHNlJykpO1xuICAgIHRoaXMuX2FwcGx5RmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW5kIHJldHVybiB0aGUgRmlsdGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyICgpIHtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5jb25maWcub3B0aW9uc1xuICAgICAgLmZpbHRlcihvID0+IG8uc2VsZWN0ZWQpXG4gICAgICAubWFwKG8gPT4gby5maWx0ZXJcbiAgICAgICAgPyBvLmZpbHRlclxuICAgICAgICA6IEZpbHRlci5lcXVhbChvLmZpZWxkLCBvLnZhbHVlKSk7XG5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KHRoaXMubmFtZSwgdGhpcy5jb25maWcub3B0aW9ucy5maWx0ZXIobyA9PiBvLnNlbGVjdGVkKS5tYXAobyA9PiBvLmxhYmVsKSk7XG4gICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMFxuICAgICAgPyBGaWx0ZXIuZ3JvdXAoLi4uZmlsdGVycylcbiAgICAgIDoge307XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJhbmdlRmlsdGVyQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICBtaW5QbGFjZWhvbGRlclRleHQ6ICdNaW4nLFxuICBtYXhQbGFjZWhvbGRlclRleHQ6ICdNYXgnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZUZpbHRlckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcih7IC4uLkRFRkFVTFRfQ09ORklHLCAuLi5jb25maWcgfSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0byBmaWx0ZXIgb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGQgPSBjb25maWcuZmllbGQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmaWx0ZXIgdmFsdWUgY2hhbmdlc1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uQ2hhbmdlID0gY29uZmlnLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc3RvcmVzIHRoZSBmaWx0ZXIgdG8gc3RvcmFnZSBvbiBlYWNoIGNoYW5nZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnN0b3JlT25DaGFuZ2U7XG5cbiAgICBsZXQgbWluVmFsID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5taW5gKTtcbiAgICBpZiAodHlwZW9mIG1pblZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pblZhbCA9IE51bWJlci5wYXJzZUludChtaW5WYWwpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgbGV0IG1heFZhbCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke3RoaXMubmFtZX0ubWF4YCk7XG4gICAgaWYgKHR5cGVvZiBtaW5WYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIucGFyc2VJbnQobWF4VmFsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmFuZ2UgcmVwcmVzZW50ZWRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmFuZ2UgPSB7XG4gICAgICBtaW46IG1pblZhbCB8fCBjb25maWcuaW5pdGlhbE1pbiB8fCAwLFxuICAgICAgbWF4OiBtYXhWYWwgfHwgY29uZmlnLmluaXRpYWxNYXggfHwgMTBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgZm9yIHRoZSByYW5nZSBjb250cm9sXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RpdGxlID0gY29uZmlnLnRpdGxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGxhYmVsIHRvIGRpc3BsYXkgZm9yIHRoZSBtaW4gaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWluTGFiZWwgPSBjb25maWcubWluTGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBsYWJlbCB0byBkaXNwbGF5IGZvciB0aGUgbWF4IGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGBjb250cm9scy9yYW5nZWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUmFuZ2VGaWx0ZXInO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB0aXRsZTogdGhpcy5fdGl0bGUsXG4gICAgICBtaW5MYWJlbDogdGhpcy5fbWluTGFiZWwsXG4gICAgICBtYXhMYWJlbDogdGhpcy5fbWF4TGFiZWwsXG4gICAgICBtaW5WYWx1ZTogdGhpcy5fcmFuZ2UubWluLFxuICAgICAgbWF4VmFsdWU6IHRoaXMuX3JhbmdlLm1heFxuICAgIH0pKTtcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtcmFuZ2UnLCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVSYW5nZShldmVudC50YXJnZXQuZGF0YXNldC5rZXksIE51bWJlci5wYXJzZUludChldmVudC50YXJnZXQudmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldE1pbiAodmFsdWUpIHtcbiAgICB0aGlzLl91cGRhdGVSYW5nZSgnbWluJywgdmFsdWUpO1xuICB9XG5cbiAgc2V0TWF4ICh2YWx1ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtYXgnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCByYW5nZSBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByYW5nZSBrZXkgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUga2V5XG4gICAqL1xuICBfdXBkYXRlUmFuZ2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9yYW5nZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JhbmdlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1pbmAsIHRoaXMuX3JhbmdlLm1pbik7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1heGAsIHRoaXMuX3JhbmdlLm1heCk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBmaWx0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIF9idWlsZEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIEZpbHRlci5pbmNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fcmFuZ2UubWluLCB0aGlzLl9yYW5nZS5tYXgpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBEYXRlRmlsdGVyQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogQSBmaWx0ZXIgZm9yIGEgcmFuZ2Ugb2YgZGF0ZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcGkgZmllbGQgdGhpcyBmaWx0ZXIgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGQgPSBjb25maWcuZmllbGQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBmb3IgdGhlIGRhdGUgcmFuZ2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1pbiBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21pbkxhYmVsID0gY29uZmlnLm1pbkxhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1heCBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgdXNlZCB3aGVuIGEgZGF0ZSBpcyBjaGFuZ2VkXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc3RvcmVPbkNoYW5nZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgZmlsdGVyIHJlcHJlc2VudHMgYW4gZXhjbHVzaXZlIHJhbmdlLCByYXRoZXIgdGhhbiBhbiBpbmNsdXNpdmUgb25lXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0V4Y2x1c2l2ZSA9IGNvbmZpZy5pc0V4Y2x1c2l2ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGBjb250cm9scy9kYXRlYDtcblxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0b2RheVN0cmluZyA9IGAke3RvZGF5LmdldEZ1bGxZZWFyKCl9LSR7YCR7dG9kYXkuZ2V0TW9udGgoKSArIDF9YC5wYWRTdGFydCgyLCAnMCcpfS0ke2Ake3RvZGF5LmdldERhdGUoKX1gLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICBjb25zdCBtaW5EYXRlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5taW5gKTtcbiAgICBjb25zdCBtYXhEYXRlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5tYXhgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGRhdGUgcmFuZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RhdGUgPSB7XG4gICAgICBtaW46IG1pbkRhdGUgfHwgY29uZmlnLmluaXRpYWxNaW4gfHwgdG9kYXlTdHJpbmcsXG4gICAgICBtYXg6IG1heERhdGUgfHwgY29uZmlnLmluaXRpYWxNYXggfHwgdG9kYXlTdHJpbmdcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0RhdGVSYW5nZUZpbHRlcic7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHRpdGxlOiB0aGlzLl90aXRsZSxcbiAgICAgIG1pbkxhYmVsOiB0aGlzLl9taW5MYWJlbCxcbiAgICAgIG1heExhYmVsOiB0aGlzLl9tYXhMYWJlbCxcbiAgICAgIGRhdGVNaW46IHRoaXMuX2RhdGUubWluLFxuICAgICAgZGF0ZU1heDogdGhpcy5fZGF0ZS5tYXhcbiAgICB9KSk7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgRE9NLmRlbGVnYXRlKHRoaXMuX2NvbnRhaW5lciwgJy5qcy15ZXh0LWRhdGUnLCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVSYW5nZShldmVudC50YXJnZXQuZGF0YXNldC5rZXksIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW4gZGF0ZSB0byB0aGUgb25lIHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIERhdGUgdG8gc2V0IGluIHl5eXktbW0tZGQgc3RyaW5nIGZvcm1hdFxuICAgKi9cbiAgc2V0TWluIChkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlUmFuZ2UoJ21pbicsIGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4IGRhdGUgdG8gdGhlIG9uZSBwcm92aWRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSBEYXRlIHRvIHNldCBpbiB5eXl5LW1tLWRkIHN0cmluZyBmb3JtYXRcbiAgICovXG4gIHNldE1heCAoZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtYXgnLCBkYXRlKTtcbiAgfVxuXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgZm9yIHRoZSBkYXRlIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3RyaW5nIGRhdGUgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVSYW5nZSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kYXRlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1pbmAsIHRoaXMuX2RhdGUubWluKTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke3RoaXMubmFtZX0ubWF4YCwgdGhpcy5fZGF0ZS5tYXgpO1xuXG4gICAgdGhpcy5fb25DaGFuZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gYXBpIGZpbHRlciB3aXRoIHRoZSBjdXJyZW50IGRhdGUgc3RhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZEZpbHRlciAoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGUubWluID09PSAnJyB8fCB0aGlzLl9kYXRlLm1heCA9PT0gJycpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzRXhjbHVzaXZlXG4gICAgICA/IEZpbHRlci5leGNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fZGF0ZS5taW4sIHRoaXMuX2RhdGUubWF4KVxuICAgICAgOiBGaWx0ZXIuaW5jbHVzaXZlUmFuZ2UodGhpcy5fZmllbGQsIHRoaXMuX2RhdGUubWluLCB0aGlzLl9kYXRlLm1heCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZhY2V0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuY2xhc3MgRmFjZXRzQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGFib3ZlIHRoZSBjb250cm9sc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IGNvbmZpZy50aXRsZSB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgcmVzdWx0cyBuZXh0IHRvIGVhY2ggZmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dDb3VudCA9IGNvbmZpZy5zaG93Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0NvdW50O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdHJpZ2dlciBhIHNlYXJjaCBvbiBlYWNoIGNoYW5nZSB0byBhIGZpbHRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoT25DaGFuZ2UgPSBjb25maWcuc2VhcmNoT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgYnV0dG9uIHRvIHJlc2V0IGZvciBlYWNoIGZhY2V0IGdyb3VwXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0ID0gY29uZmlnLnJlc2V0RmFjZXQgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0TGFiZWwgPSBjb25maWcucmVzZXRGYWNldExhYmVsIHx8ICdyZXNldCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgXCJyZXNldCBhbGxcIiBidXR0b24gdG8gcmVzZXQgYWxsIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGYWNldHMgPSBjb25maWcucmVzZXRGYWNldHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucmVzZXRGYWNldHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIFwicmVzZXQgYWxsXCIgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmFjZXRzTGFiZWwgPSBjb25maWcucmVzZXRGYWNldHNMYWJlbCB8fCAncmVzZXQgYWxsJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGZhY2V0cyB0byBzaG93IGJlZm9yZSBkaXNwbGF5aW5nIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnc2hvdyBtb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3MgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnc2hvdyBsZXNzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGVuYWJsZSBoaWRpbmcgZXhjZXNzIGZhY2V0cyBpbiBlYWNoIGdyb3VwIHdpdGggYSBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCIgYnV0dG9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZSA9IGNvbmZpZy5zaG93TW9yZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TW9yZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFsbG93IGV4cGFuZGluZyBhbmQgY29sbGFwc2luZyBlYWNoIGdyb3VwIG9mIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXhwYW5kID0gY29uZmlnLmV4cGFuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5leHBhbmQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFwcGxpZWQgZmlsdGVycyB3aGVuIGNvbGxhcHNlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd051bWJlckFwcGxpZWQgPSBjb25maWcuc2hvd051bWJlckFwcGxpZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd051bWJlckFwcGxpZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHRvIGRpc3BsYXkgb24gdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcHBseUxhYmVsID0gY29uZmlnLmFwcGx5TGFiZWwgfHwgJ2FwcGx5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9scyB0byB1c2UgZm9yIGVhY2ggZmllbGQuIEVhY2ggdHlwZSBvZiBmaWx0ZXIgaGFzIGEgZGVmYXVsdFxuICAgICAqICRlcSA6IG11bHRpb3B0aW9uIChjaGVja2JveClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRDb250cm9scyA9IGNvbmZpZy5maWVsZENvbnRyb2xzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdG9yIG9mIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hcHBseUJ1dHRvblNlbGVjdG9yID0gY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IgfHwgbnVsbDtcblxuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BsYXlzIGEgc2V0IG9mIGR5bmFtaWMgZmlsdGVycyByZXR1cm5lZCBmcm9tIHRoZSBiYWNrZW5kXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjZXRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIHRoaXMuY29uZmlnID0gbmV3IEZhY2V0c0NvbmZpZyhjb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleTtcblxuICAgIC8vIGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdG9yIG9mIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYXBwbHlCdXR0b25TZWxlY3RvciA9IGNvbmZpZy5hcHBseUJ1dHRvblNlbGVjdG9yIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgZm9yIHRoZSBkYXRhIHN0b3JhZ2UgdG8gbGlzdGVuIGZvciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkRZTkFNSUNfRklMVEVSUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWx0ZXIgYm94IHRoYXQgZGlzcGxheXMgdGhlIGR5bmFtaWMgZmlsdGVyc1xuICAgICAqIEB0eXBlIHtGaWx0ZXJCb3hDb21wb25lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJib3ggPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZhY2V0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ2ZpbHRlcnMvZmFjZXRzJztcbiAgfVxuXG4gIHJlbW92ZSAoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcmJveCkge1xuICAgICAgdGhpcy5fZmlsdGVyYm94LnJlbW92ZSgpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIHRoaXMuY29yZS5lbmFibGVEeW5hbWljRmlsdGVycygpO1xuXG4gICAgaWYgKHRoaXMuX2ZpbHRlcmJveCkge1xuICAgICAgdGhpcy5fZmlsdGVyYm94LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGxldCB7IGZpbHRlcnMgfSA9IHRoaXMuX3N0YXRlLmdldCgpO1xuXG4gICAgaWYgKCFmaWx0ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmlsdGVycyA9IGZpbHRlcnMubWFwKGYgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGYsIHtcbiAgICAgICAgdHlwZTogJ0ZpbHRlck9wdGlvbnMnLFxuICAgICAgICBjb250cm9sOiB0aGlzLmNvbmZpZy5maWVsZENvbnRyb2xzW2YuZmllbGRJZF0gfHwgJ211bHRpb3B0aW9uJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9maWx0ZXJib3ggPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKFxuICAgICAgJ0ZpbHRlckJveCcsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZywge1xuICAgICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgbmFtZTogYCR7dGhpcy5uYW1lfS5maWx0ZXJib3hgLFxuICAgICAgICBjb250YWluZXI6ICcuanMteXh0LUZhY2V0cycsXG4gICAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgICAgcmVzZXRGaWx0ZXI6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXQsXG4gICAgICAgIHJlc2V0RmlsdGVyczogdGhpcy5jb25maWcucmVzZXRGYWNldHMsXG4gICAgICAgIHJlc2V0RmlsdGVyTGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXRMYWJlbCxcbiAgICAgICAgcmVzZXRGaWx0ZXJzTGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXRzTGFiZWwsXG4gICAgICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAgICAgZmlsdGVyc1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fZmlsdGVyYm94Lm1vdW50KCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdlb0xvY2F0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBidWlsZFNlYXJjaFBhcmFtZXRlcnMgZnJvbSAnLi4vLi4vdG9vbHMvc2VhcmNocGFyYW1zcGFyc2VyJztcblxuY29uc3QgTUVURVJTX1BFUl9NSUxFID0gMTYwOS4zNDQ7XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICAvKipcbiAgICogVGhlIHJhZGl1cywgaW4gbWlsZXMsIGFyb3VuZCB0aGUgdXNlcidzIGxvY2F0aW9uIHRvIGZpbmQgcmVzdWx0cy5cbiAgICogSWYgbG9jYXRpb24gYWNjdXJhY3kgaXMgbG93LCBhIGxhcmdlciByYWRpdXMgbWF5IGJlIHVzZWQgYXV0b21hdGljYWxseVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgcmFkaXVzOiA1MCxcblxuICAvKipcbiAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHZlcnRpY2FsS2V5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBzdWJtaXRzIGEgc2VhcmNoIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzZWFyY2hPbkNoYW5nZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aXRsZTogJ0xvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGxhYmVsOiAnTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB1cmwgdG8gc2hvdyBpbiB0aGUgZ2VvIGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2VvQnV0dG9uSWNvbjogJycsXG5cbiAgLyoqXG4gICAqIFRoZSBhbHQgdGV4dCB0byBpbmNsdWRlIHdpdGggdGhlIGdlbyBidXR0b24gaWNvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2VvQnV0dG9uSWNvbkFsdFRleHQ6ICdVc2UgTXkgTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBzaG93IGluIHRoZSBnZW8gYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZW9CdXR0b25UZXh0OiAnVXNlIE15IExvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyB3aGVuIGdlb2xvY2F0aW9uIGlzIGVuYWJsZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGVuYWJsZWRUZXh0OiAnQ3VycmVudCBMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIHNob3cgd2hlbiBsb2FkaW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGxvYWRpbmdUZXh0OiAnRmluZGluZyBZb3VyIExvY2F0aW9uLi4uJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyBpZiB0aGUgdXNlcidzIGxvY2F0aW9uIGNhbm5vdCBiZSBmb3VuZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZXJyb3JUZXh0OiAnQ291bGQgTm90IEZpbmQgWW91ciBMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBDU1Mgc2VsZWN0b3Igb2YgdGhlIHRvZ2dsZSBidXR0b25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJ1dHRvblNlbGVjdG9yOiAnLmpzLXl4dC1HZW9Mb2NhdGlvbkZpbHRlci1idXR0b24nLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIHNlbGVjdG9yIG9mIHRoZSBxdWVyeSBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgaW5wdXRTZWxlY3RvcjogJy5qcy15eHQtR2VvTG9jYXRpb25GaWx0ZXItaW5wdXQnXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBidXR0b24gdGhhdCB3aGVuIGNsaWNrZWQgYWRkcyBhIHN0YXRpYyBmaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9Mb2NhdGlvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcih7IC4uLkRFRkFVTFRfQ09ORklHLCAuLi5jb25maWcgfSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgdG8gdXNlIGZvciB0aGUgaW5wdXQgYm94LCBwcm92aWRlZCB0byB0ZW1wbGF0ZSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIHRvIHVzZSBmb3IgdGhlIGN1cnJlbnQgcXVlcnlcbiAgICAgKiBAdHlwZSB7RmlsdGVyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBKU09OLnBhcnNlKHRoaXMuZmlsdGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCwgZiA9PiB7IHRoaXMuZmlsdGVyID0gZjsgfSk7XG5cbiAgICB0aGlzLnNlYXJjaFBhcmFtZXRlcnMgPSBidWlsZFNlYXJjaFBhcmFtZXRlcnMoY29uZmlnLnNlYXJjaFBhcmFtZXRlcnMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0dlb0xvY2F0aW9uRmlsdGVyJztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ2NvbnRyb2xzL2dlb2xvY2F0aW9uJztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgbGV0IHBsYWNlaG9sZGVyID0gJyc7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5fY29uZmlnLmVuYWJsZWRUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5nZW9Mb2FkaW5nKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHRoaXMuX2NvbmZpZy5sb2FkaW5nVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEuZ2VvRXJyb3IpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5fY29uZmlnLmVycm9yVGV4dDtcbiAgICB9XG4gICAgc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHRpdGxlOiB0aGlzLl9jb25maWcudGl0bGUsXG4gICAgICBnZW9FbmFibGVkOiB0aGlzLl9lbmFibGVkLFxuICAgICAgcXVlcnk6IHRoaXMucXVlcnksXG4gICAgICBsYWJlbFRleHQ6IHRoaXMuX2NvbmZpZy5sYWJlbCxcbiAgICAgIGVuYWJsZWRUZXh0OiB0aGlzLl9jb25maWcuZW5hYmxlZFRleHQsXG4gICAgICBsb2FkaW5nVGV4dDogdGhpcy5fY29uZmlnLmxvYWRpbmdUZXh0LFxuICAgICAgZXJyb3JUZXh0OiB0aGlzLl9jb25maWcuZXJyb3JUZXh0LFxuICAgICAgZ2VvQnV0dG9uSWNvbjogdGhpcy5fY29uZmlnLmdlb0J1dHRvbkljb24sXG4gICAgICBnZW9WYWx1ZTogdGhpcy5fZW5hYmxlZCB8fCBkYXRhLmdlb0xvYWRpbmcgfHwgZGF0YS5nZW9FcnJvciA/ICcnIDogdGhpcy5xdWVyeSxcbiAgICAgIGdlb1BsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgIGdlb0J1dHRvblRleHQ6IHRoaXMuX2NvbmZpZy5nZW9CdXR0b25UZXh0XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5fYXV0b2NvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9hdXRvY29tcGxldGUucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdEF1dG9Db21wbGV0ZSh0aGlzLl9jb25maWcuaW5wdXRTZWxlY3Rvcik7XG4gICAgRE9NLm9uKHRoaXMuX2NvbmZpZy5idXR0b25TZWxlY3RvciwgJ2NsaWNrJywgKCkgPT4gdGhpcy5fdG9nZ2xlR2VvRmlsdGVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB3aXJlIHVwIG91ciBhdXRvIGNvbXBsZXRlIG9uIGFuIGlucHV0IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFNlbGVjdG9yIENTUyBzZWxlY3RvciB0byBiaW5kIG91ciBhdXRvIGNvbXBsZXRlIGNvbXBvbmVudCB0b1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRBdXRvQ29tcGxldGUgKGlucHV0U2VsZWN0b3IpIHtcbiAgICBpZiAodGhpcy5fYXV0b2NvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9hdXRvY29tcGxldGUucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYXV0b2NvbXBsZXRlID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZSgnQXV0b0NvbXBsZXRlJywge1xuICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICBuYW1lOiBgJHt0aGlzLm5hbWV9LmF1dG9jb21wbGV0ZWAsXG4gICAgICBpc0ZpbHRlclNlYXJjaDogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogJy5qcy15eHQtR2VvTG9jYXRpb25GaWx0ZXItYXV0b2NvbXBsZXRlJyxcbiAgICAgIG9yaWdpbmFsUXVlcnk6IHRoaXMucXVlcnksXG4gICAgICBvcmlnaW5hbEZpbHRlcjogdGhpcy5maWx0ZXIsXG4gICAgICBpbnB1dEVsOiBpbnB1dFNlbGVjdG9yLFxuICAgICAgdmVydGljYWxLZXk6IHRoaXMuX2NvbmZpZy52ZXJ0aWNhbEtleSxcbiAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IHRoaXMuc2VhcmNoUGFyYW1ldGVycyxcbiAgICAgIG9uU3VibWl0OiAocXVlcnksIGZpbHRlcikgPT4ge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gRmlsdGVyLmZyb21SZXNwb25zZShmaWx0ZXIpO1xuICAgICAgICB0aGlzLl9zYXZlRGF0YVRvU3RvcmFnZShxdWVyeSwgdGhpcy5maWx0ZXIpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgc3RhdGljIGZpbHRlciByZXByZXNlbnRpbmcgdGhlIHVzZXIncyBsb2NhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RvZ2dsZUdlb0ZpbHRlciAoKSB7XG4gICAgaWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBnZW9FcnJvcjogdHJ1ZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBnZW9Mb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgcG9zaXRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX2J1aWxkRmlsdGVyKHBvc2l0aW9uKTtcbiAgICAgICAgICB0aGlzLl9zYXZlRGF0YVRvU3RvcmFnZSgnJywgZmlsdGVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWApO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZ2VvRXJyb3I6IHRydWUgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBwcm92aWRlZCBmaWx0ZXIgdW5kZXIgdGhpcyBjb21wb25lbnQncyBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgdG8gc2F2ZVxuICAgKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyIFRoZSBmaWx0ZXIgdG8gc2F2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHNhdmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlRGF0YVRvU3RvcmFnZSAocXVlcnksIGZpbHRlciwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gLCBxdWVyeSk7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIGZpbHRlcik7XG4gICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIGZpbHRlcik7XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiwge1xuICAgICAgICBsYXQ6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcbiAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLFxuICAgICAgICByYWRpdXM6IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgY29uc3QgZmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgICAgbGV0IHRvdGFsRmlsdGVyID0gZmlsdGVyc1swXTtcbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG90YWxGaWx0ZXIgPSBGaWx0ZXIuYW5kKC4uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VhcmNoUXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSkgfHwgJyc7XG4gICAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuXG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX2NvbmZpZy52ZXJ0aWNhbEtleSwge1xuICAgICAgICBpbnB1dDogc2VhcmNoUXVlcnksXG4gICAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwb3NpdGlvbiwgY29uc3RydWN0IGEgRmlsdGVyIG9iamVjdFxuICAgKiBAcGFyYW0ge1Bvc3RpdGlvbn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRGaWx0ZXIgKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhY2N1cmFjeSB9ID0gcG9zaXRpb24uY29vcmRzO1xuICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KGFjY3VyYWN5LCB0aGlzLl9jb25maWcucmFkaXVzICogTUVURVJTX1BFUl9NSUxFKTtcbiAgICByZXR1cm4gRmlsdGVyLnBvc2l0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUsIHJhZGl1cyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNvcnRPcHRpb25zQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcblxuLyoqXG4gKiBSZW5kZXJzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Igc29ydGluZyBWZXJ0aWNhbCBSZXN1bHRzLlxuICogVE9ETzogaG93IHRvIGRlYWwgd2l0aCBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhpcyBjb21wb25lbnQgKGFuZCBmaWx0ZXJzIGluIGdlbmVyYWwpLFxuICogaWRlYWxseSBcImlkZW50aWNhbFwiIGZpbHRlcnMvc29ydHMgd291bGQgYmUgc3luY2VkIHVwLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb3J0T3B0aW9uc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihhc3NpZ25EZWZhdWx0cyhjb25maWcpLCBzeXN0ZW1Db25maWcpO1xuICAgIC8vIFRPRE8gU1BSLTE5MjkgY2VudHJhbGl6ZSB0aGlzIGxvZ2ljXG4gICAgdGhpcy5fY29uZmlnLnZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLnZlcnRpY2FsS2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25JbmRleCA9IHBhcnNlSW50KHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKHRoaXMubmFtZSkpIHx8IDA7XG4gICAgdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRPcHRpb25JbmRleF0uaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5oaWRlRXhjZXNzT3B0aW9ucyA9IHRoaXMuX2NvbmZpZy5zaG93TW9yZSAmJiB0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXggPCB0aGlzLl9jb25maWcuc2hvd01vcmVMaW1pdDtcbiAgICB0aGlzLnNob3dSZXNldCA9IHRoaXMuX2NvbmZpZy5zaG93UmVzZXQgJiYgdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4ICE9PSAwO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5oaWRlRXhjZXNzT3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zbGljZSgwLCB0aGlzLl9jb25maWcuc2hvd01vcmVMaW1pdCk7XG4gICAgfVxuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBoaWRlRXhjZXNzT3B0aW9uczogdGhpcy5oaWRlRXhjZXNzT3B0aW9ucyxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHNob3dSZXNldDogdGhpcy5zaG93UmVzZXRcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBIYW5kbGUgcmFkaW8gYnV0dG9uIHNlbGVjdGlvbnNcbiAgICBET00ub24oXG4gICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1Tb3J0T3B0aW9ucy1maWVsZFNldCcpLFxuICAgICAgJ2NoYW5nZScsXG4gICAgICBldnQgPT4gdGhpcy5oYW5kbGVPcHRpb25TZWxlY3Rpb24ocGFyc2VJbnQoZXZ0LnRhcmdldC52YWx1ZSkpXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIG1vcmUvbGVzcyBidXR0b25cbiAgICBpZiAodGhpcy5fY29uZmlnLnNob3dNb3JlKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LVNvcnRPcHRpb25zLXNob3dUb2dnbGUnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZUV4Y2Vzc09wdGlvbnMgPSAhdGhpcy5oaWRlRXhjZXNzT3B0aW9ucztcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgc2hvdyByZXNldCBidXR0b25cbiAgICBpZiAodGhpcy5zaG93UmVzZXQpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtU29ydE9wdGlvbnMtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVPcHRpb25TZWxlY3Rpb24oMClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgYXBwbHkgYnV0dG9uXG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtU29ydE9wdGlvbnMtYXBwbHknKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4gdGhpcy5fc29ydFJlc3VsdHMoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVPcHRpb25TZWxlY3Rpb24gKG9wdGlvbkluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWRPcHRpb24ob3B0aW9uSW5kZXgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3NvcnRSZXN1bHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVNlbGVjdGVkT3B0aW9uIChvcHRpb25JbmRleCkge1xuICAgIHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnNbb3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25JbmRleCA9IG9wdGlvbkluZGV4O1xuICAgIHRoaXMuc2hvd1Jlc2V0ID0gdGhpcy5fY29uZmlnLnNob3dSZXNldCAmJiBvcHRpb25JbmRleCAhPT0gMDtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG4gIH1cblxuICBfc29ydFJlc3VsdHMgKCkge1xuICAgIGNvbnN0IG9wdGlvbkluZGV4ID0gdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4O1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc1tvcHRpb25JbmRleF07XG5cbiAgICAvLyBzZWFyY2hPbkNoYW5nZSByZWFsbHkgbWVhbnMgc29ydCBvbiBjaGFuZ2UgaGVyZSwganVzdCB0aGF0IHRoZSBzb3J0IGlzIGRvbmUgdGhyb3VnaCBhIHNlYXJjaCxcbiAgICAvLyBUaGlzIHdhcyBkb25lIHRvIGhhdmUgYSBjb25zaXN0ZW50IG9wdGlvbiBuYW1lIGJldHdlZW4gZmlsdGVycy5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KHRoaXMubmFtZSwgb3B0aW9uSW5kZXgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuc3RvcmVPbkNoYW5nZSAmJiBvcHRpb25JbmRleCA9PT0gMCkge1xuICAgICAgdGhpcy5jb3JlLmNsZWFyU29ydEJ5cygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY29uZmlnLnN0b3JlT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuY29yZS5zZXRTb3J0QnlzKG9wdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX3NlYXJjaCgpO1xuICAgIHRoaXMuX2NvbmZpZy5vbkNoYW5nZShvcHRpb24pO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2VhcmNoIHdpdGggYWxsIGZpbHRlcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgX3NlYXJjaCAoKSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgIDogYWxsRmlsdGVyc1swXTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSB8fCAnJztcbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl9jb25maWcudmVydGljYWxLZXksIHtcbiAgICAgIGlucHV0LFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU29ydE9wdGlvbnMnO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnY29udHJvbHMvc29ydG9wdGlvbnMnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzIChjb25maWcpIHtcbiAgY29uc3QgdXBkYXRlZENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG5cbiAgLy8gT3B0aW9uYWwsIFRoZSBsYWJlbCB1c2VkIGZvciB0aGUg4oCcZGVmYXVsdOKAnSBzb3J0IChha2EgdGhlIHNvcnQgc3BlY2lmaWVkIGJ5IHRoZSBleHBlcmllbmNlIGNvbmZpZ1wiKS5cbiAgdXBkYXRlZENvbmZpZy5kZWZhdWx0U29ydExhYmVsID0gY29uZmlnLmRlZmF1bHRTb3J0TGFiZWwgfHwgJ0Jlc3QgTWF0Y2gnO1xuXG4gIC8vIEFycmF5IG9mIHNlYXJjaCBvcHRpb25zLCB3aGVyZSBhbiBvcHRpb24gaGFzIHR5cGUsIGxhYmVsLCBhbmQgaWYgaXMgdHlwZSBGSUVMRCBhbHNvIGEgbGFiZWwgYW5kIGRpcmVjdGlvblxuICBpZiAoIWNvbmZpZy5vcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdjb25maWcub3B0aW9ucyBhcmUgcmVxdWlyZWQnLCAnU29ydE9wdGlvbnMnKTtcbiAgfVxuICBjb25zdCBPUFRJT05fVFlQRVMgPSBbJ0ZJRUxEJywgJ1JFTEVWQU5DRScsICdFTlRJVFlfRElTVEFOQ0UnXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5vcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMnLCAnU29ydE9wdGlvbnMnKTtcbiAgfVxuICB1cGRhdGVkQ29uZmlnLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICBpZiAoIW9wdGlvbi5sYWJlbCB8fCAhb3B0aW9uLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcihgb3B0aW9uLmxhYmVsIGFuZCBvcHRpb24udHlwZSBhcmUgcmVxdWlyZWQgb3B0aW9uICR7b3B0aW9ufWAsICdTb3J0T3B0aW9ucycpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPcHRpb24gPSB7IGlzU2VsZWN0ZWQ6IGZhbHNlIH07XG4gICAgbmV3T3B0aW9uLmxhYmVsID0gb3B0aW9uLmxhYmVsO1xuICAgIG5ld09wdGlvbi50eXBlID0gb3B0aW9uLnR5cGU7XG4gICAgY29uc3QgaXNGaWVsZCA9IE9QVElPTl9UWVBFUy5pbmRleE9mKG5ld09wdGlvbi50eXBlKSA9PT0gMDtcbiAgICBpZiAoaXNGaWVsZCAmJiBvcHRpb24uZmllbGQgJiYgb3B0aW9uLmRpcmVjdGlvbikge1xuICAgICAgbmV3T3B0aW9uLmZpZWxkID0gb3B0aW9uLmZpZWxkO1xuICAgICAgbmV3T3B0aW9uLmRpcmVjdGlvbiA9IG9wdGlvbi5kaXJlY3Rpb247XG4gICAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoYG9wdGlvbi5maWVsZCBhbmQgb3B0aW9uLmRpcmVjdGlvbiBhcmUgcmVxdWlyZWQgZm9yIG9wdGlvbjogJHtvcHRpb259YCwgJ1NvcnRPcHRpb25zJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdPcHRpb247XG4gIH0pO1xuICAvLyBBZGQgZGVmYXVsdCBvcHRpb24gdG8gdGhlIGZyb250IG9mIHRoZSBvcHRpb25zIGFycmF5XG4gIHVwZGF0ZWRDb25maWcub3B0aW9ucy51bnNoaWZ0KHtcbiAgICBsYWJlbDogdXBkYXRlZENvbmZpZy5kZWZhdWx0U29ydExhYmVsLFxuICAgIGlzU2VsZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgc2VsZWN0b3IgdXNlZCBmb3Igb3B0aW9ucyBpbiB0aGUgdGVtcGxhdGVcbiAgdXBkYXRlZENvbmZpZy5vcHRpb25TZWxlY3RvciA9IGNvbmZpZy5vcHRpb25TZWxlY3RvciB8fCAneXh0LVNvcnRPcHRpb25zLW9wdGlvblNlbGVjdG9yJztcblxuICAvLyBPcHRpb25hbCwgaWYgdHJ1ZSwgdHJpZ2dlcnMgYSBzZWFyY2ggb24gZWFjaCBjaGFuZ2UgdG8gYSBmaWx0ZXIsXG4gIC8vIGlmIGZhbHNlIHRoZSBjb21wb25lbnQgYWxzbyByZW5kZXJzIGFuIGFwcGx5IGJ1dHRvbiwgZGVmYXVsdHMgdG8gZmFsc2VcbiAgdXBkYXRlZENvbmZpZy5zZWFyY2hPbkNoYW5nZSA9IGNvbmZpZy5zZWFyY2hPbkNoYW5nZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zZWFyY2hPbkNoYW5nZTtcblxuICAvLyBPcHRpb25hbCwgc2hvdyBhIHJlc2V0IGJ1dHRvbi4gQ2xpY2tpbmcgaXQgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSB1c2VyIHRvIHRoZSBkZWZhdWx0IHNvcnRpbmcgb3B0aW9uLlxuICB1cGRhdGVkQ29uZmlnLnNob3dSZXNldCA9IGNvbmZpZy5zaG93UmVzZXQgfHwgZmFsc2U7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSByZXNldCBidXR0b25cbiAgdXBkYXRlZENvbmZpZy5yZXNldExhYmVsID0gY29uZmlnLnJlc2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAvLyBPcHRpb25hbCwgdGhlIG1heCBudW1iZXIgb2YgZmlsdGVyIG9wdGlvbnMgdG8gc2hvdyBiZWZvcmUgY29sbGFwc2luZyBleHRyYXNcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAvLyBPcHRpb25hbCwgYWxsb3cgY29sbGFwc2luZyBleGNlc3Mgc29ydCBvcHRpb25zIGFmdGVyIGEgbGltaXRcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZSA9IGNvbmZpZy5zaG93TW9yZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TW9yZTtcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZSA9IHVwZGF0ZWRDb25maWcuc2hvd01vcmUgJiYgKHVwZGF0ZWRDb25maWcub3B0aW9ucy5sZW5ndGggPiB1cGRhdGVkQ29uZmlnLnNob3dNb3JlTGltaXQpO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIG9wdGlvbnNcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ1Nob3cgbW9yZSc7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3Mgb3B0aW9uc1xuICB1cGRhdGVkQ29uZmlnLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnU2hvdyBsZXNzJztcblxuICAvLyBPcHRpb25hbCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBjaGFuZ2VkXG4gIHVwZGF0ZWRDb25maWcub25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgLy8gT3B0aW9uYWwsIFRvcCB0aXRsZSBmb3IgdGhlIHNvcnRpbmcgY29tcG9uZW50XG4gIHVwZGF0ZWRDb25maWcubGFiZWwgPSBjb25maWcubGFiZWwgfHwgJ1NvcnRpbmcnO1xuXG4gIC8vIE9wdGlvbmFsLCB3aGVuIHRydWUgY29tcG9uZW50IGRvZXMgbm90IHVwZGF0ZSBnbG9iYWxTdG9yYWdlXG4gIC8vIHBvc3NpYmx5IGRlbGVnYXRpbmcgdGhhdCB0byBhIGhpZ2hlci1vcmRlci9jb21wb3NpdGUgY29tcG9uZW50XG4gIHVwZGF0ZWRDb25maWcuc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnN0b3JlT25DaGFuZ2U7XG5cbiAgdXBkYXRlZENvbmZpZy5hcHBseUxhYmVsID0gY29uZmlnLmFwcGx5TGFiZWwgfHwgJ0FwcGx5JztcblxuICB1cGRhdGVkQ29uZmlnLnZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5O1xuICBpZiAoIXVwZGF0ZWRDb25maWcudmVydGljYWxLZXkpIHtcbiAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ3ZlcnRpY2FsIGtleSBpcyByZXF1aXJlZCcsICdTb3J0T3B0aW9ucycpO1xuICB9XG5cbiAgLy8gbm90ZTogc2hvd0V4cGFuZCBhbmQgc2hvd051bWJlckFwcGxpZWQgZXhwbGljaXRseSBub3QgaW5jbHVkZWQsIG9uIHRoZSBncm91bmRzIHRoYXRcbiAgLy8gc29ydGluZyBzaG91bGQgYWx3YXlzIGJlIGV4cG9zZWQgdG8gdGhlIHVzZXIgaWYgYWRkZWQuXG5cbiAgcmV0dXJuIHVwZGF0ZWRDb25maWc7XG59XG4iLCIvKiogQG1vZHVsZSBEaXJlY3RBbnN3ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBFdmVudFR5cGVzIGFyZSBleHBsaWNpdCBzdHJpbmdzIGRlZmluZWRcbiAqIGZvciB3aGF0IHRoZSBzZXJ2ZXIgZXhwZWN0cyBmb3IgYW5hbHl0aWNzLlxuICpcbiAqIEBlbnVtXG4gKi9cbmNvbnN0IEV2ZW50VHlwZXMgPSB7XG4gIFRIVU1CU19VUDogJ1RIVU1CU19VUCcsXG4gIFRIVU1CU19ET1dOOiAnVEhVTUJTX0RPV04nXG59O1xuXG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgcG9zaXRpdmVGZWVkYmFja1NyVGV4dDogJ1RoaXMgYW5zd2VyZWQgbXkgcXVlc3Rpb24nLFxuICBuZWdhdGl2ZUZlZWRiYWNrU3JUZXh0OiAnVGhpcyBkaWQgbm90IGFuc3dlciBteSBxdWVzdGlvbicsXG4gIGZvb3RlclRleHRPblN1Ym1pc3Npb246ICdUaGFuayB5b3UgZm9yIHlvdXIgZmVlZGJhY2shJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0QW5zd2VyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9LCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjaWV2ZSB1cGRhdGVzIGZyb20gc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGluZGV4XG4gICAgICogQHR5cGUge1N0b3JhZ2VLZXl9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB1c2VkIGZvciBzdWJtaXR0aW5nIHRoZSBmZWVkYmFja1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1FbCB8fCAnLmpzLWRpcmVjdEFuc3dlci1mZWVkYmFjay1mb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdGh1bWJzIHVwYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNVcFNlbGVjdG9yID0gY29uZmlnLnRodW1ic1VwU2VsZWN0b3IgfHwgJy5qcy1kaXJlY3RBbnN3ZXItdGh1bWJVcCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYHRodW1icyBkb3duYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IgPSBjb25maWcudGh1bWJzRG93blNlbGVjdG9yIHx8ICcuanMtZGlyZWN0QW5zd2VyLXRodW1iRG93bic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzcGxheSB0ZXh0IGZvciB0aGUgVmlldyBEZXRhaWxzIGNsaWNrIHRvIGFjdGlvbiBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92aWV3RGV0YWlsc1RleHQgPSBjb25maWcudmlld0RldGFpbHNUZXh0IHx8ICdWaWV3IERldGFpbHMnO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0RpcmVjdEFuc3dlcic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvZGlyZWN0YW5zd2VyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBiZWZvcmVNb3VudCwgb25seSBkaXNwbGF5IHRoZSBkaXJlY3QgYW5zd2VyIGNvbXBvbmVudCBpZiBpdCBoYXMgZGF0YVxuICAgKi9cbiAgYmVmb3JlTW91bnQgKCkge1xuICAgIGlmICghdGhpcy5oYXNTdGF0ZSgnYW5zd2VyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBET00gaXMgY29uc3RydWN0ZWQsXG4gICAqIHdlIHdhbnQgdG8gd2lyZSB1cCB0aGUgYmVoYXZpb3IgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIHF1YWxpdHkgZmVlZGJhY2sgcmVwb3J0aW5nICh0aHVtYnN1cC9kb3duKVxuICAgKi9cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gQXZvaWQgYmluZGluZ3MgaWYgdGhlIGZlZWRiYWNrIGhhcyBwcmV2aW91c2x5IGJlZW4gc3VibWl0dGVkXG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoJ2ZlZWRiYWNrU3VibWl0dGVkJykgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZvciBXQ0FHIGNvbXBsaWFuY2UsIHRoZSBmZWVkYmFjayBzaG91bGQgYmUgYSBzdWJtaXR0YWJsZSBmb3JtXG4gICAgRE9NLm9uKHRoaXMuX2Zvcm1FbCwgJ3N1Ym1pdCcsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsID0gZS50YXJnZXQ7XG4gICAgICBsZXQgY2hlY2tlZFZhbHVlID0gRE9NLnF1ZXJ5KGZvcm1FbCwgJ2lucHV0OmNoZWNrZWQnKS52YWx1ZSA9PT0gJ3RydWUnO1xuXG4gICAgICB0aGlzLnJlcG9ydFF1YWxpdHkoY2hlY2tlZFZhbHVlKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAnZmVlZGJhY2tTdWJtaXR0ZWQnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIElzIHRoaXMgYWN0dWFsbHkgbmVjZXNzYXJ5PyBJIGd1ZXNzIGl0J3Mgb25seSBuZWNlc3NhcnkgaWYgdGhlXG4gICAgLy8gc3VibWl0IGJ1dHRvbiBpcyBoaWRkZW4uXG4gICAgRE9NLm9uKHRoaXMuX3RodW1ic1VwU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICAgIERPTS5vbih0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGVuYWJsZXMgZm9yIHBhcnRpYWwgdXBkYXRlcyAodGhlIGRlbHRhIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3KVxuICAgKiBAdHlwZSB7b2JqZWN0fSBUaGUgbmV3IHN0YXRlIHRvIGFwcGx5IHRvIHRoZSBvbGRcbiAgICovXG4gIHVwZGF0ZVN0YXRlIChzdGF0ZSA9IHt9KSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCksIHN0YXRlKTtcbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5ldmVudE9wdGlvbnMoZGF0YSksXG4gICAgICB2aWV3RGV0YWlsc1RleHQ6IHRoaXMuX3ZpZXdEZXRhaWxzVGV4dFxuICAgIH0pKTtcbiAgfVxuXG4gIGV2ZW50T3B0aW9ucyAoZGF0YSkge1xuICAgIGlmICghZGF0YSB8fCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogZGF0YS5yZWxhdGVkSXRlbS52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgc2VhcmNoZXI6ICdVTklWRVJTQUwnLFxuICAgICAgZW50aXR5SWQ6IGRhdGEucmVsYXRlZEl0ZW0uZGF0YS5pZCxcbiAgICAgIGN0YUxhYmVsOiB0aGlzLl92aWV3RGV0YWlsc1RleHQudG9VcHBlckNhc2UoKS5yZXBsYWNlKCcgJywgJ18nKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlcG9ydFF1YWxpdHkgd2lsbCBzZW5kIHRoZSBxdWFsaXR5IGZlZWRiYWNrIHRvIGFuYWx5dGljc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzR29vZCB0cnVlIGlmIHRoZSBhbnN3ZXIgaXMgd2hhdCB5b3Ugd2VyZSBsb29raW5nIGZvclxuICAgKi9cbiAgcmVwb3J0UXVhbGl0eSAoaXNHb29kKSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gaXNHb29kID09PSB0cnVlID8gRXZlbnRUeXBlcy5USFVNQlNfVVAgOiBFdmVudFR5cGVzLlRIVU1CU19ET1dOO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KGV2ZW50VHlwZSlcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgJ2RpcmVjdEFuc3dlcic6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoZXZlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBbnN3ZXJzQ29uZmlnRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcblxuLyoqXG4gKiBUaGUgQWx0ZXJuYXRpdmVWZXJ0aWNhbCBpcyBhIG1vZGVsIHRoYXQgaXMgdXNlZCB0byBwb3dlciB0aGUgc2VhcmNoXG4gKiBzdWdnZXN0aW9ucyBpbmZvIGJveC4gSXQncyBpbml0aWFsaXplZCB0aHJvdWdoIHRoZSBjb25maWd1cmF0aW9uIHByb3ZpZGVkXG4gKiB0byB0aGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbHRlcm5hdGl2ZVZlcnRpY2FsIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0aWNhbCB0aGF0IGlzIGV4cG9zZWQgZm9yIHRoZSBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gY29uZmlnLmxhYmVsO1xuICAgIGlmICh0eXBlb2YgdGhpcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IoXG4gICAgICAgICdsYWJlbCBpcyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciB2ZXJ0aWNhbFBhZ2UuJyxcbiAgICAgICAgJ0FsdGVybmF0aXZlVmVydGljYWwnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZSBVUkwsIGluY2x1ZGluZyB0aGUgcGFyYW1zXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IGNvbmZpZy51cmw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IoXG4gICAgICAgICd1cmwgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgdmVydGljYWxQYWdlLicsXG4gICAgICAgICdBbHRlcm5hdGl2ZVZlcnRpY2FsJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuYW1lIG9mIGFuIGljb24gZnJvbSB0aGUgZGVmYXVsdCBpY29uIHNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pY29uTmFtZSA9IGNvbmZpZy5pY29uTmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byBkaXNwbGF5IG5leHQgdG8gZWFjaCBhbHRlcm5hdGl2ZVxuICAgICAqIHZlcnRpY2FsXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdHNDb3VudCA9IGNvbmZpZy5yZXN1bHRzQ291bnQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFsdGVybmF0aXZlVmVydGljYWxzQ29tcG9uZW50ICovXG5cbmltcG9ydCBBbHRlcm5hdGl2ZVZlcnRpY2FsIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2FsdGVybmF0aXZldmVydGljYWwnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsdGVybmF0aXZlVmVydGljYWxzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuQUxURVJOQVRJVkVfVkVSVElDQUxTO1xuXG4gICAgLyoqXG4gICAgICogQWx0ZXJuYXRpdmUgdmVydGljYWxzIHRoYXQgaGF2ZSByZXN1bHRzIGZvciB0aGUgY3VycmVudCBxdWVyeVxuICAgICAqIFRoaXMgZ2V0cyB1cGRhdGVkIGJhc2VkIG9uIHRoZSBzZXJ2ZXIgcmVzdWx0c1xuICAgICAqIEB0eXBlIHtBbHRlcm5hdGl2ZVZlcnRpY2Fsc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FsdGVybmF0aXZlVmVydGljYWxzID0gKG9wdHMuZGF0YSAmJiBvcHRzLmRhdGEuYWx0ZXJuYXRpdmVWZXJ0aWNhbHMpIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcGFnZXMgY29uZmlnIGZyb20gZ2xvYmFsIHZlcnRpY2FscyBjb25maWdcbiAgICAgKiBAdHlwZSB7VmVydGljYWxQYWdlc0NvbmZpZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2Fsc0NvbmZpZyA9IG9wdHMudmVydGljYWxzQ29uZmlnIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHZlcnRpY2FsIHRoYXQgaXMgZXhwb3NlZCBmb3IgdGhlIGxpbmtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRWZXJ0aWNhbExhYmVsID0gdGhpcy5nZXRDdXJyZW50VmVydGljYWxMYWJlbChvcHRzLnZlcnRpY2Fsc0NvbmZpZykgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWx0ZXJuYXRpdmUgdmVydGljYWwgc2VhcmNoIHN1Z2dlc3Rpb25zLCBwYXJzZWQgZnJvbSBhbHRlcm5hdGl2ZSB2ZXJ0aWNhbHMgYW5kXG4gICAgICogdGhlIGdsb2JhbCB2ZXJ0aWNhbHMgY29uZmlnLlxuICAgICAqIFRoaXMgZ2V0cyB1cGRhdGVkIGJhc2VkIG9uIHRoZSBzZXJ2ZXIgcmVzdWx0c1xuICAgICAqIEB0eXBlIHtBbHRlcm5hdGl2ZVZlcnRpY2FsW119XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbFN1Z2dlc3Rpb25zID0gQWx0ZXJuYXRpdmVWZXJ0aWNhbHNDb21wb25lbnQuX2J1aWxkVmVydGljYWxTdWdnZXN0aW9ucyhcbiAgICAgIHRoaXMuX2FsdGVybmF0aXZlVmVydGljYWxzLFxuICAgICAgdGhpcy5fdmVydGljYWxzQ29uZmlnXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgdG8gdGhlIHVuaXZlcnNhbCBwYWdlIHRvIGxpbmsgYmFjayB0byB3aXRoIGN1cnJlbnQgcXVlcnlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fdW5pdmVyc2FsVXJsID0gb3B0cy51bml2ZXJzYWxVcmwgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCByZXN1bHRzIGFyZSBkaXNwbGF5aW5nLCB1c2VkIHRvIGNvbnRyb2wgbGFuZ3VhZ2UgaW4gdGhlIGluZm8gYm94XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNTaG93aW5nUmVzdWx0cyA9IG9wdHMuaXNTaG93aW5nUmVzdWx0cyB8fCBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdBbHRlcm5hdGl2ZVZlcnRpY2Fscyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvYWx0ZXJuYXRpdmV2ZXJ0aWNhbHMnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgdmVydGljYWxTdWdnZXN0aW9uczogW10gfSwgZGF0YSwge1xuICAgICAgdW5pdmVyc2FsVXJsOiB0aGlzLl91bml2ZXJzYWxVcmwsXG4gICAgICB2ZXJ0aWNhbFN1Z2dlc3Rpb25zOiB0aGlzLnZlcnRpY2FsU3VnZ2VzdGlvbnMsXG4gICAgICBjdXJyZW50VmVydGljYWxMYWJlbDogdGhpcy5fY3VycmVudFZlcnRpY2FsTGFiZWwsXG4gICAgICBpc1Nob3dpbmdSZXN1bHRzOiB0aGlzLl9pc1Nob3dpbmdSZXN1bHRzLFxuICAgICAgcXVlcnk6IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKVxuICAgIH0pKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRWZXJ0aWNhbExhYmVsICh2ZXJ0aWNhbHNDb25maWcpIHtcbiAgICBjb25zdCB0aGlzVmVydGljYWwgPSB2ZXJ0aWNhbHNDb25maWcuZmluZChjb25maWcgPT4ge1xuICAgICAgcmV0dXJuIGNvbmZpZy5pc0FjdGl2ZSB8fCBmYWxzZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzVmVydGljYWwgPyB0aGlzVmVydGljYWwubGFiZWwgOiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBfYnVpbGRWZXJ0aWNhbFN1Z2dlc3Rpb25zIHdpbGwgY29uc3RydWN0IGFuIGFycmF5IG9mIHtBbHRlcm5hdGl2ZVZlcnRpY2FsfVxuICAgKiBmcm9tIGFsdGVybmF0aXZlIHZlcnRpY2FscyBhbmQgdmVydGljYWxQYWdlcyBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhbHRlcm5hdGl2ZVZlcnRpY2FscyBhbHRlcm5hdGl2ZVZlcnRpY2FscyBzZXJ2ZXIgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtvYmplY3R9IHZlcnRpY2Fsc0NvbmZpZyB0aGUgY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBfYnVpbGRWZXJ0aWNhbFN1Z2dlc3Rpb25zIChhbHRlcm5hdGl2ZVZlcnRpY2FscywgdmVydGljYWxzQ29uZmlnKSB7XG4gICAgbGV0IHZlcnRpY2FscyA9IFtdO1xuICAgIGxldCBxdWVyeVBhcmFtcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG5cbiAgICBmb3IgKGxldCBhbHRlcm5hdGl2ZVZlcnRpY2FsIG9mIGFsdGVybmF0aXZlVmVydGljYWxzKSB7XG4gICAgICBjb25zdCB2ZXJ0aWNhbEtleSA9IGFsdGVybmF0aXZlVmVydGljYWwudmVydGljYWxDb25maWdJZDtcblxuICAgICAgY29uc3QgbWF0Y2hpbmdWZXJ0aWNhbENvbmZpZyA9IHZlcnRpY2Fsc0NvbmZpZy5maW5kKGNvbmZpZyA9PiB7XG4gICAgICAgIHJldHVybiBjb25maWcudmVydGljYWxLZXkgPT09IHZlcnRpY2FsS2V5O1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWF0Y2hpbmdWZXJ0aWNhbENvbmZpZyB8fCBhbHRlcm5hdGl2ZVZlcnRpY2FsLnJlc3VsdHNDb3VudCA8IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZlcnRpY2Fscy5wdXNoKG5ldyBBbHRlcm5hdGl2ZVZlcnRpY2FsKHtcbiAgICAgICAgbGFiZWw6IG1hdGNoaW5nVmVydGljYWxDb25maWcubGFiZWwsXG4gICAgICAgIHVybDogbWF0Y2hpbmdWZXJ0aWNhbENvbmZpZy51cmwgKyBxdWVyeVBhcmFtcyxcbiAgICAgICAgaWNvbk5hbWU6IG1hdGNoaW5nVmVydGljYWxDb25maWcuaWNvbixcbiAgICAgICAgcmVzdWx0c0NvdW50OiBhbHRlcm5hdGl2ZVZlcnRpY2FsLnJlc3VsdHNDb3VudFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJ0aWNhbHM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1hcFByb3ZpZGVyICovXG5cbi8qKlxuICogQSBNYXBQcm92aWRlciBpcyBhbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoYXQgc2hvdWxkIGJlIGltcGxlbWVudGVkXG4gKiBpbiBvcmRlciB0byBpbnRlZ3JhdGUgd2l0aCBhIFRoaXJkIFBhcnR5IE1hcCBwcm92aWRlciBmb3JcbiAqIGludGVyYWN0aXZlIG1hcHMuIE1hcFByb3ZpZGVycyBhcmUgdXNlZCBieSB0aGUgTWFwQ29tcG9uZW50LlxuICpcbiAqIEltcGxlbWVudGF0aW9ucyBzaG91bGQgZXh0ZW5kIHRoaXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBBUEkgS2V5IHVzZWQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIG1hcCBwcm92aWRlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAsIGRlZmF1bHRzIHRvIDE0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl96b29tID0gY29uZmlnLnpvb20gfHwgMTQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb29yZGluYXRlcyB0byBkaXNwbGF5IGlmIHRoZXJlIGFyZSBubyByZXN1bHRzIHJldHVybmVkXG4gICAgICogT25seSB1c2VkIGlmIHNob3dFbXB0eU1hcCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGVmYXVsdFBvc2l0aW9uID0gY29uZmlnLmRlZmF1bHRQb3NpdGlvbiB8fCB7IGxhdDogMzcuMDkwMiwgbG5nOiAtOTUuNzEyOSB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbXB0eSBtYXAgc2hvdWxkIGJlIHNob3duIHdoZW4gdGhlcmUgYXJlIG5vIHJlc3VsdHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9zaG93RW1wdHlNYXAgPSBjb25maWcuc2hvd0VtcHR5TWFwIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgbWFwIGluc3RhbmNlLCBjcmVhdGVkIGJ5IHRoZSBleHRlcm5hbCBsaWIuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IGJvb2xlYW4gdHJhY2tpbmcgd2hldGhlciBvciBub3QgdGhlIGV4dGVybmFsIEpTIGxpYnJhcnkgaXMgbG9hZGVkIChzZWUgVE9ETyBiZWxvdylcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYSBwaW4gaXMgY2xpY2tlZC4gVGhlIGNsaWNrZWQgaXRlbShzKSBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9vblBpbkNsaWNrID0gY29uZmlnLm9uUGluQ2xpY2sgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSBvbmNlIHRoZSBKYXZhc2NyaXB0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9vbkxvYWRlZCA9IGNvbmZpZy5vbkxvYWRlZCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXN0b20gY29uZmlndXJhdGlvbiBvdmVycmlkZSB0byB1c2UgZm9yIHRoZSBtYXAgbWFya2Vyc1xuICAgICAqIEB0eXBlIHtPYmplY3R8RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fcGluQ29uZmlnID0gdHlwZW9mIGNvbmZpZy5waW4gPT09ICdmdW5jdGlvbicgPyBjb25maWcucGluIDogT2JqZWN0LmFzc2lnbihNYXBQcm92aWRlci5ERUZBVUxUX1BJTl9DT05GSUcsIGNvbmZpZy5waW4pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBjb2xsYXBzZSBwaW5zIGF0IHRoZSBzYW1lIGxhdC9sbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9jb2xsYXBzZVBpbnMgPSBjb25maWcuY29sbGFwc2VQaW5zIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gdG8gdXNlIGZvciB0aGUgbWFwIG1hcmtlcnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogVE9ETyhiaWxseSkgQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBtb2RlbFxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1BJTl9DT05GSUcgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiB7XG4gICAgICAgIGFuY2hvcjogbnVsbCwgLy8gZS5nLiB7IHg6IDEsIHk6IDEgfVxuICAgICAgICBzdmc6IG51bGwsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgc2NhbGVkU2l6ZTogbnVsbCAvLyBlLmcuIHsgdzogMjAsIGg6IDIwIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbFR5cGU6ICdudW1lcmljJ1xuICAgIH07XG4gIH1cblxuICBvbkxvYWRlZCAoY2IpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fb25Mb2FkZWQgPSBjYjtcbiAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICB0aGlzLl9vbkxvYWRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGlzTG9hZGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gIH1cblxuICBsb2FkSlMgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBNZXRob2Q6IGxvYWRKUycpO1xuICB9XG5cbiAgaW5pdCAobWFwRGF0YSkge1xuICAgIC8vIFRPRE8oYmlsbHkpIFRoaXMgc2hvdWxkIGJlIGJhc2VkIG9mZiBhIHByb21pc2UgdGhhdCBnZXRzIGNyZWF0ZWQgZnJvbSBsb2FkSlNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgTWV0aG9kOiBpbml0Jyk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBsaXN0IG9mIG1hcmtlcnMsIGNvbWJpbmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGxhdC9sbmcgaW50byBhIHNpbmdsZSBtYXJrZXJcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gbWFya2VycyBUaGUgbWFya2VycyB0byBjb2xsYXBzZVxuICAgKi9cbiAgX2NvbGxhcHNlTWFya2VycyAobWFya2Vycykge1xuICAgIGNvbnN0IGxvY2F0aW9uVG9JdGVtID0ge307XG4gICAgbWFya2Vycy5mb3JFYWNoKG0gPT4ge1xuICAgICAgbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdXG4gICAgICAgID8gbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdLnB1c2gobSlcbiAgICAgICAgOiBsb2NhdGlvblRvSXRlbVtgJHttLmxhdGl0dWRlfSR7bS5sb25naXR1ZGV9YF0gPSBbbV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXJzID0gW107XG4gICAgZm9yIChsZXQgWywgbWFya2Vyc10gb2YgT2JqZWN0LmVudHJpZXMobG9jYXRpb25Ub0l0ZW0pKSB7XG4gICAgICBpZiAobWFya2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZE1hcmtlciA9IHtcbiAgICAgICAgICBpdGVtOiBtYXJrZXJzLm1hcChtID0+IG0uaXRlbSksXG4gICAgICAgICAgbGFiZWw6IG1hcmtlcnMubGVuZ3RoLFxuICAgICAgICAgIGxhdGl0dWRlOiBtYXJrZXJzWzBdLmxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogbWFya2Vyc1swXS5sb25naXR1ZGVcbiAgICAgICAgfTtcbiAgICAgICAgY29sbGFwc2VkTWFya2Vycy5wdXNoKGNvbGxhcHNlZE1hcmtlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsYXBzZWRNYXJrZXJzLnB1c2gobWFya2Vyc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxhcHNlZE1hcmtlcnM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdvb2dsZU1hcFByb3ZpZGVyICovXG5cbmltcG9ydCBNYXBQcm92aWRlciBmcm9tICcuL21hcHByb3ZpZGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vLi4vZG9tL2RvbSc7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cblxuLyoqXG4gKiBHb29nbGVNYXBQcm92aWRlciBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE1hcFByb3ZpZGVyXG4gKiB0aGF0IGhhbmRsZXMgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIHRoaXJkIHBhcnR5IEFQSSB0byBleHBvc2UgbWFwcy5cbiAqIEBleHRlbmRzIE1hcFByb3ZpZGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvb2dsZU1hcFByb3ZpZGVyIGV4dGVuZHMgTWFwUHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgLy8gbm9ybWFsaXplIGJlY2F1c2UgZ29vZ2xlJ3Mgem9vbSBpcyBlZmZlY3RpdmVseSAxIHVuaXQgb2YgZGlmZmVyZW5jZSBhd2F5IGZyb20gbWFwYm94IHpvb21cbiAgICB0aGlzLl96b29tT2Zmc2V0ID0gMTtcbiAgICB0aGlzLl96b29tICs9IHRoaXMuX3pvb21PZmZzZXQ7XG4gICAgdGhpcy5fY2xpZW50SWQgPSBvcHRzLmNsaWVudElkO1xuICAgIHRoaXMuX3NpZ25hdHVyZSA9IG9wdHMuc2lnbmF0dXJlO1xuXG4gICAgaWYgKCF0aGlzLmhhc1ZhbGlkQ2xpZW50Q3JlZGVudGlhbHMoKSAmJiAhdGhpcy5fYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZU1hcHNQcm92aWRlcjogTWlzc2luZyBgYXBpS2V5YCBvciB7YGNsaWVudElkYCwgYHNpZ25hdHVyZWB9Jyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZEpTICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuX29uTG9hZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNlbGYuX29uTG9hZGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgZ29vZ2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2VsZi5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgb25Mb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHNjcmlwdCA9IERPTS5xdWVyeSgnI3lleHQtbWFwLWpzJyk7XG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgY29uc3Qgb25Mb2FkRnVuYyA9IHNjcmlwdC5vbmxvYWQ7XG4gICAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWRGdW5jKCk7XG4gICAgICAgIG9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY3JpcHQgPSBET00uY3JlYXRlRWwoJ3NjcmlwdCcsIHtcbiAgICAgIGlkOiAneWV4dC1tYXAtanMnLFxuICAgICAgb25sb2FkOiAoKSA9PiB7XG4gICAgICAgIHNlbGYuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgb25Mb2FkKCk7XG4gICAgICB9LFxuICAgICAgYXN5bmM6IHRydWUsXG4gICAgICBzcmM6IGBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/JHtzZWxmLmdlbmVyYXRlQ3JlZGVudGlhbHMoKX1gXG4gICAgfSk7XG5cbiAgICBET00uYXBwZW5kKCdib2R5Jywgc2NyaXB0KTtcbiAgfVxuXG4gIGdlbmVyYXRlQ3JlZGVudGlhbHMgKCkge1xuICAgIGlmICh0aGlzLmhhc1ZhbGlkQ2xpZW50Q3JlZGVudGlhbHMoKSkge1xuICAgICAgcmV0dXJuIGBjbGllbnQ9JHt0aGlzLl9jbGllbnRJZH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYGtleT0ke3RoaXMuX2FwaUtleX1gO1xuICAgIH1cbiAgfVxuXG4gIGhhc1ZhbGlkQ2xpZW50Q3JlZGVudGlhbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRJZDtcbiAgfVxuXG4gIGluaXQgKGVsLCBtYXBEYXRhKSB7XG4gICAgaWYgKCghbWFwRGF0YSB8fCBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoIDw9IDApICYmICF0aGlzLl9zaG93RW1wdHlNYXApIHtcbiAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBOT1RFKGJpbGx5KSBUaGlzIHRpbWVvdXQgaXMgYSBoYWNrIGZvciBkZWFsaW5nIHdpdGggYXN5bmMgbmF0dXJlLlxuICAgIC8vIE9ubHkgaGVyZSBmb3IgZGVtbyBwdXJwb3Nlcywgc28gd2UnbGwgZml4IGxhdGVyLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IERPTS5xdWVyeShlbCk7XG4gICAgICB0aGlzLm1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoY29udGFpbmVyLCB7XG4gICAgICAgIHpvb206IHRoaXMuX3pvb20sXG4gICAgICAgIGNlbnRlcjogdGhpcy5nZXRDZW50ZXJNYXJrZXIobWFwRGF0YSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBcHBseSBvdXIgc2VhcmNoIGRhdGEgdG8gb3VyIEdvb2dsZU1hcFxuICAgICAgaWYgKG1hcERhdGEgJiYgbWFwRGF0YS5tYXBNYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXJzID0gdGhpcy5fY29sbGFwc2VQaW5zXG4gICAgICAgICAgPyB0aGlzLl9jb2xsYXBzZU1hcmtlcnMobWFwRGF0YS5tYXBNYXJrZXJzKVxuICAgICAgICAgIDogbWFwRGF0YS5tYXBNYXJrZXJzO1xuICAgICAgICBsZXQgZ29vZ2xlTWFwTWFya2VyQ29uZmlncyA9IEdvb2dsZU1hcE1hcmtlckNvbmZpZy5mcm9tKFxuICAgICAgICAgIGNvbGxhcHNlZE1hcmtlcnMsXG4gICAgICAgICAgdGhpcy5fcGluQ29uZmlnLFxuICAgICAgICAgIHRoaXMubWFwKTtcblxuICAgICAgICBsZXQgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihnb29nbGVNYXBNYXJrZXJDb25maWdzW2ldKTtcbiAgICAgICAgICBpZiAodGhpcy5fb25QaW5DbGljaykge1xuICAgICAgICAgICAgbWFya2VyLmFkZExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuX29uUGluQ2xpY2soY29sbGFwc2VkTWFya2Vyc1tpXS5pdGVtKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvdW5kcy5leHRlbmQobWFya2VyLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnb29nbGVNYXBNYXJrZXJDb25maWdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9XG5cbiAgZ2V0Q2VudGVyTWFya2VyIChtYXBEYXRhKSB7XG4gICAgcmV0dXJuIG1hcERhdGEgJiYgbWFwRGF0YS5tYXBDZW50ZXIgJiYgbWFwRGF0YS5tYXBDZW50ZXIubG9uZ2l0dWRlICYmIG1hcERhdGEubWFwQ2VudGVyLmxhdGl0dWRlXG4gICAgICA/IHsgbG5nOiBtYXBEYXRhLm1hcENlbnRlci5sb25naXR1ZGUsIGxhdDogbWFwRGF0YS5tYXBDZW50ZXIubGF0aXR1ZGUgfVxuICAgICAgOiB7IGxuZzogdGhpcy5fZGVmYXVsdFBvc2l0aW9uLmxuZywgbGF0OiB0aGlzLl9kZWZhdWx0UG9zaXRpb24ubGF0IH07XG4gIH1cbn1cblxuLy8gVE9ETyhiaWxseSkgTW92ZSB0byBvd24gY2xhc3NcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBNYXJrZXJDb25maWcge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBnb29nbGUgbWFwLCB0aGF0IHRoZSBtYXJrZXIgaXMgYXBwZW5kZWQgdG9cbiAgICAgKiBAdHlwZSB7R29vZ2xlTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gb3B0cy5tYXAgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXJrZXIgKGxhdC9sbmcpXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbiB8fCB7XG4gICAgICBsYXQ6IHVuZGVmaW5lZCxcbiAgICAgIGxuZzogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9wZXJ0aWVzL3NldHRpbmdzIG9mIHRoZSBpY29uIHVzZWQgZm9yIHRoZSBtYXJrZXJcbiAgICAgKiBlLmcuIHtcbiAgICAgKiAgICAgICAgYW5jaG9yOiB7IHg6IDAsIHk6IDAgfVxuICAgICAqICAgICAgICB1cmw6ICdwYXRoL3RvL3VybC5qcGcnXG4gICAgICogICAgICAgIHNjYWxlZFNpemU6IHsgdzogMCwgaDogMCB9XG4gICAgICogICAgICAgfVxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmljb24gPSBvcHRzLmljb24gfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIG9mIHRoZSBtYXJrZXIgdG8gdXNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gb3B0cy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhbiBhcnJheSBvZiBtYXJrZXIgY29uZmlnc1xuICAgKiBAcGFyYW0ge0dvb2dsZU1hcE1hcmtlckNvbmZpZ1tdfSBnb29nbGVNYXBNYXJrZXJDb25maWdzXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemUgKGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MpIHtcbiAgICBsZXQgc2VyaWFsaXplZE1hcmtlcnMgPSBbXTtcbiAgICBnb29nbGVNYXBNYXJrZXJDb25maWdzLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgc2VyaWFsaXplZE1hcmtlcnMucHVzaChgbWFya2Vycz1sYWJlbDoke21hcmtlci5sYWJlbH18JHttYXJrZXIucG9zaXRpb24ubGF0fSwke21hcmtlci5wb3NpdGlvbi5sbmd9YCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNYXJrZXJzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3RvcmFnZSBkYXRhIG1vZGVsIG9mIG1hcmtlcnMgaW50byBHb29nbGVBUElNYXJrZXJcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gbWFya2VycyBUaGUgZGF0YSBvZiB0aGUgbWFya2VyXG4gICAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBpbkNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgbWFya2VyXG4gICAqIEBwYXJhbSB7R29vZ2xlTWFwfSBtYXAgcmVmZXJlbmNlIHRvIHRoZSBnb29nbGUgbWFwIHRvIGFwcGx5IHRoZSBtYXJrZXIgdG9cbiAgICogQHJldHVybnMge0dvb2dsZU1hcE1hcmtlckNvbmZpZ1tdfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKG1hcmtlcnMsIHBpbkNvbmZpZywgbWFwKSB7XG4gICAgbGV0IGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWFya2VycykpIHtcbiAgICAgIG1hcmtlcnMgPSBbbWFya2Vyc107XG4gICAgfVxuXG4gICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgIC8vIFN1cHBvcnQgY29uZmlndXJhdGlvbiBhcyBhIGZ1bmN0aW9uXG4gICAgICBsZXQgcGluQ29uZmlnT2JqID0gcGluQ29uZmlnO1xuICAgICAgaWYgKHR5cGVvZiBwaW5Db25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGluQ29uZmlnT2JqID0gcGluQ29uZmlnKFxuICAgICAgICAgIG1hcmtlci5pdGVtLFxuICAgICAgICAgIE1hcFByb3ZpZGVyLkRFRkFVTFRfUElOX0NPTkZJRyxcbiAgICAgICAgICBtYXJrZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmFuc2Zvcm0gb3VyIENvbmZpZ3VyYXRpb24gT2JqZWN0IGludG8gdGhlIGV4cGVjdGVkXG4gICAgICAvLyBHb29nbGUgQVBJIGZvcm1hdC5cbiAgICAgIGxldCBpY29uID0ge307XG4gICAgICBpZiAocGluQ29uZmlnT2JqLmFuY2hvcikge1xuICAgICAgICBpY29uLmFuY2hvciA9IGdvb2dsZS5tYXBzLlBvaW50KHBpbkNvbmZpZ09iai5hbmNob3IueCwgcGluQ29uZmlnT2JqLmFuY2hvci55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbkNvbmZpZ09iai5zY2FsZWRTaXplKSB7XG4gICAgICAgIGljb24uc2NhbGVkU2l6ZSA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpbkNvbmZpZ09iai5zY2FsZWRTaXplLncsIHBpbkNvbmZpZ09iai5zY2FsZWRTaXplLmgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluQ29uZmlnT2JqLnVybCkge1xuICAgICAgICBpY29uLnVybCA9IHBpbkNvbmZpZ09iai51cmw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5Db25maWdPYmouc3ZnKSB7XG4gICAgICAgIGljb24udXJsID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCAke2VuY29kZVVSSUNvbXBvbmVudChwaW5Db25maWdPYmouc3ZnKX1gO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGFiZWw7XG4gICAgICBpZiAocGluQ29uZmlnT2JqLmxhYmVsKSB7XG4gICAgICAgIGxhYmVsID0gcGluQ29uZmlnT2JqLmxhYmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWwgPSBtYXJrZXIubGFiZWwudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTk9URShiaWxseSkgR29vZ2xlIG1hcHMgZG9lc24ndCBoYW5kbGUgZW1wdHkgaWNvbiBvYmplY3RzIG5pY2VseVxuICAgICAgLy8gTWFrZSBnb29nbGUgbWFwcyBoYXBweSBpZiBubyBzZXR0aW5ncyBmb3IgaWNvbiBhcmUgcHJvdmlkZWQ7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoaWNvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGljb24gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MucHVzaChcbiAgICAgICAgbmV3IEdvb2dsZU1hcE1hcmtlckNvbmZpZyh7XG4gICAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIGxhdDogbWFya2VyLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBtYXJrZXIubG9uZ2l0dWRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpY29uOiBpY29uLFxuICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBnb29nbGVNYXBNYXJrZXJDb25maWdzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBCb3hNYXBQcm92aWRlciAqL1xuXG5pbXBvcnQgTWFwUHJvdmlkZXIgZnJvbSAnLi9tYXBwcm92aWRlcic7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uLy4uL2RvbS9kb20nO1xuXG4vKiBnbG9iYWwgbWFwYm94Z2wgKi9cblxuLyoqXG4gKiBNYXBCb3hNYXBQcm92aWRlciBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE1hcFByb3ZpZGVyXG4gKiB0aGF0IGhhbmRsZXMgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIHRoaXJkIHBhcnR5IEFQSSB0byBleHBvc2UgbWFwcy5cbiAqIEBleHRlbmRzIE1hcFByb3ZpZGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEJveE1hcFByb3ZpZGVyIGV4dGVuZHMgTWFwUHJvdmlkZXIge1xuICAvKipcbiAgICogTG9hZCB0aGUgZXh0ZXJuYWwgSlMgTGlicmFyeVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkxvYWQgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIEpTIGlzIGxvYWRlZC5cbiAgICovXG4gIGxvYWRKUyAob25Mb2FkKSB7XG4gICAgbGV0IHNjcmlwdCA9IERPTS5jcmVhdGVFbCgnc2NyaXB0Jywge1xuICAgICAgaWQ6ICd5ZXh0LW1hcC1qcycsXG4gICAgICBvbmxvYWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHRoaXMuX2FwaUtleTtcblxuICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vbkxvYWRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX29uTG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIHNyYzogJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YwLjQ0LjEvbWFwYm94LWdsLmpzJ1xuICAgIH0pO1xuXG4gICAgbGV0IGNzcyA9IERPTS5jcmVhdGVFbCgnbGluaycsIHtcbiAgICAgIGlkOiAneWV4dC1tYXAtY3NzJyxcbiAgICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgICAgaHJlZjogJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YwLjQ0LjEvbWFwYm94LWdsLmNzcydcbiAgICB9KTtcblxuICAgIERPTS5hcHBlbmQoJ2JvZHknLCBjc3MpO1xuICAgIERPTS5hcHBlbmQoJ2JvZHknLCBzY3JpcHQpO1xuICB9XG5cbiAgaW5pdCAoZWwsIG1hcERhdGEpIHtcbiAgICBpZiAoKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwTWFya2Vycy5sZW5ndGggPD0gMCkgJiYgIXRoaXMuX3Nob3dFbXB0eU1hcCkge1xuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBjb250YWluZXIgPSBET00ucXVlcnkoZWwpO1xuICAgIHRoaXMuX21hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICB6b29tOiB0aGlzLl96b29tLFxuICAgICAgc3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3N0cmVldHMtdjknLFxuICAgICAgY2VudGVyOiB0aGlzLmdldENlbnRlck1hcmtlcihtYXBEYXRhKVxuICAgIH0pO1xuXG4gICAgaWYgKG1hcERhdGEgJiYgbWFwRGF0YS5tYXBNYXJrZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY29sbGFwc2VkTWFya2VycyA9IHRoaXMuX2NvbGxhcHNlUGluc1xuICAgICAgICA/IHRoaXMuX2NvbGxhcHNlTWFya2VycyhtYXBEYXRhLm1hcE1hcmtlcnMpXG4gICAgICAgIDogbWFwRGF0YS5tYXBNYXJrZXJzO1xuICAgICAgY29uc3QgbWFwYm94TWFwTWFya2VyQ29uZmlncyA9IE1hcEJveE1hcmtlckNvbmZpZy5mcm9tKFxuICAgICAgICBjb2xsYXBzZWRNYXJrZXJzLFxuICAgICAgICB0aGlzLl9waW5Db25maWcsXG4gICAgICAgIHRoaXMuX21hcCk7XG5cbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwYm94TWFwTWFya2VyQ29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgd3JhcHBlciA9IG1hcGJveE1hcE1hcmtlckNvbmZpZ3NbaV0ud3JhcHBlcjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IG5ldyBtYXBib3hnbC5MbmdMYXQoXG4gICAgICAgICAgbWFwYm94TWFwTWFya2VyQ29uZmlnc1tpXS5wb3NpdGlvbi5sb25naXR1ZGUsXG4gICAgICAgICAgbWFwYm94TWFwTWFya2VyQ29uZmlnc1tpXS5wb3NpdGlvbi5sYXRpdHVkZSk7XG4gICAgICAgIGxldCBtYXJrZXIgPSBuZXcgbWFwYm94Z2wuTWFya2VyKHdyYXBwZXIpLnNldExuZ0xhdChjb29yZHMpO1xuICAgICAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5nZXRMbmdMYXQoKSk7XG4gICAgICAgIG1hcmtlci5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICBpZiAodGhpcy5fb25QaW5DbGljaykge1xuICAgICAgICAgIG1hcmtlci5nZXRFbGVtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLl9vblBpbkNsaWNrKGNvbGxhcHNlZE1hcmtlcnNbaV0uaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFwYm94TWFwTWFya2VyQ29uZmlncy5sZW5ndGggPj0gMikge1xuICAgICAgICB0aGlzLl9tYXAuZml0Qm91bmRzKGJvdW5kcywgeyBwYWRkaW5nOiA1MCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRDZW50ZXJNYXJrZXIgKG1hcERhdGEpIHtcbiAgICByZXR1cm4gbWFwRGF0YSAmJiBtYXBEYXRhLm1hcENlbnRlciAmJiBtYXBEYXRhLm1hcENlbnRlci5sb25naXR1ZGUgJiYgbWFwRGF0YS5tYXBDZW50ZXIubGF0aXR1ZGVcbiAgICAgID8gW21hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSwgbWFwRGF0YS5tYXBDZW50ZXIubGF0aXR1ZGVdXG4gICAgICA6IHsgbG5nOiB0aGlzLl9kZWZhdWx0UG9zaXRpb24ubG5nLCBsYXQ6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sYXQgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWFwQm94TWFya2VyQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgbWFwYm94IG1hcCwgdGhhdCB0aGUgbWFya2VyIGlzIGFwcGVuZGVkIHRvXG4gICAgICogQHR5cGUge01hcEJveH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IG9wdHMubWFwIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgbWFya2VyIChsYXQvbG5nKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdHMucG9zaXRpb24gfHwge1xuICAgICAgbGF0aXR1ZGU6IHVuZGVmaW5lZCxcbiAgICAgIGxvbmdpdHVkZTogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBodG1sIGVsZW1lbnQgdG8gYmUgdXNlZCBhcyB0aGUgbWFwIG1hcmtlclxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy53cmFwcGVyID0gb3B0cy53cmFwcGVyIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCBvZiB0aGUgbWFya2VyIHRvIHVzZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IG9wdHMubGFiZWwgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCBvZiB0aGUgcGluIGZvciB0aGUgc3RhdGljIG1hcFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdGF0aWNNYXBQaW4gPSBvcHRzLnN0YXRpY01hcFBpbiB8fCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhbiBhcnJheSBvZiBtYXJrZXIgY29uZmlnc1xuICAgKiBAcGFyYW0ge01hcEJveE1hcmtlckNvbmZpZ1tdfSBtYXBib3hNYXBNYXJrZXJDb25maWdzXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemUgKG1hcGJveE1hcE1hcmtlckNvbmZpZ3MpIHtcbiAgICBsZXQgc2VyaWFsaXplZE1hcmtlcnMgPSBbXTtcbiAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgaWYgKG1hcmtlci5zdGF0aWNNYXBQaW4pIHtcbiAgICAgICAgc2VyaWFsaXplZE1hcmtlcnMucHVzaChgdXJsLSR7bWFya2VyLnN0YXRpY01hcFBpbn0oJHttYXJrZXIucG9zaXRpb24ubG9uZ2l0dWRlfSwke21hcmtlci5wb3NpdGlvbi5sYXRpdHVkZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkTWFya2Vycy5wdXNoKGBwaW4tcy0ke21hcmtlci5sYWJlbH0oJHttYXJrZXIucG9zaXRpb24ubG9uZ2l0dWRlfSwke21hcmtlci5wb3NpdGlvbi5sYXRpdHVkZX0pYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNYXJrZXJzLmpvaW4oJywnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3RvcmFnZSBkYXRhIG1vZGVsIG9mIG1hcmtlcnMgaW50byBNYXBCb3hNYXJrZXJDb25maWdcbiAgICogQHBhcmFtIHtNYXBCb3h9IEEgcmVmZXJlbmNlIHRvIHRoZSBtYXBib3ggbWFwIHRvIGFwcGx5IHRoZSBtYXJrZXIgdG9cbiAgICogQHBhcmFtIHtvYmplY3RbXX0gbWFya2VycyBUaGUgZGF0YSBvZiB0aGUgbWFya2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwaW5Db25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIG1hcmtlclxuICAgKiBAcmV0dXJucyB7TWFwQm94TWFya2VyQ29uZmlnW119XG4gICAqL1xuICBzdGF0aWMgZnJvbSAobWFya2VycywgcGluQ29uZmlnLCBtYXApIHtcbiAgICBsZXQgbWFwYm94TWFwTWFya2VyQ29uZmlncyA9IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXJrZXJzKSkge1xuICAgICAgbWFya2VycyA9IFttYXJrZXJzXTtcbiAgICB9XG5cbiAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgLy8gU3VwcG9ydCBjb25maWd1cmF0aW9uIGFzIGEgZnVuY3Rpb25cbiAgICAgIGxldCBwaW5Db25maWdPYmogPSBwaW5Db25maWc7XG4gICAgICBpZiAodHlwZW9mIHBpbkNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwaW5Db25maWdPYmogPSBwaW5Db25maWcoXG4gICAgICAgICAgbWFya2VyLml0ZW0sXG4gICAgICAgICAgTWFwUHJvdmlkZXIuREVGQVVMVF9QSU5fQ09ORklHLFxuICAgICAgICAgIG1hcmtlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBwaW5Db25maWdPYmoud3JhcHBlciA/IHBpbkNvbmZpZ09iai53cmFwcGVyIDogbnVsbDtcbiAgICAgIGNvbnN0IHN0YXRpY01hcFBpbiA9IHBpbkNvbmZpZ09iai5zdGF0aWNNYXBQaW4gPyBwaW5Db25maWdPYmouc3RhdGljTWFwUGluIDogbnVsbDtcblxuICAgICAgbWFwYm94TWFwTWFya2VyQ29uZmlncy5wdXNoKFxuICAgICAgICBuZXcgTWFwQm94TWFya2VyQ29uZmlnKHtcbiAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IG1hcmtlci5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogbWFya2VyLmxvbmdpdHVkZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JhcHBlcjogd3JhcHBlcixcbiAgICAgICAgICBsYWJlbDogbWFya2VyLmxhYmVsLFxuICAgICAgICAgIHN0YXRpY01hcFBpbjogc3RhdGljTWFwUGluXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcGJveE1hcE1hcmtlckNvbmZpZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1hcENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbmltcG9ydCBHb29nbGVNYXBQcm92aWRlciBmcm9tICcuL3Byb3ZpZGVycy9nb29nbGVtYXBwcm92aWRlcic7XG5pbXBvcnQgTWFwQm94TWFwUHJvdmlkZXIgZnJvbSAnLi9wcm92aWRlcnMvbWFwYm94bWFwcHJvdmlkZXInO1xuXG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuY29uc3QgUHJvdmlkZXJUeXBlcyA9IHtcbiAgJ2dvb2dsZSc6IEdvb2dsZU1hcFByb3ZpZGVyLFxuICAnbWFwYm94JzogTWFwQm94TWFwUHJvdmlkZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIHN5c3RlbU9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbU9wdHMpO1xuXG4gICAgLyoqXG4gICAgICogQmluZCB0aGlzIGNvbXBvbmVudCB0byBsaXN0ZW4gdG8gdGhlIHN0b3JhZ2UgYmFzZWQgb24gdGhpcyBrZXlcbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUztcblxuICAgIC8qKlxuICAgICAqIEFuIGFsaWFzZWQgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgbWFwIHByb3ZpZGVyIHRvIHVzZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fbWFwUHJvdmlkZXIgPSBvcHRzLm1hcFByb3ZpZGVyO1xuICAgIGlmICghdGhpcy5fbWFwUHJvdmlkZXIgfHwgISh0aGlzLl9tYXBQcm92aWRlci50b0xvd2VyQ2FzZSgpIGluIFByb3ZpZGVyVHlwZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcENvbXBvbmVudDogSW52YWxpZCBNYXAgUHJvdmlkZXI7IG11c3QgYmUgYGdvb2dsZWAgb3IgYG1hcEJveGAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhbiBpbnN0YW5jZSBvZiB0aGUge01hcFByb3ZpZGVyfSB0aGF0J3MgY29uc3RydWN0ZWRcbiAgICAgKiBAdHlwZSB7TWFwUHJvdmlkZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdNYXAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL21hcCc7XG4gIH1cblxuICAvLyBUT0RPKGJpbGx5KSBNYWtlIFByb3ZpZGVyVHlwZXMgYSBmYWN0b3J5IGNsYXNzXG4gIGdldFByb3ZpZGVySW5zdGFuY2UgKHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3ZpZGVyVHlwZXNbdHlwZS50b0xvd2VyQ2FzZSgpXSh0aGlzLl9jb25maWcpO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIHRoaXMuX21hcCA9IHRoaXMuZ2V0UHJvdmlkZXJJbnN0YW5jZSh0aGlzLl9tYXBQcm92aWRlcik7XG4gICAgdGhpcy5fbWFwLmxvYWRKUygpO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgdGhpcy5fbWFwLm9uTG9hZGVkKCgpID0+IHtcbiAgICAgIHRoaXMuX21hcC5pbml0KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5nZXRTdGF0ZSgnbWFwJykpO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShkYXRhLCB2YWwpO1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgY2FyZFRlbXBsYXRlcyA9IHtcbiAgJ1N0YW5kYXJkJzogJ2NhcmRzL3N0YW5kYXJkJyxcbiAgJ0FjY29yZGlvbic6ICdjYXJkcy9hY2NvcmRpb24nLFxuICAnTGVnYWN5JzogJ2NhcmRzL2xlZ2FjeSdcbn07XG5cbmV4cG9ydCBjb25zdCBjYXJkVHlwZXMgPSB7XG4gICdTdGFuZGFyZCc6ICdTdGFuZGFyZENhcmQnLFxuICAnQWNjb3JkaW9uJzogJ0FjY29yZGlvbkNhcmQnLFxuICAnTGVnYWN5JzogJ0xlZ2FjeUNhcmQnXG59O1xuIiwiLyoqIEBtb2R1bGUgQ2FyZENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBjYXJkVHlwZXMgfSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29uZmlnRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuXG5jbGFzcyBDYXJkQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhcmQgdHlwZSB0byB1c2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY2FyZFR5cGUgPSBjb25maWcuY2FyZFR5cGUgfHwgJ1N0YW5kYXJkJztcblxuICAgIC8qKlxuICAgICAqIERhdGEgbWFwcGluZ3MgaXMgYSBmdW5jdGlvbiBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZ1xuICAgICAqIHRoYXQgcmV0dXJucyBjb25maWcgYmFzZWQgb24gdGhlIGRhdGEgcGFzc2VkIGludG8gY2FyZFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFNYXBwaW5ncyA9IGNvbmZpZy5kYXRhTWFwcGluZ3MgfHwgKCgpID0+IHt9KTtcblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgc3BpdHMgb3V0IGFuIGFycmF5IG9mIENUQSBjb25maWcgb2JqZWN0cyBvciBhbiBhcnJheSBvZiBDVEEgY29uZmlnIG9iamVjdHNcbiAgICAgKiBvciBhcGkgZmllbGRuYW1lc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbnxBcnJheTxPYmplY3R8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSBjb25maWcuY2FsbHNUb0FjdGlvbiB8fCBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2FyZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2luZGV4ID0gY29uZmlnLl9pbmRleCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNhcmQgaXMgcGFydCBvZiBhIHVuaXZlcnNhbCBzZWFyY2hcbiAgICAgKi9cbiAgICB0aGlzLmlzVW5pdmVyc2FsID0gY29uZmlnLmlzVW5pdmVyc2FsIHx8IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcmRDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIobmV3IENhcmRDb25maWcoY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIGNvbmZpZy5kYXRhIGNvbWVzIGZyb20gdGhlIGRhdGEtcHJvcCBhdHRyaWJ1dGUgcGFzc2VkIGluXG4gICAgICogZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZGF0YSBmb3IgdGhpcyBjYXJkLlxuICAgICAqIEB0eXBlIHtSZXN1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSBkYXRhLnJlc3VsdCB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBkYXRhLnZlcnRpY2FsS2V5O1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBjb25zdCBjYXJkVHlwZSA9IHRoaXMuX2NvbmZpZy5jYXJkVHlwZTtcbiAgICBpZiAoIWNhcmRUeXBlc1tjYXJkVHlwZV0pIHtcbiAgICAgIGNvbnN0IHZhbGlkQ2FyZHMgPSBgW1wiJHtPYmplY3Qua2V5cyhjYXJkVHlwZXMpLmpvaW4oJ1wiLCBcIicpfVwiXWA7XG4gICAgICBjb25zdCBtc2cgPSBgQ2FyZCB0eXBlIFwiJHtjYXJkVHlwZX1cIiBpcyBub3QgcmVjb2duaXplZCBhcyBhIHZhbGlkIGJ1aWx0LWluIGNhcmQgdHlwZS5gICtcbiAgICAgIGAgVmFsaWQgdHlwZXMgaW5jbHVkZSAke3ZhbGlkQ2FyZHN9YDtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IobXNnLCAnQ2FyZENvbXBvbmVudCcpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlc3VsdDogdGhpcy5yZXN1bHQsXG4gICAgICBjYXJkVHlwZTogY2FyZFR5cGVzW2NhcmRUeXBlXVxuICAgIH0pO1xuICB9XG5cbiAgYWRkQ2hpbGQgKGRhdGEsIHR5cGUsIG9wdHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLnZlcnRpY2FsS2V5LFxuICAgICAgcmVzdWx0OiBkYXRhXG4gICAgfTtcbiAgICBjb25zdCBuZXdPcHRzID0ge1xuICAgICAgc2hvd09yZGluYWw6IHRoaXMuX2NvbmZpZy5zaG93T3JkaW5hbCxcbiAgICAgIGRhdGFNYXBwaW5nczogdGhpcy5fY29uZmlnLmRhdGFNYXBwaW5ncyxcbiAgICAgIGNhbGxzVG9BY3Rpb246IHRoaXMuX2NvbmZpZy5jYWxsc1RvQWN0aW9uLFxuICAgICAgdmVydGljYWxLZXk6IHRoaXMuX2NvbmZpZy52ZXJ0aWNhbEtleSxcbiAgICAgIF9pbmRleDogdGhpcy5fY29uZmlnLl9pbmRleCxcbiAgICAgIGlzVW5pdmVyc2FsOiB0aGlzLl9jb25maWcuaXNVbml2ZXJzYWwsXG4gICAgICAuLi5vcHRzXG4gICAgfTtcbiAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQodXBkYXRlZERhdGEsIHR5cGUsIG5ld09wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgY2hpbGRyZW4gY2FyZCBjb21wb25lbnRzIGxpa2UgU3RhbmRhcmRDYXJkQ29tcG9uZW50IHRvXG4gICAqIGFwcGx5IGdpdmVuIHRlbXBsYXRlIG1hcHBpbmdzIGFzIGNvbmZpZy5cbiAgICogQHBhcmFtIHtSZXN1bHR9IHJlc3VsdFxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGF0YU1hcHBpbmdzXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEYXRhTWFwcGluZ3MgKHJlc3VsdCwgZGF0YU1hcHBpbmdzKSB7XG4gICAgY29uc3QgY29uZmlnID0ge307XG4gICAgaWYgKHR5cGVvZiBkYXRhTWFwcGluZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRhdGFNYXBwaW5ncyA9IGRhdGFNYXBwaW5ncyhyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGFNYXBwaW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGFNYXBwaW5ncykuZm9yRWFjaCgoW2F0dHJpYnV0ZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25maWdbYXR0cmlidXRlXSA9IHZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZmlnW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnQ2FyZCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ2NhcmRzL2NhcmQnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFwcGxpZWRGaWx0ZXJzQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN1bHRzSGVhZGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgbnVtYmVyIG9mIHJlc3VsdHMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fY29uZmlnLnNob3dSZXN1bHRDb3VudCA9IGNvbmZpZy5zaG93UmVzdWx0Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd1Jlc3VsdENvdW50O1xuXG4gICAgLyoqXG4gICAgICogSWYgcHJlc2VudCwgc2hvdyB0aGUgZmlsdGVycyB0aGF0IHdlcmUgdWx0aW1hdGVseSBhcHBsaWVkIHRvIHRoaXMgcXVlcnlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9jb25maWcuc2hvd0FwcGxpZWRGaWx0ZXJzID0gY29uZmlnLnNob3dBcHBsaWVkRmlsdGVycyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93QXBwbGllZEZpbHRlcnM7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzaG93QXBwbGllZEZpbHRlcnMgaXMgdHJ1ZSwgc2hvdyB0aGUgZmllbGQgbmFtZSBpbiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IGEgY29sb24uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fY29uZmlnLnNob3dGaWVsZE5hbWVzID0gY29uZmlnLnNob3dGaWVsZE5hbWVzIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2hvd1Jlc3VsdENvdW50IGFuZCBzaG93QXBwbGllZEZpbHRlcnMgYXJlIHRydWUsXG4gICAgICogZGlzcGxheSB0aGlzIHNlcGFyYXRvciBiZXR3ZWVuIHRoZSByZXN1bHQgY291bnQgYW5kIHRoZSBhcHBsaWVkIHF1ZXJ5IGZpbHRlcnNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2NvbmZpZy5yZXN1bHRzQ291bnRTZXBhcmF0b3IgPSBjb25maWcucmVzdWx0c0NvdW50U2VwYXJhdG9yIHx8ICd8JztcblxuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHRzQ291bnQgPSBkYXRhLnJlc3VsdHNDb3VudCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHJlc3VsdHMgZGlzcGxheWVkIG9uIHRoZSBwYWdlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHRzTGVuZ3RoID0gZGF0YS5yZXN1bHRzTGVuZ3RoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXBwbGllZFF1ZXJ5RmlsdGVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGxpZWRRdWVyeUZpbHRlcnMgPSBkYXRhLmFwcGxpZWRRdWVyeUZpbHRlcnMgfHwgW107XG4gIH1cblxuICBzdGF0aWMgZ2V0IGR1cGxpY2F0ZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldEFwcGxpZWRGaWx0ZXJzQXJyYXkgKCkge1xuICAgIGNvbnN0IGdyb3VwZWRGaWx0ZXJzID0ge307XG4gICAgdGhpcy5hcHBsaWVkUXVlcnlGaWx0ZXJzLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICAgIGlmICghZ3JvdXBlZEZpbHRlcnNbZmlsdGVyLmtleV0pIHtcbiAgICAgICAgZ3JvdXBlZEZpbHRlcnNbZmlsdGVyLmtleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyb3VwZWRGaWx0ZXJzW2ZpbHRlci5rZXldLnB1c2goZmlsdGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgICAvLyBIYXMgdG8gYmUgcGFyc2VkIGludG8gYW4gYXJyYXkgYmVjYXVzZSBvdXIgaGFuZGxlYmFycyBjYW4gb25seSBsb29wIHRocm91Z2ggYXJyYXlzLCBub3Qgb2JqZWN0cy5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZ3JvdXBlZEZpbHRlcnMpLm1hcChsYWJlbCA9PiAoe1xuICAgICAgbGFiZWw6IGxhYmVsLCBkaXNwbGF5VmFsdWVzOiBncm91cGVkRmlsdGVyc1tsYWJlbF1cbiAgICB9KSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIGNvbnN0IGhhc0ZpbHRlcnMgPSB0aGlzLmFwcGxpZWRRdWVyeUZpbHRlcnMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBzaG91bGRTaG93RmlsdGVycyA9IGhhc0ZpbHRlcnMgJiYgdGhpcy5fY29uZmlnLnNob3dBcHBsaWVkRmlsdGVycztcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlc3VsdHNDb3VudDogdGhpcy5yZXN1bHRzQ291bnQsXG4gICAgICByZXN1bHRzQ291bnRTdGFydDogb2Zmc2V0ICsgMSxcbiAgICAgIHJlc3VsdHNDb3VudEVuZDogb2Zmc2V0ICsgdGhpcy5yZXN1bHRzTGVuZ3RoLFxuICAgICAgc2hvd1Jlc3VsdFNlcGFyYXRvcjogdGhpcy5fY29uZmlnLnNob3dSZXN1bHRDb3VudCAmJiBzaG91bGRTaG93RmlsdGVycyxcbiAgICAgIHNob3VsZFNob3dGaWx0ZXJzOiBzaG91bGRTaG93RmlsdGVycyxcbiAgICAgIGFwcGxpZWRGaWx0ZXJzQXJyYXk6IHRoaXMuZ2V0QXBwbGllZEZpbHRlcnNBcnJheSgpXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUmVzdWx0c0hlYWRlcic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2hlYWRlcic7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFZlcnRpY2FsUmVzdWx0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbmltcG9ydCBBbHRlcm5hdGl2ZVZlcnRpY2Fsc0NvbXBvbmVudCBmcm9tICcuL2FsdGVybmF0aXZldmVydGljYWxzY29tcG9uZW50JztcbmltcG9ydCBNYXBDb21wb25lbnQgZnJvbSAnLi4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgUmVzdWx0c0NvbnRleHQgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3Jlc3VsdHNjb250ZXh0JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcbmltcG9ydCBDYXJkQ29tcG9uZW50IGZyb20gJy4uL2NhcmRzL2NhcmRjb21wb25lbnQnO1xuaW1wb3J0IFJlc3VsdHNIZWFkZXJDb21wb25lbnQgZnJvbSAnLi9yZXN1bHRzaGVhZGVyY29tcG9uZW50JztcbmltcG9ydCB7IGFkZFBhcmFtc1RvVXJsIH0gZnJvbSAnLi4vLi4vLi4vY29yZS91dGlscy91cmx1dGlscyc7XG5cbmNsYXNzIFZlcnRpY2FsUmVzdWx0c0NvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIGlzVW5pdmVyc2FsIGlzIHNldCB0byB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIGJ5IHRoZSBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzVW5pdmVyc2FsID0gY29uZmlnLmlzVW5pdmVyc2FsIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogX2Rpc3BsYXlBbGxSZXN1bHRzIGlzIHNldCB0byB0cnVlIGlmIHRoZSBjb25maWcgb3B0aW9uIG5vUmVzdWx0cy5kaXNwbGF5QWxsUmVzdWx0cyBpcyB0cnVlLFxuICAgICAqIG1lYW5pbmcgdGhhdCBhbGwgcmVzdWx0cyBmb3IgdGhlIHZlcnRpY2FsIHdpbGwgZGlzcGxheSB3aGVuIHRoZXJlIGFyZSBubyByZXN1bHRzIGZvciBhIHF1ZXJ5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kaXNwbGF5QWxsUmVzdWx0cyA9IGNvbmZpZy5ub1Jlc3VsdHMgJiYgY29uZmlnLm5vUmVzdWx0cy5kaXNwbGF5QWxsUmVzdWx0cztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBubyByZXN1bHRzIHRlbXBsYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5vUmVzdWx0c1RlbXBsYXRlID0gY29uZmlnLm5vUmVzdWx0cyA/IGNvbmZpZy5ub1Jlc3VsdHMudGVtcGxhdGUgOiAnJztcblxuICAgIGNvbnN0IHBhcmVudE9wdHMgPSBjb25maWcuX3BhcmVudE9wdHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVySXRlbSA9IGNvbmZpZy5yZW5kZXJJdGVtIHx8IHBhcmVudE9wdHMucmVuZGVySXRlbTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBpdGVtIHRlbXBsYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLml0ZW1UZW1wbGF0ZSA9IGNvbmZpZy5pdGVtVGVtcGxhdGUgfHwgcGFyZW50T3B0cy5pdGVtVGVtcGxhdGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29sdW1ucyB0byBkaXNwbGF5LCBzdXBwb3J0cyAxLCAyLCAzLCBvciA0LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhOdW1iZXJPZkNvbHVtbnMgPSBjb25maWcubWF4TnVtYmVyT2ZDb2x1bW5zIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlnIHRvIHBhc3MgdG8gdGhlIGNhcmRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuY2FyZCA9IGNvbmZpZy5jYXJkIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlnIG9wdGlvbnMgdXNlZCBpbiB0aGUge0BsaW5rIFJlc3VsdHNIZWFkZXJDb21wb25lbnR9XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHRzSGVhZGVyT3B0cyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBkaXNwbGF5IHRoZSBudW1iZXIgb2YgcmVzdWx0cy5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBzaG93UmVzdWx0Q291bnQ6IGNvbmZpZy5zaG93UmVzdWx0Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd1Jlc3VsdENvdW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHByZXNlbnQsIHNob3cgdGhlIGZpbHRlcnMgdGhhdCB3ZXJlIHVsdGltYXRlbHkgYXBwbGllZCB0byB0aGlzIHF1ZXJ5XG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgc2hvd0FwcGxpZWRGaWx0ZXJzOiBjb25maWcuc2hvd0FwcGxpZWRGaWx0ZXJzID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dBcHBsaWVkRmlsdGVycyxcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiBzaG93UmVzdWx0Q291bnQgYW5kIHNob3dBcHBsaWVkRmlsdGVycyBhcmUgdHJ1ZSxcbiAgICAgICAqIGRpc3BsYXkgdGhpcyBzZXBhcmF0b3IgYmV0d2VlbiB0aGUgcmVzdWx0IGNvdW50IGFuZCB0aGUgYXBwbGllZCBxdWVyeSBmaWx0ZXJzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICByZXN1bHRzQ291bnRTZXBhcmF0b3I6IGNvbmZpZy5yZXN1bHRzQ291bnRTZXBhcmF0b3IgfHwgJ3wnLFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHNob3dBcHBsaWVkRmlsdGVycyBpcyB0cnVlLCBzaG93IHRoZSBmaWVsZCBuYW1lIGluIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgYSBjb2xvbi5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBzaG93RmllbGROYW1lczogY29uZmlnLnNob3dGaWVsZE5hbWVzIHx8IGZhbHNlXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0aWNhbFJlc3VsdHNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIobmV3IFZlcnRpY2FsUmVzdWx0c0NvbmZpZyhjb25maWcpLCBzeXN0ZW1Db25maWcpO1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTO1xuICAgIHRoaXMuX3ZlcnRpY2Fsc0NvbmZpZyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlXG4gICAgICAuZ2V0U3RhdGUoU3RvcmFnZUtleXMuVkVSVElDQUxfUEFHRVNfQ09ORklHKS5nZXQoKSB8fCBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UmVzdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdHMgPSBbXTtcbiAgICB0aGlzLm51bUNvbHVtbnMgPSB0aGlzLl9jb25maWcubWF4TnVtYmVyT2ZDb2x1bW5zO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OT19SRVNVTFRTX0NPTkZJRywgdGhpcy5fY29uZmlnLm5vUmVzdWx0cyB8fCB7fSk7XG4gIH1cblxuICBtb3VudCAoKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZ2V0U3RhdGUoKSkubGVuZ3RoID4gMCkge1xuICAgICAgc3VwZXIubW91bnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGR1cGxpY2F0ZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldFVuaXZlcnNhbFVybCAoKSB7XG4gICAgY29uc3QgdW5pdmVyc2FsQ29uZmlnID0gdGhpcy5fdmVydGljYWxzQ29uZmlnLmZpbmQoY29uZmlnID0+ICFjb25maWcudmVydGljYWxLZXkpIHx8IHt9O1xuICAgIGlmICh1bml2ZXJzYWxDb25maWcudXJsKSB7XG4gICAgICByZXR1cm4gYWRkUGFyYW1zVG9VcmwodW5pdmVyc2FsQ29uZmlnLnVybCwgeyBxdWVyeTogdGhpcy5xdWVyeSB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRWZXJ0aWNhbFVSTCAoZGF0YSkge1xuICAgIGNvbnN0IHZlcnRpY2FsQ29uZmlnID0gdGhpcy5fdmVydGljYWxzQ29uZmlnLmZpbmQoY29uZmlnID0+IGNvbmZpZy52ZXJ0aWNhbEtleSA9PT0gdGhpcy52ZXJ0aWNhbEtleSkgfHwge307XG4gICAgY29uc3QgdmVydGljYWxVUkwgPSB2ZXJ0aWNhbENvbmZpZy51cmwgfHwgZGF0YS52ZXJ0aWNhbFVSTCB8fCB0aGlzLnZlcnRpY2FsS2V5ICsgJy5odG1sJztcbiAgICByZXR1cm4gYWRkUGFyYW1zVG9VcmwodmVydGljYWxVUkwsIHsgcXVlcnk6IHRoaXMucXVlcnkgfSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSA9IHt9LCB2YWwpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UmVzdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdHMgPSBkYXRhLnJlc3VsdHMgfHwgW107XG4gICAgdGhpcy5yZXN1bHRzQ291bnQgPSBkYXRhLnJlc3VsdHNDb3VudDtcbiAgICB0aGlzLnZlcnRpY2FsS2V5ID0gZGF0YS52ZXJ0aWNhbENvbmZpZ0lkO1xuICAgIHRoaXMuYXBwbGllZFF1ZXJ5RmlsdGVycyA9IGRhdGEuYXBwbGllZFF1ZXJ5RmlsdGVycztcbiAgICBjb25zdCBzZWFyY2hTdGF0ZSA9IGRhdGEuc2VhcmNoU3RhdGUgfHwgU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0g7XG4gICAgY29uc3QgZGlzcGxheVJlc3VsdHNJZkV4aXN0ID0gdGhpcy5fY29uZmlnLmlzVW5pdmVyc2FsIHx8XG4gICAgICB0aGlzLl9jb25maWcuX2Rpc3BsYXlBbGxSZXN1bHRzIHx8XG4gICAgICBkYXRhLnJlc3VsdHNDb250ZXh0ID09PSBSZXN1bHRzQ29udGV4dC5OT1JNQUw7XG4gICAgY29uc3Qgc2hvd1Jlc3VsdHNIZWFkZXIgPSB0aGlzLl9jb25maWcucmVzdWx0c0hlYWRlck9wdHMuc2hvd1Jlc3VsdENvdW50IHx8XG4gICAgICB0aGlzLl9jb25maWcucmVzdWx0c0hlYWRlck9wdHMuc2hvd0FwcGxpZWRGaWx0ZXJzO1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHJlc3VsdHM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5ldmVudE9wdGlvbnMoKSxcbiAgICAgIHVuaXZlcnNhbFVybDogdGhpcy5nZXRVbml2ZXJzYWxVcmwoKSxcbiAgICAgIHZlcnRpY2FsVVJMOiB0aGlzLmdldFZlcnRpY2FsVVJMKGRhdGEpLFxuICAgICAgcXVlcnk6IHRoaXMucXVlcnksXG4gICAgICBjdXJyZW50VmVydGljYWxMYWJlbDogdGhpcy5fY3VycmVudFZlcnRpY2FsTGFiZWwsXG4gICAgICByZXN1bHRzUHJlc2VudDogZGlzcGxheVJlc3VsdHNJZkV4aXN0ICYmIHRoaXMucmVzdWx0cy5sZW5ndGggIT09IDAsXG4gICAgICBzaG93Tm9SZXN1bHRzOiBkYXRhLnJlc3VsdHNDb250ZXh0ID09PSBSZXN1bHRzQ29udGV4dC5OT19SRVNVTFRTLFxuICAgICAgcGxhY2Vob2xkZXJzOiBuZXcgQXJyYXkodGhpcy5fY29uZmlnLm1heE51bWJlck9mQ29sdW1ucyArIDEpLFxuICAgICAgbnVtQ29sdW1uczogTWF0aC5taW4odGhpcy5fY29uZmlnLm1heE51bWJlck9mQ29sdW1ucywgdGhpcy5yZXN1bHRzLmxlbmd0aCksXG4gICAgICBzaG93UmVzdWx0c0hlYWRlcjogc2hvd1Jlc3VsdHNIZWFkZXIsXG4gICAgICB1c2VMZWdhY3lOb1Jlc3VsdHM6IHRoaXMuX2NvbmZpZy5pc1VuaXZlcnNhbCB8fCAhdGhpcy5fY29uZmlnLm5vUmVzdWx0c1xuICAgIH0pLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciB0byBjb25zdHJ1Y3QgdGhlIGV2ZW50T3B0aW9ucyBvYmplY3QgZm9yIHRoZSB2aWV3IGFsbCBsaW5rXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBldmVudE9wdGlvbnMgKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB0aGlzLnZlcnRpY2FsS2V5XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnVmVydGljYWxSZXN1bHRzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy92ZXJ0aWNhbHJlc3VsdHMnO1xuICB9XG5cbiAgYWRkQ2hpbGQgKGRhdGEsIHR5cGUsIG9wdHMpIHtcbiAgICBpZiAodHlwZSA9PT0gTWFwQ29tcG9uZW50LnR5cGUpIHtcbiAgICAgIGNvbnN0IG5ld09wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9jb25maWcubWFwQ29uZmlnLCBvcHRzKTtcbiAgICAgIHJldHVybiBzdXBlci5hZGRDaGlsZCh7IG1hcDogZGF0YSB9LCB0eXBlLCBuZXdPcHRzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IENhcmRDb21wb25lbnQudHlwZSkge1xuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XG4gICAgICAgIHJlc3VsdDogdGhpcy5yZXN1bHRzW29wdHMuX2luZGV4XSxcbiAgICAgICAgdmVydGljYWxLZXk6IHRoaXMudmVydGljYWxLZXlcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXdPcHRzID0ge1xuICAgICAgICAuLi50aGlzLl9jb25maWcuY2FyZCxcbiAgICAgICAgaXNVbml2ZXJzYWw6IHRoaXMuX2NvbmZpZy5pc1VuaXZlcnNhbCxcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuX2NvbmZpZy5pdGVtVGVtcGxhdGUsXG4gICAgICAgIHJlbmRlcjogdGhpcy5fY29uZmlnLnJlbmRlckl0ZW0sXG4gICAgICAgIC4uLm9wdHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQodXBkYXRlZERhdGEsIHR5cGUsIG5ld09wdHMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQWx0ZXJuYXRpdmVWZXJ0aWNhbHNDb21wb25lbnQudHlwZSkge1xuICAgICAgY29uc3QgaGFzUmVzdWx0cyA9IHRoaXMucmVzdWx0cyAmJiB0aGlzLnJlc3VsdHMubGVuZ3RoID4gMDtcbiAgICAgIGRhdGEgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5BTFRFUk5BVElWRV9WRVJUSUNBTFMpO1xuICAgICAgY29uc3QgbmV3T3B0cyA9IHtcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuX2NvbmZpZy5ub1Jlc3VsdHNUZW1wbGF0ZSxcbiAgICAgICAgdW5pdmVyc2FsVXJsOiB0aGlzLmdldFVuaXZlcnNhbFVybCgpLFxuICAgICAgICB2ZXJ0aWNhbHNDb25maWc6IHRoaXMuX3ZlcnRpY2Fsc0NvbmZpZyxcbiAgICAgICAgaXNTaG93aW5nUmVzdWx0czogdGhpcy5fY29uZmlnLl9kaXNwbGF5QWxsUmVzdWx0cyAmJiBoYXNSZXN1bHRzLFxuICAgICAgICAuLi5vcHRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG5ld09wdHMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVzdWx0c0hlYWRlckNvbXBvbmVudC50eXBlKSB7XG4gICAgICBjb25zdCByZXN1bHRzSGVhZGVyRGF0YSA9IHtcbiAgICAgICAgcmVzdWx0c0xlbmd0aDogdGhpcy5yZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0c0NvdW50OiB0aGlzLnJlc3VsdHNDb3VudCxcbiAgICAgICAgYXBwbGllZFF1ZXJ5RmlsdGVyczogdGhpcy5hcHBsaWVkUXVlcnlGaWx0ZXJzLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKHJlc3VsdHNIZWFkZXJEYXRhLCB0eXBlLCBvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG9wdHMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50ICovXG5pbXBvcnQgVmVydGljYWxSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vdmVydGljYWxyZXN1bHRzY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi4vLi4vLi4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgVmVydGljYWxSZXN1bHRzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIGJhc2Ugc2VsZWN0b3IgdG8gdXNlIHdoZW4gZmluZGluZyBET00gdGFyZ2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fc2VsZWN0b3JCYXNlID0gY29uZmlnLnNlbGVjdG9yQmFzZSB8fCAnLmpzLXl4dC1BY2NvcmRpb25SZXN1bHQnO1xuXG4gICAgLyoqXG4gICAgICogY29sbGFwc2VkIHN0YXRlIGNsYXNzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZENsYXNzID0gY29uZmlnLmNvbGxhcHNlZENsYXNzIHx8ICdpcy1jb2xsYXBzZWQnO1xuXG4gICAgLyoqXG4gICAgICogdmVydGljYWwgY29uZmlnIGlkIGlzIHJlcXVpcmVkIGZvciBhbmFseXRpY3NcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbENvbmZpZ0lkID0gY29uZmlnLnZlcnRpY2FsQ29uZmlnSWQgfHwgY29uZmlnLl9wYXJlbnRPcHRzLnZlcnRpY2FsQ29uZmlnSWQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgY29tcG9uZW50IHR5cGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnQWNjb3JkaW9uUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2FjY29yZGlvbic7XG4gIH1cblxuICAvKipcbiAgICogb3ZlcnJpZGVzIG9uTW91bnQgdG8gYWRkIGJpbmRpbmdzIHRvIGNoYW5nZSB0aGUgaGVpZ2h0IG9uIGNsaWNrXG4gICAqIEByZXR1cm5zIHtBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uTW91bnQgKCkge1xuICAgIHN1cGVyLm9uTW91bnQoKTtcblxuICAgIC8vIE5PVEUoYW11bGxpbmdzKTogVGhpcyBpcyBhIGhhY2ssIHNpbmNlIGN1cnJlbnRseSBjb21wb25lbnRzIHdpdGggc2libGluZ3NcbiAgICAvLyBoYXZlIG5vIHdheSBvZiByZWZlcnJpbmcgdG8gdGhlaXIgb3duIGVsZW1lbnQuIFdlIGhhdmUgdG8gZ3JhYiB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IHNpbmNlIHNlY3Rpb25zIGdldCBhZGRlZCBpbiByZXZlcnNlLlxuICAgIGNvbnN0IHNlbGZFbCA9IHRoaXMuX2NvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZDtcblxuICAgIGNvbnN0IGFjY29yZGlvbkVscyA9IERPTS5xdWVyeUFsbChzZWxmRWwsIHRoaXMuX3NlbGVjdG9yQmFzZSk7XG4gICAgYWNjb3JkaW9uRWxzLmZvckVhY2goKGFjY29yZGlvbkVsKSA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy50b2dnbGVTZWxlY3RvcigpKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy5ib2R5U2VsZWN0b3IoKSk7XG4gICAgICB0aGlzLmNoYW5nZUhlaWdodChjb250ZW50RWwsIGFjY29yZGlvbkVsKTtcbiAgICAgIHRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGFjY29yZGlvbkVsLCB0b2dnbGVFbCwgY29udGVudEVsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBtb2RpZmllcjogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRoZSBhY2NvcmRpb24gdG9nZ2xlIGJ1dHRvblxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHBhcmFtIHRvZ2dsZUVsIHtIVE1MRWxlbWVudH0gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0gY29udGVudEVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSB0YXJnZXRcbiAgICovXG4gIGhhbmRsZUNsaWNrICh3cmFwcGVyRWwsIHRvZ2dsZUVsLCBjb250ZW50RWwpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBBbmFseXRpY3NFdmVudCh0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAnUk9XX0VYUEFORCcgOiAnUk9XX0NPTExBUFNFJylcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgICBlbnRpdHlJZDogdG9nZ2xlRWwuZGF0YXNldC5lbnRpdHlJZFxuICAgICAgfSk7XG4gICAgd3JhcHBlckVsLmNsYXNzTGlzdC50b2dnbGUodGhpcy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgdGhpcy5jaGFuZ2VIZWlnaHQoY29udGVudEVsLCB3cmFwcGVyRWwpO1xuICAgIHRvZ2dsZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRoaXMuaXNDb2xsYXBzZWQod3JhcHBlckVsKSA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGNvbGxhcHNlZFxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvbGxhcHNlZCAod3JhcHBlckVsKSB7XG4gICAgaWYgKCF3cmFwcGVyRWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlckVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbGxhcHNlZENsYXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b2dnbGVzIHRoZSBoZWlnaHQgYmV0d2VlbiAwIGFuZCB0aGUgY29udGVudCBoZWlnaHQgZm9yIHNtb290aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHRhcmdldEVsIHtIVE1MRWxlbWVudH1cbiAgICogQHBhcmFtIHdyYXBwZXJFbCB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjaGFuZ2VIZWlnaHQgKHRhcmdldEVsLCB3cmFwcGVyRWwpIHtcbiAgICB0YXJnZXRFbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAwIDogdGFyZ2V0RWwuc2Nyb2xsSGVpZ2h0fXB4YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIGNvbXBvc2luZyBjaGlsZCBlbGVtZW50IHNlbGVjdG9yc1xuICAgKiBAcGFyYW0gY2hpbGQge3N0cmluZ31cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJ1aWxkU2VsZWN0b3IgKGNoaWxkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3NlbGVjdG9yQmFzZX0ke2NoaWxkfWA7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9nZ2xlU2VsZWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkU2VsZWN0b3IoJy10b2dnbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIHRoZSBjb250ZW50IGVsZW1lbnQgc2VsZWN0b3JcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJvZHlTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRTZWxlY3RvcignLWJvZHknKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5pbXBvcnQgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL2FjY29yZGlvbnJlc3VsdHNjb21wb25lbnQuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFM7XG4gICAgdGhpcy5fbGltaXQgPSBvcHRzLmxpbWl0IHx8IDEwO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1VuaXZlcnNhbFJlc3VsdHMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3VuaXZlcnNhbHJlc3VsdHMnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbml0IChvcHRzKSB7XG4gICAgc3VwZXIuaW5pdChvcHRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgY29uc3Qgc2VhcmNoU3RhdGUgPSBkYXRhLnNlYXJjaFN0YXRlIHx8IFNlYXJjaFN0YXRlcy5QUkVfU0VBUkNIO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2VjdGlvbnM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIHNob3dOb1Jlc3VsdHM6IHNlY3Rpb25zLmxlbmd0aCA9PT0gMCxcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSlcbiAgICB9KSwgdmFsKTtcbiAgfVxuXG4gIGFkZENoaWxkIChkYXRhID0ge30sIHR5cGUsIG9wdHMpIHtcbiAgICBjb25zdCBjaGlsZE9wdHMgPSB7IC4uLm9wdHMsIC4uLnRoaXMuZ2V0Q2hpbGRDb25maWcoW2RhdGFbJ3ZlcnRpY2FsQ29uZmlnSWQnXV0pIH07XG4gICAgaWYgKGNoaWxkT3B0cy51c2VBY2NvcmRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50LnR5cGUsIGNoaWxkT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCB0eXBlLCBjaGlsZE9wdHMpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb25maWcgKGNvbmZpZ0lkKSB7XG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IGNvbmZpZ0lkLFxuICAgICAgaXNVbml2ZXJzYWw6IHRydWVcbiAgICB9O1xuICAgIGxldCBjb25maWcgPSB0aGlzLl9jb25maWcuY29uZmlnO1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRDb25maWcsIHRoaXMuX2NvbmZpZ1snY29uZmlnJ11bY29uZmlnSWRdIHx8IHRoaXMuX2NvbmZpZ1snY29uZmlnJ10pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBQYWdpbmF0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuaW1wb3J0IFJlc3VsdHNDb250ZXh0IGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9yZXN1bHRzY29udGV4dCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2luYXRpb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2UgZm9yIHNlYXJjaGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykudmVydGljYWxLZXk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl92ZXJ0aWNhbEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICd2ZXJ0aWNhbEtleSBub3QgcHJvdmlkZWQsIGJ1dCBuZWNlc3NhcnkgZm9yIHBhZ2luYXRpb24nLFxuICAgICAgICAnUGFnaW5hdGlvbkNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXlzIHRoZSBmaXJzdCBwYWdlIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCA9IGNvbmZpZy5zaG93Rmlyc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0ZpcnN0O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheXMgdGhlIGxhc3QgcGFnZSBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCA9IGNvbmZpZy5zaG93TGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TGFzdDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGFsbCBhbmFseXRpYyBldmVudHMgc2VudCBieSB0aGlzIGNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NPcHRpb25zID0ge1xuICAgICAgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExhYmVsIGZvciBhIHBhZ2Ugb2YgcmVzdWx0cy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFnZUxhYmVsID0gY29uZmlnLnBhZ2VMYWJlbCB8fCAnUGFnZSc7XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBOdW1iZXIob2Zmc2V0KSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIG9mZnNldCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIE51bWJlcihvZmZzZXQpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTLCByZXN1bHRzID0+IHtcbiAgICAgIGlmIChyZXN1bHRzLnNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdQYWdpbmF0aW9uJztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcGFnaW5hdGlvbic7XG4gIH1cblxuICBzaG91bGRTaG93Q29udHJvbHMgKHJlc3VsdHMsIGxpbWl0KSB7XG4gICAgY29uc3QgaGFzUmVzdWx0cyA9IHJlc3VsdHMuc2VhcmNoU3RhdGUgPT09ICdzZWFyY2gtY29tcGxldGUnICYmIHJlc3VsdHMucmVzdWx0c0NvdW50ID4gbGltaXQ7XG4gICAgY29uc3Qgbm9SZXN1bHRzQ29uZmlnID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuTk9fUkVTVUxUU19DT05GSUcpIHx8IHt9O1xuICAgIGNvbnN0IHNob3dDb250cm9scyA9IGhhc1Jlc3VsdHMgJiZcbiAgICAgIChyZXN1bHRzLnJlc3VsdHNDb250ZXh0ID09PSBSZXN1bHRzQ29udGV4dC5OT1JNQUwgfHwgbm9SZXN1bHRzQ29uZmlnLmRpc3BsYXlBbGxSZXN1bHRzKTtcbiAgICByZXR1cm4gc2hvd0NvbnRyb2xzO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMpIHx8IHt9O1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQ7XG4gICAgY29uc3Qgc2hvd0NvbnRyb2xzID0gdGhpcy5zaG91bGRTaG93Q29udHJvbHMocmVzdWx0cywgbGltaXQpO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDA7XG4gICAgaWYgKCFzaG93Q29udHJvbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c1BhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLXByZXZpb3VzJyk7XG4gICAgY29uc3QgbmV4dFBhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLW5leHQnKTtcbiAgICBjb25zdCBtYXhQYWdlID0gTWF0aC50cnVuYygocmVzdWx0cy5yZXN1bHRzQ291bnQgLSAxKSAvIGxpbWl0KTtcblxuICAgIERPTS5vbihwcmV2aW91c1BhZ2VCdXR0b24sICdjbGljaycsICgpID0+IHRoaXMudXBkYXRlUGFnZShvZmZzZXQgLSBsaW1pdCkpO1xuICAgIERPTS5vbihuZXh0UGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKG9mZnNldCArIGxpbWl0KSk7XG5cbiAgICBpZiAodGhpcy5fZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCkge1xuICAgICAgY29uc3QgZmlyc3RQYWdlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtUGFnaW5hdGlvbi1maXJzdCcpO1xuICAgICAgRE9NLm9uKGZpcnN0UGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGFzdFBhZ2VCdXR0b25FbmFibGVkKSB7XG4gICAgICBjb25zdCBsYXN0UGFnZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LVBhZ2luYXRpb24tbGFzdCcpO1xuICAgICAgRE9NLm9uKGxhc3RQYWdlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZVBhZ2UobWF4UGFnZSAqIGxpbWl0KSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUGFnZSAob2Zmc2V0KSB7XG4gICAgdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBvZmZzZXQpO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgb2Zmc2V0KTtcbiAgICB0aGlzLmNvcmUudmVydGljYWxQYWdlKHRoaXMuX3ZlcnRpY2FsS2V5LCBvZmZzZXQpO1xuICB9XG5cbiAgc2Nyb2xsVG9Ub3AgKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIC8vIFNhZmFyaVxuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMpIHx8IHt9O1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwO1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQ7XG4gICAgY29uc3QgcGFnZU51bWJlciA9IG9mZnNldCAvIGxpbWl0O1xuICAgIGNvbnN0IGlzTW9yZVJlc3VsdHMgPSByZXN1bHRzLnJlc3VsdHNDb3VudCA+IG9mZnNldCArIGxpbWl0O1xuICAgIGNvbnN0IG1heFBhZ2UgPSBNYXRoLnRydW5jKChyZXN1bHRzLnJlc3VsdHNDb3VudCAtIDEpIC8gbGltaXQpO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZSh7XG4gICAgICBzaG93Q29udHJvbHM6IHRoaXMuc2hvdWxkU2hvd0NvbnRyb2xzKHJlc3VsdHMsIGxpbWl0KSxcbiAgICAgIGZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQ6IHRoaXMuX2ZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQsXG4gICAgICBsYXN0UGFnZUJ1dHRvbkVuYWJsZWQ6IHRoaXMuX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCxcbiAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIgKyAxLFxuICAgICAgcGFnZUxhYmVsOiB0aGlzLl9wYWdlTGFiZWwsXG4gICAgICBzaG93Rmlyc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyID4gMSxcbiAgICAgIHNob3dQcmV2aW91c1BhZ2VCdXR0b246IHBhZ2VOdW1iZXIgPiAwLFxuICAgICAgc2hvd05leHRQYWdlQnV0dG9uOiBpc01vcmVSZXN1bHRzLFxuICAgICAgc2hvd0xhc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyIDwgbWF4UGFnZSAtIDEsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIENUQUNvbGxlY3Rpb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDVEFDb2xsZWN0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlc3VsdCBkYXRhXG4gICAgICogQHR5cGUge1Jlc3VsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IGRhdGEucmVzdWx0IHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRE9NIHNob3VsZCBpbmNsdWRlIGxlZ2FjeSBjbGFzcyBuYW1lc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW5jbHVkZUxlZ2FjeUNsYXNzZXMgPSB0aGlzLl9jb25maWcuaW5jbHVkZUxlZ2FjeUNsYXNzZXMgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBrZXkgZm9yIHRoZSBzZWFyY2guXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2FsS2V5ID0gZGF0YS52ZXJ0aWNhbEtleTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBjdGEgaXMgcGFydCBvZiBhIHVuaXZlcnNhbCBzZWFyY2guXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1VuaXZlcnNhbCA9IHRoaXMuX2NvbmZpZy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgc3BpdHMgb3V0IGFuIGFycmF5IG9mIENUQSBjb25maWcgb2JqZWN0cyBvciBhbiBhcnJheSBvZiBDVEEgY29uZmlnIG9iamVjdHNcbiAgICAgKiBvciBhcGkgZmllbGRuYW1lc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbnxBcnJheTxPYmplY3R8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBjb25zdCBjYWxsc1RvQWN0aW9uID0gdGhpcy5fY29uZmlnLmNhbGxzVG9BY3Rpb24gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlnIGZvciBlYWNoIGNhbGxzIHRvIGFjdGlvbiBjb21wb25lbnQgdG8gcmVuZGVyLlxuICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuY2FsbHNUb0FjdGlvbiA9IENUQUNvbGxlY3Rpb25Db21wb25lbnQucmVzb2x2ZUNUQU1hcHBpbmcodGhpcy5yZXN1bHQuX3JhdywgLi4uY2FsbHNUb0FjdGlvbik7XG5cbiAgICAvLyBBc3NpZ24gYW55IGV4dHJhIGN0YSBjb25maWcgdGhhdCBkb2VzIG5vdCBjb21lIGZyb20gdGhlIGN0YSBtYXBwaW5ncy5cbiAgICBjb25zdCBfY3RhTW9kaWZpZXJzID0gdGhpcy5fY29uZmlnLl9jdGFNb2RpZmllcnMgfHwgW107XG4gICAgaWYgKHRoaXMuY2FsbHNUb0FjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIF9jdGFNb2RpZmllcnMucHVzaCgnc29sbycpO1xuICAgIH1cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSB0aGlzLmNhbGxzVG9BY3Rpb24ubWFwKGN0YSA9PiAoe1xuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmRlZmF1bHRFdmVudE9wdGlvbnModGhpcy5yZXN1bHQpLFxuICAgICAgX2N0YU1vZGlmaWVyczogX2N0YU1vZGlmaWVycyxcbiAgICAgIGluY2x1ZGVMZWdhY3lDbGFzc2VzOiB0aGlzLmluY2x1ZGVMZWdhY3lDbGFzc2VzLFxuICAgICAgLi4uY3RhXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgcmVzb2x2aW5nIGN0YXMgZnJvbSBhIGN0YSBtYXBwaW5nIHdoaWNoIGFyZSBlaXRoZXJcbiAgICogMS4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBjdGEncyBjb25maWdcbiAgICogMi4gYW4gb2JqZWN0IHRoYXQgaGFzIGEgcGVyLWF0dHJpYnV0ZSBtYXBwaW5nIG9mIGVpdGhlciBhXG4gICAqICAgIGEpIHN0YXRpYyB2YWx1ZVxuICAgKiAgICBiKSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIHJlc3V0IGRhdGEgYW5kIHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdmFsdWVcbiAgICogTm90ZTogSW50ZW50aW9uYWxseSBkb2VzIG5vdCBhbGxvdyBuZXN0aW5nIGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihPYmplY3R8c3RyaW5nKX0gY3Rhc1xuICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn1cbiAgICovXG4gIHN0YXRpYyByZXNvbHZlQ1RBTWFwcGluZyAocmVzdWx0LCAuLi5jdGFzKSB7XG4gICAgbGV0IHBhcnNlZENUQXMgPSBbXTtcbiAgICBjdGFzLm1hcChjdGFNYXBwaW5nID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY3RhTWFwcGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwYXJzZWRDVEFzID0gcGFyc2VkQ1RBcy5jb25jYXQoY3RhTWFwcGluZyhyZXN1bHQpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN0YU1hcHBpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGN0YU9iamVjdCA9IHsgLi4uY3RhTWFwcGluZyB9O1xuICAgICAgICBmb3IgKGxldCBbY3RhQXR0cmlidXRlLCBhdHRyaWJ1dGVNYXBwaW5nXSBvZiBPYmplY3QuZW50cmllcyhjdGFNYXBwaW5nKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlTWFwcGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY3RhT2JqZWN0W2N0YUF0dHJpYnV0ZV0gPSBhdHRyaWJ1dGVNYXBwaW5nKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlZENUQXMucHVzaChjdGFPYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHBhcnNlZENUQXMgPSBwYXJzZWRDVEFzLmZpbHRlcihjdGEgPT4gY3RhKTtcblxuICAgIHBhcnNlZENUQXMuZm9yRWFjaChjdGEgPT4ge1xuICAgICAgaWYgKCFjdGEubGFiZWwgJiYgIWN0YS51cmwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYWxsIHRvIEFjdGlvbjonLCBjdGEsICdpcyBtaXNzaW5nIGJvdGggYSBsYWJlbCBhbmQgdXJsIGF0dHJpYnV0ZSBhbmQgaXMgYmVpbmcgYXV0b21hdGljYWxseSBoaWRkZW4nKTtcbiAgICAgIH0gZWxzZSBpZiAoIWN0YS5sYWJlbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgdG8gQWN0aW9uOicsIGN0YSwgJ2lzIG1pc3NpbmcgYSBsYWJlbCBhdHRyaWJ1dGUgYW5kIGlzIGJlaW5nIGF1dG9tYXRpY2FsbHkgaGlkZGVuJyk7XG4gICAgICB9IGVsc2UgaWYgKCFjdGEudXJsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2FsbCB0byBBY3Rpb246JywgY3RhLCAnaXMgbWlzc2luZyBhIHVybCBhdHRyaWJ1dGUgYW5kIGlzIGJlaW5nIGF1dG9tYXRpY2FsbHkgaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFyc2VkQ1RBcy5maWx0ZXIoY3RhID0+IGN0YS51cmwgJiYgY3RhLnVybC50cmltKCkgJiYgY3RhLmxhYmVsICYmIGN0YS5sYWJlbC50cmltKCkpO1xuICB9XG5cbiAgc3RhdGljIGhhc0NUQXMgKHJlc3VsdCwgY3Rhcykge1xuICAgIHJldHVybiBDVEFDb2xsZWN0aW9uQ29tcG9uZW50LnJlc29sdmVDVEFNYXBwaW5nKHJlc3VsdCwgLi4uY3RhcykubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGRlZmF1bHRFdmVudE9wdGlvbnMgKHJlc3VsdCkge1xuICAgIGNvbnN0IGV2ZW50T3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLnZlcnRpY2FsS2V5LFxuICAgICAgc2VhcmNoZXI6IHRoaXMuX2NvbmZpZy5pc1VuaXZlcnNhbCA/ICdVTklWRVJTQUwnIDogJ1ZFUlRJQ0FMJ1xuICAgIH07XG4gICAgaWYgKHJlc3VsdC5fcmF3LmlkKSB7XG4gICAgICBldmVudE9wdGlvbnMuZW50aXR5SWQgPSByZXN1bHQuX3Jhdy5pZDtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50T3B0aW9ucztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpbmNsdWRlTGVnYWN5Q2xhc3NlczogdGhpcy5pbmNsdWRlTGVnYWN5Q2xhc3NlcyxcbiAgICAgIGNhbGxzVG9BY3Rpb246IHRoaXMuY2FsbHNUb0FjdGlvblxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0NUQUNvbGxlY3Rpb24nO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnY3Rhcy9jdGFjb2xsZWN0aW9uJztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3RhbmRhcmRDYXJkQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBDYXJkQ29tcG9uZW50IGZyb20gJy4vY2FyZGNvbXBvbmVudCc7XG5pbXBvcnQgeyBjYXJkVGVtcGxhdGVzLCBjYXJkVHlwZXMgfSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IENUQUNvbGxlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY3Rhcy9jdGFjb2xsZWN0aW9uY29tcG9uZW50JztcblxuY2xhc3MgU3RhbmRhcmRDYXJkQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuXG4gICAgY29uc3QgZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBkYXRhXG4gICAgICogQHR5cGUge1Jlc3VsdH1cbiAgICAgKi9cbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLnJlc3VsdCB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYXcgcHJvZmlsZSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdCByYXdSZXN1bHQgPSByZXN1bHQuX3JhdyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhTWFwcGluZ3MgYXR0cmlidXRlIG9mIHRoZSBjb25maWdcbiAgICAgKiBpcyBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWRkaXRpb25hbCBjb25maWcgZm9yXG4gICAgICogYSBjYXJkIG9yIGFuIG9iamVjdCB0aGF0IGlzIHRoZSBhZGRpdGlvbmFsIGNvbmZpZy5cbiAgICAgKi9cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIENhcmRDb21wb25lbnQuYXBwbHlEYXRhTWFwcGluZ3MocmF3UmVzdWx0LCBjb25maWcuZGF0YU1hcHBpbmdzIHx8IHt9KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0IGRhdGFcbiAgICAgKiBAdHlwZSB7UmVzdWx0fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gY29uZmlnLmRhdGEgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIGNhcmRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IHJlc3VsdC50aXRsZSB8fCByYXdSZXN1bHQubmFtZSB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIERldGFpbHMgZm9yIHRoZSBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRldGFpbHMgPSB0aGlzLmRldGFpbHMgPT09IG51bGwgPyBudWxsIDogKHRoaXMuZGV0YWlscyB8fCByZXN1bHQuZGV0YWlscyB8fCByYXdSZXN1bHQuZGVzY3JpcHRpb24gfHwgJycpO1xuXG4gICAgLyoqXG4gICAgICogVXJsIHdoZW4geW91IGNsaWNrIHRoZSB0aXRsZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy51cmwgPSB0aGlzLnVybCB8fCByZXN1bHQubGluayB8fCByYXdSZXN1bHQud2Vic2l0ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNob3dNb3JlTGltaXQgaXMgc2V0LCB0aGUgdGV4dCB0aGF0IGRpc3BsYXlzIGJlbmVhdGggaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVUZXh0ID0gdGhpcy5zaG93TW9yZVRleHQgfHwgJ1Nob3cgTW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzaG93TW9yZUxpbWl0IGlzIHNldCwgdGhlIHRleHQgdGhhdCBkaXNwbGF5cyBiZW5lYXRoIGl0IHdoZW4gYWxsIHRleHQgaXMgc2hvd25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0xlc3NUZXh0ID0gdGhpcy5zaG93TGVzc1RleHQgfHwgJ1Nob3cgTGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaG93IG1vcmUgbGluayBpZiB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIHNob3duLFxuICAgICAqIGFuZCB0cnVuY2F0ZSB0aGUgbGFzdCAzIGNoYXJhY3RlcnMgd2l0aCBhbiBlbGxpcHNlcy5cbiAgICAgKiBDbGlja2luZyBzaG93IG1vcmUgc2hvdWxkIGV4cGFuZCB0aGUgcmVzdWx0cyAoYnV0IG5vIOKAnHNob3cgbGVzc+KAnSBsaW5rKS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IHRoaXMuc2hvd01vcmVMaW1pdCB8fCAzNTA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGF0dHJpYnV0ZSBmb3IgdGhlIHRpdGxlIGxpbmsuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRoaXMudGFyZ2V0IHx8ICdfc2VsZic7XG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSB1cmwgdG8gZGlzcGxheVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0aXRsZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGEgJ3Nob3cgbW9yZScgdG9nZ2xlIGJ1dHRvbiBuZWVkcyB0byBiZSByZW5kZXJlZCBhdCBhbGxcbiAgICAgKi9cbiAgICBjb25zdCBkZXRhaWxzT3ZlckxpbWl0ID0gdGhpcy5kZXRhaWxzLmxlbmd0aCA+IHRoaXMuc2hvd01vcmVMaW1pdDtcbiAgICB0aGlzLnNob3dUb2dnbGUgPSB0aGlzLnNob3dNb3JlTGltaXQgJiYgZGV0YWlsc092ZXJMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgc3BpdHMgb3V0IGFuIGFycmF5IG9mIENUQSBjb25maWcgb2JqZWN0cyBvciBhbiBhcnJheSBvZiBDVEEgY29uZmlnIG9iamVjdHNcbiAgICAgKiBvciBhcGkgZmllbGRuYW1lc1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbnxBcnJheTxPYmplY3R8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSB0aGlzLmNhbGxzVG9BY3Rpb24gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIG9yZGluYWwgb2YgdGhlIGNhcmQgaW4gdGhlIHJlc3VsdHMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93T3JkaW5hbCA9IHRoaXMuc2hvd09yZGluYWwgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2FyZCBpcyBwYXJ0IG9mIGEgdW5pdmVyc2FsIHNlYXJjaC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzVW5pdmVyc2FsID0gdGhpcy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2FyZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2luZGV4ID0gY29uZmlnLl9pbmRleCB8fCAwO1xuICB9XG59XG5cbi8qKlxuICogQ2FyZCBjb21wb25lbnRzIGV4cGVjdCB0byByZWNlaXZlIGEgZGF0YSBjb25maWcgb3B0aW9uLCBjb250YWluaW5nIGRhdGEgcmVnYXJkaW5nIGVudGl0eSByZXN1bHRcbiAqIGVhY2ggY2FyZCBpcyBhc3NpZ25lZCB0bywgaW5jbHVkaW5nIGFsbCBmaWVsZCBkYXRhIGluIGRhdGEuX3Jhdy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhbmRhcmRDYXJkQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKG5ldyBTdGFuZGFyZENhcmRDb25maWcoY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcbiAgICB0aGlzLmhpZGVFeGNlc3NEZXRhaWxzID0gdGhpcy5fY29uZmlnLnNob3dUb2dnbGU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBkYXRhLnZlcnRpY2FsS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBkYXRhXG4gICAgICogQHR5cGUge1Jlc3VsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IGRhdGEucmVzdWx0IHx8IHt9O1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5oaWRlRXhjZXNzRGV0YWlsc1xuICAgICAgPyBgJHt0aGlzLl9jb25maWcuZGV0YWlscy5zdWJzdHJpbmcoMCwgdGhpcy5fY29uZmlnLnNob3dNb3JlTGltaXQpfS4uLmBcbiAgICAgIDogdGhpcy5fY29uZmlnLmRldGFpbHM7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBoaWRlRXhjZXNzRGV0YWlsczogdGhpcy5oaWRlRXhjZXNzRGV0YWlscyxcbiAgICAgIHJlc3VsdDogdGhpcy5yZXN1bHQsXG4gICAgICBoYXNDVEFzOiBDVEFDb2xsZWN0aW9uQ29tcG9uZW50Lmhhc0NUQXModGhpcy5yZXN1bHQuX3JhdywgdGhpcy5fY29uZmlnLmNhbGxzVG9BY3Rpb24pLFxuICAgICAgZW50aXR5SWQ6IHRoaXMucmVzdWx0Ll9yYXcuaWQsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy52ZXJ0aWNhbEtleSxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcuc2hvd1RvZ2dsZSkge1xuICAgICAgY29uc3QgZWwgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1TdGFuZGFyZENhcmQtdG9nZ2xlJyk7XG4gICAgICBET00ub24oZWwsICdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlRXhjZXNzRGV0YWlscyA9ICF0aGlzLmhpZGVFeGNlc3NEZXRhaWxzO1xuICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhZGRDaGlsZCAoZGF0YSwgdHlwZSwgb3B0cykge1xuICAgIGlmICh0eXBlID09PSBDVEFDb2xsZWN0aW9uQ29tcG9uZW50LnR5cGUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuICAgICAgICB2ZXJ0aWNhbEtleTogdGhpcy52ZXJ0aWNhbEtleSxcbiAgICAgICAgcmVzdWx0OiBkYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKHVwZGF0ZWREYXRhLCB0eXBlLCB7XG4gICAgICAgIGNhbGxzVG9BY3Rpb246IHRoaXMuX2NvbmZpZy5jYWxsc1RvQWN0aW9uLFxuICAgICAgICBpc1VuaXZlcnNhbDogdGhpcy5fY29uZmlnLmlzVW5pdmVyc2FsLFxuICAgICAgICBfY3RhTW9kaWZpZXJzOiBbJ1N0YW5kYXJkQ2FyZCddLFxuICAgICAgICAuLi5vcHRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gY2FyZFR5cGVzLlN0YW5kYXJkO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiBjYXJkVGVtcGxhdGVzLlN0YW5kYXJkO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFjY29yZGlvbkNhcmRDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IENhcmRDb21wb25lbnQgZnJvbSAnLi9jYXJkY29tcG9uZW50JztcbmltcG9ydCB7IGNhcmRUZW1wbGF0ZXMsIGNhcmRUeXBlcyB9IGZyb20gJy4vY29uc3RzJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi4vLi4vLi4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuaW1wb3J0IENUQUNvbGxlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY3Rhcy9jdGFjb2xsZWN0aW9uY29tcG9uZW50JztcblxuY2xhc3MgQWNjb3JkaW9uQ2FyZENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcblxuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZGF0YVxuICAgICAqIEB0eXBlIHtSZXN1bHR9XG4gICAgICovXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5yZXN1bHQgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHByb2ZpbGUgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgY29uc3QgcmF3UmVzdWx0ID0gcmVzdWx0Ll9yYXcgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YU1hcHBpbmdzIGF0dHJpYnV0ZSBvZiB0aGUgY29uZmlnXG4gICAgICogaXMgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFkZGl0aW9uYWwgY29uZmlnIGZvclxuICAgICAqIGEgY2FyZCBvciBhbiBvYmplY3QgdGhhdCBpcyB0aGUgYWRkaXRpb25hbCBjb25maWcuXG4gICAgICovXG4gICAgY29uc3QgZGF0YU1hcHBpbmdzID0gY29uZmlnLmRhdGFNYXBwaW5ncyB8fCB7fTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIENhcmRDb21wb25lbnQuYXBwbHlEYXRhTWFwcGluZ3MocmF3UmVzdWx0LCBkYXRhTWFwcGluZ3MpKTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGtleSBmb3IgdGhlIGNhcmQsIGFkZGVkIHRvIGFuYWx5dGljcyBldmVudHMgc2VudCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IHJlc3VsdC50aXRsZSB8fCByYXdSZXN1bHQubmFtZSB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZGV0YWlscyA9IHRoaXMuZGV0YWlscyA9PT0gbnVsbCA/IG51bGwgOiAodGhpcy5kZXRhaWxzIHx8IHJlc3VsdC5kZXRhaWxzIHx8IHJhd1Jlc3VsdC5kZXNjcmlwdGlvbiB8fCAnJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiBleHBhbmRlZCBpcyB0cnVlIHRoZSBmaXJzdCBhY2NvcmRpb24gaW4gdmVydGljYWwvdW5pdmVyc2FsIHJlc3VsdHMgcmVuZGVycyBvbiBwYWdlIGxvYWQgZXhwYW5kZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHBhbmRlZCA9IHRoaXMuZXhwYW5kZWQgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBmdW5jdGlvbiB0aGF0IHNwaXRzIG91dCBhbiBhcnJheSBvZiBDVEEgY29uZmlnIG9iamVjdHMgb3IgYW4gYXJyYXkgb2YgQ1RBIGNvbmZpZyBvYmplY3RzXG4gICAgICogb3IgYXBpIGZpZWxkbmFtZXNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258QXJyYXk8T2JqZWN0fHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jYWxsc1RvQWN0aW9uID0gdGhpcy5jYWxsc1RvQWN0aW9uIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNhcmQgaXMgcGFydCBvZiBhIHVuaXZlcnNhbCBzZWFyY2guIFVzZWQgaW4gYW5hbHl0aWNzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNVbml2ZXJzYWwgPSBjb25maWcuaXNVbml2ZXJzYWwgfHwgZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3JkaW9uQ2FyZENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihuZXcgQWNjb3JkaW9uQ2FyZENvbmZpZyhjb25maWcpLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYWNjb3JkaW9uIGlzIGNvbGxhcHNlZCBvciBub3QuXG4gICAgICogRGVmYXVsdHMgdG8gdHJ1ZSBvbmx5IGlmIHRoZSBleHBhbmRlZCBvcHRpb24gaXMgdHJ1ZVxuICAgICAqIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBjYXJkIGluIHRoZSByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNFeHBhbmRlZCA9IHRoaXMuX2NvbmZpZy5leHBhbmRlZCAmJiBjb25maWcuX2luZGV4ID09PSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBjb25zdCBkYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBrZXkgZm9yIHRoZSBjYXJkLCBhZGRlZCB0byBhbmFseXRpY3MgZXZlbnRzIHNlbnQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2FsS2V5ID0gZGF0YS52ZXJ0aWNhbEtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZGF0YSwgc2VudCB0byBjaGlsZHJlbiBDVEEgQ29tcG9uZW50cyB0aGF0IG5lZWQgdGhpcy5cbiAgICAgKiBAdHlwZSB7UmVzdWx0fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gZGF0YS5yZXN1bHQgfHwge307XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5yZXN1bHQuaWQgfHwgdGhpcy5yZXN1bHQub3JkaW5hbDtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHJlc3VsdDogdGhpcy5yZXN1bHQsXG4gICAgICBpc0V4cGFuZGVkOiB0aGlzLmlzRXhwYW5kZWQsXG4gICAgICBpZDogYCR7dGhpcy5uYW1lfS0ke2lkfS0ke3RoaXMudmVydGljYWxLZXl9YCxcbiAgICAgIGhhc0NUQXM6IENUQUNvbGxlY3Rpb25Db21wb25lbnQuaGFzQ1RBcyh0aGlzLnJlc3VsdC5fcmF3LCB0aGlzLl9jb25maWcuY2FsbHNUb0FjdGlvbilcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGljayBoYW5kbGVyIGZvciB0aGUgYWNjb3JkaW9uIHRvZ2dsZSBidXR0b25cbiAgICogVGhpcyBpcyB1c2VkIG92ZXIgc2V0IHN0YXRlIGJlY2F1c2UgaXQncyBhIGxvdCBzbW9vdGhlciwgc2luY2VcbiAgICogaXQgZG9lc24ndCByaXAgdGhlIHdob2xlIGNvbXBvbmVudCBvZmYgb2YgdGhlIHBhZ2UgYW5kIHJlbW91bnQgaXQuXG4gICAqIEFsc28gcmVwb3J0cyBhbiBhbmFseXRpY3MgZXZlbnQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvZ2dsZUVsIHRoZSB0b2dnbGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250ZW50RWwgdGhlIGNvbnRlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhY2NvcmRpb25FbCB0aGUgcm9vdCBhY2NvcmRpb24gZWxlbWVudFxuICAgKi9cbiAgaGFuZGxlQ2xpY2sgKHRvZ2dsZUVsLCBjb250ZW50RWwsIGFjY29yZGlvbkVsKSB7XG4gICAgdGhpcy5pc0V4cGFuZGVkID0gIXRoaXMuaXNFeHBhbmRlZDtcbiAgICBhY2NvcmRpb25FbC5jbGFzc0xpc3QudG9nZ2xlKCd5eHQtQWNjb3JkaW9uQ2FyZC0tZXhwYW5kZWQnKTtcblxuICAgIGNvbnRlbnRFbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmlzRXhwYW5kZWQgPyBjb250ZW50RWwuc2Nyb2xsSGVpZ2h0IDogMH1weGA7XG5cbiAgICB0b2dnbGVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLmlzRXhwYW5kZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICBjb250ZW50RWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuaXNFeHBhbmRlZCA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KHRoaXMuaXNFeHBhbmRlZCA/ICdST1dfRVhQQU5EJyA6ICdST1dfQ09MTEFQU0UnKVxuICAgICAgLmFkZE9wdGlvbnMoe1xuICAgICAgICB2ZXJ0aWNhbEtleTogdGhpcy52ZXJ0aWNhbEtleSxcbiAgICAgICAgZW50aXR5SWQ6IHRoaXMucmVzdWx0Ll9yYXcuaWQsXG4gICAgICAgIHNlYXJjaGVyOiB0aGlzLl9jb25maWcuaXNVbml2ZXJzYWwgPyAnVU5JVkVSU0FMJyA6ICdWRVJUSUNBTCdcbiAgICAgIH0pO1xuICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGNvbnN0IHRvZ2dsZUVsID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtQWNjb3JkaW9uQ2FyZC10b2dnbGUnKTtcbiAgICBjb25zdCBjb250ZW50RWwgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1BY2NvcmRpb25DYXJkLWNvbnRlbnQnKTtcbiAgICBjb25zdCBhY2NvcmRpb25FbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LUFjY29yZGlvbkNhcmQnKTtcblxuICAgIGNvbnRlbnRFbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmlzRXhwYW5kZWQgPyBjb250ZW50RWwuc2Nyb2xsSGVpZ2h0IDogMH1weGA7XG5cbiAgICBET00ub24odG9nZ2xlRWwsICdjbGljaycsICgpID0+IHRoaXMuaGFuZGxlQ2xpY2sodG9nZ2xlRWwsIGNvbnRlbnRFbCwgYWNjb3JkaW9uRWwpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgcGFzc2luZyBmdW5jdGlvbnMgdG8gdGhlIGNvbmZpZyBvZiBjaGlsZHJlbiB7QGxpbmsgQ1RBQ29sbGVjdGlvbkNvbXBvbmVudH1cbiAgICovXG4gIGFkZENoaWxkIChkYXRhLCB0eXBlLCBvcHRzKSB7XG4gICAgaWYgKHR5cGUgPT09IENUQUNvbGxlY3Rpb25Db21wb25lbnQudHlwZSkge1xuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSB7XG4gICAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLnZlcnRpY2FsS2V5LFxuICAgICAgICByZXN1bHQ6IGRhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQodXBkYXRlZERhdGEsIHR5cGUsIHtcbiAgICAgICAgY2FsbHNUb0FjdGlvbjogdGhpcy5fY29uZmlnLmNhbGxzVG9BY3Rpb24sXG4gICAgICAgIF9jdGFNb2RpZmllcnM6IFsnQWNjb3JkaW9uQ2FyZCddLFxuICAgICAgICBpc1VuaXZlcnNhbDogdGhpcy5fY29uZmlnLmlzVW5pdmVyc2FsLFxuICAgICAgICAuLi5vcHRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gY2FyZFR5cGVzLkFjY29yZGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gY2FyZFRlbXBsYXRlcy5BY2NvcmRpb247XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTGVnYWN5Q2FyZENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgQ2FyZENvbXBvbmVudCBmcm9tICcuL2NhcmRjb21wb25lbnQnO1xuaW1wb3J0IHsgY2FyZFRlbXBsYXRlcywgY2FyZFR5cGVzIH0gZnJvbSAnLi9jb25zdHMnO1xuaW1wb3J0IENUQUNvbGxlY3Rpb25Db21wb25lbnQgZnJvbSAnLi4vY3Rhcy9jdGFjb2xsZWN0aW9uY29tcG9uZW50JztcblxuY2xhc3MgTGVnYWN5Q2FyZENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcblxuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZGF0YVxuICAgICAqIEB0eXBlIHtSZXN1bHR9XG4gICAgICovXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5yZXN1bHQgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHByb2ZpbGUgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgY29uc3QgcmF3UmVzdWx0ID0gcmVzdWx0Ll9yYXcgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YU1hcHBpbmdzIGF0dHJpYnV0ZSBvZiB0aGUgY29uZmlnXG4gICAgICogaXMgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFkZGl0aW9uYWwgY29uZmlnIGZvclxuICAgICAqIGEgY2FyZCBvciBhbiBvYmplY3QgdGhhdCBpcyB0aGUgYWRkaXRpb25hbCBjb25maWcuXG4gICAgICovXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBDYXJkQ29tcG9uZW50LmFwcGx5RGF0YU1hcHBpbmdzKHJhd1Jlc3VsdCwgY29uZmlnLmRhdGFNYXBwaW5ncyB8fCB7fSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBkYXRhXG4gICAgICogQHR5cGUge1Jlc3VsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIHRoZSBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gdGhpcy50aXRsZSB8fCByZXN1bHQudGl0bGUgfHwgcmF3UmVzdWx0Lm5hbWUgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhaWxzIGZvciB0aGUgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxzID0gdGhpcy5kZXRhaWxzID09PSBudWxsID8gbnVsbCA6ICh0aGlzLmRldGFpbHMgfHwgcmVzdWx0LmRldGFpbHMgfHwgcmF3UmVzdWx0LmRlc2NyaXB0aW9uIHx8ICcnKTtcblxuICAgIC8qKlxuICAgICAqIFVybCB3aGVuIHlvdSBjbGljayB0aGUgdGl0bGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gdGhpcy51cmwgfHwgcmVzdWx0LmxpbmsgfHwgcmF3UmVzdWx0LndlYnNpdGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGF0dHJpYnV0ZSBmb3IgdGhlIHRpdGxlIGxpbmsuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRoaXMudGFyZ2V0IHx8ICdfc2VsZic7XG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSB1cmwgdG8gZGlzcGxheVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0aXRsZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBmdW5jdGlvbiB0aGF0IHNwaXRzIG91dCBhbiBhcnJheSBvZiBDVEEgY29uZmlnIG9iamVjdHMgb3IgYW4gYXJyYXkgb2YgQ1RBIGNvbmZpZyBvYmplY3RzXG4gICAgICogb3IgYXBpIGZpZWxkbmFtZXNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258QXJyYXk8T2JqZWN0fHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jYWxsc1RvQWN0aW9uID0gdGhpcy5jYWxsc1RvQWN0aW9uIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSBvcmRpbmFsIG9mIHRoZSBjYXJkIGluIHRoZSByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd09yZGluYWwgPSB0aGlzLnNob3dPcmRpbmFsIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNhcmQgaXMgcGFydCBvZiBhIHVuaXZlcnNhbCBzZWFyY2guXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1VuaXZlcnNhbCA9IHRoaXMuaXNVbml2ZXJzYWwgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNhcmQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9pbmRleCA9IGNvbmZpZy5faW5kZXggfHwgMDtcbiAgfVxufVxuXG4vKipcbiAqIENhcmQgY29tcG9uZW50cyBleHBlY3QgdG8gcmVjZWl2ZSBhIGRhdGEgY29uZmlnIG9wdGlvbiwgY29udGFpbmluZyBkYXRhIHJlZ2FyZGluZyBlbnRpdHkgcmVzdWx0XG4gKiBlYWNoIGNhcmQgaXMgYXNzaWduZWQgdG8sIGluY2x1ZGluZyBhbGwgZmllbGQgZGF0YSBpbiBkYXRhLl9yYXcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlZ2FjeUNhcmRDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIobmV3IExlZ2FjeUNhcmRDb25maWcoY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbnN0IGRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBkYXRhLnZlcnRpY2FsS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBkYXRhXG4gICAgICogQHR5cGUge1Jlc3VsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IGRhdGEucmVzdWx0IHx8IHt9O1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5fbGVnYWN5RXZlbnRPcHRpb25zKHRoaXMucmVzdWx0Ll9yYXcuaWQsIHRoaXMucmVzdWx0LmxpbmspLFxuICAgICAgcmVzdWx0OiB0aGlzLnJlc3VsdCxcbiAgICAgIGhhc0NUQXM6IENUQUNvbGxlY3Rpb25Db21wb25lbnQuaGFzQ1RBcyh0aGlzLnJlc3VsdC5fcmF3LCB0aGlzLl9jb25maWcuY2FsbHNUb0FjdGlvbiksXG4gICAgICBlbnRpdHlJZDogdGhpcy5yZXN1bHQuX3Jhdy5pZCxcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLnZlcnRpY2FsS2V5XG4gICAgfSk7XG4gIH1cblxuICBfbGVnYWN5RXZlbnRPcHRpb25zIChlbnRpdHlJZCwgdXJsKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHRoaXMudmVydGljYWxLZXksXG4gICAgICBzZWFyY2hlcjogdGhpcy5fY29uZmlnLmlzVW5pdmVyc2FsID8gJ1VOSVZFUlNBTCcgOiAnVkVSVElDQUwnXG4gICAgfTtcblxuICAgIGlmIChlbnRpdHlJZCkge1xuICAgICAgb3B0aW9ucy5lbnRpdHlJZCA9IGVudGl0eUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIH1cblxuICBhZGRDaGlsZCAoZGF0YSwgdHlwZSwgb3B0cykge1xuICAgIGlmICh0eXBlID09PSBDVEFDb2xsZWN0aW9uQ29tcG9uZW50LnR5cGUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0ge1xuICAgICAgICB2ZXJ0aWNhbEtleTogdGhpcy52ZXJ0aWNhbEtleSxcbiAgICAgICAgcmVzdWx0OiBkYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKHVwZGF0ZWREYXRhLCB0eXBlLCB7XG4gICAgICAgIGNhbGxzVG9BY3Rpb246IHRoaXMuX2NvbmZpZy5jYWxsc1RvQWN0aW9uLFxuICAgICAgICBpc1VuaXZlcnNhbDogdGhpcy5fY29uZmlnLmlzVW5pdmVyc2FsLFxuICAgICAgICBfY3RhTW9kaWZpZXJzOiBbJ0xlZ2FjeUNhcmQnXSxcbiAgICAgICAgaW5jbHVkZUxlZ2FjeUNsYXNzZXM6IHRydWUsXG4gICAgICAgIC4uLm9wdHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQoZGF0YSwgdHlwZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiBjYXJkVHlwZXMuTGVnYWN5O1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiBjYXJkVGVtcGxhdGVzLkxlZ2FjeTtcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFF1ZXN0aW9uU3VibWlzc2lvbiBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9xdWVzdGlvbnN1Ym1pc3Npb24nO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuLi8uLi8uLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgLyoqXG4gICAqIFRoZSBlbnRpdHkgaWRlbnRpZmllciB0aGF0IHRoZSBxdWVzdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqIFRoaXMgaXMgdHlwaWNhbGx5IGFuIG9yZ2FuaXphdGlvbiBvYmplY3RcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gICdlbnRpdHlJZCc6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIENTUyBzZWxlY3RvciB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgZm9ybSBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAqL1xuICAnZm9ybVNlbGVjdG9yJzogJ2Zvcm0nLFxuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsYWJlbCB0byB1c2UgZm9yIHRoZSBlLW1haWwgYWRkcmVzcyBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ2VtYWlsTGFiZWwnOiAnRW1haWwnLFxuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsYWJlbCB0byB1c2UgZm9yIHRoZSBuYW1lIGlucHV0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnbmFtZUxhYmVsJzogJ05hbWUnLFxuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsYWJlbCB0byB1c2UgZm9yIHRoZSBxdWVzdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3F1ZXN0aW9uTGFiZWwnOiAnUXVlc3Rpb24nLFxuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBsYWJlbCB0byB1c2UgZm9yIHRoZSBQcml2YWN5IFBvbGljeVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lUZXh0JzogJ0J5IHN1Ym1pdHRpbmcgbXkgZW1haWwgYWRkcmVzcywgSSBjb25zZW50IHRvIGJlaW5nIGNvbnRhY3RlZCB2aWEgZW1haWwgYXQgdGhlIGFkZHJlc3MgcHJvdmlkZWQuJyxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIHRvIHVzZSBmb3IgdGhlIFN1Ym1pdCBidXR0b25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdidXR0b25MYWJlbCc6ICdTdWJtaXQnLFxuXG4gIC8qKlxuICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBpbiB0aGUgdGl0bGUgYmFyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnc2VjdGlvblRpdGxlJzogJ0FzayBhIFF1ZXN0aW9uJyxcblxuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIHRvIGRpc3BsYXkgaW4gdGhlIHRpdGxlIGJhclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3RlYXNlcic6ICdDYW7igJl0IGZpbmQgd2hhdCB5b3VcXCdyZSBsb29raW5nIGZvcj8gQXNrIGEgcXVlc3Rpb24gYmVsb3cuJyxcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gdXNlIGluIHRoZSB0aXRsZSBiYXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdzZWN0aW9uVGl0bGVJY29uTmFtZSc6ICdzdXBwb3J0JyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gZGlzcGxheSBpbiB0aGUgZmVlZGJhY2sgZm9ybSBhaGVhZCBvZiB0aGUgUXVlc3Rpb24gaW5wdXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdkZXNjcmlwdGlvbic6ICdFbnRlciB5b3VyIHF1ZXN0aW9uIGFuZCBjb250YWN0IGluZm9ybWF0aW9uLCBhbmQgd2VcXCdsbCBnZXQgYmFjayB0byB5b3Ugd2l0aCBhIHJlc3BvbnNlIHNob3J0bHkuJyxcblxuICAvKipcbiAgICogVGhlIHBsYWNlaG9sZGVyIHRleHQgZm9yIHJlcXVpcmVkIGlucHV0c1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3JlcXVpcmVkSW5wdXRQbGFjZWhvbGRlcic6ICcocmVxdWlyZWQpJyxcblxuICAvKipcbiAgICogVGhlIHBsYWNlaG9sZGVyIHRleHQgZm9yIHRoZSBxdWVzdGlvbiB0ZXh0IGFyZWFcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdxdWVzdGlvbklucHV0UGxhY2Vob2xkZXInOiAnRW50ZXIgeW91ciBxdWVzdGlvbiBoZXJlJyxcblxuICAvKipcbiAgICogVGhlIGNvbmZpcm1hdGlvbiB0ZXh0IHRvIGRpc3BsYXkgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRpbmcgZmVlZGJhY2tcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdxdWVzdGlvblN1Ym1pc3Npb25Db25maXJtYXRpb25UZXh0JzogJ1RoYW5rIHlvdSBmb3IgeW91ciBxdWVzdGlvbiEnLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcml2YWN5IHBvbGljeSB1cmwgbGFiZWxcbiAgICogQHR5cGUge3N0cmluZ31cbiAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lVcmxMYWJlbCc6ICdMZWFybiBtb3JlIGhlcmUuJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcHJpdmFjeSBwb2xpY3kgdXJsXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncHJpdmFjeVBvbGljeVVybCc6ICcnLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcml2YWN5IHBvbGljeSBlcnJvciB0ZXh0LCBzaG93biB3aGVuIHRoZSB1c2VyIGRvZXMgbm90IGFncmVlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncHJpdmFjeVBvbGljeUVycm9yVGV4dCc6ICcqIFlvdSBtdXN0IGFncmVlIHRvIHRoZSBwcml2YWN5IHBvbGljeSB0byBzdWJtaXQgYSBxdWVzdGlvbi4nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlbWFpbCBmb3JtYXQgZXJyb3IgdGV4dCwgc2hvd24gd2hlbiB0aGUgdXNlciBzdWJtaXRzIGFuIGludmFsaWQgZW1haWxcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdlbWFpbEZvcm1hdEVycm9yVGV4dCc6ICcqIFBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbmV0d29yayBlcnJvciB0ZXh0LCBzaG93biB3aGVuIHRoZXJlIGlzIGFuIGlzc3VlIHdpdGggdGhlIFFBIFN1Ym1pc3Npb25cbiAgICogcmVxdWVzdC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICduZXR3b3JrRXJyb3JUZXh0JzogJ1dlXFwncmUgc29ycnksIGFuIGVycm9yIG9jY3VycmVkLicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IGlzIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgJ2V4cGFuZGVkJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQgaXMgYSBjb21wb25lbnQgdGhhdCBjcmVhdGVzIGEgZm9ybVxuICogdGhhdHMgZGlzcGxheWVkIHdoZW5ldmVyIGEgcXVlcnkgaXMgcnVuLiBJdCBlbmFibGVzIHRoZSB1c2VyXG4gKiB0byBzdWJtaXQgcXVlc3Rpb25zIHRoYXQgdGhleSBjYW50IGZpbmQgdGhlIGFuc3dlciBmb3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgc3RvcmFnZSBtb2RlbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT047XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxvY2FsZSBhcyBzZXQgaW4gdGhlIGdsb2JhbCBjb25maWdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuTE9DQUxFKTtcblxuICAgIC8qKlxuICAgICAqIE5PVEUoYmlsbHkpIGlmIHRoaXMgaXMgYSBwYXR0ZXJuIHdlIHdhbnQgdG8gZm9sbG93IGZvciBjb25maWd1cmF0aW9uXG4gICAgICogd2Ugc2hvdWxkIGJha2UgaXQgaW50byB0aGUgY29yZSBjbGFzcy5cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUXVlc3Rpb25TdWJtaXNzaW9uIGNvbXBvbmVudCBzaG91bGQgYmUgcmVuZGVyZWQgb25seSBvbmNlIGEgc2VhcmNoIGhhcyBjb21wbGV0ZWQuIElmIHRoZVxuICAgICAqIHNlYXJjaCByZXN1bHRzIGFyZSBzdGlsbCBsb2FkaW5nLCB0aGUgY29tcG9uZW50IHNob3VsZCBub3QgYmUgZGlzcGxheWVkLlxuICAgICAqL1xuICAgIGNvbnN0IG9uUmVzdWx0c1VwZGF0ZSA9IHJlc3VsdHMgPT4ge1xuICAgICAgaWYgKHJlc3VsdHMuc2VhcmNoU3RhdGUgIT09IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORykge1xuICAgICAgICBjb25zdCBxdWVzdGlvblRleHQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3IFF1ZXN0aW9uU3VibWlzc2lvbih7XG4gICAgICAgICAgcXVlc3Rpb25UZXh0OiBxdWVzdGlvblRleHQsXG4gICAgICAgICAgZXhwYW5kZWQ6IHRoaXMuX2NvbmZpZy5leHBhbmRlZFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuTW91bnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIG9uUmVzdWx0c1VwZGF0ZSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlVOSVZFUlNBTF9SRVNVTFRTLCBvblJlc3VsdHNVcGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdxdWVzdGlvbnMvcXVlc3Rpb25zdWJtaXNzaW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGludGVyZmFjZSBhbGlhcyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdRQVN1Ym1pc3Npb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIHZhbGlkYXRpb25Db25maWcgY29udGFpbnMgYSBidW5jaCBvZiBydWxlc1xuICAgKiB0aGF0IGFyZSB1c2VkIHRvIHZhbGlkYXRlIGFnaW5zdCBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAqL1xuICB2YWxpZGF0ZUNvbmZpZyAoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5lbnRpdHlJZCA9PT0gbnVsbCB8fCB0aGlzLl9jb25maWcuZW50aXR5SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ2BlbnRpdHlJZGAgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgUXVlc3Rpb24gU3VibWlzc2lvbicsXG4gICAgICAgICdRdWVzdGlvblN1Ym1pc3Npb24nKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgLy8gQXZvaWQgbW91bnRpbmcgdGhlIGNvbXBvbmVudCBpZiB0aGVyZXMgbm8gZGF0YVxuICAgIC8vIE5vdGUsIDEgYmVjYXVzZSBgY29uZmlnYCBpcyBhbHdheXMgcGFydCBvZiB0aGUgc3RhdGUuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0U3RhdGUoKSkubGVuZ3RoID4gMTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGxldCB0cmlnZ2VyRWwgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLWNvbnRlbnQtdmlzaWJpbGl0eS10b2dnbGUnKTtcbiAgICBpZiAodHJpZ2dlckVsICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmJpbmRGb3JtVG9nZ2xlKHRyaWdnZXJFbCk7XG4gICAgfVxuXG4gICAgbGV0IGZvcm1FbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbmZpZy5mb3JtU2VsZWN0b3IpO1xuICAgIGlmIChmb3JtRWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRGb3JtRm9jdXMoZm9ybUVsKTtcbiAgICB0aGlzLmJpbmRGb3JtU3VibWl0KGZvcm1FbCk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1Gb2N1cyB3aWxsIHdpcmUgdXAgdGhlIERPTSBmb2N1cyBldmVudCB0byBzZXJ2ZXJzaWRlIHJlcG9ydGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICovXG4gIGJpbmRGb3JtRm9jdXMgKGZvcm1FbCkge1xuICAgIGlmICh0aGlzLmFuYWx5dGljc1JlcG9ydGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcXVlc3Rpb25UZXh0ID0gRE9NLnF1ZXJ5KGZvcm1FbCwgJy5qcy1xdWVzdGlvbi10ZXh0Jyk7XG4gICAgRE9NLm9uKHF1ZXN0aW9uVGV4dCwgJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQodGhpcy5nZXRBbmFseXRpY3NFdmVudCgnUVVFU1RJT05fRk9DVVMnKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1TdWJtaXQgaGFuZGxlcyBzdWJtaXR0aW5nIHRoZSBxdWVzdGlvbiB0byB0aGUgc2VydmVyLFxuICAgKiBhbmQgc3VibWl0cyBhbiBldmVudCB0byBzZXJ2ZXJzaWRlIHJlcG9ydGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICovXG4gIGJpbmRGb3JtU3VibWl0IChmb3JtRWwpIHtcbiAgICBET00ub24oZm9ybUVsLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KHRoaXMuZ2V0QW5hbHl0aWNzRXZlbnQoJ1FVRVNUSU9OX1NVQk1JVCcpKTtcblxuICAgICAgLy8gVE9ETyhiaWxseSkgd2UgcHJvYmFibHkgd2FudCB0byBkaXNhYmxlIHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHR3aWNlXG4gICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnZhbGlkYXRlKGZvcm1FbCk7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IHRoaXMucGFyc2UoZm9ybUVsKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShuZXcgUXVlc3Rpb25TdWJtaXNzaW9uKGZvcm1EYXRhLCBlcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlLnN1Ym1pdFF1ZXN0aW9uKHtcbiAgICAgICAgJ2VudGl0eUlkJzogdGhpcy5fY29uZmlnLmVudGl0eUlkLFxuICAgICAgICAncXVlc3Rpb25MYW5ndWFnZSc6IHRoaXMubG9jYWxlLFxuICAgICAgICAnc2l0ZSc6ICdGSVJTVFBBUlRZJyxcbiAgICAgICAgJ25hbWUnOiBmb3JtRGF0YS5uYW1lLFxuICAgICAgICAnZW1haWwnOiBmb3JtRGF0YS5lbWFpbCxcbiAgICAgICAgJ3F1ZXN0aW9uVGV4dCc6IGZvcm1EYXRhLnF1ZXN0aW9uVGV4dCxcbiAgICAgICAgJ3F1ZXN0aW9uRGVzY3JpcHRpb24nOiBmb3JtRGF0YS5xdWVzdGlvbkRlc2NyaXB0aW9uXG4gICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBuZXcgUXVlc3Rpb25TdWJtaXNzaW9uKGZvcm1EYXRhLCB7XG4gICAgICAgICAgICAgICduZXR3b3JrJzogJ1dlXFwncmUgc29ycnksIGFuIGVycm9yIG9jY3VycmVkLidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1Ub2dnbGUgaGFuZGxlcyBleHBhbmRpbmcgYW5kIG1pbWltaXppbmcgdGhlIGNvbXBvbmVudCdzIGZvcm0uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRyaWdnZXJFbFxuICAgKi9cbiAgYmluZEZvcm1Ub2dnbGUgKHRyaWdnZXJFbCkge1xuICAgIERPTS5vbih0cmlnZ2VyRWwsICdjbGljaycsIChlKSA9PiB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgIG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oe1xuICAgICAgICAgIC4uLmZvcm1EYXRhLFxuICAgICAgICAgICdleHBhbmRlZCc6ICFmb3JtRGF0YS5xdWVzdGlvbkV4cGFuZGVkLFxuICAgICAgICAgICdzdWJtaXR0ZWQnOiBmb3JtRGF0YS5xdWVzdGlvblN1Ym1pdHRlZCB9LFxuICAgICAgICBmb3JtRGF0YS5lcnJvcnMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZm9ybSwgYW5kIGJ1aWxkcyBhIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGlucHV0IG5hbWVzXG4gICAqIGFuZCB0ZXh0IGZpZWxkcy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZm9ybUVsXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBwYXJzZSAoZm9ybUVsKSB7XG4gICAgY29uc3QgaW5wdXRGaWVsZHMgPSBET00ucXVlcnlBbGwoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLWZpZWxkJyk7XG4gICAgaWYgKCFpbnB1dEZpZWxkcyB8fCBpbnB1dEZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBsZXQgb2JqID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHZhbCA9IGlucHV0RmllbGRzW2ldLnZhbHVlO1xuICAgICAgaWYgKGlucHV0RmllbGRzW2ldLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgdmFsID0gaW5wdXRGaWVsZHNbaV0uY2hlY2tlZDtcbiAgICAgIH1cbiAgICAgIG9ialtpbnB1dEZpZWxkc1tpXS5uYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgZmllbGRzIGZvciBjb3JyZWN0IGZvcm1hdHRpbmdcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZm9ybUVsXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGVycm9ycyBvYmplY3QgaWYgYW55IGVycm9ycyBmb3VuZFxuICAgKi9cbiAgdmFsaWRhdGUgKGZvcm1FbCkge1xuICAgIGxldCBlcnJvcnMgPSB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBET00ucXVlcnlBbGwoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLWZpZWxkJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZmllbGRzW2ldLmNoZWNrVmFsaWRpdHkoKSkge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIC8vIHNldCBmb2N1cyBzdGF0ZSBvbiBmaXJzdCBlcnJvclxuICAgICAgICAgIGZpZWxkc1tpXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmllbGRzW2ldLm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdlbWFpbCc6XG4gICAgICAgICAgICBlcnJvcnNbJ2VtYWlsRXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc1tpXS52YWxpZGl0eS52YWx1ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgZXJyb3JzWydlbWFpbEVycm9yVGV4dCddID0gdGhpcy5fY29uZmlnLmVtYWlsRm9ybWF0RXJyb3JUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICBlcnJvcnNbJ25hbWVFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ByaXZhY3lQb2xpY3knOlxuICAgICAgICAgICAgZXJyb3JzWydwcml2YWN5UG9saWN5RXJyb3JUZXh0J10gPSB0aGlzLl9jb25maWcucHJpdmFjeVBvbGljeUVycm9yVGV4dDtcbiAgICAgICAgICAgIGVycm9yc1sncHJpdmFjeVBvbGljeUVycm9yJ10gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncXVlc3Rpb25UZXh0JzpcbiAgICAgICAgICAgIGVycm9yc1sncXVlc3Rpb25UZXh0RXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3B0aW9ucyBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29udGV4dCBvZiBhIHJlcG9ydGFibGUgZXZlbnRcbiAgICovXG4gIGdldEFuYWx5dGljc0V2ZW50IChldmVudFR5cGUpIHtcbiAgICBjb25zdCBhbmFseXRpY3NFdmVudCA9IG5ldyBBbmFseXRpY3NFdmVudChldmVudFR5cGUpO1xuICAgIGFuYWx5dGljc0V2ZW50LmFkZE9wdGlvbnMoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBzZWFyY2hlcjogdGhpcy5fdmVydGljYWxLZXkgPyAnVkVSVElDQUwnIDogJ1VOSVZFUlNBTCdcbiAgICB9KTtcbiAgICByZXR1cm4gYW5hbHl0aWNzRXZlbnQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEljb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEljb25Db21wb25lbnRcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHBhcmFtIG9wdHMuaWNvbk5hbWUge3N0cmluZ31cbiAgICogQHBhcmFtIG9wdHMuaWNvblVybCB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBuYW1lIG9mIGFuIGljb24gZnJvbSB0aGUgZGVmYXVsdCBpY29uIHNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pY29uTmFtZSA9IG9wdHMuaWNvbk5hbWUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgLyoqXG4gICAgICogdGhlIHVybCB0byBhIGN1c3RvbSBpbWFnZSBpY29uXG4gICAgICogQHR5cGUge251bGx9XG4gICAgICovXG4gICAgdGhpcy5pY29uVXJsID0gb3B0cy5pY29uVXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhZGRpdGlvbmFsIHN0cmluZyB0byBhcHBlbmQgdG8gdGhlIGljb24ncyBjc3MgY2xhc3MuIE11bHRpcGxlXG4gICAgICogY2xhc3NlcyBzaG91bGQgYmUgc3BhY2UgZGVsaW1pdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IG9wdHMuY2xhc3NOYW1lcyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgaWQgdG8gcGFzcyB0byB0aGUgaWNvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuY29tcGxleENvbnRlbnRzUGFyYW1zID0gb3B0cy5jb21wbGV4Q29udGVudHNQYXJhbXMgfHwge307XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnSWNvbkNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ2ljb25zL2ljb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIGFsbG93aW5nIGR1cGxpY2F0ZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogb3ZlcnJpZGVzIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSB0byBwcm92aWRlIG5hbWUgYW5kIG1hcmt1cFxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcmV0dXJucyB7SWNvbkNvbXBvbmVudH1cbiAgICovXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgaWNvblVybDogdGhpcy5pY29uVXJsLFxuICAgICAgaWNvbk5hbWU6IHRoaXMuaWNvbk5hbWUsXG4gICAgICBuYW1lOiB0aGlzLmljb25OYW1lID8gdGhpcy5pY29uTmFtZSA6ICdjdXN0b20nLFxuICAgICAgY2xhc3NOYW1lczogdGhpcy5jbGFzc05hbWVzLFxuICAgICAgY29tcGxleENvbnRlbnRzUGFyYW1zOiB0aGlzLmNvbXBsZXhDb250ZW50c1BhcmFtc1xuICAgIH0pKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQ1RBQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuLi8uLi8uLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG5jbGFzcyBDVEFDb25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBiZWxvdyB0aGUgQ1RBIGljb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBjb25maWcubGFiZWw7XG5cbiAgICAvKipcbiAgICAgKiBDVEEgaWNvbiwgbWFwcyB0byBhIHNldCBvZiBpY29ucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWNvbiA9IGNvbmZpZy5pY29uO1xuXG4gICAgLyoqXG4gICAgICogVXJsIHRvIGN1c3RvbSBpY29uLCBoYXMgcHJpb3JpdHkgb3ZlciBpY29uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pY29uVXJsID0gY29uZmlnLmljb25Vcmw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBET00gc2hvdWxkIGluY2x1ZGUgbGVnYWN5IGNsYXNzIG5hbWVzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbmNsdWRlTGVnYWN5Q2xhc3NlcyA9IGNvbmZpZy5pbmNsdWRlTGVnYWN5Q2xhc3NlcyB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENsaWNrIHRocm91Z2ggdXJsIGZvciB0aGUgaWNvbiBhbmQgbGFiZWxcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcblxuICAgIC8qKlxuICAgICAqIEFuYWx5dGljcyBldmVudCB0aGF0IHNob3VsZCBmaXJlOlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hbmFseXRpY3NFdmVudFR5cGUgPSBjb25maWcuYW5hbHl0aWNzIHx8ICdDVEFfQ0xJQ0snO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBhdHRyaWJ1dGUgZm9yIHRoZSBDVEEgbGluay5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IGNvbmZpZy50YXJnZXQgfHwgJ19zZWxmJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudE9wdGlvbnMgbmVlZGVkIGZvciB0aGUgZXZlbnQgdG8gZmlyZSwgcGFzc2VkIGFzIGEgc3RyaW5nIG9yIE9iamVjdFxuICAgICAqIGZyb20gY29uZmlnLmRhdGFNYXBwaW5ncyB8fCB7fS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgY29uZmlnLmV2ZW50T3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZXZlbnRPcHRpb25zID0gSlNPTi5wYXJzZShjb25maWcuZXZlbnRPcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudE9wdGlvbnMgPSB0aGlzLmV2ZW50T3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgY3NzIGNsYXNzTmFtZSBtb2RpZmllcnMgZm9yIHRoZSBjdGFcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2N0YU1vZGlmaWVycyA9IGNvbmZpZy5fY3RhTW9kaWZpZXJzO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY3RhIGlzIHRoZSBvbmx5IG9uZSBpbiBpdHMgQ1RBQ29sbGVjdGlvbkNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2lzU29sbyA9IGNvbmZpZy5faXNTb2xvIHx8IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENUQUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihuZXcgQ1RBQ29uZmlnKGNvbmZpZyksIHN5c3RlbUNvbmZpZyk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBjb25zdCBlbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIGAuanMteXh0LUNUQWApO1xuICAgIGlmIChlbCAmJiB0aGlzLl9jb25maWcuZXZlbnRPcHRpb25zKSB7XG4gICAgICBET00ub24oZWwsICdjbGljaycsICgpID0+IHRoaXMucmVwb3J0QW5hbHl0aWNzRXZlbnQoKSk7XG4gICAgfVxuICB9XG5cbiAgcmVwb3J0QW5hbHl0aWNzRXZlbnQgKCkge1xuICAgIGNvbnN0IGFuYWx5dGljc0V2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KHRoaXMuX2NvbmZpZy5hbmFseXRpY3NFdmVudFR5cGUpO1xuICAgIGFuYWx5dGljc0V2ZW50LmFkZE9wdGlvbnModGhpcy5fY29uZmlnLmV2ZW50T3B0aW9ucyk7XG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoYW5hbHl0aWNzRXZlbnQpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0NUQSc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdjdGFzL2N0YSc7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5pbXBvcnQgTmF2aWdhdGlvbkNvbXBvbmVudCBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBTZWFyY2hDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvc2VhcmNoY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXJTZWFyY2hDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvZmlsdGVyc2VhcmNoY29tcG9uZW50JztcbmltcG9ydCBBdXRvQ29tcGxldGVDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvYXV0b2NvbXBsZXRlY29tcG9uZW50JztcbmltcG9ydCBTcGVsbENoZWNrQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL3NwZWxsY2hlY2tjb21wb25lbnQnO1xuaW1wb3J0IExvY2F0aW9uQmlhc0NvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9sb2NhdGlvbmJpYXNjb21wb25lbnQnO1xuXG5pbXBvcnQgRmlsdGVyQm94Q29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9maWx0ZXJib3hjb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlck9wdGlvbnNDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2ZpbHRlcm9wdGlvbnNjb21wb25lbnQnO1xuaW1wb3J0IFJhbmdlRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9yYW5nZWZpbHRlcmNvbXBvbmVudCc7XG5pbXBvcnQgRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9kYXRlcmFuZ2VmaWx0ZXJjb21wb25lbnQnO1xuaW1wb3J0IEZhY2V0c0NvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZmFjZXRzY29tcG9uZW50JztcbmltcG9ydCBHZW9Mb2NhdGlvbkNvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZ2VvbG9jYXRpb25jb21wb25lbnQnO1xuaW1wb3J0IFNvcnRPcHRpb25zQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9zb3J0b3B0aW9uc2NvbXBvbmVudCc7XG5cbmltcG9ydCBEaXJlY3RBbnN3ZXJDb21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL2RpcmVjdGFuc3dlcmNvbXBvbmVudCc7XG5pbXBvcnQgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvYWNjb3JkaW9ucmVzdWx0c2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgVmVydGljYWxSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy92ZXJ0aWNhbHJlc3VsdHNjb21wb25lbnQnO1xuaW1wb3J0IFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL3VuaXZlcnNhbHJlc3VsdHNjb21wb25lbnQnO1xuaW1wb3J0IFBhZ2luYXRpb25Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL3BhZ2luYXRpb25jb21wb25lbnQnO1xuXG5pbXBvcnQgQ2FyZENvbXBvbmVudCBmcm9tICcuL2NhcmRzL2NhcmRjb21wb25lbnQnO1xuaW1wb3J0IFN0YW5kYXJkQ2FyZENvbXBvbmVudCBmcm9tICcuL2NhcmRzL3N0YW5kYXJkY2FyZGNvbXBvbmVudCc7XG5pbXBvcnQgQWNjb3JkaW9uQ2FyZENvbXBvbmVudCBmcm9tICcuL2NhcmRzL2FjY29yZGlvbmNhcmRjb21wb25lbnQnO1xuaW1wb3J0IExlZ2FjeUNhcmRDb21wb25lbnQgZnJvbSAnLi9jYXJkcy9sZWdhY3ljYXJkY29tcG9uZW50JztcblxuaW1wb3J0IEFsdGVybmF0aXZlVmVydGljYWxzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9hbHRlcm5hdGl2ZXZlcnRpY2Fsc2NvbXBvbmVudCc7XG5pbXBvcnQgTWFwQ29tcG9uZW50IGZyb20gJy4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50IGZyb20gJy4vcXVlc3Rpb25zL3F1ZXN0aW9uc3VibWlzc2lvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBJY29uQ29tcG9uZW50IGZyb20gJy4vaWNvbnMvaWNvbmNvbXBvbmVudC5qcyc7XG5pbXBvcnQgQ1RBQ29tcG9uZW50IGZyb20gJy4vY3Rhcy9jdGFjb21wb25lbnQnO1xuaW1wb3J0IENUQUNvbGxlY3Rpb25Db21wb25lbnQgZnJvbSAnLi9jdGFzL2N0YWNvbGxlY3Rpb25jb21wb25lbnQnO1xuaW1wb3J0IFJlc3VsdHNIZWFkZXJDb21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL3Jlc3VsdHNoZWFkZXJjb21wb25lbnQnO1xuXG5jb25zdCBDT01QT05FTlRfQ0xBU1NfTElTVCA9IFtcbiAgLy8gQ29yZSBDb21wb25lbnRcbiAgQ29tcG9uZW50LFxuXG4gIC8vIE5hdmlnYXRpb24gQ29tcG9uZW50c1xuICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuXG4gIC8vIFNlYXJjaCBDb21wb25lbnRzXG4gIFNlYXJjaENvbXBvbmVudCxcbiAgRmlsdGVyU2VhcmNoQ29tcG9uZW50LFxuICBBdXRvQ29tcGxldGVDb21wb25lbnQsXG4gIFNwZWxsQ2hlY2tDb21wb25lbnQsXG4gIExvY2F0aW9uQmlhc0NvbXBvbmVudCxcblxuICAvLyBGaWx0ZXIgQ29tcG9uZW50c1xuICBGaWx0ZXJCb3hDb21wb25lbnQsXG4gIEZpbHRlck9wdGlvbnNDb21wb25lbnQsXG4gIFJhbmdlRmlsdGVyQ29tcG9uZW50LFxuICBEYXRlUmFuZ2VGaWx0ZXJDb21wb25lbnQsXG4gIEZhY2V0c0NvbXBvbmVudCxcbiAgR2VvTG9jYXRpb25Db21wb25lbnQsXG4gIFNvcnRPcHRpb25zQ29tcG9uZW50LFxuXG4gIC8vIFJlc3VsdHMgQ29tcG9uZW50c1xuICBEaXJlY3RBbnN3ZXJDb21wb25lbnQsXG4gIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnQsXG4gIFZlcnRpY2FsUmVzdWx0c0NvbXBvbmVudCxcbiAgUGFnaW5hdGlvbkNvbXBvbmVudCxcbiAgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCxcbiAgTWFwQ29tcG9uZW50LFxuICBBbHRlcm5hdGl2ZVZlcnRpY2Fsc0NvbXBvbmVudCxcbiAgUmVzdWx0c0hlYWRlckNvbXBvbmVudCxcblxuICAvLyBDYXJkIENvbXBvbmVudHNcbiAgQ2FyZENvbXBvbmVudCxcbiAgU3RhbmRhcmRDYXJkQ29tcG9uZW50LFxuICBBY2NvcmRpb25DYXJkQ29tcG9uZW50LFxuICBMZWdhY3lDYXJkQ29tcG9uZW50LFxuXG4gIC8vIFF1ZXN0aW9ucyBDb21wb25lbnRzXG4gIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCxcblxuICAvLyBIZWxwZXIgQ29tcG9uZW50c1xuICBJY29uQ29tcG9uZW50LFxuICBDVEFDb21wb25lbnQsXG4gIENUQUNvbGxlY3Rpb25Db21wb25lbnRcbl07XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCByZWdpc3RyeSBpcyBhIG1hcCB0aGF0IGNvbnRhaW5zXG4gKiBhbGwgYXZhaWxhYmxlIGNvbXBvbmVudCBjbGFzc2VzIHVzZWQgZm9yIGNyZWF0aW9uIG9yIGV4dGVuc2lvbi5cbiAqIEVhY2ggY29tcG9uZW50IGNsYXNzIGhhcyBhIHVuaXF1ZSB0eXBlLCB3aGljaCBpcyB1c2VkIGFzIHRoZSBrZXkgZm9yIHRoZSByZWdpc3RyeVxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDb21wb25lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgQ09NUE9ORU5UX1JFR0lTVFJZID0gQ09NUE9ORU5UX0NMQVNTX0xJU1QucmVkdWNlKChyZWdpc3RyeSwgY2xhenopID0+IHtcbiAgcmVnaXN0cnlbY2xhenoudHlwZV0gPSBjbGF6ejtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufSwge30pO1xuIiwiLyoqIEBtb2R1bGUgQ29tcG9uZW50TWFuYWdlciAqL1xuXG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi9kb20vZG9tJztcbmltcG9ydCB7IENPTVBPTkVOVF9SRUdJU1RSWSB9IGZyb20gJy4vcmVnaXN0cnknO1xuXG4vKipcbiAqIENvbXBvbmVudE1hbmFnZXIgaXMgYSBTaW5nbGV0b25lIHRoYXQgY29udGFpbnMgYm90aCBhbiBpbnRlcm5hbCByZWdpc3RyeSBvZlxuICogZWxpZ2libGUgY29tcG9uZW50cyB0byBiZSBjcmVhdGVkLCBhcyB3ZWxsIGFzIGtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50XG4gKiBpbnN0YW50aWF0ZWQgYW5kIGFjdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIEFMTCBjb21wb25lbnRzIHNob3VsZCBiZSBjb25zdHJ1Y3RlZCB1c2luZyB0aGUge0NvbXBvbmVudE1hbmFnZXJ9IHZpYSBpdHMgYGNyZWF0ZWAgbWV0aG9kLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBhY3RpdmUgY29tcG9uZW50cyBpcyBhbiBpbnRlcm5hbCBjb250YWluZXIgdG8ga2VlcCB0cmFja1xuICAgICAqIG9mIGFsbCBvZiB0aGUgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIGxpYnJhcnkgZGVwZW5kZW5jeVxuICAgICAqXG4gICAgICogVGhlIENvcmUgY29udGFpbnMgYm90aCB0aGUgc3RvcmFnZSBBTkQgc2VydmljZXMgdGhhdCBhcmUgbmVlZGVkIGZvciBwZXJmb3JtaW5nIG9wZXJhdGlvbnNcbiAgICAgKiBsaWtlIHNlYXJjaCBhbmQgYXV0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBzdG9yYWdlIGlzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBzdGF0ZSBvZiBBTEwgY29tcG9uZW50cy5cbiAgICAgKiBXaGVuZXZlciB0aGUgc3RvcmFnZSBpcyB1cGRhdGVkLCB0aGUgc3RhdGUgZ2V0cyBwdXNoZWQgZG93biB0byB0aGUgbmVjZXNzYXJ5IGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0NvcmV9XG4gICAgICovXG4gICAgdGhpcy5fY29yZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSByZW5kZXJlciB0byB1c2UgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogQHR5cGUge0hhbmRsZWJhcnNSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgYW5hbHl0aWNzIHJlcG9ydGVyIGRlcGVuZGVuY3lcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDb21wb25lbnRNYW5hZ2VyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBzZXRSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q29yZSAoY29yZSkge1xuICAgIHRoaXMuX2NvcmUgPSBjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QW5hbHl0aWNzUmVwb3J0ZXIgKHJlcG9ydGVyKSB7XG4gICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiByZWdpc3RlcnMgYSBjb21wb25lbnQgdG8gYmUgZWxpZ2libGUgZm9yIGNyZWF0aW9uIGFuZCBvdmVycmlkZS5cbiAgICogQHBhcmFtIHtDb21wb25lbnR9IFRoZSBDb21wb25lbnQgQ2xhc3MgdG8gcmVnaXN0ZXJcbiAgICovXG4gIHJlZ2lzdGVyIChjb21wb25lbnRDbGF6eikge1xuICAgIENPTVBPTkVOVF9SRUdJU1RSWVtjb21wb25lbnRDbGF6ei50eXBlXSA9IGNvbXBvbmVudENsYXp6O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29tcG9uZW50cyB3aXRoIG5hbWVzIHNpbWlsYXIgdG8gdGhlIHBhc3NlZCBpbiBjb21wb25lbnQgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRUeXBlXG4gICAqL1xuICBnZXRTaW1pbGFyQ29tcG9uZW50cyAoY29tcG9uZW50VHlwZSkge1xuICAgIGxldCBzaW1pbGFyQ29tcG9uZW50cyA9IE9iamVjdC5rZXlzKENPTVBPTkVOVF9SRUdJU1RSWSkuZmlsdGVyKHR5cGUgPT5cbiAgICAgIHR5cGUuc3RhcnRzV2l0aChjb21wb25lbnRUeXBlLnN1YnN0cmluZygwLCAyKSlcbiAgICApO1xuICAgIGlmIChzaW1pbGFyQ29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNpbWlsYXJDb21wb25lbnRzID0gT2JqZWN0LmtleXMoQ09NUE9ORU5UX1JFR0lTVFJZKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbWlsYXJDb21wb25lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGNvbnN0cnVjdGluZyBhbnkgYW5kIGFsbCBjb21wb25lbnRzLlxuICAgKiBJdCB3aWxsIGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQsIGFuZCBib3RoIGFwcGx5XG4gICAqIGluaXRpYWwgc3RhdGUgZnJvbSB0aGUgc3RvcmFnZSBhbmQgYmluZCBpdCB0byB0aGUgc3RvcmFnZSBmb3IgdXBkYXRlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFR5cGUgVGhlIGNvbXBvbmVudCB0eXBlIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwaXBlIHRvIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY3JlYXRlIChjb21wb25lbnRUeXBlLCBvcHRzKSB7XG4gICAgLy8gRXZlcnkgY29tcG9uZW50IG5lZWRzIGxvY2FsIGFjY2VzcyB0byB0aGUgY29tcG9uZW50IG1hbmFnZXJcbiAgICAvLyBiZWNhdXNlIHNvbWV0aW1lcyBjb21wb25lbnRzIGhhdmUgc3ViY29tcG9uZW50cyB0aGF0IG5lZWQgdG8gYmVcbiAgICAvLyBjb25zdHJ1Y3RlZCBkdXJpbmcgY3JlYXRpb25cbiAgICBsZXQgc3lzdGVtT3B0cyA9IHtcbiAgICAgIGNvcmU6IHRoaXMuX2NvcmUsXG4gICAgICByZW5kZXJlcjogdGhpcy5fcmVuZGVyZXIsXG4gICAgICBhbmFseXRpY3NSZXBvcnRlcjogdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXIsXG4gICAgICBjb21wb25lbnRNYW5hZ2VyOiB0aGlzXG4gICAgfTtcblxuICAgIGxldCBjb21wb25lbnRDbGFzcyA9IENPTVBPTkVOVF9SRUdJU1RSWVtjb21wb25lbnRUeXBlXTtcbiAgICBpZiAoIWNvbXBvbmVudENsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50IHR5cGUgJHtjb21wb25lbnRUeXBlfSBpcyBub3QgcmVjb2duaXplZCBhcyBhIHZhbGlkIGNvbXBvbmVudC5gICtcbiAgICAgICAgYCBZb3UgbWlnaHQgaGF2ZSBtZWFudCAke3RoaXMuZ2V0U2ltaWxhckNvbXBvbmVudHMoY29tcG9uZW50VHlwZSkuam9pbignLCAnKX0/YCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWNvbXBvbmVudENsYXNzLmFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCgpICYmXG4gICAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNvbWUoYyA9PiBjLm5hbWUgPT09IG9wdHMubmFtZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgIGBBbm90aGVyIGNvbXBvbmVudCB3aXRoIG5hbWUgJHtvcHRzLm5hbWV9IGFscmVhZHkgZXhpc3RzYCxcbiAgICAgICAgY29tcG9uZW50VHlwZSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgaXNUd2luOiB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNvbWUoY29tcG9uZW50ID0+IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci50eXBlID09PSBjb21wb25lbnRUeXBlKSxcbiAgICAgIC4uLm9wdHNcbiAgICB9O1xuXG4gICAgLy8gSW5zdGFudGlhdGUgb3VyIG5ldyBjb21wb25lbnQgYW5kIGtlZXAgdHJhY2sgb2YgaXRcbiAgICBsZXQgY29tcG9uZW50ID1cbiAgICAgIG5ldyBDT01QT05FTlRfUkVHSVNUUllbY29tcG9uZW50VHlwZV0oY29uZmlnLCBzeXN0ZW1PcHRzKVxuICAgICAgICAuaW5pdChjb25maWcpO1xuXG4gICAgdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGdsb2JhbCBzdG9yYWdlIHRvIHBvd2VyIHN0YXRlLCBhcHBseSB0aGUgc3RhdGVcbiAgICAvLyBmcm9tIHRoZSBzdG9yYWdlIHRvIHRoZSBjb21wb25lbnQsIGFuZCB0aGVuIGJpbmQgdGhlIGNvbXBvbmVudFxuICAgIC8vIHN0YXRlIHRvIHRoZSBzdG9yYWdlIHZpYSBpdHMgdXBkYXRlc1xuICAgIGlmICh0aGlzLl9jb3JlICYmIHRoaXMuX2NvcmUuZ2xvYmFsU3RvcmFnZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbXBvbmVudC5tb2R1bGVJZCA9PT0gdW5kZWZpbmVkIHx8IGNvbXBvbmVudC5tb2R1bGVJZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb3JlLmdsb2JhbFN0b3JhZ2VcbiAgICAgICAgLm9uKCd1cGRhdGUnLCBjb21wb25lbnQubW9kdWxlSWQsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29tcG9uZW50LnNldFN0YXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgY29tcG9uZW50IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGNvbXBvbmVudHMgYW5kIHJlbW92ZVxuICAgKiB0aGUgYXNzb2NpYXRlZCBzdG9yYWdlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZSAoY29tcG9uZW50KSB7XG4gICAgdGhpcy5fY29yZS5nbG9iYWxTdG9yYWdlLm9mZigndXBkYXRlJywgY29tcG9uZW50Lm1vZHVsZUlkKTtcblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5maW5kSW5kZXgoYyA9PiBjLm5hbWUgPT09IGNvbXBvbmVudC5uYW1lKTtcbiAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29tcG5lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVCeU5hbWUgKG5hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9hY3RpdmVDb21wb25lbnRzLmZpbmQoYyA9PiBjLm5hbWUgPT09IG5hbWUpO1xuICAgIGNvbXBvbmVudC5yZW1vdmUoKTtcbiAgICBET00uZW1wdHkoY29tcG9uZW50Ll9jb250YWluZXIpO1xuICB9XG5cbiAgZ2V0QWN0aXZlQ29tcG9uZW50ICh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuZmluZChjID0+IGMuY29uc3RydWN0b3IudHlwZSA9PT0gdHlwZSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFZlcnRpY2FsUGFnZXNDb25maWcgKi9cblxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsUGFnZUNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0YWIgdGhhdCBpcyBleHBvc2VkIGZvciB0aGUgbGlua1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBsZXRlIFVSTCwgaW5jbHVkaW5nIHRoZSBwYXJhbXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gY29uZmlnLnVybCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlcnNpZGUgdmVydGljYWwgY29uZmlnIGlkIHRoYXQgdGhpcyBpcyByZWZlcmVuY2VkIHRvLlxuICAgICAqIEJ5IHByb3ZpZGluZyB0aGlzLCBlbmFibGVzIGR5bmFtaWMgc29ydGluZyBiYXNlZCBvbiByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhpcyB0YWIgaW4gdGhlIG5hdmlnYXRpb24gY29tcG9uZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oaWRlSW5OYXZpZ2F0aW9uID0gY29uZmlnLmhpZGVJbk5hdmlnYXRpb24gfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gc2hvdyB0aGlzIHRhYiBmaXJzdCBpbiB0aGUgb3JkZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRmlyc3QgPSBjb25maWcuaXNGaXJzdCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gYXBwbHkgYSBzcGVjaWFsIGNsYXNzIHRvIHRoZVxuICAgICAqIG1hcmt1cCB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBhY3RpdmUgdGFiXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGNvbmZpZy5pc0FjdGl2ZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIG5hbWUgb2YgYW4gaWNvbiBmcm9tIHRoZSBkZWZhdWx0IGljb24gc2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmljb24gPSBjb25maWcuaWNvbjtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsUGFnZXNDb25maWcge1xuICBjb25zdHJ1Y3RvciAocGFnZXMgPSBbXSkge1xuICAgIHRoaXMudmVydGljYWxQYWdlc0NvbmZpZyA9IFZlcnRpY2FsUGFnZXNDb25maWcuZnJvbShwYWdlcyk7XG4gIH1cblxuICAvKipcbiAgICogVXNpbmcgYSBnZXR0ZXIgdGhhdCBjb3BpZXMgdGhlIGRhdGEgaW5zdGVhZCBvZiBwcm92aWRpbmcgYSByZWZlcmVuY2UgcHJldmVudHMgaXQgZnJvbSBiZWluZyBtdXRhdGVkLlxuICAgKiBUaGlzIGlzIGltcG9ydGFudCBmb3IgZ2xvYmFsIGNvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxWZXJ0aWNhbFBhZ2VDb25maWc+fVxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbFBhZ2VzQ29uZmlnLm1hcChwYWdlID0+ICh7IC4uLnBhZ2UgfSkpO1xuICB9XG5cbiAgc3RhdGljIGZyb20gKHBhZ2VzKSB7XG4gICAgcmV0dXJuIHBhZ2VzLm1hcChwYWdlID0+IG5ldyBWZXJ0aWNhbFBhZ2VDb25maWcocGFnZSkpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5pbXBvcnQgQ29yZSBmcm9tICcuL2NvcmUvY29yZSc7XG5cbmltcG9ydCB7XG4gIERlZmF1bHRUZW1wbGF0ZXNMb2FkZXIsXG4gIFJlbmRlcmVycyxcbiAgRE9NXG59IGZyb20gJy4vdWkvaW5kZXgnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL3VpL2NvbXBvbmVudHMvY29tcG9uZW50JztcblxuaW1wb3J0IEVycm9yUmVwb3J0ZXIgZnJvbSAnLi9jb3JlL2Vycm9ycy9lcnJvcnJlcG9ydGVyJztcbmltcG9ydCBDb25zb2xlRXJyb3JSZXBvcnRlciBmcm9tICcuL2NvcmUvZXJyb3JzL2NvbnNvbGVlcnJvcnJlcG9ydGVyJztcbmltcG9ydCB7IEFuYWx5dGljc1JlcG9ydGVyLCBOb29wQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IFBlcnNpc3RlbnRTdG9yYWdlIGZyb20gJy4vdWkvc3RvcmFnZS9wZXJzaXN0ZW50c3RvcmFnZSc7XG5pbXBvcnQgR2xvYmFsU3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZS9nbG9iYWxzdG9yYWdlJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgU2VhcmNoQ29uZmlnIGZyb20gJy4vY29yZS9tb2RlbHMvc2VhcmNoY29uZmlnJztcbmltcG9ydCBBdXRvQ29tcGxldGVBcGkgZnJvbSAnLi9jb3JlL3NlYXJjaC9hdXRvY29tcGxldGVhcGknO1xuaW1wb3J0IE1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIGZyb20gJy4vY29yZS9zZWFyY2gvbW9ja2F1dG9jb21wbGV0ZXNlcnZpY2UnO1xuaW1wb3J0IFF1ZXN0aW9uQW5zd2VyQXBpIGZyb20gJy4vY29yZS9zZWFyY2gvcXVlc3Rpb25hbnN3ZXJhcGknO1xuaW1wb3J0IE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UgZnJvbSAnLi9jb3JlL3NlYXJjaC9tb2NrcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJztcbmltcG9ydCBTZWFyY2hBcGkgZnJvbSAnLi9jb3JlL3NlYXJjaC9zZWFyY2hhcGknO1xuaW1wb3J0IE1vY2tTZWFyY2hTZXJ2aWNlIGZyb20gJy4vY29yZS9zZWFyY2gvbW9ja3NlYXJjaHNlcnZpY2UnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi91aS9jb21wb25lbnRzL2NvbXBvbmVudG1hbmFnZXInO1xuaW1wb3J0IFZlcnRpY2FsUGFnZXNDb25maWcgZnJvbSAnLi9jb3JlL21vZGVscy92ZXJ0aWNhbHBhZ2VzY29uZmlnJztcbmltcG9ydCB7IFNBTkRCT1gsIFBST0RVQ1RJT04gfSBmcm9tICcuL2NvcmUvY29uc3RhbnRzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvZXJyb3JyZXBvcnRlcnNlcnZpY2UnKS5kZWZhdWx0fSBFcnJvclJlcG9ydGVyU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9hbmFseXRpY3NyZXBvcnRlcnNlcnZpY2UnKS5kZWZhdWx0fSBBbmFseXRpY3NSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBTZXJ2aWNlc1xuICogQHByb3BlcnR5IHtTZWFyY2hTZXJ2aWNlfSBzZWFyY2hTZXJ2aWNlXG4gKiBAcHJvcGVydHkge0F1dG9Db21wbGV0ZVNlcnZpY2V9IGF1dG9Db21wbGV0ZVNlcnZpY2VcbiAqIEBwcm9wZXJ0eSB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfSBxdWVzdGlvbkFuc3dlclNlcnZpY2VcbiAqIEBwcm9wZXJ0eSB7RXJyb3JSZXBvcnRlclNlcnZpY2V9IGVycm9yUmVwb3J0ZXJTZXJ2aWNlXG4gKi9cblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIGxvY2FsZTogJ2VuJ1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBBbnN3ZXJzIGludGVyZmFjZVxuICovXG5jbGFzcyBBbnN3ZXJzIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmICghQW5zd2Vycy5zZXRJbnN0YW5jZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIEFuc3dlcnMuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgQ29tcG9uZW50IGJhc2UgY2xhc3MgZm9yIGN1c3RvbVxuICAgICAqIGNvbXBvbmVudHMgdG8gZXh0ZW5kXG4gICAgICovXG4gICAgdGhpcy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgQW5hbHl0aWNzRXZlbnQgYmFzZSBjbGFzcyBmb3IgcmVwb3J0aW5nXG4gICAgICogY3VzdG9tIGFuYWx5dGljc1xuICAgICAqL1xuICAgIHRoaXMuQW5hbHl0aWNzRXZlbnQgPSBBbmFseXRpY3NFdmVudDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIHRoZSBjb21wb25lbnRzXG4gICAgICogVGhpcyBpcyBwcm92aWRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJzLkhhbmRsZWJhcnMoKTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQgbWFuYWdlclxuICAgICAqIEB0eXBlIHtDb21wb25lbnRNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuY29tcG9uZW50cyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIGFwaVxuICAgICAqIEB0eXBlIHtDb3JlfVxuICAgICAqL1xuICAgIHRoaXMuY29yZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBvbmNlIHRoZSBsaWJyYXJ5IGlzIHJlYWR5LlxuICAgICAqIFR5cGljYWxseSBmaXJlZCBhZnRlciB0ZW1wbGF0ZXMgYXJlIGZldGNoZWQgZnJvbSBzZXJ2ZXIgZm9yIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICB0aGlzLl9vblJlYWR5ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2VydmljZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZXJ2aWNlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBzZXRJbnN0YW5jZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgaW5pdCAoY29uZmlnKSB7XG4gICAgY29uc3QgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZUNvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudmFsaWRhdGVDb25maWcocGFyc2VkQ29uZmlnKTtcblxuICAgIHBhcnNlZENvbmZpZy5zZWFyY2ggPSBuZXcgU2VhcmNoQ29uZmlnKHBhcnNlZENvbmZpZy5zZWFyY2gpO1xuICAgIHBhcnNlZENvbmZpZy52ZXJ0aWNhbFBhZ2VzID0gbmV3IFZlcnRpY2FsUGFnZXNDb25maWcocGFyc2VkQ29uZmlnLnZlcnRpY2FsUGFnZXMpO1xuXG4gICAgY29uc3QgZ2xvYmFsU3RvcmFnZSA9IG5ldyBHbG9iYWxTdG9yYWdlKCk7XG4gICAgY29uc3QgcGVyc2lzdGVudFN0b3JhZ2UgPSBuZXcgUGVyc2lzdGVudFN0b3JhZ2Uoe1xuICAgICAgdXBkYXRlTGlzdGVuZXI6IHBhcnNlZENvbmZpZy5vblN0YXRlQ2hhbmdlLFxuICAgICAgcmVzZXRMaXN0ZW5lcjogZGF0YSA9PiBnbG9iYWxTdG9yYWdlLnNldEFsbChkYXRhKVxuICAgIH0pO1xuICAgIGdsb2JhbFN0b3JhZ2Uuc2V0QWxsKHBlcnNpc3RlbnRTdG9yYWdlLmdldEFsbCgpKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHLCBwYXJzZWRDb25maWcuc2VhcmNoKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5WRVJUSUNBTF9QQUdFU19DT05GSUcsIHBhcnNlZENvbmZpZy52ZXJ0aWNhbFBhZ2VzKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBTEUsIHBhcnNlZENvbmZpZy5sb2NhbGUpO1xuICAgIGdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTiwgcGFyc2VkQ29uZmlnLnNlc3Npb25UcmFja2luZ0VuYWJsZWQpO1xuXG4gICAgdGhpcy5fc2VydmljZXMgPSBwYXJzZWRDb25maWcubW9ja1xuICAgICAgPyBnZXRNb2NrU2VydmljZXMoKVxuICAgICAgOiBnZXRTZXJ2aWNlcyhwYXJzZWRDb25maWcsIGdsb2JhbFN0b3JhZ2UpO1xuXG4gICAgdGhpcy5jb3JlID0gbmV3IENvcmUoe1xuICAgICAgYXBpS2V5OiBwYXJzZWRDb25maWcuYXBpS2V5LFxuICAgICAgZ2xvYmFsU3RvcmFnZTogZ2xvYmFsU3RvcmFnZSxcbiAgICAgIHBlcnNpc3RlbnRTdG9yYWdlOiBwZXJzaXN0ZW50U3RvcmFnZSxcbiAgICAgIGV4cGVyaWVuY2VLZXk6IHBhcnNlZENvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgZmllbGRGb3JtYXR0ZXJzOiBwYXJzZWRDb25maWcuZmllbGRGb3JtYXR0ZXJzLFxuICAgICAgZXhwZXJpZW5jZVZlcnNpb246IHBhcnNlZENvbmZpZy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgIGxvY2FsZTogcGFyc2VkQ29uZmlnLmxvY2FsZSxcbiAgICAgIHNlYXJjaFNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLnNlYXJjaFNlcnZpY2UsXG4gICAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlcy5hdXRvQ29tcGxldGVTZXJ2aWNlLFxuICAgICAgcXVlc3Rpb25BbnN3ZXJTZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlcy5xdWVzdGlvbkFuc3dlclNlcnZpY2VcbiAgICB9KTtcblxuICAgIGlmIChwYXJzZWRDb25maWcub25TdGF0ZUNoYW5nZSAmJiB0eXBlb2YgcGFyc2VkQ29uZmlnLm9uU3RhdGVDaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcnNlZENvbmZpZy5vblN0YXRlQ2hhbmdlKHBlcnNpc3RlbnRTdG9yYWdlLmdldEFsbCgpLCB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzXG4gICAgICAuc2V0Q29yZSh0aGlzLmNvcmUpXG4gICAgICAuc2V0UmVuZGVyZXIodGhpcy5yZW5kZXJlcik7XG5cbiAgICB0aGlzLl9lbGlnaWJsZUZvckFuYWx5dGljcyA9IHBhcnNlZENvbmZpZy5idXNpbmVzc0lkICE9IG51bGw7XG4gICAgaWYgKHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzKSB7XG4gICAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IEluaXRpYWxpemUgd2l0aCBvdGhlciBzZXJ2aWNlc1xuICAgICAgY29uc3QgcmVwb3J0ZXIgPSBwYXJzZWRDb25maWcubW9ja1xuICAgICAgICA/IG5ldyBOb29wQW5hbHl0aWNzUmVwb3J0ZXIoKVxuICAgICAgICA6IG5ldyBBbmFseXRpY3NSZXBvcnRlcihcbiAgICAgICAgICB0aGlzLmNvcmUsXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5idXNpbmVzc0lkLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5hbmFseXRpY3NPcHRpb25zLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5lbnZpcm9ubWVudCk7XG5cbiAgICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyU2VydmljZSA9IHJlcG9ydGVyO1xuXG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0QW5hbHl0aWNzUmVwb3J0ZXIocmVwb3J0ZXIpO1xuICAgICAgaW5pdFNjcm9sbExpc3RlbmVyKHJlcG9ydGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXREZWZhdWx0SW5pdGlhbFNlYXJjaChwYXJzZWRDb25maWcuc2VhcmNoKTtcblxuICAgIHRoaXMuX29uUmVhZHkgPSBwYXJzZWRDb25maWcub25SZWFkeSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGlmIChwYXJzZWRDb25maWcudXNlVGVtcGxhdGVzID09PSBmYWxzZSB8fCBwYXJzZWRDb25maWcudGVtcGxhdGVCdW5kbGUpIHtcbiAgICAgIGlmIChwYXJzZWRDb25maWcudGVtcGxhdGVCdW5kbGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5pbml0KHBhcnNlZENvbmZpZy50ZW1wbGF0ZUJ1bmRsZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uUmVhZHkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRlbXBsYXRlcyBhcmUgY3VycmVudGx5IGRvd25sb2FkZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBDT1JFIGFuZCBVSSBidW5kbGUuXG4gICAgLy8gRnV0dXJlIGVuaGFuY2VtZW50IGlzIHRvIHNoaXAgdGhlIGNvbXBvbmVudHMgd2l0aCB0ZW1wbGF0ZXMgaW4gYSBzZXBhcmF0ZSBidW5kbGUuXG4gICAgdGhpcy50ZW1wbGF0ZXMgPSBuZXcgRGVmYXVsdFRlbXBsYXRlc0xvYWRlcih0ZW1wbGF0ZXMgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5pbml0KHRlbXBsYXRlcyk7XG4gICAgICB0aGlzLl9vblJlYWR5KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRvbVJlYWR5IChjYikge1xuICAgIERPTS5vblJlYWR5KGNiKTtcbiAgfVxuXG4gIG9uUmVhZHkgKGNiKSB7XG4gICAgdGhpcy5fb25SZWFkeSA9IGNiO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgY29uZmlnIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLiBJbiB0aGUgcGFyc2VkIGNvbmZpZywgYW55IG9wdGlvbnMgbm90IHN1cHBsaWVkIGJ5IHRoZVxuICAgKiB1c2VyIGFyZSBnaXZlbiBkZWZhdWx0IHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgdXNlciBzdXBwbGllZCBjb25maWcuXG4gICAqL1xuICBwYXJzZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgY29uc3QgcGFyc2VkQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFMsIGNvbmZpZyk7XG4gICAgbGV0IHNlc3Npb25UcmFja2luZ0VuYWJsZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnNlc3Npb25UcmFja2luZ0VuYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9IGNvbmZpZy5zZXNzaW9uVHJhY2tpbmdFbmFibGVkO1xuICAgIH1cbiAgICBwYXJzZWRDb25maWcuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9IHNlc3Npb25UcmFja2luZ0VuYWJsZWQ7XG5cbiAgICBjb25zdCBzYW5kYm94UHJlZml4ID0gYCR7U0FOREJPWH0tYDtcbiAgICBwYXJzZWRDb25maWcuYXBpS2V5LmluY2x1ZGVzKHNhbmRib3hQcmVmaXgpXG4gICAgICA/IHBhcnNlZENvbmZpZy5lbnZpcm9ubWVudCA9IFNBTkRCT1hcbiAgICAgIDogcGFyc2VkQ29uZmlnLmVudmlyb25tZW50ID0gUFJPRFVDVElPTjtcbiAgICBwYXJzZWRDb25maWcuYXBpS2V5ID0gcGFyc2VkQ29uZmlnLmFwaUtleS5yZXBsYWNlKHNhbmRib3hQcmVmaXgsICcnKTtcblxuICAgIHJldHVybiBwYXJzZWRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBBbnN3ZXJzIGNvbmZpZyBvYmplY3QgdG8gZW5zdXJlIHRoaW5ncyBsaWtlIGFwaSBrZXkgYW5kIGV4cGVyaWVuY2Uga2V5IGFyZVxuICAgKiBwcm9wZXJseSBzZXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIEFuc3dlcnMgY29uZmlnLlxuICAgKi9cbiAgdmFsaWRhdGVDb25maWcgKGNvbmZpZykge1xuICAgIC8vIFRPRE8gKHRtZXllcik6IEV4dHJhY3QgdGhpcyBtZXRob2QgaW50byBpdCdzIG93biBjbGFzcy4gSW52ZXN0aWdhdGUgdGhlIHVzZSBvZiBKU09OIHNjaGVtYVxuICAgIC8vIHRvIHZhbGlkYXRlIHRoZXNlIGNvbmZpZ3MuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuYXBpS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGBhcGlLZXlgLiBUeXBlIG11c3QgYmUge3N0cmluZ30nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5leHBlcmllbmNlS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGBleHBlcmllbmNlS2V5YC4gVHlwZSBtdXN0IGJlIHtzdHJpbmd9Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY3VzdG9tIGNvbXBvbmVudCB0eXBlIHNvIGl0IGNhbiBiZSBjcmVhdGVkIHZpYVxuICAgKiBhZGRDb21wb25lbnQgYW5kIHVzZWQgYXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudENsYXNzXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudFR5cGUgKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGhpcy5jb21wb25lbnRzLnJlZ2lzdGVyKGNvbXBvbmVudENsYXNzKTtcbiAgfVxuXG4gIGFkZENvbXBvbmVudCAodHlwZSwgb3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogb3B0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21wb25lbnRzLmNyZWF0ZSh0eXBlLCBvcHRzKS5tb3VudCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoJ0ZhaWxlZCB0byBhZGQgY29tcG9uZW50JywgdHlwZSwgZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29tcG9uZW50IC0gYW5kIGFsbCBvZiBpdHMgY2hpbGRyZW4gLSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDb21wb25lbnQgKG5hbWUpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMucmVtb3ZlQnlOYW1lKG5hbWUpO1xuICB9XG5cbiAgY3JlYXRlQ29tcG9uZW50IChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5jcmVhdGUoJ0NvbXBvbmVudCcsIG9wdHMpLm1vdW50KCk7XG4gIH1cblxuICByZWdpc3RlckhlbHBlciAobmFtZSwgY2IpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlZ2lzdGVySGVscGVyKG5hbWUsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHQgaW4gb3Igb3V0IG9mIGNvbnZlcnRpb24gdHJhY2tpbmcgYW5hbHl0aWNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0SW5cbiAgICovXG4gIHNldENvbnZlcnNpb25zT3B0SW4gKG9wdEluKSB7XG4gICAgaWYgKHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzKSB7XG4gICAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlclNlcnZpY2Uuc2V0Q29udmVyc2lvblRyYWNraW5nRW5hYmxlZChvcHRJbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wdCBpbiBvciBvdXQgb2Ygc2Vzc2lvbiBjb29raWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0SW5cbiAgICovXG4gIHNldFNlc3Npb25zT3B0SW4gKG9wdEluKSB7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTiwgb3B0SW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzZWFyY2ggcXVlcnkgb24gaW5pdGlhbGl6YXRpb24gZm9yIHZlcnRpY2FsIHNlYXJjaGVycyB0aGF0IGhhdmUgYVxuICAgKiBkZWZhdWx0SW5pdGlhbFNlYXJjaCBwcm92aWRlZCwgaWYgdGhlIHVzZXIgaGFzbid0IGFscmVhZHkgcHJvdmlkZWQgdGhlaXJcbiAgICogb3duIHZpYSBVUkwgcGFyYW0uXG4gICAqIEBwYXJhbSB7U2VhcmNoQ29uZmlnfSBzZWFyY2hDb25maWdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXREZWZhdWx0SW5pdGlhbFNlYXJjaCAoc2VhcmNoQ29uZmlnKSB7XG4gICAgaWYgKHNlYXJjaENvbmZpZy5kZWZhdWx0SW5pdGlhbFNlYXJjaCA9PSBudWxsIHx8ICFzZWFyY2hDb25maWcudmVydGljYWxLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJlcG9wdWxhdGVkUXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgaWYgKHByZXBvcHVsYXRlZFF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KCdxdWVyeVRyaWdnZXInLCAnaW5pdGlhbGl6ZScpO1xuICAgIHRoaXMuY29yZS5zZXRRdWVyeShzZWFyY2hDb25maWcuZGVmYXVsdEluaXRpYWxTZWFyY2gpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtHbG9iYWxTdG9yYWdlfSBnbG9iYWxTdG9yYWdlXG4gKiBAcmV0dXJucyB7U2VydmljZXN9XG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZpY2VzIChjb25maWcsIGdsb2JhbFN0b3JhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWFyY2hTZXJ2aWNlOiBuZXcgU2VhcmNoQXBpKHtcbiAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgIGV4cGVyaWVuY2VLZXk6IGNvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgZXhwZXJpZW5jZVZlcnNpb246IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgIGxvY2FsZTogY29uZmlnLmxvY2FsZSxcbiAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICB9KSxcbiAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiBuZXcgQXV0b0NvbXBsZXRlQXBpKFxuICAgICAge1xuICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICAgIGV4cGVyaWVuY2VLZXk6IGNvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICBsb2NhbGU6IGNvbmZpZy5sb2NhbGUsXG4gICAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgIH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBRdWVzdGlvbkFuc3dlckFwaShcbiAgICAgIHsgYXBpS2V5OiBjb25maWcuYXBpS2V5LCBlbnZpcm9ubWVudDogY29uZmlnLmVudmlyb25tZW50IH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKSxcbiAgICBlcnJvclJlcG9ydGVyU2VydmljZTogbmV3IEVycm9yUmVwb3J0ZXIoXG4gICAgICB7XG4gICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICAgIGV4cGVyaWVuY2VWZXJzaW9uOiBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgIHByaW50VmVyYm9zZTogY29uZmlnLmRlYnVnLFxuICAgICAgICBzZW5kVG9TZXJ2ZXI6ICFjb25maWcuc3VwcHJlc3NFcnJvclJlcG9ydHMsXG4gICAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgIH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKVxuICB9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtTZXJ2aWNlc31cbiAqL1xuZnVuY3Rpb24gZ2V0TW9ja1NlcnZpY2VzICgpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWFyY2hTZXJ2aWNlOiBuZXcgTW9ja1NlYXJjaFNlcnZpY2UoKSxcbiAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiBuZXcgTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2UoKSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlKCksXG4gICAgZXJyb3JSZXBvcnRlclNlcnZpY2U6IG5ldyBDb25zb2xlRXJyb3JSZXBvcnRlcigpXG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRvIHNlbmQgYW5hbHl0aWNzIGV2ZW50c1xuICogd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBib3R0b20uIERlYm91bmNlcyBzY3JvbGwgZXZlbnRzIHNvXG4gKiB0aGV5IGFyZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHVzZXIgc3RvcHMgc2Nyb2xsaW5nXG4gKi9cbmZ1bmN0aW9uIGluaXRTY3JvbGxMaXN0ZW5lciAocmVwb3J0ZXIpIHtcbiAgY29uc3QgREVCT1VOQ0VfVElNRSA9IDEwMDtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuXG4gIGNvbnN0IHNlbmRFdmVudCA9ICgpID0+IHtcbiAgICBpZiAoKHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5wYWdlWU9mZnNldCkgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KCdTQ1JPTExfVE9fQk9UVE9NX09GX1BBR0UnKTtcbiAgICAgIHJlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEV2ZW50LCBERUJPVU5DRV9USU1FKTtcbiAgfSk7XG59XG5cbmNvbnN0IEFOU1dFUlMgPSBuZXcgQW5zd2VycygpO1xuZXhwb3J0IGRlZmF1bHQgQU5TV0VSUztcbiJdLCJuYW1lcyI6WyJQUkVfU0VBUkNIIiwiU0VBUkNIX0xPQURJTkciLCJTRUFSQ0hfQ09NUExFVEUiLCJSZXN1bHQiLCJkYXRhIiwiX3JhdyIsInJhdyIsIl9mb3JtYXR0ZWQiLCJmb3JtYXR0ZWQiLCJfaGlnaGxpZ2h0ZWQiLCJoaWdobGlnaHRlZCIsIm9yZGluYWwiLCJ0aXRsZSIsImRldGFpbHMiLCJsaW5rIiwiaWQiLCJzdWJ0aXRsZSIsIm1vZGlmaWVyIiwiYmlnRGF0ZSIsImltYWdlIiwiY2FsbHNUb0FjdGlvbiIsImNvbGxhcHNlZCIsInVuZGVmaW5lZCIsIkhpZ2hsaWdodGVkVmFsdWUiLCJ2YWx1ZSIsInNob3J0VmFsdWUiLCJtYXRjaGVkU3Vic3RyaW5ncyIsIl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MiLCJidWlsZEhpZ2hsaWdodGVkVmFsdWUiLCJpbnZlcnRlZFN1YnN0cmluZ3MiLCJfZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzIiwibGVuZ3RoIiwidmFsIiwiaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzIiwiaGlnaGxpZ2h0ZWRWYWx1ZSIsIm5leHRTdGFydCIsImoiLCJzdGFydCIsIk51bWJlciIsIm9mZnNldCIsImVuZCIsInNsaWNlIiwiam9pbiIsInNvcnQiLCJhIiwiYiIsInZhbHVlTGVuZ3RoIiwiaSIsInN1YnN0cmluZyIsIm5leHRPZmZzZXQiLCJwdXNoIiwiQW5zd2Vyc0Jhc2VFcnJvciIsImVycm9yQ29kZSIsIm1lc3NhZ2UiLCJib3VuZGFyeSIsImNhdXNlZEJ5IiwiZXJyb3JNZXNzYWdlIiwicmVwb3J0ZWQiLCJmcm9tIiwic3RhY2siLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyaW5nIiwidG9TdHJpbmciLCJidWlsdGluRXJyb3IiLCJlcnJvciIsIkFuc3dlcnNCYXNpY0Vycm9yIiwiRXJyb3IiLCJBbnN3ZXJzQ29uZmlnRXJyb3IiLCJBbnN3ZXJzQ29tcG9uZW50RXJyb3IiLCJjb21wb25lbnQiLCJBbnN3ZXJzRW5kcG9pbnRFcnJvciIsIkFuc3dlcnNDb3JlRXJyb3IiLCJBbnN3ZXJzU3RvcmFnZUVycm9yIiwic3RvcmFnZUtleSIsIkFuc3dlcnNBbmFseXRpY3NFcnJvciIsImV2ZW50IiwiUmVzdWx0RmFjdG9yeSIsInJlc3VsdHNEYXRhIiwiZm9ybWF0dGVycyIsInZlcnRpY2FsSWQiLCJzb3VyY2UiLCJyZXN1bHRzIiwiZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSIsImZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lIiwiZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUiLCJmcm9tQWxnb2xpYVNlYXJjaEVuZ2luZSIsImhpZ2hsaWdodGVkRmllbGRzIiwiZnJvbUtub3dsZWRnZU1hbmFnZXIiLCJmcm9tR2VuZXJpYyIsImVudGl0eVByb2ZpbGVEYXRhIiwiaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSIsIk9iamVjdCIsImtleXMiLCJmb3JtYXR0ZWREYXRhIiwiZW50cmllcyIsImZvckVhY2giLCJmaWVsZE5hbWUiLCJmaWVsZFZhbCIsImhpZ2hsaWdodGVkRmllbGRWYWwiLCJlbnRpdHlGaWVsZFZhbHVlIiwiaGlnaGxpZ2h0ZWRFbnRpdHlGaWVsZFZhbHVlIiwiaXNEaXJlY3RBbnN3ZXIiLCJoaWdobGlnaHRlZERhdGEiLCJoaWdobGlnaHRlZEZpZWxkTmFtZSIsImhpZ2hsaWdodGVkRmllbGQiLCJjb21wdXRlSGlnaGxpZ2h0ZWREYXRhIiwiaGlnaGxpZ2h0ZWREYXRhVmFsdWUiLCJpbmRleCIsIm5hbWUiLCJ0cnVuY2F0ZSIsImRlc2NyaXB0aW9uIiwid2Vic2l0ZSIsImZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhIiwiY29tcHV0ZUZvcm1hdHRlZERhdGEiLCJyZXN1bHREZXRhaWxzIiwiaHRtbFRpdGxlIiwicmVwbGFjZSIsImh0bWxTbmlwcGV0Iiwic25pcHBldCIsInVybCIsImh0bWxfdXJsIiwib2JqZWN0SUQiLCJzdHIiLCJsaW1pdCIsInRyYWlsaW5nIiwic2VwIiwid29yZHMiLCJzcGxpdCIsIm1heCIsInRydW5jYXRlZCIsIndvcmQiLCJTZWN0aW9uIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZXMiLCJ2ZXJ0aWNhbENvbmZpZ0lkIiwicmVzdWx0c0NvdW50IiwiZW5jb2RlZFN0YXRlIiwiYXBwbGllZFF1ZXJ5RmlsdGVycyIsIkFwcGxpZWRRdWVyeUZpbHRlciIsImZhY2V0cyIsIm1hcCIsInBhcnNlTWFwIiwidmVydGljYWxVUkwiLCJtYXBNYXJrZXJzIiwiY2VudGVyQ29vcmRpbmF0ZXMiLCJyZXN1bHQiLCJ5ZXh0RGlzcGxheUNvb3JkaW5hdGUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsIml0ZW0iLCJsYWJlbCIsIm1vZHVsZXMiLCJ1cmxzIiwic2VjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhcHBsaWVkUXVlcnlGaWx0ZXIiLCJrZXkiLCJkaXNwbGF5S2V5IiwiZGlzcGxheVZhbHVlIiwiZmlsdGVycyIsIlVuaXZlcnNhbFJlc3VsdHMiLCJxdWVyeUlkIiwicmVzcG9uc2UiLCJEaXJlY3RBbnN3ZXIiLCJkaXJlY3RBbnN3ZXIiLCJhc3NpZ24iLCJmcmVlemUiLCJhbnN3ZXIiLCJyZWxhdGVkSXRlbSIsImZpZWxkQXBpTmFtZSIsImZpZWxkVmFsdWVzIiwiTmF2aWdhdGlvbiIsInRhYk9yZGVyIiwibmF2IiwiTk9STUFMIiwiTk9fUkVTVUxUUyIsIlZlcnRpY2FsUmVzdWx0cyIsInJlc3VsdHNDb250ZXh0IiwibWVyZ2VkIiwiY29uY2F0IiwiYWxsUmVzdWx0c0ZvclZlcnRpY2FsIiwidmVydGljYWxLZXkiLCJoYXNSZXN1bHRzIiwiX2Zvcm1SZXNwb25zZUZyb21BbGxSZXN1bHRzRm9yVmVydGljYWwiLCJSZXN1bHRzQ29udGV4dCIsIlNwZWxsQ2hlY2siLCJxdWVyeSIsImNvcnJlY3RlZFF1ZXJ5IiwidHlwZSIsInNob3VsZFNob3ciLCJvcmlnaW5hbFF1ZXJ5IiwiTkFWSUdBVElPTiIsIlVOSVZFUlNBTF9SRVNVTFRTIiwiVkVSVElDQUxfUkVTVUxUUyIsIkFMVEVSTkFUSVZFX1ZFUlRJQ0FMUyIsIkFVVE9DT01QTEVURSIsIkRJUkVDVF9BTlNXRVIiLCJGSUxURVIiLCJRVUVSWSIsIlFVRVJZX0lEIiwiRkFDRVRfRklMVEVSIiwiRFlOQU1JQ19GSUxURVJTIiwiUEFSQU1TIiwiR0VPTE9DQVRJT04iLCJJTlRFTlRTIiwiUVVFU1RJT05fU1VCTUlTU0lPTiIsIlNFQVJDSF9DT05GSUciLCJTRUFSQ0hfT0ZGU0VUIiwiU1BFTExfQ0hFQ0siLCJMT0NBVElPTl9CSUFTIiwiU0VTU0lPTlNfT1BUX0lOIiwiVkVSVElDQUxfUEFHRVNfQ09ORklHIiwiTE9DQUxFIiwiU09SVF9CWVMiLCJOT19SRVNVTFRTX0NPTkZJRyIsIkR5bmFtaWNGaWx0ZXJzIiwiZHluYW1pY0ZpbHRlcnMiLCJmIiwiZmllbGRJZCIsIm9wdGlvbnMiLCJvIiwiY291bnRMYWJlbCIsInNlbGVjdGVkIiwiZmlsdGVyIiwiU2VhcmNoSW50ZW50cyIsImludGVudHMiLCJuZWFyTWUiLCJpbmNsdWRlcyIsIkxvY2F0aW9uQmlhcyIsImFjY3VyYWN5IiwibG9jYXRpb25EaXNwbGF5TmFtZSIsIkFsdGVybmF0aXZlVmVydGljYWxzIiwiYWx0ZXJuYXRpdmVWZXJ0aWNhbHMiLCJTZWFyY2hEYXRhVHJhbnNmb3JtZXIiLCJTdG9yYWdlS2V5cyIsInNlYXJjaEludGVudHMiLCJzcGVsbENoZWNrIiwibG9jYXRpb25CaWFzIiwiUXVlc3Rpb25TdWJtaXNzaW9uIiwicXVlc3Rpb24iLCJlcnJvcnMiLCJlbWFpbCIsInByaXZhY3lQb2xpY3kiLCJxdWVzdGlvblRleHQiLCJxdWVzdGlvbkRlc2NyaXB0aW9uIiwicXVlc3Rpb25FeHBhbmRlZCIsImV4cGFuZGVkIiwicXVlc3Rpb25TdWJtaXR0ZWQiLCJzdWJtaXR0ZWQiLCJGaWx0ZXIiLCJyZXNwb25zZUZpbHRlciIsInBhcnNlIiwiZ3JvdXBzIiwiZ3JvdXBGaWx0ZXJzIiwiZmllbGQiLCJvciIsImFuZCIsIl9mcm9tTWF0Y2hlciIsIm1pbiIsImxhdCIsImxuZyIsInJhZGl1cyIsIm1hdGNoZXIiLCJDb3JlIiwiY29uZmlnIiwiX2FwaUtleSIsImFwaUtleSIsIl9leHBlcmllbmNlS2V5IiwiZXhwZXJpZW5jZUtleSIsIl9leHBlcmllbmNlVmVyc2lvbiIsImV4cGVyaWVuY2VWZXJzaW9uIiwiX2xvY2FsZSIsImxvY2FsZSIsIl9maWVsZEZvcm1hdHRlcnMiLCJmaWVsZEZvcm1hdHRlcnMiLCJnbG9iYWxTdG9yYWdlIiwicGVyc2lzdGVudFN0b3JhZ2UiLCJfc2VhcmNoZXIiLCJzZWFyY2hTZXJ2aWNlIiwiX2F1dG9Db21wbGV0ZSIsImF1dG9Db21wbGV0ZVNlcnZpY2UiLCJfcXVlc3Rpb25BbnN3ZXIiLCJxdWVzdGlvbkFuc3dlclNlcnZpY2UiLCJhcHBlbmQiLCJzZXQiLCJzZWFyY2hMb2FkaW5nIiwidmVydGljYWxTZWFyY2giLCJnZXRTdGF0ZSIsImdlb2xvY2F0aW9uIiwiaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJfaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJza2lwU3BlbGxDaGVjayIsInF1ZXJ5VHJpZ2dlciIsInNlc3Npb25UcmFja2luZ0VuYWJsZWQiLCJzb3J0QnlzIiwidGhlbiIsInRyYW5zZm9ybVZlcnRpY2FsIiwibWVyZ2VkUmVzdWx0cyIsImFsbEZpbHRlcnMiLCJnZXRBbGwiLCJ0b3RhbEZpbHRlciIsImZhY2V0RmlsdGVyIiwiaW5wdXQiLCJxdWVyeVN0cmluZyIsInVuaXZlcnNhbFNlYXJjaCIsInRyYW5zZm9ybSIsIm5hbWVzcGFjZSIsInF1ZXJ5VW5pdmVyc2FsIiwicXVlcnlWZXJ0aWNhbCIsInF1ZXJ5RmlsdGVyIiwic3VibWl0UXVlc3Rpb24iLCJzb3J0QnlPcHRpb25zIiwib3B0aW9uIiwiZGlyZWN0aW9uIiwiZXZ0IiwibW9kdWxlSWQiLCJjYiIsIm9uIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJET00iLCJkIiwicCIsImh0bWwiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiZnJhZyIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiYXBwZW5kQ2hpbGQiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwicGFyZW50Iiwic2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIldpbmRvdyIsIkhUTUxEb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVhZHlTdGF0ZSIsImVsIiwib3B0c19kYXRhIiwibm9kZSIsInByb3BzIiwiYWRkQ2xhc3MiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJjbGFzc05hbWUiLCJjbGFzc2VzIiwibGVuIiwiY2xhc3NMaXN0IiwiYWRkIiwiaW5uZXJIVE1MIiwic3R5bGVzIiwicHJvcCIsInN0eWxlIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsImF0dHJzIiwic2V0dGluZ3MiLCJlIiwiX2N1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRldGFpbCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImN0eHQiLCJ0YXJnZXQiLCJpc0VxdWFsTm9kZSIsIm1hdGNoZXMiLCJwYXJlbnROb2RlIiwiZWxlbWVudCIsInBvdGVudGlhbE1hdGNoIiwiRWxlbWVudCIsInByb3RvdHlwZSIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiU2VhcmNoUGFyYW1zIiwiX3BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsInNlYXJjaCIsImluZGV4T2YiLCJlbmNvZGVkUGFyYW1zIiwia2V5VmFsIiwiZGVjb2RlIiwiU3RyaW5nIiwiZW5jb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJSZW5kZXJlciIsInRlbXBsYXRlIiwiU1ZHSWNvbiIsInBhdGgiLCJjb21wbGV4Q29udGVudHMiLCJ2aWV3Qm94IiwiY29udGVudHMiLCJwYXRoRGVmaW5pdGlvbiIsImNvbXBsZXhDb250ZW50c1BhcmFtcyIsInBhcnNlQ29udGVudHMiLCJpY29uUHJlZml4IiwiaWNvbnNBcnJheSIsInRodW1iSWNvbiIsInJlY2VpcHRJY29uIiwicGFudGhlb25JY29uIiwibWljSWNvbiIsImRpcmVjdGlvbnNJY29uIiwiY2FsZW5kYXJJY29uIiwiY2FsbG91dEljb24iLCJpbmZvSWNvbiIsImJyaWVmY2FzZUljb24iLCJrYWJvYkljb24iLCJwZXJzb25JY29uIiwibWFnbmlmeWluZ0dsYXNzSWNvbiIsIm9mZmljZUljb24iLCJsaW5rSWNvbiIsIndpbmRvd0ljb24iLCJwaG9uZUljb24iLCJ0YWdJY29uIiwiZG9jdW1lbnRJY29uIiwiY2hldnJvbkljb24iLCJzdXBwb3J0SWNvbiIsInlleHRJY29uIiwicGluSWNvbiIsImdlYXJJY29uIiwibGlnaHRCdWxiSWNvbiIsImVsZW1lbnRzIiwiY2xvc2UiLCJ5ZXh0QW5pbWF0ZWRGb3J3YXJkIiwieWV4dEFuaW1hdGVkUmV2ZXJzZSIsInN0YXJJY29uIiwiSWNvbnMiLCJpY29uIiwibWFya3VwIiwiSGFuZGxlYmFyc1JlbmRlcmVyIiwidGVtcGxhdGVzIiwiX2hhbmRsZWJhcnMiLCJfaGIiLCJfdGVtcGxhdGVzIiwiX3JlZ2lzdGVyQ3VzdG9tSGVscGVycyIsInJlZ2lzdGVySGVscGVyIiwiU2FmZVN0cmluZyIsImVzY2FwZUV4cHJlc3Npb24iLCJjb21waWxlIiwidGVtcGxhdGVOYW1lIiwiYXJnMSIsImFyZzIiLCJmbiIsImludmVyc2UiLCJwaG9uZU51bWJlclN0cmluZyIsImNsZWFuZWQiLCJpbnRsQ29kZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJyb290IiwidiIsIm51bWJlciIsInNpbmd1bGFyVGV4dCIsInBsdXJhbFRleHQiLCJzZWxmIiwiZ2V0SW52ZXJ0ZWQiLCJlc2NhcGVkSW5wdXQiLCJoaWdobGlnaHRlZFZhbCIsImdldCIsIlJlbmRlcmVycyIsIlNPWSIsIkhhbmRsZWJhcnMiLCJMSUJfVkVSU0lPTiIsIlBST0RVQ1RJT04iLCJTQU5EQk9YIiwiQ09NUElMRURfVEVNUExBVEVTX1VSTCIsIkRlZmF1bHRUZW1wbGF0ZXNMb2FkZXIiLCJvbkxvYWRlZCIsInNldEluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJfb25Mb2FkZWQiLCJfZmV0Y2hUZW1wbGF0ZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNjcmlwdCIsImNyZWF0ZUVsIiwib25sb2FkIiwib25lcnJvciIsImFzeW5jIiwic3JjIiwiaW5zdGFuY2UiLCJFdmVudEVtaXR0ZXIiLCJfbGlzdGVuZXJzIiwibGlzdGVuZXJzIiwia2VlcCIsIlN0YXRlIiwiX3N0YXRlIiwib3B0VmFsIiwiX3NldCIsImVtaXQiLCJvcHRQcm9wIiwiZmV0Y2giLCJNZXRob2RzIiwiR0VUIiwiUE9TVCIsIlBVVCIsIkRFTEVURSIsIkh0dHBSZXF1ZXN0ZXIiLCJvcHRzIiwicmVxdWVzdCIsImVuY29kZVBhcmFtcyIsInVybFBhcmFtcyIsImpzb25Cb2R5IiwicmVxdWVzdENvbmZpZyIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwicmVxQXJncyIsIl9mZXRjaCIsImZldGNoUG9seWZpbGwiLCJfc2VuZEJlYWNvbiIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJzeW5jIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJBY3RpdmVYT2JqZWN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJjYWxsIiwic2VuZCIsImhhc1BhcmFtIiwic2VhcmNoUXVlcnkiLCJnZXRMaXZlQXBpVXJsIiwiZW52IiwiZ2V0Q2FjaGVkTGl2ZUFwaVVybCIsImdldEtub3dsZWRnZUFwaVVybCIsImdldEFuYWx5dGljc1VybCIsImNvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQiLCJhZGRQYXJhbXNUb1VybCIsImxvY2F0aW9uIiwicGFyYW1LZXkiLCJBcGlSZXF1ZXN0IiwiX3JlcXVlc3RlciIsIl9lbnZpcm9ubWVudCIsImVudmlyb25tZW50IiwiX2Jhc2VVcmwiLCJiYXNlVXJsIiwiX2VuZHBvaW50IiwiZW5kcG9pbnQiLCJfdmVyc2lvbiIsInZlcnNpb24iLCJfZ2xvYmFsU3RvcmFnZSIsImJhc2VQYXJhbXMiLCJzYW5pdGl6ZVBhcmFtcyIsInBvc3QiLCJoYXMiLCJTZWFyY2hBcGkiLCJqc29uIiwiQW5hbHl0aWNzRXZlbnQiLCJldmVudFR5cGUiLCJ0b1VwcGVyQ2FzZSIsIkFuYWx5dGljc1JlcG9ydGVyIiwiY29yZSIsImJ1c2luZXNzSWQiLCJnbG9iYWxPcHRpb25zIiwiX2J1c2luZXNzSWQiLCJfZ2xvYmFsT3B0aW9ucyIsIl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwic2V0UXVlcnlJZCIsImNvb2tpZURhdGEiLCJ5dGFnIiwiYWRkT3B0aW9ucyIsImJlYWNvbiIsInRvQXBpRXZlbnQiLCJpc0VuYWJsZWQiLCJOb29wQW5hbHl0aWNzUmVwb3J0ZXIiLCJNb2R1bGVEYXRhIiwiX2lkIiwiX2hpc3RvcnkiLCJfZGF0YSIsImNhcHR1cmVQcmV2aW91cyIsInNoaWZ0IiwicHJldmlvdXMiLCJfcHJldmlvdXMiLCJwb3AiLCJHbG9iYWxTdG9yYWdlIiwiX21vZHVsZURhdGFDb250YWluZXIiLCJfZnV0dXJlTGlzdGVuZXJzIiwiX2luaXREYXRhQ29udGFpbmVyIiwiX2FwcGx5RnV0dXJlTGlzdGVuZXJzIiwiZGF0YUtleSIsInN0YXJ0c1dpdGgiLCJtb2R1bGVEYXRhIiwib2ZmIiwiZnV0dXJlcyIsImZ1dHVyZSIsIkNvbXBvbmVudCIsInN5c3RlbUNvbmZpZyIsImNvbnN0cnVjdG9yIiwiX2NvbmZpZyIsIl90eXBlIiwiX3BhcmVudENvbnRhaW5lciIsInBhcmVudENvbnRhaW5lciIsIl9jaGlsZHJlbiIsInN0YXRlIiwiY29tcG9uZW50TWFuYWdlciIsImFuYWx5dGljc1JlcG9ydGVyIiwiX2FuYWx5dGljc09wdGlvbnMiLCJhbmFseXRpY3NPcHRpb25zIiwiX2NvbnRhaW5lciIsIl9jbGFzc05hbWUiLCJfcmVuZGVyIiwicmVuZGVyIiwiX3JlbmRlcmVyIiwicmVuZGVyZXIiLCJfdGVtcGxhdGUiLCJfdGVtcGxhdGVOYW1lIiwiZGVmYXVsdFRlbXBsYXRlTmFtZSIsIl9pc01vdW50ZWQiLCJ0cmFuc2Zvcm1EYXRhIiwib25DcmVhdGUiLCJvbkNyZWF0ZU92ZXJyaWRlIiwiYmluZCIsIm9uTW91bnQiLCJvbk1vdW50T3ZlcnJpZGUiLCJvblVwZGF0ZSIsIm9uVXBkYXRlT3ZlcnJpZGUiLCJ1c2VyT25DcmVhdGUiLCJ1c2VyT25Nb3VudCIsInVzZXJPblVwZGF0ZSIsInNldFN0YXRlIiwidW5Nb3VudCIsIm1vdW50IiwibmV3U3RhdGUiLCJjaGlsZENvbXBvbmVudCIsImNyZWF0ZSIsIl9wYXJlbnRPcHRzIiwiYyIsInJlbW92ZSIsImNoaWxkIiwiZW1wdHkiLCJvblVuTW91bnQiLCJiZWZvcmVNb3VudCIsImFzSlNPTiIsImRvbUNvbXBvbmVudHMiLCJxdWVyeUFsbCIsIl9jcmVhdGVTdWJjb21wb25lbnQiLCJkb21Ib29rcyIsIl9jcmVhdGVBbmFseXRpY3NIb29rIiwiYmVmb3JlUmVuZGVyIiwiYWZ0ZXJSZW5kZXIiLCJkb21Db21wb25lbnQiLCJkYXRhc2V0IiwiaXNDb21wb25lbnRNb3VudGVkIiwiY2hpbGREYXRhIiwiYWRkQ2hpbGQiLCJyZXZlcnNlIiwiaXNBbmFseXRpY3NBdHRhY2hlZCIsImV2ZW50dHlwZSIsImV2ZW50bGFiZWwiLCJldmVudG9wdGlvbnMiLCJyZXBvcnQiLCJFcnJvclJlcG9ydGVyIiwicHJpbnRWZXJib3NlIiwic2VuZFRvU2VydmVyIiwiZXJyIiwicHJpbnRFcnJvciIsInRvSnNvbiIsImNvbnNvbGUiLCJDb25zb2xlRXJyb3JSZXBvcnRlciIsIlBlcnNpc3RlbnRTdG9yYWdlIiwiX2hpc3RvcnlUaW1lciIsIl91cGRhdGVMaXN0ZW5lciIsInVwZGF0ZUxpc3RlbmVyIiwiX3Jlc2V0TGlzdGVuZXIiLCJyZXNldExpc3RlbmVyIiwib25wb3BzdGF0ZSIsIl9jYWxsTGlzdGVuZXIiLCJyZXBsYWNlSGlzdG9yeSIsIm5ld0RhdGEiLCJfdXBkYXRlSGlzdG9yeSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwicHVzaFN0YXRlIiwibGlzdGVuZXIiLCJhbGxQYXJhbXMiLCJTZWFyY2hDb25maWciLCJkZWZhdWx0SW5pdGlhbFNlYXJjaCIsInZhbGlkYXRlIiwiQXV0b0NvbXBsZXRlRGF0YSIsImlucHV0SW50ZW50cyIsInMiLCJyIiwiQXV0b0NvbXBsZXRlUmVzdWx0IiwicXVlcnlJbnRlbnRzIiwiQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIiwiQXV0b0NvbXBsZXRlQXBpIiwic2VhcmNoUGFyYW1ldGVycyIsInZlcnRpY2FsIiwidW5pdmVyc2FsIiwidW5pdmVyc2FsT3B0aW9ucyIsInZlcnRpY2FsT3B0aW9ucyIsIk1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIiwiZW1wdHlSZXN1bHRzIiwiZmlsdGVyT3B0aW9ucyIsIm9wdCIsImxvd2VyY2FzZSIsInRvTG93ZXJDYXNlIiwicmFuZG9tU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsIlF1ZXN0aW9uQW5zd2VyQXBpIiwiZW50aXR5SWQiLCJzaXRlIiwicXVlc3Rpb25MYW5ndWFnZSIsIm1vZGUiLCJoZWFkZXJzIiwiTW9ja1F1ZXN0aW9uQW5zd2VyU2VydmljZSIsIkFSQklUUkFSWV9CVVNJTkVTU19JRCIsIk1vY2tTZWFyY2hTZXJ2aWNlIiwiX2dldE1vY2tEYXRhSnNvbiIsInJlc3AiLCJ0ZXh0IiwidXNlTW9ja0RhdGEiLCJkZWxheWVkUmVzcG9uc2UiLCJjb25zdHJ1Y3RWZXJ0aWNhbFJlc3BvbnNlIiwic2VjdGlvbiIsImZpbmQiLCJ2ZXJ0aWNhbE1vZHVsZSIsImZsb29yIiwibW9kaWZ5UmVzdWx0cyIsImdldFJlc3VsdHNGaWx0ZXJlciIsImNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlIiwiY29uc3VtZXIiLCJtb2RpZnlGbiIsImZpbGxTZWN0aW9uRmllbGRzIiwibWV0YSIsInV1aWQiLCJ1dWlkVjQiLCJmYWlsZWRWZXJ0aWNhbHMiLCJxdWVyeUR1cmF0aW9uTWlsbGlzIiwicmFuZG9tSW50IiwiUkVTSVpFX0RFQk9VTkNFIiwiTU9CSUxFX0JSRUFLUE9JTlQiLCJNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OIiwiQ09MTEFQU0UiLCJJTk5FUlNDUk9MTCIsIlRhYiIsImlzRmlyc3QiLCJpc0FjdGl2ZSIsInRhYnNDb25maWciLCJ0YWJzIiwidGFiIiwiaGlkZUluTmF2aWdhdGlvbiIsIk5hdmlnYXRpb25Db21wb25lbnQiLCJvdmVyZmxvd0xhYmVsIiwib3ZlcmZsb3dJY29uIiwiX3RhYnNDb25maWciLCJfdGFicyIsIl90YWJPcmRlciIsImdldERlZmF1bHRUYWJPcmRlciIsImdldFVybFBhcmFtcyIsIl9uYXZCcmVha3BvaW50cyIsIl9tb2JpbGVPdmVyZmxvd0JlaGF2aW9yIiwibW9iaWxlT3ZlcmZsb3dCZWhhdmlvciIsIl9hcmlhTGFiZWwiLCJhcmlhTGFiZWwiLCJjaGVja091dHNpZGVDbGljayIsImNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvciIsInNob3VsZENvbGxhcHNlIiwiYmluZE92ZXJmbG93SGFuZGxlcnMiLCJyZWZpdE5hdiIsInRvZ2dsZU1vcmVEcm9wZG93biIsInVuYmluZE92ZXJmbG93SGFuZGxlcnMiLCJtb3JlQnV0dG9uIiwibWFpbkxpbmtzIiwiY29sbGFwc2VkTGlua3MiLCJuYXZXaWR0aCIsImNvbnRhaW5zIiwib2Zmc2V0V2lkdGgiLCJudW1CcmVha3BvaW50cyIsIm1haW5MaW5rc1dpZHRoIiwiY2hpbGRyZW4iLCJsYXN0TGluayIsIl9wcmVwZW5kIiwiZmlyc3RMaW5rIiwiY2xvc2VNb3JlRHJvcGRvd24iLCJ0b2dnbGUiLCJfY2xvc2VzdCIsIl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lciIsIm1lcmdlVGFiT3JkZXIiLCJnZW5lcmF0ZVRhYlVybCIsInNob3dDb2xsYXBzZSIsImhhc093blByb3BlcnR5IiwiZG9jRnJhZyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJpc05vZGUiLCJOb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwicHJlcGVuZCIsImNsb3Nlc3RFbFNlbGVjdG9yIiwicGFyZW50RWxlbWVudCIsIm5vZGVUeXBlIiwiY2xvc2VzdCIsInVuc2hpZnQiLCJvdGhlclRhYk9yZGVyIiwidGFiQ29uZmlnIiwiSWNvblN0YXRlIiwiU2VhcmNoQ29tcG9uZW50IiwiX3ZlcnRpY2FsS2V5IiwiX2Zvcm1FbCIsImZvcm1TZWxlY3RvciIsIl9pbnB1dEVsIiwiaW5wdXRFbCIsImxhYmVsVGV4dCIsInN1Ym1pdFRleHQiLCJjbGVhclRleHQiLCJzdWJtaXRJY29uIiwicHJvbXB0SGVhZGVyIiwiYXV0b0ZvY3VzIiwiY2xlYXJCdXR0b24iLCJhdXRvY29tcGxldGVPbkxvYWQiLCJyZWRpcmVjdFVybCIsIl9pc1R3aW4iLCJpc1R3aW4iLCJxIiwicXVlcnlFbCIsImRlYm91bmNlZFNlYXJjaCIsIl9zZWFyY2hDb29sZG93biIsInNlYXJjaENvb2xkb3duIiwiX3Byb21wdEZvckxvY2F0aW9uIiwicHJvbXB0Rm9yTG9jYXRpb24iLCJCb29sZWFuIiwiX3Nob3dDbGVhckJ1dHRvbiIsIl9hbGxvd0VtcHR5U2VhcmNoIiwiYWxsb3dFbXB0eVNlYXJjaCIsIl9hdXRvQ29tcGxldGVOYW1lIiwic2V0UXVlcnkiLCJmb2N1c0lucHV0RWxlbWVudCIsImlzVXNpbmdZZXh0QW5pbWF0ZWRJY29uIiwiY3VzdG9tSWNvblVybCIsImluaXRBbmltYXRlZEljb24iLCJpbml0U2VhcmNoIiwiaW5pdEF1dG9Db21wbGV0ZSIsImluaXRDbGVhckJ1dHRvbiIsImljb25TdGF0ZSIsImlzUmVxdWVzdGluZ0FuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9yd2FyZEljb24iLCJyZXZlcnNlSWNvbiIsIk1BR05JRllJTkdfR0xBU1MiLCJZRVhUIiwiaWNvbklzRnJvemVuIiwicmVxdWVzdEljb25BbmltYXRpb25GcmFtZSIsImZvY3VzU3RpbGxJblNlYXJjaGJhciIsInJlbGF0ZWRUYXJnZXQiLCJjbGlja2FibGVFbGVtZW50U2VsZWN0b3JzIiwiY2xpY2thYmxlRWwiLCJhbmltYXRlSWNvblRvTWFnbmlmeWluZ0dsYXNzIiwiYW5pbWF0ZUljb25Ub1lleHQiLCJfYXV0b2NvbXBsZXRlIiwiYnV0dG9uIiwiZm9ybSIsInByZXZlbnREZWZhdWx0IiwiaHJlZiIsImJsdXIiLCJpbnB1dFNlbGVjdG9yIiwib25TdWJtaXQiLCJ0cmlnZ2VyIiwib25DaGFuZ2UiLCJfdGhyb3R0bGVkIiwiZmV0Y2hRdWVyeUludGVudHMiLCJxdWVyeUhhc05lYXJNZUludGVudCIsImdldEN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwiY29vcmRzIiwiZ2V0QWN0aXZlQ29tcG9uZW50IiwiY29uZmlnSWQiLCJhdXRvY29tcGxldGVEYXRhIiwiYXV0b2NvbXBsZXRlUmVxdWVzdCIsImF1dG9Db21wbGV0ZVZlcnRpY2FsIiwiYXV0b0NvbXBsZXRlVW5pdmVyc2FsIiwiZmxhdE1hcCIsIm1hdGNoaW5nUmVzdWx0IiwiZm9yd2FyZEljb25PcHRzIiwiaWNvbk5hbWUiLCJjbGFzc05hbWVzIiwicmV2ZXJzZUljb25PcHRzIiwic2hvd0NsZWFyQnV0dG9uIiwiZXZlbnRPcHRpb25zIiwiaWNvbklkIiwiZm9jdXMiLCJidWlsZFNlYXJjaFBhcmFtZXRlcnMiLCJzZWFyY2hQYXJhbWV0ZXJDb25maWdzIiwic2VjdGlvbmVkIiwiZmllbGRzIiwiYnVpbGRGaWVsZHMiLCJmaWVsZENvbmZpZ3MiLCJmYyIsImZldGNoRW50aXRpZXMiLCJGaWx0ZXJTZWFyY2hDb21wb25lbnQiLCJfc3RvcmVPbkNoYW5nZSIsInN0b3JlT25DaGFuZ2UiLCJzZWFyY2hUZXh0IiwiaXNGaWx0ZXJTZWFyY2giLCJvcmlnaW5hbEZpbHRlciIsImZyb21SZXNwb25zZSIsInNldEZpbHRlciIsIktleXMiLCJCQUNLU1BBQ0UiLCJUQUIiLCJFTlRFUiIsIlNISUZUIiwiQ1RSTCIsIkFMVCIsIkVTQ0FQRSIsIkxFRlQiLCJSSUdIVCIsIlVQIiwiRE9XTiIsIkxFRlRfT1NfS0VZIiwiUklHSFRfT1NfS0VZIiwiU0VMRUNUX0tFWSIsIkF1dG9Db21wbGV0ZUNvbXBvbmVudCIsInN5c3RlbU9wdHMiLCJfYXV0b2NvbXBsZXRlRWxzIiwiYXV0b0NvbXBsZXRlRWxzIiwiX29yaWdpbmFsUXVlcnkiLCJfc2VjdGlvbkluZGV4IiwiX3Jlc3VsdEluZGV4IiwiX2F1dG9Gb2N1cyIsIl9vblN1Ym1pdCIsIl9vbkNoYW5nZSIsIl9zZWFyY2hQYXJhbWV0ZXJzIiwiaXNRdWVyeUlucHV0Rm9jdXNlZCIsInNlY3Rpb25JbmRleCIsInJlc3VsdEluZGV4IiwiYWN0aXZlRWxlbWVudCIsInF1ZXJ5SW5wdXQiLCJhdHRyaWJ1dGVzIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJzcGVsbGNoZWNrIiwicmVzZXQiLCJhdXRvQ29tcGxldGUiLCJoYW5kbGVOYXZpZ2F0ZVJlc3VsdHMiLCJrZXlDb2RlIiwiaGFuZGxlU3VibWl0UmVzdWx0IiwiZGVsZWdhdGUiLCJ1cGRhdGVRdWVyeSIsImhhbmRsZVR5cGluZyIsInVwZGF0ZVN0YXRlIiwib3B0VmFsdWUiLCJpZ25vcmVkS2V5cyIsImF1dG9Db21wbGV0ZUZpbHRlciIsIkRFRkFVTFRfQ09ORklHIiwic3VnZ2VzdGlvbkhlbHBUZXh0IiwiU3BlbGxDaGVja0NvbXBvbmVudCIsImNvcnJlY3RlZFF1ZXJ5VXJsIiwiX2J1aWxkUmVkaXJlY3RRdWVyeVVybCIsImhlbHBUZXh0IiwiX2dldEhlbHBUZXh0IiwiaXBBY2N1cmFjeUhlbHBUZXh0IiwiZGV2aWNlQWNjdXJhY3lIZWxwVGV4dCIsInVwZGF0ZUxvY2F0aW9uQnV0dG9uVGV4dCIsIkxvY2F0aW9uQmlhc0NvbXBvbmVudCIsIl91cGRhdGVMb2NhdGlvbkVsIiwidXBkYXRlTG9jYXRpb25FbCIsIl9sb2NhdGlvbkRpc3BsYXlOYW1lIiwiX2FjY3VyYWN5IiwiX2FsbG93VXBkYXRlIiwiX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQiLCJfZG9TZWFyY2giLCJjb2RlIiwiX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSIsIl9nZXRMb2NhdGlvbkRpc3BsYXlOYW1lIiwiYWNjdXJhY3lUZXh0IiwiX2dldEFjY3VyYWN5SGVscFRleHQiLCJpc1ByZWNpc2VMb2NhdGlvbiIsImlzVW5rbm93bkxvY2F0aW9uIiwiYWxsb3dVcGRhdGUiLCJwZXJtaXNzaW9ucyIsIkZhY2V0IiwiYXZhaWxhYmxlRmllbGRJZHMiLCJmbGF0RmlsdGVycyIsIiRvciIsIkZpbHRlckJveENvbmZpZyIsInNob3dDb3VudCIsInNlYXJjaE9uQ2hhbmdlIiwicmVzZXRGaWx0ZXIiLCJyZXNldEZhY2V0IiwicmVzZXRGaWx0ZXJMYWJlbCIsInJlc2V0RmFjZXRMYWJlbCIsInJlc2V0RmlsdGVycyIsInJlc2V0RmFjZXRzIiwicmVzZXRGaWx0ZXJzTGFiZWwiLCJyZXNldEZhY2V0c0xhYmVsIiwic2hvd01vcmVMaW1pdCIsInNob3dNb3JlTGFiZWwiLCJzaG93TGVzc0xhYmVsIiwic2hvd01vcmUiLCJleHBhbmQiLCJzaG93TnVtYmVyQXBwbGllZCIsImFwcGx5TGFiZWwiLCJhcHBseUJ1dHRvblNlbGVjdG9yIiwiZmlsdGVyQ29uZmlncyIsImlzRHluYW1pYyIsIkZpbHRlckJveENvbXBvbmVudCIsIl9maWx0ZXJDb21wb25lbnRzIiwiX2ZpbHRlcnMiLCJzaG93UmVzZXQiLCJyZXNldExhYmVsIiwic2hvd0FwcGx5QnV0dG9uIiwic2hvd0V4cGFuZCIsIm9uRmlsdGVyQ2hhbmdlIiwiZ2V0RmlsdGVyIiwiX3NhdmVGaWx0ZXJzVG9TdG9yYWdlIiwiX3NlYXJjaCIsImNsZWFyT3B0aW9ucyIsInZhbGlkRmlsdGVycyIsImNvbWJpbmVkRmlsdGVyIiwiZnJvbUZpbHRlcnMiLCJzZXRGYWNldEZpbHRlciIsIlNVUFBPUlRFRF9DT05UUk9MUyIsIkZpbHRlck9wdGlvbnNDb25maWciLCJjb250cm9sIiwib3B0aW9uU2VsZWN0b3IiLCJwcmV2aW91c09wdGlvbnMiLCJzZWxlY3RlZE9wdGlvbnMiLCJzZXREZWZhdWx0U2VsZWN0ZWRWYWx1ZXMiLCJyZWR1Y2UiLCJudW1TZWxlY3RlZCIsIkZpbHRlck9wdGlvbnNDb21wb25lbnQiLCJzZWxlY3RlZENvdW50IiwiZ2V0U2VsZWN0ZWRDb3VudCIsImFsbFNob3duIiwiaXNTaW5nbGVPcHRpb24iLCJfdXBkYXRlT3B0aW9uIiwicGFyc2VJbnQiLCJjaGVja2VkIiwibGVnZW5kIiwiY2xpY2siLCJ1cGRhdGVMaXN0ZW5lcnMiLCJfYnVpbGRGaWx0ZXIiLCJfYXBwbHlGaWx0ZXIiLCJlcXVhbCIsImdyb3VwIiwibWluUGxhY2Vob2xkZXJUZXh0IiwibWF4UGxhY2Vob2xkZXJUZXh0IiwiUmFuZ2VGaWx0ZXJDb21wb25lbnQiLCJfZmllbGQiLCJtaW5WYWwiLCJtYXhWYWwiLCJfcmFuZ2UiLCJpbml0aWFsTWluIiwiaW5pdGlhbE1heCIsIl90aXRsZSIsIl9taW5MYWJlbCIsIm1pbkxhYmVsIiwiX21heExhYmVsIiwibWF4TGFiZWwiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiX3VwZGF0ZVJhbmdlIiwiaW5jbHVzaXZlUmFuZ2UiLCJEYXRlUmFuZ2VGaWx0ZXJDb21wb25lbnQiLCJfaXNFeGNsdXNpdmUiLCJpc0V4Y2x1c2l2ZSIsInRvZGF5IiwiRGF0ZSIsInRvZGF5U3RyaW5nIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInBhZFN0YXJ0IiwiZ2V0RGF0ZSIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiX2RhdGUiLCJkYXRlTWluIiwiZGF0ZU1heCIsImRhdGUiLCJleGNsdXNpdmVSYW5nZSIsIkZhY2V0c0NvbmZpZyIsImZpZWxkQ29udHJvbHMiLCJGYWNldHNDb21wb25lbnQiLCJfYXBwbHlCdXR0b25TZWxlY3RvciIsIl9maWx0ZXJib3giLCJlbmFibGVEeW5hbWljRmlsdGVycyIsIk1FVEVSU19QRVJfTUlMRSIsImdlb0J1dHRvbkljb24iLCJnZW9CdXR0b25JY29uQWx0VGV4dCIsImdlb0J1dHRvblRleHQiLCJlbmFibGVkVGV4dCIsImxvYWRpbmdUZXh0IiwiZXJyb3JUZXh0IiwiYnV0dG9uU2VsZWN0b3IiLCJHZW9Mb2NhdGlvbkNvbXBvbmVudCIsInBsYWNlaG9sZGVyIiwiX2VuYWJsZWQiLCJnZW9Mb2FkaW5nIiwiZ2VvRXJyb3IiLCJnZW9FbmFibGVkIiwiZ2VvVmFsdWUiLCJnZW9QbGFjZWhvbGRlciIsIl9pbml0QXV0b0NvbXBsZXRlIiwiX3RvZ2dsZUdlb0ZpbHRlciIsIl9zYXZlRGF0YVRvU3RvcmFnZSIsIlNvcnRPcHRpb25zQ29tcG9uZW50IiwiYXNzaWduRGVmYXVsdHMiLCJzZWxlY3RlZE9wdGlvbkluZGV4IiwiaXNTZWxlY3RlZCIsImhpZGVFeGNlc3NPcHRpb25zIiwiaGFuZGxlT3B0aW9uU2VsZWN0aW9uIiwiX3NvcnRSZXN1bHRzIiwib3B0aW9uSW5kZXgiLCJfdXBkYXRlU2VsZWN0ZWRPcHRpb24iLCJjbGVhclNvcnRCeXMiLCJzZXRTb3J0QnlzIiwidXBkYXRlZENvbmZpZyIsImRlZmF1bHRTb3J0TGFiZWwiLCJPUFRJT05fVFlQRVMiLCJuZXdPcHRpb24iLCJpc0ZpZWxkIiwiRXZlbnRUeXBlcyIsIlRIVU1CU19VUCIsIlRIVU1CU19ET1dOIiwicG9zaXRpdmVGZWVkYmFja1NyVGV4dCIsIm5lZ2F0aXZlRmVlZGJhY2tTclRleHQiLCJmb290ZXJUZXh0T25TdWJtaXNzaW9uIiwiRGlyZWN0QW5zd2VyQ29tcG9uZW50IiwiZm9ybUVsIiwiX3RodW1ic1VwU2VsZWN0b3IiLCJ0aHVtYnNVcFNlbGVjdG9yIiwiX3RodW1ic0Rvd25TZWxlY3RvciIsInRodW1ic0Rvd25TZWxlY3RvciIsIl92aWV3RGV0YWlsc1RleHQiLCJ2aWV3RGV0YWlsc1RleHQiLCJoYXNTdGF0ZSIsImNoZWNrZWRWYWx1ZSIsInJlcG9ydFF1YWxpdHkiLCJzZWFyY2hlciIsImN0YUxhYmVsIiwiaXNHb29kIiwiQWx0ZXJuYXRpdmVWZXJ0aWNhbCIsIkFsdGVybmF0aXZlVmVydGljYWxzQ29tcG9uZW50IiwiX2FsdGVybmF0aXZlVmVydGljYWxzIiwiX3ZlcnRpY2Fsc0NvbmZpZyIsInZlcnRpY2Fsc0NvbmZpZyIsIl9jdXJyZW50VmVydGljYWxMYWJlbCIsImdldEN1cnJlbnRWZXJ0aWNhbExhYmVsIiwidmVydGljYWxTdWdnZXN0aW9ucyIsIl9idWlsZFZlcnRpY2FsU3VnZ2VzdGlvbnMiLCJfdW5pdmVyc2FsVXJsIiwidW5pdmVyc2FsVXJsIiwiX2lzU2hvd2luZ1Jlc3VsdHMiLCJpc1Nob3dpbmdSZXN1bHRzIiwiY3VycmVudFZlcnRpY2FsTGFiZWwiLCJ0aGlzVmVydGljYWwiLCJ2ZXJ0aWNhbHMiLCJxdWVyeVBhcmFtcyIsImFsdGVybmF0aXZlVmVydGljYWwiLCJtYXRjaGluZ1ZlcnRpY2FsQ29uZmlnIiwiTWFwUHJvdmlkZXIiLCJfem9vbSIsInpvb20iLCJfZGVmYXVsdFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwiX3Nob3dFbXB0eU1hcCIsInNob3dFbXB0eU1hcCIsIl9tYXAiLCJfaXNMb2FkZWQiLCJfb25QaW5DbGljayIsIm9uUGluQ2xpY2siLCJfcGluQ29uZmlnIiwicGluIiwiREVGQVVMVF9QSU5fQ09ORklHIiwiX2NvbGxhcHNlUGlucyIsImNvbGxhcHNlUGlucyIsImlzTG9hZGVkIiwibWFwRGF0YSIsIm1hcmtlcnMiLCJsb2NhdGlvblRvSXRlbSIsIm0iLCJjb2xsYXBzZWRNYXJrZXJzIiwiY29sbGFwc2VkTWFya2VyIiwiYW5jaG9yIiwic3ZnIiwic2NhbGVkU2l6ZSIsImxhYmVsVHlwZSIsIkdvb2dsZU1hcFByb3ZpZGVyIiwiX3pvb21PZmZzZXQiLCJfY2xpZW50SWQiLCJjbGllbnRJZCIsIl9zaWduYXR1cmUiLCJzaWduYXR1cmUiLCJoYXNWYWxpZENsaWVudENyZWRlbnRpYWxzIiwib25Mb2FkIiwiZ29vZ2xlIiwib25Mb2FkRnVuYyIsImdlbmVyYXRlQ3JlZGVudGlhbHMiLCJtYXBzIiwiTWFwIiwiY2VudGVyIiwiZ2V0Q2VudGVyTWFya2VyIiwiX2NvbGxhcHNlTWFya2VycyIsImdvb2dsZU1hcE1hcmtlckNvbmZpZ3MiLCJHb29nbGVNYXBNYXJrZXJDb25maWciLCJib3VuZHMiLCJMYXRMbmdCb3VuZHMiLCJtYXJrZXIiLCJNYXJrZXIiLCJhZGRMaXN0ZW5lciIsImV4dGVuZCIsImZpdEJvdW5kcyIsIm1hcENlbnRlciIsInNlcmlhbGl6ZWRNYXJrZXJzIiwicGluQ29uZmlnIiwicGluQ29uZmlnT2JqIiwiUG9pbnQiLCJ4IiwieSIsIlNpemUiLCJ3IiwiaCIsIk1hcEJveE1hcFByb3ZpZGVyIiwibWFwYm94Z2wiLCJhY2Nlc3NUb2tlbiIsImNzcyIsInJlbCIsIm1hcGJveE1hcE1hcmtlckNvbmZpZ3MiLCJNYXBCb3hNYXJrZXJDb25maWciLCJMbmdMYXRCb3VuZHMiLCJ3cmFwcGVyIiwiTG5nTGF0Iiwic2V0TG5nTGF0IiwiZ2V0TG5nTGF0IiwiYWRkVG8iLCJnZXRFbGVtZW50IiwicGFkZGluZyIsInN0YXRpY01hcFBpbiIsIlByb3ZpZGVyVHlwZXMiLCJNYXBDb21wb25lbnQiLCJfbWFwUHJvdmlkZXIiLCJtYXBQcm92aWRlciIsImdldFByb3ZpZGVySW5zdGFuY2UiLCJsb2FkSlMiLCJpbml0IiwiY2FyZFRlbXBsYXRlcyIsImNhcmRUeXBlcyIsIkNhcmRDb25maWciLCJjYXJkVHlwZSIsImRhdGFNYXBwaW5ncyIsIl9pbmRleCIsImlzVW5pdmVyc2FsIiwiQ2FyZENvbXBvbmVudCIsInZhbGlkQ2FyZHMiLCJtc2ciLCJ1cGRhdGVkRGF0YSIsIm5ld09wdHMiLCJzaG93T3JkaW5hbCIsImF0dHJpYnV0ZSIsIlJlc3VsdHNIZWFkZXJDb21wb25lbnQiLCJzaG93UmVzdWx0Q291bnQiLCJzaG93QXBwbGllZEZpbHRlcnMiLCJzaG93RmllbGROYW1lcyIsInJlc3VsdHNDb3VudFNlcGFyYXRvciIsInJlc3VsdHNMZW5ndGgiLCJncm91cGVkRmlsdGVycyIsImRpc3BsYXlWYWx1ZXMiLCJoYXNGaWx0ZXJzIiwic2hvdWxkU2hvd0ZpbHRlcnMiLCJyZXN1bHRzQ291bnRTdGFydCIsInJlc3VsdHNDb3VudEVuZCIsInNob3dSZXN1bHRTZXBhcmF0b3IiLCJhcHBsaWVkRmlsdGVyc0FycmF5IiwiZ2V0QXBwbGllZEZpbHRlcnNBcnJheSIsIlZlcnRpY2FsUmVzdWx0c0NvbmZpZyIsIl9kaXNwbGF5QWxsUmVzdWx0cyIsIm5vUmVzdWx0cyIsImRpc3BsYXlBbGxSZXN1bHRzIiwibm9SZXN1bHRzVGVtcGxhdGUiLCJwYXJlbnRPcHRzIiwicmVuZGVySXRlbSIsIml0ZW1UZW1wbGF0ZSIsIm1heE51bWJlck9mQ29sdW1ucyIsImNhcmQiLCJyZXN1bHRzSGVhZGVyT3B0cyIsIlZlcnRpY2FsUmVzdWx0c0NvbXBvbmVudCIsIm51bUNvbHVtbnMiLCJ1bml2ZXJzYWxDb25maWciLCJ2ZXJ0aWNhbENvbmZpZyIsImRpc3BsYXlSZXN1bHRzSWZFeGlzdCIsInNob3dSZXN1bHRzSGVhZGVyIiwiaXNQcmVTZWFyY2giLCJpc1NlYXJjaExvYWRpbmciLCJpc1NlYXJjaENvbXBsZXRlIiwiZ2V0VW5pdmVyc2FsVXJsIiwiZ2V0VmVydGljYWxVUkwiLCJyZXN1bHRzUHJlc2VudCIsInNob3dOb1Jlc3VsdHMiLCJwbGFjZWhvbGRlcnMiLCJ1c2VMZWdhY3lOb1Jlc3VsdHMiLCJtYXBDb25maWciLCJyZXN1bHRzSGVhZGVyRGF0YSIsIkFjY29yZGlvblJlc3VsdHNDb21wb25lbnQiLCJfc2VsZWN0b3JCYXNlIiwic2VsZWN0b3JCYXNlIiwiY29sbGFwc2VkQ2xhc3MiLCJzZWxmRWwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImFjY29yZGlvbkVscyIsImFjY29yZGlvbkVsIiwidG9nZ2xlRWwiLCJ0b2dnbGVTZWxlY3RvciIsImNvbnRlbnRFbCIsImJvZHlTZWxlY3RvciIsImNoYW5nZUhlaWdodCIsImhhbmRsZUNsaWNrIiwid3JhcHBlckVsIiwiaXNDb2xsYXBzZWQiLCJ0YXJnZXRFbCIsImhlaWdodCIsInNjcm9sbEhlaWdodCIsImJ1aWxkU2VsZWN0b3IiLCJVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IiwiX2xpbWl0IiwiY2hpbGRPcHRzIiwiZ2V0Q2hpbGRDb25maWciLCJ1c2VBY2NvcmRpb24iLCJkZWZhdWx0Q29uZmlnIiwiUGFnaW5hdGlvbkNvbXBvbmVudCIsIl9maXJzdFBhZ2VCdXR0b25FbmFibGVkIiwic2hvd0ZpcnN0IiwiX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCIsInNob3dMYXN0IiwiX3BhZ2VMYWJlbCIsInBhZ2VMYWJlbCIsIm5vUmVzdWx0c0NvbmZpZyIsInNob3dDb250cm9scyIsInNob3VsZFNob3dDb250cm9scyIsInByZXZpb3VzUGFnZUJ1dHRvbiIsIm5leHRQYWdlQnV0dG9uIiwibWF4UGFnZSIsInRydW5jIiwidXBkYXRlUGFnZSIsImZpcnN0UGFnZUJ1dHRvbiIsImxhc3RQYWdlQnV0dG9uIiwic2Nyb2xsVG9Ub3AiLCJ2ZXJ0aWNhbFBhZ2UiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJwYWdlTnVtYmVyIiwiaXNNb3JlUmVzdWx0cyIsImZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJsYXN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJzaG93Rmlyc3RQYWdlQnV0dG9uIiwic2hvd1ByZXZpb3VzUGFnZUJ1dHRvbiIsInNob3dOZXh0UGFnZUJ1dHRvbiIsInNob3dMYXN0UGFnZUJ1dHRvbiIsIkNUQUNvbGxlY3Rpb25Db21wb25lbnQiLCJpbmNsdWRlTGVnYWN5Q2xhc3NlcyIsInJlc29sdmVDVEFNYXBwaW5nIiwiX2N0YU1vZGlmaWVycyIsImN0YSIsImRlZmF1bHRFdmVudE9wdGlvbnMiLCJwYXJzZWRDVEFzIiwiY3RhcyIsImN0YU1hcHBpbmciLCJjdGFPYmplY3QiLCJjdGFBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVNYXBwaW5nIiwid2FybiIsInRyaW0iLCJTdGFuZGFyZENhcmRDb25maWciLCJyYXdSZXN1bHQiLCJhcHBseURhdGFNYXBwaW5ncyIsInNob3dNb3JlVGV4dCIsInNob3dMZXNzVGV4dCIsImRldGFpbHNPdmVyTGltaXQiLCJzaG93VG9nZ2xlIiwiU3RhbmRhcmRDYXJkQ29tcG9uZW50IiwiaGlkZUV4Y2Vzc0RldGFpbHMiLCJoYXNDVEFzIiwiU3RhbmRhcmQiLCJBY2NvcmRpb25DYXJkQ29uZmlnIiwiQWNjb3JkaW9uQ2FyZENvbXBvbmVudCIsImlzRXhwYW5kZWQiLCJBY2NvcmRpb24iLCJMZWdhY3lDYXJkQ29uZmlnIiwiTGVnYWN5Q2FyZENvbXBvbmVudCIsIl9sZWdhY3lFdmVudE9wdGlvbnMiLCJMZWdhY3kiLCJRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQiLCJ2YWxpZGF0ZUNvbmZpZyIsIm9uUmVzdWx0c1VwZGF0ZSIsInRyaWdnZXJFbCIsImJpbmRGb3JtVG9nZ2xlIiwiYmluZEZvcm1Gb2N1cyIsImJpbmRGb3JtU3VibWl0IiwiZ2V0QW5hbHl0aWNzRXZlbnQiLCJmb3JtRGF0YSIsImlucHV0RmllbGRzIiwib2JqIiwiY2hlY2tWYWxpZGl0eSIsInZhbGlkaXR5IiwidmFsdWVNaXNzaW5nIiwiZW1haWxGb3JtYXRFcnJvclRleHQiLCJwcml2YWN5UG9saWN5RXJyb3JUZXh0IiwiYW5hbHl0aWNzRXZlbnQiLCJJY29uQ29tcG9uZW50IiwiaWNvblVybCIsIkNUQUNvbmZpZyIsImFuYWx5dGljc0V2ZW50VHlwZSIsImFuYWx5dGljcyIsIl9pc1NvbG8iLCJDVEFDb21wb25lbnQiLCJyZXBvcnRBbmFseXRpY3NFdmVudCIsIkNPTVBPTkVOVF9DTEFTU19MSVNUIiwiQ09NUE9ORU5UX1JFR0lTVFJZIiwicmVnaXN0cnkiLCJjbGF6eiIsIkNvbXBvbmVudE1hbmFnZXIiLCJfYWN0aXZlQ29tcG9uZW50cyIsIl9jb3JlIiwiX2FuYWx5dGljc1JlcG9ydGVyIiwicmVwb3J0ZXIiLCJjb21wb25lbnRDbGF6eiIsImNvbXBvbmVudFR5cGUiLCJzaW1pbGFyQ29tcG9uZW50cyIsImNvbXBvbmVudENsYXNzIiwiZ2V0U2ltaWxhckNvbXBvbmVudHMiLCJhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQiLCJzb21lIiwiZmluZEluZGV4Iiwic3BsaWNlIiwiVmVydGljYWxQYWdlQ29uZmlnIiwiVmVydGljYWxQYWdlc0NvbmZpZyIsInBhZ2VzIiwidmVydGljYWxQYWdlc0NvbmZpZyIsInBhZ2UiLCJERUZBVUxUUyIsIkFuc3dlcnMiLCJjb21wb25lbnRzIiwiX29uUmVhZHkiLCJfZWxpZ2libGVGb3JBbmFseXRpY3MiLCJfc2VydmljZXMiLCJfYW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlIiwicGFyc2VkQ29uZmlnIiwicGFyc2VDb25maWciLCJ2ZXJ0aWNhbFBhZ2VzIiwib25TdGF0ZUNoYW5nZSIsInNldEFsbCIsIm1vY2siLCJnZXRNb2NrU2VydmljZXMiLCJnZXRTZXJ2aWNlcyIsInN1YnN0ciIsInNldENvcmUiLCJzZXRSZW5kZXJlciIsInNldEFuYWx5dGljc1JlcG9ydGVyIiwiaW5pdFNjcm9sbExpc3RlbmVyIiwiX3NldERlZmF1bHRJbml0aWFsU2VhcmNoIiwib25SZWFkeSIsInVzZVRlbXBsYXRlcyIsInRlbXBsYXRlQnVuZGxlIiwic2FuZGJveFByZWZpeCIsInJlZ2lzdGVyIiwicmVtb3ZlQnlOYW1lIiwib3B0SW4iLCJzZXRDb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwic2VhcmNoQ29uZmlnIiwicHJlcG9wdWxhdGVkUXVlcnkiLCJlcnJvclJlcG9ydGVyU2VydmljZSIsImRlYnVnIiwic3VwcHJlc3NFcnJvclJlcG9ydHMiLCJERUJPVU5DRV9USU1FIiwidGltZW91dCIsInNlbmRFdmVudCIsImlubmVySGVpZ2h0IiwicGFnZVlPZmZzZXQiLCJBTlNXRVJTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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