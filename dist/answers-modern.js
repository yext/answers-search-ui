(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.ANSWERS = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /** @module SearchStates */

  /**
   * SearchStates is an ENUM for the various stages of searching,
   * used to show different templates
   * @enum {string}
   */
  var SearchStates = {
    PRE_SEARCH: 'pre-search',
    SEARCH_LOADING: 'search-loading',
    SEARCH_COMPLETE: 'search-complete'
  };

  /** @module Result */
  var Result = function Result() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Result);

    /**
     * The raw profile data
     * @type {Object}
     * @private
     */
    this._raw = data.raw || null;
    /**
     * The formatted profile data
     * @type {Object}
     * @private
     */

    this._formatted = data.formatted;
    /**
     * The highlighted profile data with highlights applied to applicable fields
     * @type {Object}
     * @private
     */

    this._highlighted = data.highlighted;
    /**
     * The index number of the result
     * @type {Number}
     */

    this.ordinal = data.ordinal || null;
    /**
     * The title of the result card
     * @type {string|null}
     */

    this.title = data.title || null;
    /**
     * The body of the details section of the result card, can contain HTML
     * @type {string| null}
     */

    this.details = data.details || null;
    /**
     * The destination link for the title of the result card
     * @type {string|null}
     */

    this.link = data.link || null;
    /**
     * The Entity ID, or other unique identifier, used for to power interactivity
     * @type {string|null}
     */

    this.id = data.id || null;
    /**
     * The subtitle on the result card
     * @type {string|null}
     */

    this.subtitle = data.subtitle || null;
    /**
     * The class modifier, usually derived from the vertical configuration ID
     * Used to apply different styling to different result card types
     * @type {string|null}
     */

    this.modifier = data.modifier || null;
    /**
     * A large date, of the format { month: 'Jan', day: '01' }
     * @type {Object|null}
     */

    this.bigDate = data.bigDate || null;
    /**
     * An image profile object, expected to have a url property
     * @type {Object|null}
     */

    this.image = data.image || null;
    /**
     * An array of calls to action, of the format:
     * { icon: '', url: '', text: '', eventType: '', eventOptions: {}}
     * @type {Array}
     */

    this.callsToAction = data.callsToAction || [];
    /**
     * Determines if an accordian result should be collapsed by default
     * @type {boolean}
     */

    this.collapsed = data.collapsed === undefined ? true : data.collapsed;
  };

  /** @module HighlightedValue */

  /**
   * Model representing a highlighted value.
   */
  var HighlightedValue =
  /*#__PURE__*/
  function () {
    function HighlightedValue() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HighlightedValue);

      this.value = data.value || data.shortValue || '';
      this.matchedSubstrings = data.matchedSubstrings || [];
    }
    /**
     * get highlighted value string
     * @returns {string}
     */


    _createClass(HighlightedValue, [{
      key: "get",
      value: function get() {
        this._sortMatchedSubstrings();

        return this.buildHighlightedValue(this.value, this.matchedSubstrings);
      }
      /**
       * get inverted highlighted value string
       * @returns {string}
       */

    }, {
      key: "getInverted",
      value: function getInverted() {
        this._sortMatchedSubstrings();

        var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

        return this.buildHighlightedValue(this.value, invertedSubstrings);
      }
      /**
       * introduces highlighting to input data according to highlighting specifiers
       *
       * @param {Object} val input object to apply highlighting to
       *
       *  example object :
       *  {
       *    name: 'ATM',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 ATMs'
       *    }
       *  }
       *
       * @param {Object} highlightedSubstrings highlighting specifiers to apply to input object
       *
       *  example object :
       *  {
       *    name: {
       *      matchedSubstrings: [{
       *        length: 3,
       *        offset: 0
       *      }],
       *      value: 'ATM'
       *    },
       *    featuredMessage: {
       *      description: {
       *        matchedSubstrings: [{
       *          length: 4,
       *          offset: 45
       *        }],
       *        value: 'Save time & bank on your terms at over 1,800 ATMs'
       *      }
       *    }
       *  }
       *
       * @returns {string} copy of input value with highlighting applied
       *
       *  example object :
       *  {
       *    name: '<strong>ATM</strong>',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 <strong>ATMs</strong>'
       *    }
       *  }
       *
       */

    }, {
      key: "buildHighlightedValue",
      value: function buildHighlightedValue(val, highlightedSubstrings) {
        var highlightedValue = '';
        var nextStart = 0;

        if (highlightedSubstrings.length === 0) {
          return val;
        }

        for (var j = 0; j < highlightedSubstrings.length; j++) {
          var start = Number(highlightedSubstrings[j].offset);
          var end = start + highlightedSubstrings[j].length;
          highlightedValue += [val.slice(nextStart, start), '<strong>', val.slice(start, end), '</strong>'].join('');

          if (j === highlightedSubstrings.length - 1 && end < val.length) {
            highlightedValue += val.slice(end);
          }

          nextStart = end;
        }

        return highlightedValue;
      }
    }, {
      key: "_sortMatchedSubstrings",
      value: function _sortMatchedSubstrings() {
        this.matchedSubstrings.sort(function (a, b) {
          if (a.offset < b.offset) {
            return -1;
          }

          if (a.offset > b.offset) {
            return 1;
          }

          return 0;
        });
      }
    }, {
      key: "_getInvertedSubstrings",
      value: function _getInvertedSubstrings(matchedSubstrings, valueLength) {
        var invertedSubstrings = [];

        for (var i = 0; i < matchedSubstrings.length; i++) {
          var substring = matchedSubstrings[i];
          var nextOffset = substring.offset + substring.length;

          if (i === 0 && substring.offset !== 0) {
            invertedSubstrings.push({
              offset: 0,
              length: substring.offset
            });
          }

          if (valueLength > nextOffset) {
            invertedSubstrings.push({
              offset: nextOffset,
              length: i < matchedSubstrings.length - 1 ? matchedSubstrings[i + 1].offset - nextOffset : valueLength - nextOffset
            });
          }
        }

        return invertedSubstrings;
      }
    }]);

    return HighlightedValue;
  }();

  /** @module Errors */

  /**
   * AnswersBaseError is an extension of the base Error object.
   * This is the object that is used to when reporting to the server.
   * @extends Error
   *
   * Error codes fall into one of four categories:
   * 1XX errors: Basic errors
   * 2XX errors: UI errors
   * 3XX errors: Endpoint errors
   * 4XX errors: Core errors
   */
  var AnswersBaseError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(AnswersBaseError, _Error);

    function AnswersBaseError(errorCode, message) {
      var _this;

      var boundary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unknown';
      var causedBy = arguments.length > 3 ? arguments[3] : undefined;

      _classCallCheck(this, AnswersBaseError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnswersBaseError).call(this, message));
      _this.errorCode = errorCode;
      _this.errorMessage = message;
      _this.boundary = boundary;
      _this.reported = false;

      if (causedBy) {
        _this.causedBy = causedBy instanceof AnswersBaseError ? causedBy : AnswersBaseError.from(causedBy);
        _this.stack = "".concat(_this.stack, "\nCaused By: ").concat(_this.causedBy.stack);
      }

      return _this;
    }

    _createClass(AnswersBaseError, [{
      key: "toJson",
      value: function toJson() {
        return JSON.stringify(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        var string = "".concat(this.errorMessage, " (").concat(this.boundary, ")");

        if (this.causedBy) {
          string += "\n  Caused By: ".concat(this.causedBy.toString());
        }

        return string;
      }
    }], [{
      key: "from",
      value: function from(builtinError, boundary) {
        var error = new AnswersBasicError(builtinError.message, boundary);
        error.stack = builtinError.stack;
        return error;
      }
    }]);

    return AnswersBaseError;
  }(_wrapNativeSuper(Error));
  /**
   * AnswersBasicError is a wrapper around all the built-in errors
   * e.g. undefined variables, incorrect syntax, types, missing methods, etc.
   * @extends AnswersBaseError
   */

  var AnswersBasicError =
  /*#__PURE__*/
  function (_AnswersBaseError) {
    _inherits(AnswersBasicError, _AnswersBaseError);

    function AnswersBasicError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersBasicError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersBasicError).call(this, 100, message, boundary, causedBy));
    }

    return AnswersBasicError;
  }(AnswersBaseError);
  /**
   * AnswersUiError used for things like DOM errors.
   * @extends AnswersBaseError
   */

  var AnswersConfigError =
  /*#__PURE__*/
  function (_AnswersBaseError2) {
    _inherits(AnswersConfigError, _AnswersBaseError2);

    function AnswersConfigError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersConfigError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersConfigError).call(this, 101, message, boundary, causedBy));
    }

    return AnswersConfigError;
  }(AnswersBaseError);
  /**
   * AnswersComponentError is used for Component oriented errors
   * e.g. failure to render, or catching unknowns.
   * @extends AnswersBaseError
   */

  var AnswersComponentError =
  /*#__PURE__*/
  function (_AnswersBaseError4) {
    _inherits(AnswersComponentError, _AnswersBaseError4);

    function AnswersComponentError(message, component, causedBy) {
      _classCallCheck(this, AnswersComponentError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersComponentError).call(this, 201, message, component, causedBy));
    }

    return AnswersComponentError;
  }(AnswersBaseError);
  /**
   * AnswersEndpointError represents all network related errors.
   * @extends AnswersBaseError
   */

  var AnswersEndpointError =
  /*#__PURE__*/
  function (_AnswersBaseError5) {
    _inherits(AnswersEndpointError, _AnswersBaseError5);

    function AnswersEndpointError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersEndpointError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersEndpointError).call(this, 300, message, boundary, causedBy));
    }

    return AnswersEndpointError;
  }(AnswersBaseError);
  /**
   * AnswersCoreError represents errors for precondition failures in the core library
   * @extends AnswersBaseError
   */

  var AnswersCoreError =
  /*#__PURE__*/
  function (_AnswersBaseError6) {
    _inherits(AnswersCoreError, _AnswersBaseError6);

    function AnswersCoreError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersCoreError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersCoreError).call(this, 400, message, boundary, causedBy));
    }

    return AnswersCoreError;
  }(AnswersBaseError);
  /**
   * AnswersStorageError represents storage related errors
   * @extends AnswersBaseError
   */

  var AnswersStorageError =
  /*#__PURE__*/
  function (_AnswersBaseError7) {
    _inherits(AnswersStorageError, _AnswersBaseError7);

    function AnswersStorageError(message, storageKey, data, causedBy) {
      var _this2;

      _classCallCheck(this, AnswersStorageError);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersStorageError).call(this, 401, message, 'Storage', causedBy));
      _this2.storageKey = storageKey;
      _this2.data = data;
      return _this2;
    }

    return AnswersStorageError;
  }(AnswersBaseError);
  /**
   * AnswersAnalyticsError is used for errors when reporting analytics
   * @extends AnswersBaseError
   */

  var AnswersAnalyticsError =
  /*#__PURE__*/
  function (_AnswersBaseError8) {
    _inherits(AnswersAnalyticsError, _AnswersBaseError8);

    function AnswersAnalyticsError(message, event, causedBy) {
      var _this3;

      _classCallCheck(this, AnswersAnalyticsError);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersAnalyticsError).call(this, 402, message, 'Analytics', causedBy));
      _this3.event = event;
      return _this3;
    }

    return AnswersAnalyticsError;
  }(AnswersBaseError);

  var ResultFactory =
  /*#__PURE__*/
  function () {
    function ResultFactory() {
      _classCallCheck(this, ResultFactory);
    }

    _createClass(ResultFactory, null, [{
      key: "from",

      /**
       * Converts an API result object into a Result view model.
       * Includes default mappings of GoogleCustomSearchEngine results to
       * the fields exposed by the template.
       * @param resultsData  {Array} expected format: { data: { ... }, highlightedFields: { ... }}
       * @param {Object.<string, function>} formatters The formatters to apply to the result
       * @param {string} verticalId The vertical of these results
       * @param {string} source Backend source of these results
       * @returns {Result[]}
       */
      value: function from(resultsData, formatters, verticalId, source) {
        var results = [];

        for (var i = 0; i < resultsData.length; i++) {
          var data = resultsData[i].data || resultsData[i];

          switch (source) {
            case 'GOOGLE_CSE':
              results.push(ResultFactory.fromGoogleCustomSearchEngine(data));
              break;

            case 'BING_CSE':
              results.push(ResultFactory.fromBingCustomSearchEngine(data));
              break;

            case 'ZENDESK':
              results.push(ResultFactory.fromZendeskSearchEngine(data));
              break;

            case 'ALGOLIA':
              results.push(ResultFactory.fromAlgoliaSearchEngine(data));
              break;

            case 'KNOWLEDGE_MANAGER':
              var highlightedFields = resultsData[i].highlightedFields || {};
              results.push(ResultFactory.fromKnowledgeManager(data, formatters, verticalId, highlightedFields, i));
              break;

            default:
              results.push(ResultFactory.fromGeneric(data, i));
          }
        }

        return results;
      }
      /**
       * Applies field formatters to Knowledge Manager Entity Profile Data
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} formatters Developer specified Field Formatters
       * @param {string} verticalId Identifier for Vertical
       * @param {Object} highlightedEntityProfileData Subset of Entity Profile Data with highlighting applied
       * @returns {Object} Subset of Entity Profile Data Fields with field formatters applied
       */

    }, {
      key: "computeFormattedData",
      value: function computeFormattedData(entityProfileData, formatters, verticalId, highlightedEntityProfileData) {
        // if no field formatters specified, nothing to format
        if (Object.keys(formatters).length === 0) {
          return {};
        }

        var formattedData = {};
        Object.entries(entityProfileData).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              fieldName = _ref2[0],
              fieldVal = _ref2[1];

          // check if a field formatter exists for the current entity profile field
          if (formatters[fieldName] === undefined) {
            return;
          } // verify the field formatter provided is a formatter function as expected


          if (typeof formatters[fieldName] !== 'function') {
            throw new AnswersCoreError('Field formatter is not of expected type function', 'ResultFactory');
          } // if highlighted version of field value is available, make it available to field formatter


          var highlightedFieldVal = null;

          if (highlightedEntityProfileData && highlightedEntityProfileData[fieldName]) {
            highlightedFieldVal = highlightedEntityProfileData[fieldName];
          } // call formatter function associated with the field name
          // the input object defines the interface that field formatter functions work with


          formattedData[fieldName] = formatters[fieldName]({
            entityProfileData: entityProfileData,
            entityFieldValue: fieldVal,
            highlightedEntityFieldValue: highlightedFieldVal,
            verticalId: verticalId,
            isDirectAnswer: false
          });
        });
        return formattedData;
      }
      /**
       * Applies highlighting to substrings within Knowledge Manager Entity Field Values
       * according to highlighting specifiers returned from the Knowledge Manager Search Backend
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} highlightedFields KM specified highlighting instructions to highlight certain Fields
       * @returns {Object} Subset of Entity Profile Data Fields with highlighting applied
       */

    }, {
      key: "computeHighlightedData",
      value: function computeHighlightedData(entityProfileData, highlightedFields) {
        // if no highlighted fields specified, nothing to highlight
        if (Object.keys(highlightedFields).length === 0) {
          return {};
        }

        var highlightedData = {}; // iterate through entity fields that have highlighting instructions

        Object.entries(highlightedFields).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              highlightedFieldName = _ref4[0];

          // verify that the highlighted field name corresponds to an existing entity profile field
          if (entityProfileData[highlightedFieldName] === undefined) {
            throw new AnswersCoreError('Highlighted Field Name does not exist in Entity Profile', 'ResultFactory');
          }

          var highlightedField = highlightedFields[highlightedFieldName]; // check for nested fields

          if (_typeof(highlightedField) === 'object' && Object.keys(highlightedField).length > 0 && highlightedField['matchedSubstrings'] === undefined) {
            // recurse to children fields
            highlightedData[highlightedFieldName] = ResultFactory.computeHighlightedData(entityProfileData[highlightedFieldName], highlightedFields[highlightedFieldName]);
          } else {
            var highlightedDataValue = new HighlightedValue(entityProfileData).buildHighlightedValue(highlightedField.value, highlightedField.matchedSubstrings);
            highlightedData[highlightedFieldName] = highlightedDataValue;
          }
        });
        return highlightedData;
      }
      /**
       * Converts an API result object into a generic result view model.
       * @param {Object} data
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromGeneric",
      value: function fromGeneric(data, index) {
        return new Result({
          raw: data,
          title: data.name,
          details: this.truncate(data.description),
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a Knowledge Manager result view model.
       * @param {Object} data
       * @param {Object} formatters
       * @param {string} verticalId
       * @param {Object} highlightedFields
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromKnowledgeManager",
      value: function fromKnowledgeManager(data, formatters, verticalId, highlightedFields, index) {
        // compute highlighted entity profile data
        var highlightedEntityProfileData = ResultFactory.computeHighlightedData(data, highlightedFields); // compute formatted entity profile data

        var formattedEntityProfileData = ResultFactory.computeFormattedData(data, formatters, verticalId, highlightedEntityProfileData); // set result details checking the following in order of priority : formatted, highlighted, raw

        var resultDetails = null;

        if (formattedEntityProfileData.description !== undefined) {
          resultDetails = formattedEntityProfileData.description;
        } else if (highlightedEntityProfileData.description !== undefined) {
          resultDetails = this.truncate(highlightedEntityProfileData.description);
        } else {
          resultDetails = this.truncate(data.description);
        }

        return new Result({
          raw: data,
          formatted: formattedEntityProfileData,
          highlighted: highlightedEntityProfileData,
          title: formattedEntityProfileData.name || data.name,
          details: resultDetails,
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Google Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromGoogleCustomSearchEngine",
      value: function fromGoogleCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.htmlTitle.replace(/(<([^>]+)>)/ig, ''),
          details: data.htmlSnippet,
          link: data.link
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Bing Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromBingCustomSearchEngine",
      value: function fromBingCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.name,
          details: data.snippet,
          link: data.url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Zendesk Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromZendeskSearchEngine",
      value: function fromZendeskSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.title,
          details: data.snippet,
          link: data.html_url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Algolia Search Engine object.
       * Details field is set to objectID since response has only one general field objectID.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromAlgoliaSearchEngine",
      value: function fromAlgoliaSearchEngine(data) {
        return new Result({
          raw: data,
          details: data.objectID,
          id: data.objectID
        });
      }
      /**
       * Truncates strings to 250 characters, attempting to preserve whole words
       * @param str {string} the string to truncate
       * @param limit {Number} the maximum character length to return
       * @param trailing {string} a trailing string to denote truncation, e.g. '...'
       * @param sep {string} the word separator
       * @returns {string}
       */

    }, {
      key: "truncate",
      value: function truncate(str) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
        var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';
        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';

        if (!str || str.length <= limit) {
          return str;
        } // TODO (bmcginnis): split punctuation too so we don't end up with "foo,..."


        var words = str.split(sep);
        var max = limit - trailing.length;
        var truncated = '';

        for (var i = 0; i < words.length; i++) {
          var word = words[i];

          if (truncated.length + word.length > max || i !== 0 && truncated.length + word.length + sep.length > max) {
            truncated += trailing;
            break;
          }

          truncated += i === 0 ? word : sep + word;
        }

        return truncated;
      }
    }]);

    return ResultFactory;
  }();

  var Section =
  /*#__PURE__*/
  function () {
    function Section(data, url, formatters) {
      _classCallCheck(this, Section);

      this.searchState = SearchStates.SEARCH_COMPLETE;
      this.verticalConfigId = data.verticalConfigId || null;
      this.resultsCount = data.resultsCount || 0;
      this.encodedState = data.encodedState || '';
      this.appliedQueryFilters = AppliedQueryFilter.from(data.appliedQueryFilters);
      this.facets = data.facets || null;
      this.results = ResultFactory.from(data.results, formatters, this.verticalConfigId, data.source);
      this.map = Section.parseMap(data.results);
      this.verticalURL = url || null;
    }

    _createClass(Section, null, [{
      key: "parseMap",
      value: function parseMap(results) {
        var mapMarkers = [];
        var centerCoordinates = {};

        for (var j = 0; j < results.length; j++) {
          // TODO(billy) Remove legacy fallback from all data format
          var result = results[j].data || results[j];

          if (result && result.yextDisplayCoordinate) {
            if (!centerCoordinates.latitude) {
              centerCoordinates = {
                latitude: result.yextDisplayCoordinate.latitude,
                longitude: result.yextDisplayCoordinate.longitude
              };
            }

            mapMarkers.push({
              item: result,
              label: mapMarkers.length + 1,
              latitude: result.yextDisplayCoordinate.latitude,
              longitude: result.yextDisplayCoordinate.longitude
            });
          }
        }

        return {
          'mapCenter': centerCoordinates,
          'mapMarkers': mapMarkers
        };
      }
      /**
       * Create a section from the provided data
       * @param {Object|Array} modules The result modules
       * @param {Object} urls The tab urls
       * @param {Object.<string, function>} formatters Field formatters for results
       */

    }, {
      key: "from",
      value: function from(modules, urls, formatters) {
        var sections = [];

        if (!modules) {
          return sections;
        }

        if (!Array.isArray(modules)) {
          return new Section(modules, null, formatters);
        } // Our sections should contain a property of mapMarker objects


        for (var i = 0; i < modules.length; i++) {
          sections.push(new Section(modules[i], urls[modules[i].verticalConfigId], formatters));
        }

        return sections;
      }
    }]);

    return Section;
  }();

  var AppliedQueryFilter =
  /*#__PURE__*/
  function () {
    // Support legacy model and new model until fully migrated.
    // TODO(billy) Remove the left expression during assignment when migrated.
    function AppliedQueryFilter(appliedQueryFilter) {
      _classCallCheck(this, AppliedQueryFilter);

      this.key = appliedQueryFilter.key || appliedQueryFilter.displayKey;
      this.value = appliedQueryFilter.value || appliedQueryFilter.displayValue;
    }

    _createClass(AppliedQueryFilter, null, [{
      key: "from",
      value: function from(appliedQueryFilters) {
        var filters = [];

        for (var i = 0; i < appliedQueryFilters.length; i++) {
          filters.push(new AppliedQueryFilter(appliedQueryFilters[i]));
        }

        return filters;
      }
    }]);

    return AppliedQueryFilter;
  }();

  var UniversalResults =
  /*#__PURE__*/
  function () {
    function UniversalResults(data) {
      _classCallCheck(this, UniversalResults);

      this.queryId = data.queryId || null;
      this.sections = data.sections || [];
      /**
       * The current state of the search, used to render different templates before, during,
       * and after loading
       * @type {string}
       */

      this.searchState = data.searchState || SearchStates.SEARCH_COMPLETE;
    }
    /**
     * Create universal results from server data
     * @param {Object} response The server response
     * @param {Object} urls The tab urls
     * @param {Object.<string, function>} formatters The field formatters to use
     */


    _createClass(UniversalResults, null, [{
      key: "from",
      value: function from(response, urls, formatters) {
        return new UniversalResults({
          queryId: response.queryId,
          sections: Section.from(response.modules, urls, formatters)
        });
      }
      /**
       * Construct a UnivervalResults object representing loading results
       * @return {UniversalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new UniversalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }]);

    return UniversalResults;
  }();

  /** @module DirectAnswer */
  var DirectAnswer =
  /*#__PURE__*/
  function () {
    function DirectAnswer() {
      var directAnswer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, DirectAnswer);

      Object.assign(this, directAnswer);
      Object.freeze(this);
    }
    /**
     * Create a DirectAnswer model from the given server data and formatters
     * @param {Object} response The server direct answer
     * @param {Object.<string, function>} formatters The formatters to apply to this direct answer
     */


    _createClass(DirectAnswer, null, [{
      key: "from",
      value: function from(response, formatters) {
        var data = _objectSpread({}, response);

        var answer = data.answer,
            relatedItem = data.relatedItem;

        if (answer && formatters[answer.fieldApiName]) {
          answer.value = formatters[answer.fieldApiName](answer.value, relatedItem.data.fieldValues, relatedItem.verticalConfigId, true);
        }

        return new DirectAnswer(data);
      }
    }]);

    return DirectAnswer;
  }();

  /** @module Navigation */
  var Navigation =
  /*#__PURE__*/
  function () {
    function Navigation(tabOrder) {
      _classCallCheck(this, Navigation);

      this.tabOrder = tabOrder || [];
      Object.freeze(this);
    }

    _createClass(Navigation, null, [{
      key: "from",
      value: function from(modules) {
        var nav = [];

        if (!modules || !Array.isArray(modules)) {
          return nav;
        }

        for (var i = 0; i < modules.length; i++) {
          nav.push(modules[i].verticalConfigId);
        }

        return new Navigation(nav);
      }
    }]);

    return Navigation;
  }();

  var VerticalResults =
  /*#__PURE__*/
  function () {
    function VerticalResults() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, VerticalResults);

      Object.assign(this, {
        searchState: SearchStates.SEARCH_COMPLETE
      }, data);
      Object.freeze(this);
    }
    /**
     * Append the provided results to the current results
     * @param {VerticalResults} results the results to append to the current results
     */


    _createClass(VerticalResults, [{
      key: "append",
      value: function append(results) {
        var merged = _objectSpread({}, this);

        merged.results = this.results.concat(results.results);
        merged.map.mapMarkers = this.map.mapMarkers.concat(results.map.mapMarkers);
        return new VerticalResults(merged);
      }
      /**
       * Create vertical results from server data
       * @param {Object} response The server response
       * @param {Object.<string, function>} formatters The field formatters to use
       */

    }], [{
      key: "from",
      value: function from(response, formatters) {
        return new VerticalResults(Section.from(response, null, formatters));
      }
      /**
       * Construct a VerticalResults object representing loading results
       * @return {VerticalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new VerticalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }]);

    return VerticalResults;
  }();

  /**
   * SpellCheck is the core state model
   * to power the SpellCheck component
   */

  var SpellCheck =
  /*#__PURE__*/
  function () {
    function SpellCheck(data) {
      _classCallCheck(this, SpellCheck);

      /**
       * The original query
       * @type {string}
       */
      this.query = data.query || null;
      /**
       * The corrected query
       * @type {string}
       */

      this.correctedQuery = data.correctedQuery || null;
      /**
       * The corrected query with highlighted tags
       * @type {string}
       */

      this.correctedQueryDisplay = data.correctedQueryDisplay || null;
      /**
       * The spell check type
       * @type {string}
       */

      this.type = data.type || null;
      /**
       * Should show spell check or not
       * @type {boolean}
       */

      this.shouldShow = this.correctedQuery !== null;
    }
    /**
     * Create a spell check model from the provided data
     * @param {Object} response The spell check response
     */


    _createClass(SpellCheck, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return {};
        }

        return new SpellCheck({
          query: response.originalQuery,
          correctedQuery: response.correctedQuery,
          correctedQueryDisplay: new HighlightedValue(response.correctedQuery).get(),
          type: response.type
        });
      }
    }]);

    return SpellCheck;
  }();

  /** @module StorageKeys */

  /**
   * StorageKeys is an ENUM are considered the root context
   * for how data is stored and scoped in the storage.
   *
   * @enum {string}
   */
  var StorageKeys = {
    NAVIGATION: 'navigation',
    UNIVERSAL_RESULTS: 'universal-results',
    VERTICAL_RESULTS: 'vertical-results',
    AUTOCOMPLETE: 'autocomplete',
    DIRECT_ANSWER: 'direct-answer',
    FILTER: 'filter',
    QUERY: 'query',
    QUERY_ID: 'query-id',
    FACET_FILTER: 'facet-filter',
    DYNAMIC_FILTERS: 'dynamic-filters',
    PARAMS: 'params',
    GEOLOCATION: 'geolocation',
    INTENTS: 'intents',
    QUESTION_SUBMISSION: 'question-submission',
    SEARCH_CONFIG: 'search-config',
    SEARCH_OFFSET: 'search-offset',
    SPELL_CHECK: 'spell-check',
    LOCATION_BIAS: 'location-bias',
    SESSIONS_OPT_IN: 'sessions-opt-in',
    NAVIGATION_CONFIG: 'navigation-config',
    LOCALE: 'locale',
    SORT_BYS: 'sort-bys'
  };

  /** @module DynamicFilters */

  /**
   * Model representing a set of dynamic filters
   */
  var DynamicFilters =
  /*#__PURE__*/
  function () {
    function DynamicFilters(data) {
      _classCallCheck(this, DynamicFilters);

      /**
       * The list of filters this model holds
       * @type {{label: string, fieldId: string, options: object[]}}
       */
      this.filters = data.filters || [];
      Object.freeze(this);
    }
    /**
     * Organize 'facets' from the api response into dynamic filters
     * @param {Object} response dynamic filter response from the api
     * @returns {DynamicFilters}
     */


    _createClass(DynamicFilters, null, [{
      key: "from",
      value: function from(response) {
        var facets = response.facets;
        var dynamicFilters = facets.map(function (f) {
          return {
            label: f['displayName'],
            fieldId: f['fieldId'],
            options: f.options.map(function (o) {
              return {
                label: o['displayName'],
                countLabel: o['count'],
                selected: o['selected'],
                filter: o['filter']
              };
            })
          };
        });
        return new DynamicFilters({
          filters: dynamicFilters
        });
      }
    }]);

    return DynamicFilters;
  }();

  /** @module SearchIntents */
  var SearchIntents =
  /*#__PURE__*/
  function () {
    function SearchIntents(intents) {
      _classCallCheck(this, SearchIntents);

      /**
       * The intent to find results based on the user's location
       * @type {boolean}
       */
      this.nearMe = intents.nearMe;
      Object.freeze(this);
    }
    /**
     * Create SearchIntents from server response
     * @param {Object} response The server response intents
     * @returns {SearchIntents}
     */


    _createClass(SearchIntents, null, [{
      key: "from",
      value: function from(response) {
        var intents = response || [];
        return new SearchIntents({
          nearMe: intents.includes('NEAR_ME')
        });
      }
    }]);

    return SearchIntents;
  }();

  /** @module LocationBias */

  /**
   * LocationBias is the core state model
   * to power the LocationBias component
   */
  var LocationBias =
  /*#__PURE__*/
  function () {
    function LocationBias(data) {
      _classCallCheck(this, LocationBias);

      /**
       * The location bias accuracy which are IP, DEVICE and UNKNWON
       * @type {string}
       */
      this.accuracy = data.accuracy || null;
      /**
       * The latitude used for location bias
       * @type {number}
       */

      this.latitude = data.latitude || null;
      /**
       * The longitude used for location bias
       * @type {number}
       */

      this.longitude = data.longitude || null;
      /**
       * The location display name
       * @type {string}
       */

      this.locationDisplayName = data.locationDisplayName || null;
    }
    /**
     * Create a location bias model from the provided data
     * @param {Object} response The location bias response
     */


    _createClass(LocationBias, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return new LocationBias({
            accuracy: 'UNKNOWN'
          });
        }

        return new LocationBias({
          accuracy: response.accuracy,
          latitude: response.latitude,
          longitude: response.longitude,
          locationDisplayName: response.locationDisplayName
        });
      }
    }]);

    return LocationBias;
  }();

  /**
   * A Data Transformer that takes the response object from a Search request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   */

  var SearchDataTransformer =
  /*#__PURE__*/
  function () {
    function SearchDataTransformer() {
      _classCallCheck(this, SearchDataTransformer);
    }

    _createClass(SearchDataTransformer, null, [{
      key: "transform",
      value: function transform(data) {
        var _ref;

        var urls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var formatters = arguments.length > 2 ? arguments[2] : undefined;
        var response = data.response;
        return _ref = {}, _defineProperty(_ref, StorageKeys.QUERY_ID, response.queryId), _defineProperty(_ref, StorageKeys.NAVIGATION, Navigation.from(response.modules)), _defineProperty(_ref, StorageKeys.DIRECT_ANSWER, DirectAnswer.from(response.directAnswer, formatters)), _defineProperty(_ref, StorageKeys.UNIVERSAL_RESULTS, UniversalResults.from(response, urls, formatters)), _defineProperty(_ref, StorageKeys.INTENTS, SearchIntents.from(response.searchIntents)), _defineProperty(_ref, StorageKeys.SPELL_CHECK, SpellCheck.from(response.spellCheck)), _defineProperty(_ref, StorageKeys.LOCATION_BIAS, LocationBias.from(response.locationBias)), _ref;
      }
    }, {
      key: "transformVertical",
      value: function transformVertical(data, formatters) {
        var _ref2;

        return _ref2 = {}, _defineProperty(_ref2, StorageKeys.QUERY_ID, data.response.queryId), _defineProperty(_ref2, StorageKeys.NAVIGATION, new Navigation()), _defineProperty(_ref2, StorageKeys.VERTICAL_RESULTS, VerticalResults.from(data.response, formatters)), _defineProperty(_ref2, StorageKeys.DYNAMIC_FILTERS, DynamicFilters.from(data.response)), _defineProperty(_ref2, StorageKeys.INTENTS, SearchIntents.from(data.response.searchIntents)), _defineProperty(_ref2, StorageKeys.SPELL_CHECK, SpellCheck.from(data.response.spellCheck)), _defineProperty(_ref2, StorageKeys.LOCATION_BIAS, LocationBias.from(data.response.locationBias)), _ref2;
      }
    }]);

    return SearchDataTransformer;
  }();

  /** @module QuestionSubmission */

  /**
   * QuestionSubmission is the core state model
   * to power the QuestionSubmission component
   */
  var QuestionSubmission =
  /*#__PURE__*/
  function () {
    function QuestionSubmission() {
      var question = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var errors = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, QuestionSubmission);

      /**
       * The author of the question
       * @type {string}
       */
      this.name = question.name || null;
      /**
       * The email address of the question
       * @type {string}
       */

      this.email = question.email || null;
      /**
       * True if the privacy policy was approved
       * @type {boolean}
       */

      this.privacyPolicy = question.privacyPolicy || null;
      /**
       * The question to be sent to the server
       * @type {string}
       */

      this.questionText = question.questionText || null;
      /**
       * Alternative question meta information
       * @type {string}
       */

      this.questionDescription = question.questionDescription || null;
      /**
       * Whether the form is expanded or not. Defaults to true.
       */

      this.questionExpanded = typeof question.expanded !== 'boolean' || question.expanded;
      /**
       * Contains any errors about the question submission
       * @type {object}
       */

      this.errors = errors || null;
      /**
       * Whether the form has been submitted or not. Defaults to false.
       */

      this.questionSubmitted = question.submitted || false;
      Object.freeze(this);
    }

    _createClass(QuestionSubmission, null, [{
      key: "submitted",
      value: function submitted() {
        return {
          questionSubmitted: true,
          questionExpanded: true
        };
      }
    }, {
      key: "errors",
      value: function errors(question, _errors) {
        return QuestionSubmission(question, _errors);
      }
    }]);

    return QuestionSubmission;
  }();

  /** @module Filter */

  /**
   * Represents an api filter and provides static methods for easily constructing Filters.
   * See https://developer.yext.com/docs/api-reference/#operation/listEntities for structure details
   */
  var Filter =
  /*#__PURE__*/
  function () {
    function Filter() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Filter);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Parse a JSON format filter returned from the server into a Filter
     * @param {*} responseFilter A filter in JSON format returned from the backend
     * @returns {Filter}
     */


    _createClass(Filter, null, [{
      key: "fromResponse",
      value: function fromResponse(responseFilter) {
        return new Filter(JSON.parse(responseFilter));
      }
      /**
       * Return a new Filter representing the OR of all provided filters
       * @param  {...Filter} filters The filters to OR together
       * @returns {Filter}
       */

    }, {
      key: "or",
      value: function or() {
        for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
          filters[_key] = arguments[_key];
        }

        return new Filter({
          '$or': filters
        });
      }
      /**
       * Return a new Filter representing the AND of all provided filters
       * @param  {...Filter} filters The filters to AND together
       * @returns {Filter}
       */

    }, {
      key: "and",
      value: function and() {
        for (var _len2 = arguments.length, filters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          filters[_key2] = arguments[_key2];
        }

        return new Filter({
          '$and': filters
        });
      }
      /**
       * OR filters with the same keys, then AND the resulting groups
       * @param  {...Filter} filters The filters to group
       * @returns {Filter}
       */

    }, {
      key: "group",
      value: function group() {
        var groups = {};

        for (var _len3 = arguments.length, filters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          filters[_key3] = arguments[_key3];
        }

        for (var _i = 0, _filters = filters; _i < _filters.length; _i++) {
          var filter = _filters[_i];
          var key = Object.keys(filter)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(filter);
        }

        var groupFilters = [];

        for (var _i2 = 0, _Object$keys = Object.keys(groups); _i2 < _Object$keys.length; _i2++) {
          var field = _Object$keys[_i2];
          groupFilters.push(groups[field].length > 1 ? Filter.or.apply(Filter, _toConsumableArray(groups[field])) : groups[field][0]);
        }

        return groupFilters.length > 1 ? Filter.and.apply(Filter, groupFilters) : groupFilters[0];
      }
      /**
       * Create a new "equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be equal to
       * @returns {Filter}
       */

    }, {
      key: "equal",
      value: function equal(field, value) {
        return Filter._fromMatcher(field, '$eq', value);
      }
      /**
       * Create a new "less than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than
       * @returns {Filter}
       */

    }, {
      key: "lessThan",
      value: function lessThan(field, value) {
        return Filter._fromMatcher(field, '$lt', value);
      }
      /**
       * Create a new "less than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than or equal to
       * @returns {Filter}
       */

    }, {
      key: "lessThanEqual",
      value: function lessThanEqual(field, value) {
        return Filter._fromMatcher(field, '$le', value);
      }
      /**
       * Create a new "greater than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than
       * @returns {Filter}
       */

    }, {
      key: "greaterThan",
      value: function greaterThan(field, value) {
        return Filter._fromMatcher(field, '$gt', value);
      }
      /**
       * Create a new "greater than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than or equal to
       * @returns {Filter}
       */

    }, {
      key: "greaterThanEqual",
      value: function greaterThanEqual(field, value) {
        return Filter._fromMatcher(field, '$ge', value);
      }
      /**
       * Create a new inclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "inclusiveRange",
      value: function inclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$ge': min,
          '$le': max
        }));
      }
      /**
       * Create a new exclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "exclusiveRange",
      value: function exclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$gt': min,
          '$lt': max
        }));
      }
      /**
       * Create a new position filter
       * @param {number} lat The latitude of the position
       * @param {number} lng The longitude of the position
       * @param {number} radius The search radius (in meters)
       */

    }, {
      key: "position",
      value: function position(lat, lng, radius) {
        return Filter._fromMatcher('builtin.location', '$near', {
          lat: lat,
          lng: lng,
          radius: radius
        });
      }
      /**
       * Create a new filter with the given matcher
       * @private
       * @param {string} field The subject field of the filter
       * @param {string} matcher The matcher for the filer
       * @param {*} value The value for the filter
       * @returns {Filter}
       */

    }, {
      key: "_fromMatcher",
      value: function _fromMatcher(field, matcher, value) {
        return new Filter(_defineProperty({}, field, _defineProperty({}, matcher, value)));
      }
    }]);

    return Filter;
  }();

  /** @typedef {import('./services/searchservice').default} SearchService */

  /** @typedef {import('./services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./services/questionanswerservice').default} QuestionAnswerService */

  /**
   * Core is the main application container for all of the network and storage
   * related behaviors of the application.
   */

  var Core =
  /*#__PURE__*/
  function () {
    function Core() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Core);

      /**
       * A reference to the client API Key used for all requests
       * @type {string}
       * @private
       */
      this._apiKey = config.apiKey;
      /**
       * A reference to the client Answers Key used for all requests
       * @type {string}
       * @private
       */

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * A reference to the client locale used for all requests. If not specified, defaults to "en" (for
       * backwards compatibility).
       * @type {string}
       * @private
       */

      this._locale = config.locale;
      /**
       * A map of field formatters used to format results, if present
       * @type {Object.<string, function>}
       * @private
       */

      this._fieldFormatters = config.fieldFormatters || {};
      /**
       * A reference to the core data storage that powers the UI
       * @type {GlobalStorage}
       * @private
       */

      this.globalStorage = config.globalStorage;
      /**
       * A reference to the core persistent storage
       * @type {PersistentStorage}
       * @private
       */

      this.persistentStorage = config.persistentStorage;
      /**
       * An abstraction containing the integration with the RESTful search API
       * For both vertical and universal search
       * @type {SearchService}
       * @private
       */

      this._searcher = config.searchService;
      /**
       * An abstraction containing the integration with the RESTful autocomplete API
       * For filter search, vertical autocomplete, and universal autocomplete
       * @type {AutoCompleteService}
       * @private
       */

      this._autoComplete = config.autoCompleteService;
      /**
       * An abstraction for interacting with the Q&A rest interface
       * @type {QuestionAnswerService}
       * @private
       */

      this._questionAnswer = config.questionAnswerService;
    }
    /**
     * Search in the context of a vertical
     * @param {string} verticalKey vertical ID for the search
     * @param {object} query The query details
     * @param {string} query.input The input to search for
     * @param {string} query.filter The filter to use in the search
     * @param {string} query.facetFilter The facet filter to use in the search
     * @param {number} query.limit The max number of results to include, max of 50
     * @param {number} query.offset The results offset, for fetching more results of the same query
     * @param {string} query.id The query ID to use. If paging within a query, the same ID should be used
     * @param {boolean} query.append If true, adds the results of this query to the end of the current results, defaults false
     */


    _createClass(Core, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, query) {
        var _this = this;

        if (!query.append) {
          this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading());
          this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
          this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        }

        return this._searcher.verticalSearch(verticalKey, _objectSpread({
          limit: this.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit,
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION)
        }, query, {
          isDynamicFiltersEnabled: this._isDynamicFiltersEnabled,
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN),
          sortBys: this.globalStorage.getState(StorageKeys.SORT_BYS)
        })).then(function (response) {
          return SearchDataTransformer.transformVertical(response, _this._fieldFormatters);
        }).then(function (data) {
          _this.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          if (query.append) {
            var mergedResults = _this.globalStorage.getState(StorageKeys.VERTICAL_RESULTS).append(data[StorageKeys.VERTICAL_RESULTS]);

            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, mergedResults);
          } else {
            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, data[StorageKeys.VERTICAL_RESULTS]);
          }

          if (data[StorageKeys.DYNAMIC_FILTERS]) {
            _this.globalStorage.set(StorageKeys.DYNAMIC_FILTERS, data[StorageKeys.DYNAMIC_FILTERS]);
          }

          if (data[StorageKeys.SPELL_CHECK]) {
            _this.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);
          }

          if (data[StorageKeys.LOCATION_BIAS]) {
            _this.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);
          }

          _this.globalStorage["delete"]('skipSpellCheck');

          _this.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Page within the results of the last query
       * @param {string} verticalKey The vertical key to use in the search
       * @param {number} offset The offset to use in the search
       */

    }, {
      key: "verticalPage",
      value: function verticalPage(verticalKey, offset) {
        var allFilters = this.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var facetFilter = this.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.verticalSearch(verticalKey, {
          input: this.globalStorage.getState(StorageKeys.QUERY),
          id: this.globalStorage.getState(StorageKeys.QUERY_ID),
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter),
          offset: offset
        });
      }
    }, {
      key: "search",
      value: function search(queryString, urls) {
        var _this2 = this;

        this.globalStorage.set(StorageKeys.DIRECT_ANSWER, {});
        this.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
        this.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, {});
        this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
        this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        return this._searcher.universalSearch(queryString, {
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION),
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        }).then(function (response) {
          return SearchDataTransformer.transform(response, urls, _this2._fieldFormatters);
        }).then(function (data) {
          _this2.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this2.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this2.globalStorage.set(StorageKeys.DIRECT_ANSWER, data[StorageKeys.DIRECT_ANSWER]);

          _this2.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, data[StorageKeys.UNIVERSAL_RESULTS], urls);

          _this2.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          _this2.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);

          _this2.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);

          _this2.globalStorage["delete"]('skipSpellCheck');

          _this2.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Given an input, query for a list of similar results and set into storage
       *
       * @param {string} input     the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       */

    }, {
      key: "autoCompleteUniversal",
      value: function autoCompleteUniversal(input, namespace) {
        var _this3 = this;

        return this._autoComplete.queryUniversal(input).then(function (data) {
          _this3.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);

          return data;
        });
      }
      /**
       * Given an input, query for a list of similar results in the provided vertical
       * and set into storage
       *
       * @param {string} input       the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       * @param {string} verticalKey the vertical key for the experience
       */

    }, {
      key: "autoCompleteVertical",
      value: function autoCompleteVertical(input, namespace, verticalKey) {
        var _this4 = this;

        return this._autoComplete.queryVertical(input, verticalKey).then(function (data) {
          _this4.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);

          return data;
        });
      }
      /**
       * Given an input, provide a list of suitable filters for autocompletion
       *
       * @param {string} input  the string to search for filters with
       * @param {object} config  the config to serach for filters with
       * @param {string} config.namespace  the namespace to use for the storage key
       * @param {string} config.verticalKey the vertical key for the config
       * @param {object} config.searchParameters  the search parameters for the config v2
       */

    }, {
      key: "autoCompleteFilter",
      value: function autoCompleteFilter(input, config) {
        var _this5 = this;

        return this._autoComplete.queryFilter(input, config).then(function (data) {
          _this5.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(config.namespace), data);
        });
      }
      /**
       * Submits a question to the server and updates the underlying question model
       * @param {object} question The question object to submit to the server
       * @param {number} question.entityId The entity to associate with the question (required)
       * @param {string} question.lanuage The language of the question
       * @param {string} question.site The "publisher" of the (e.g. 'FIRST_PARTY')
       * @param {string} question.name The name of the author
       * @param {string} question.email The email address of the author
       * @param {string} question.questionText The question
       * @param {string} question.questionDescription Additional information about the question
       */

    }, {
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var _this6 = this;

        return this._questionAnswer.submitQuestion(question).then(function (data) {
          _this6.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, QuestionSubmission.submitted());
        });
      }
      /**
       * Stores the given sortBy into storage, to be used for the next search
       * @param {Object} sortByOptions
       */

    }, {
      key: "setSortBys",
      value: function setSortBys() {
        for (var _len = arguments.length, sortByOptions = new Array(_len), _key = 0; _key < _len; _key++) {
          sortByOptions[_key] = arguments[_key];
        }

        var sortBys = sortByOptions.map(function (option) {
          return {
            type: option.type,
            field: option.field,
            direction: option.direction
          };
        });
        this.globalStorage.set(StorageKeys.SORT_BYS, JSON.stringify(sortBys));
      }
      /**
       * Clears the sortBys key in global storage.
       */

    }, {
      key: "clearSortBys",
      value: function clearSortBys() {
        this.globalStorage["delete"](StorageKeys.SORT_BYS);
      }
      /**
       * Stores the given query into storage, to be used for the next search
       * @param {string} query the query to store
       */

    }, {
      key: "setQuery",
      value: function setQuery(query) {
        this.globalStorage.set(StorageKeys.QUERY, query);
      }
      /**
       * Stores the provided query ID, to be used in analytics
       * @param {string} queryId The query id to store
       */

    }, {
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this.globalStorage.set(StorageKeys.QUERY_ID, queryId);
      }
      /**
       * Stores the given filter into storage, to be used for the next search
       *
       * @param {string} namespace the namespace to use for the storage key
       * @param {Filter} filter    the filter to set
       */

    }, {
      key: "setFilter",
      value: function setFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "setFacetFilter",
      value: function setFacetFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FACET_FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "enableDynamicFilters",
      value: function enableDynamicFilters() {
        this._isDynamicFiltersEnabled = true;
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        return this.globalStorage.on(evt, moduleId, cb);
      }
    }]);

    return Core;
  }();

  /** @module DOM */

  /* global HTMLElement, HTMLDocument, Window, Event */
  var document$1 = window.document;
  /**
   * Static interface for interacting with the DOM API.
   * @namespace
   */

  var DOM =
  /*#__PURE__*/
  function () {
    function DOM() {
      _classCallCheck(this, DOM);
    }

    _createClass(DOM, null, [{
      key: "setup",
      value: function setup(d, p) {
        document$1 = d;
      }
      /**
       * create a HTMLElement from and HTML string
       * @param {string} html The HTML to parse to a DOM node.
       * @return {HTMLElement}
       */

    }, {
      key: "create",
      value: function create(html) {
        if ('createRange' in document$1) {
          // prefer this implementation as it has wider browser support
          // and it's better performing.
          // see https://davidwalsh.name/convert-html-stings-dom-nodes
          var container = document$1.createElement('div');
          var frag = document$1.createRange().createContextualFragment(html);
          container.appendChild(frag);
          return container;
        } // fallback to this because of a bug in jsdom that causes tests to fail
        // see: https://github.com/jsdom/jsdom/issues/399


        return new DOMParser().parseFromString(html, 'text/html').body;
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {HTMLElement} the FIRST node it finds, if any
       */

    }, {
      key: "query",
      value: function query(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof Window || selector instanceof HTMLDocument) {
          return selector;
        }

        return parent.querySelector(selector);
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {Array} the FIRST node it finds, if any
       */

    }, {
      key: "queryAll",
      value: function queryAll(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        } // handle the case where client code is using a pointer to a dom node and it's null, e.g. this._container


        if (parent == null) {
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof Window) {
          return [selector];
        }

        return Array.from(parent.querySelectorAll(selector));
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        if (document$1.readyState === 'complete' || document$1.readyState === 'loaded' || document$1.readyState === 'interactive') {
          cb();
          return;
        }

        DOM.on(document$1, 'DOMContentLoaded', cb);
      }
      /**
       * createEle will create a {HTMLElement} and apply the properties attributes through an object provided.
       * @param {string} el The element `tag` name to construct
       * @param {Object} opts_data Optional attributes to apply to the new HTMLElement
       */

    }, {
      key: "createEl",
      value: function createEl(el) {
        var opts_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var node = document$1.createElement(el);
        var props = Object.keys(opts_data);

        for (var i = 0; i < props.length; i++) {
          if (props[i] === 'class') {
            DOM.addClass(node, opts_data[props[i]]);
            continue;
          }

          node[props[i]] = opts_data[props[i]];
        }

        return node;
      }
    }, {
      key: "append",
      value: function append(parent, node) {
        if (node === undefined) {
          node = parent;
          parent = document$1;
        }

        if (typeof parent === 'string') {
          parent = DOM.query(parent);
        } // Support HTML injection as well as HTMLElement appends


        if (typeof node === 'string') {
          parent.insertAdjacentHTML('afterBegin', node);
        } else {
          parent.appendChild(node);
        }
      }
    }, {
      key: "addClass",
      value: function addClass(node, className) {
        if (!node) {
          return;
        }

        var classes = className.split(',');
        var len = classes.length;

        for (var i = 0; i < len; i++) {
          node.classList.add(classes[i]);
        }
      }
    }, {
      key: "empty",
      value: function empty(parent) {
        parent.innerHTML = '';
      }
    }, {
      key: "css",
      value: function css(selector, styles) {
        var node = DOM.query(selector);

        for (var prop in styles) {
          node.style[prop] = styles[prop];
        }
      }
    }, {
      key: "attr",
      value: function attr(selector, _attr, val) {
        DOM.query(selector).setAttribute(_attr, val);
      }
    }, {
      key: "attributes",
      value: function attributes(selector, attrs) {
        var _this = this;

        Object.entries(attrs).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              attr = _ref2[0],
              val = _ref2[1];

          return _this.attr(selector, attr, val);
        });
      }
    }, {
      key: "trigger",
      value: function trigger(selector, event, settings) {
        var e = new Event(event, Object.assign({
          'bubbles': true,
          'cancelable': true
        }, settings || {}));
        DOM.query(selector).dispatchEvent(e);
      }
    }, {
      key: "on",
      value: function on(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler);
      }
    }, {
      key: "once",
      value: function once(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler, {
          once: true
        });
      }
    }, {
      key: "off",
      value: function off(selector, evt, handler) {
        DOM.query(selector).removeEventListener(evt, handler);
      }
    }, {
      key: "delegate",
      value: function delegate(ctxt, selector, evt, handler) {
        var el = DOM.query(ctxt);
        el.addEventListener(evt, function (event) {
          var target = event.target;

          while (!target.isEqualNode(el)) {
            if (target.matches(selector)) {
              handler(event, target);
              break;
            }

            target = target.parentNode;
          }
        });
      }
    }]);

    return DOM;
  }();

  /** @module SearchParams */

  /* global window */

  /**
   * SearchParams is a class to get the search params in a URL.
   * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
   */
  var SearchParams =
  /*#__PURE__*/
  function () {
    function SearchParams(url) {
      _classCallCheck(this, SearchParams);

      /**
       * Mapping of all query parameters in the given url, query param -> value
       * Only used if URLSearchParams does not exist in the window
       * @type {Object}
       * @private
       */
      this._params = {};

      if (window && window.URLSearchParams) {
        return new URLSearchParams(url);
      } else {
        this._params = this.parse(url);
      }
    }
    /**
     * parse creates a mapping of all query params in a given url
     * The query param values are decoded before being put in the map
     * Three types of input are supported
     *   (1) full URL e.g. http://www.yext.com/?q=hello
     *   (2) params with ? e.g. ?q=hello
     *   (1) params without ? e.g. q=hello
     * @param {string} url The url
     * @returns {Object} mapping from query param -> value where value is '' if no value is provided
     */


    _createClass(SearchParams, [{
      key: "parse",
      value: function parse(url) {
        var params = {};
        var search = url;

        if (search === '') {
          return params;
        } // Normalize all url inputs to string of query params separated by &


        if (url.indexOf('?') > -1) {
          search = url.slice(url.indexOf('?') + 1);
        }

        var encodedParams = search.split('&');

        for (var i = 0; i < encodedParams.length; i++) {
          var keyVal = encodedParams[i].split('=');

          if (keyVal.length > 1) {
            params[keyVal[0]] = SearchParams.decode(keyVal[1]);
          } else {
            params[keyVal[0]] = '';
          }
        }

        return params;
      }
      /**
       * get returns the value of the given query param
       * @param {string} query the query param key to get the value of
       * @return {string} param value, null otherwise
       */

    }, {
      key: "get",
      value: function get(query) {
        if (typeof this._params[String(query)] === 'undefined') {
          return null;
        }

        return this._params[query];
      }
      /**
       * set changes the value of a given query param
       * @param {string} name the query param key
       * @param {string} value the value of the query param update with
       */

    }, {
      key: "set",
      value: function set(name, value) {
        this._params[String(name)] = String(value);
      }
      /**
       * has checks to see if the given query param key exists in the params object
       * @param {string} query the query param to check
       * @return {boolean} true if the query param is in the params object, false o/w
       */

    }, {
      key: "has",
      value: function has(query) {
        return query in this._params;
      }
      /**
       * delete removes the given query param and its associated value from the params object
       * @param {string} name the query param key
       */

    }, {
      key: "delete",
      value: function _delete(name) {
        delete this._params[String(name)];
      }
      /**
       * toString returns a url with all the query params in the params object (without a ?)
       * @return {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        var string = [];

        for (var key in this._params) {
          string.push("".concat(key, "=").concat(SearchParams.encode(this._params[key])));
        }

        return string.join('&');
      }
    }, {
      key: "entries",
      value: function entries() {
        var entries = [];

        for (var key in this._params) {
          entries.push([key, this._params[key]]);
        }

        return entries;
      }
      /**
       * decode returns the decoded representation of the given string
       * @param {string} string the string to decode
       * @return {string}
       */

    }], [{
      key: "decode",
      value: function decode(string) {
        return decodeURIComponent(string.replace(/[ +]/g, '%20'));
      }
      /**
       * decode returns the encoded representation of the given string (e.g. + -> %2B)
       * @param {string} string the string to encode
       * @return {string}
       */

    }, {
      key: "encode",
      value: function encode(string) {
        var replace = {
          '!': '%21',
          "'": '%27',
          '(': '%28',
          ')': '%29',
          '%20': '+'
        };
        return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
          return replace[match];
        });
      }
    }]);

    return SearchParams;
  }();

  /** @module Renderer */

  /**
   * Renderer is an abstract class that all Renderers should extend and implement
   */
  var Renderer =
  /*#__PURE__*/
  function () {
    function Renderer() {
      _classCallCheck(this, Renderer);
    }

    _createClass(Renderer, [{
      key: "render",

      /**
       * render is a core method for all renderers.
       * All implementations should override this class
       * @param {string} template
       * @param {object} data
       */
      value: function render(template, data) {
        return template;
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {}
    }, {
      key: "compile",
      value: function compile(template) {}
    }]);

    return Renderer;
  }();

  /**
   * HandlebarsRenderer is a wrapper around the nativate handlebars renderer.
   * @extends Renderer
   */

  var HandlebarsRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    _inherits(HandlebarsRenderer, _Renderer);

    function HandlebarsRenderer() {
      var _this;

      var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HandlebarsRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(HandlebarsRenderer).call(this));
      /**
       * A local reference to the handlebars compiler
       * @type {Handlebars}
       * @private
       */

      _this._handlebars = templates._hb || null;
      /**
       * A local reference to the pre-compiled handlebars templates
       * @type {Handlebars}
       * @private
       */

      _this._templates = templates || {};
      return _this;
    }

    _createClass(HandlebarsRenderer, [{
      key: "init",
      value: function init(templates) {
        // Assign the handlebars compiler and templates based on
        // information provided from external dep (in default case, it comes from external server request)
        this._handlebars = templates._hb;
        this._templates = templates; // TODO(billy) Once we re-write templates using the new helpers library
        // we probably don't need these custom helpers anymore

        this._registerCustomHelpers();
      }
      /**
       * registerHelper is a public interface for external dependencies to
       * register their own custom helpers to our internal Handlebars Compiler
       */

    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this._handlebars.registerHelper(name, cb);
      }
      /**
       * compile a handlebars template so that it can be rendered,
       * using the {Handlebars} compiler
       * @param {string} template The template string to compile
       */

    }, {
      key: "compile",
      value: function compile(template) {
        if (typeof template !== 'string') {
          return '';
        }

        return this._handlebars.compile(template);
      }
      /**
       * render will render a template with data
       * @param {Object} config Provide either a templateName or a pre-compiled template
       * @param {Object} data The data to provide to the template
       */

    }, {
      key: "render",
      value: function render(config, data) {
        // If a custom template is provided, use it,
        // otherwise fall back to the template name
        // TODO(billy) This interface should probably be less ugly
        if (config.template !== null) {
          return config.template(data);
        }

        try {
          return this._templates[config.templateName](data);
        } catch (e) {
          throw new Error('Can not find/render template: ' + config.templateName, e);
        }
      }
    }, {
      key: "_registerCustomHelpers",
      value: function _registerCustomHelpers() {
        this.registerHelper('ifeq', function (arg1, arg2, options) {
          return arg1 === arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('ifnoteq', function (arg1, arg2, options) {
          return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('formatPhoneNumber', function (phoneNumberString) {
          var cleaned = ('' + phoneNumberString).replace(/\D/g, '');
          var match = cleaned.match(/^(1|)?(\d{3})(\d{3})(\d{4})$/);

          if (match) {
            var intlCode = match[1] ? '+1 ' : '';
            return [intlCode, '(', match[2], ') ', match[3], '-', match[4]].join('');
          }

          return null;
        });
        this.registerHelper('assign', function (name, value, options) {
          var args = arguments;
          options = args[args.length - 1];

          if (!options.data.root) {
            options.data.root = {};
          }

          var v = '';

          for (var i = 1; i < args.length - 1; i++) {
            v = v + args[i];
          }

          options.data.root[name] = v;
        });
        this.registerHelper('json', function (name, value, options) {
          return name === undefined ? '' : JSON.stringify(name);
        });
      }
    }]);

    return HandlebarsRenderer;
  }(Renderer);

  /** @module */
  // E.g. Mustache, SOY, HandleBars, React, etc.

  var Renderers = {
    SOY: Renderer,
    Handlebars: HandlebarsRenderer
  };

  /** @module */

  /** The current lib version, reported with errors and analytics */
  var LIB_VERSION = 'v0.12.1';
  /** The identifier of the production environment */

  var PRODUCTION = 'production';
  /** The identifier of the sandbox environment */

  var SANDBOX = 'sandbox';
  /** The default url for compiled component templates */

  var COMPILED_TEMPLATES_URL = "https://assets.sitescdn.net/answers/".concat(LIB_VERSION, "/answerstemplates.compiled.min.js");

  /**
   * TemplateLoader exposes an interface for loading templates asynchronously
   * from the server and registers them with the proper renderer.
   * It also allows you to assign them synchronously.
   */

  var TemplateLoader =
  /*#__PURE__*/
  function () {
    function TemplateLoader(config) {
      _classCallCheck(this, TemplateLoader);

      if (!TemplateLoader.setInstance(this)) {
        return TemplateLoader.getInstance();
      }
      /**
       * The template url to fetch compiled templates from
       * @type {string}
       * @private
       */


      this._templateUrl = config.templateUrl || COMPILED_TEMPLATES_URL;
      this._templates = {};

      this._onLoaded = function () {};

      this._init();
    }

    _createClass(TemplateLoader, [{
      key: "_init",
      value: function _init() {
        this.fetchTemplates();
      }
    }, {
      key: "fetchTemplates",
      value: function fetchTemplates() {
        var _this = this;

        // If we already have templates loaded, do nothing
        var node = DOM.query('#yext-answers-templates');

        if (node) {
          return;
        } // Inject a script to fetch the compiled templates,
        // wrapping it a Promise for cleanliness


        new Promise(function (resolve, reject) {
          var script = DOM.createEl('script', {
            id: 'yext-answers-templates',
            onload: resolve,
            onerror: reject,
            async: true,
            src: _this._templateUrl
          });
          DOM.append('body', script);
        }).then(function (response) {
          // TODO(billy) Implmenet error handling here (e.g. request could fail)
          console.log('Templates loaded successfully!');
        });
        return this;
      }
      /**
       * register the templates internally so that they can be later consumed
       * (e.g. by components and renderers) with convienience.
       *
       * `fetchTemplates` will automatically call this, providing the compiled templates from the server.
       */

    }, {
      key: "register",
      value: function register(templates) {
        this._templates = templates; // Notify our consumers that the templates are here :)

        this._onLoaded(this._templates);

        return this;
      }
    }, {
      key: "onLoaded",
      value: function onLoaded(cb) {
        this._onLoaded = cb;
        return this;
      }
    }, {
      key: "get",
      value: function get(templateName) {
        return this._templates[templateName];
      }
      /**
       * @return The internal template collection
       */

    }, {
      key: "getTemplates",
      value: function getTemplates() {
        return this._templates;
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return TemplateLoader;
  }();

  /** @module */

  /** @module EventEmitter */

  /**
   * EventEmitter is a base class for any object that wants to expose
   * a pub/sub interface, for emitting messages and providing listeners.
   */
  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      /**
       * The subscribers of messages
       * @type {object[]}
       * @private
       */
      this._listeners = {};
    }
    /**
     * on is the public interface for subscribing events that are emitted.
     * @param {string} evt the event name to listen to
     * @param {function} cb The callback to invoke when the {evt} is emitted
     * @param {boolean} once Optional value which will only handle the message once
     */


    _createClass(EventEmitter, [{
      key: "on",
      value: function on(evt, cb, once) {
        if (typeof cb !== 'function') {
          throw new Error('callback handler should be of type {function}');
        }

        if (this._listeners[evt] === undefined) {
          this._listeners[evt] = [];
        }

        this._listeners[evt].push({
          event: evt,
          cb: cb,
          once: once || false
        });

        return this;
      }
      /**
       * once is the public interface for subscribing events that are emitted.
       * The handler will only be triggered once.
       *
       * @param {string} evt the event name to listen to
       * @param {function} cb The callback to invoke when the {evt} is emitted
       * @param {boolean} once Optional value which will only handle the message once
       */

    }, {
      key: "once",
      value: function once(evt, cb) {
        return this.on(evt, cb, true);
      }
      /**
       * off is the public interface for unsubscribing from an event
       * @param {string} evt the event name to unsubscribe from
       */

    }, {
      key: "off",
      value: function off(evt) {
        delete this._listeners[evt];
        return this;
      }
      /**
       * emit is the public interface for broadcasting messages/events
       * @param {string} evt the event name to publish from
       * @param {Object} data the data to send along to the subscribers
       */

    }, {
      key: "emit",
      value: function emit(evt, data) {
        var listeners = this._listeners[evt];

        if (listeners === undefined) {
          return;
        } // Invoke each of all the listener handlers and remove the ones that should fire only once.


        var keep = [];

        for (var i = 0; i < listeners.length; i++) {
          listeners[i].cb(data);

          if (listeners[i].once === true) {
            continue;
          } // Instead of having a 'dirty' array with deleted or 'undefined' entries,
          // we just create a brand new array without the listeners that were removed


          keep.push(listeners[i]);
        } // Update our old list of listeners to the newly created array


        this._listeners[evt] = keep;
        return this;
      }
    }]);

    return EventEmitter;
  }();

  /**
   * State contains the data for the component
   * and exposes an {EventEmitter} interface so that external
   * dependencies can listen/hook subscribe to messages/updates.
   * @extends EventEmitter
   */

  var State =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(State, _EventEmitter);

    function State(data) {
      var _this;

      _classCallCheck(this, State);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(State).call(this));
      /**
       * The initial state of the component
       * @type {Object}
       * @private
       */

      _this._state = data || {};
      return _this;
    }
    /**
     * Set the initial state of the component.
     * NOTE(billy): Does not fire an update message
     */


    _createClass(State, [{
      key: "init",
      value: function init(prop, optVal) {
        this._set(prop, optVal);
      }
      /**
       * setter for the state
       * @param prop {string|Object} The property to set
       * @param optVal Optional, if prop is a {string}, it will assign the value to that property
       */

    }, {
      key: "set",
      value: function set(prop, optVal) {
        this._set(prop, optVal);

        this.emit('update');
      }
      /**
       * setter for the state enables you to update a single property, or complete state
       * depending on the arguments provided.
       * @param prop {string|Object} The property to set
       * @param optVal If prop is a {string}, provide its value
       * @private
       */

    }, {
      key: "_set",
      value: function _set(prop, optVal) {
        if (optVal === undefined) {
          this._state = prop;
        } else {
          this._state[prop] = optVal;
        }
      }
    }, {
      key: "update",
      value: function update(data) {
        this._state = data;
        this.emit('update');
      }
      /**
       * Retrieve a properties value from the state
       * If no property provided, return the full state
       * @param {string} optProp optional property to retrieve
       */

    }, {
      key: "get",
      value: function get(optProp) {
        if (optProp === undefined) {
          return this._state;
        }

        return this._state[optProp];
      }
    }, {
      key: "has",
      value: function has(prop) {
        return this._state[prop] !== undefined;
      }
    }, {
      key: "asJSON",
      value: function asJSON() {
        return this._state;
      }
    }]);

    return State;
  }(EventEmitter);

  /** @module HttpRequester */

  /* global fetch */

  /**
   * Types of HTTP requests
   */
  var Methods = {
    GET: 'get',
    POST: 'post',
    PUT: 'put',
    DELETE: 'delete'
  };
  /**
   * HttpRequester is a wrapper around the native implementation of AJAX
   * related matters. It's used to make all types of network requests
   * and exposes a promise interface.
   */

  var HttpRequester =
  /*#__PURE__*/
  function () {
    function HttpRequester() {
      _classCallCheck(this, HttpRequester);
    }

    _createClass(HttpRequester, [{
      key: "get",

      /**
       * Create a GET HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} data The data to provide (gets encoded into the URL)
       * @param {Object} opts Configuration options to use for the request
       */
      value: function get(url, data, opts) {
        return this.request(Methods.GET, this.encodeParams(url, data), opts);
      }
      /**
       * Create a POST HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} urlParams The params to encode into the URL
       * @param {Object} jsonBody The request body (json) to provide with the POST request
       * @param {Object} requestConfig Configuration options to use for the request
       */

    }, {
      key: "post",
      value: function post(url, urlParams, jsonBody, requestConfig) {
        return this.request(Methods.POST, this.encodeParams(url, urlParams), Object.assign({}, {
          body: JSON.stringify(jsonBody),
          credentials: undefined
        }, requestConfig));
      }
    }, {
      key: "request",
      value: function request(method, url, opts) {
        var reqArgs = Object.assign({}, {
          'method': method,
          'credentials': 'include'
        }, opts);
        return fetch(url, reqArgs);
      }
      /**
       * Send a beacon to the provided url which will send a non-blocking request
       * to the server that is guaranteed to send before page load. No response is returned,
       * so beacons are primarily used for analytics reporting.
       * @param {string} url The url to send the beacon to
       * @param {object} data The data payload to send in the beacon
       * @return {boolean} true if the request is successfully queued
       */

    }, {
      key: "beacon",
      value: function beacon(url, data) {
        return navigator.sendBeacon(url, JSON.stringify(data));
      }
    }, {
      key: "encodeParams",
      value: function encodeParams(url, params) {
        if (_typeof(params) !== 'object') {
          return;
        }

        var hasParam = url.indexOf('?') > -1;
        var searchQuery = '';

        for (var key in params) {
          if (!hasParam) {
            hasParam = true;
            searchQuery += '?';
          } else {
            searchQuery += '&';
          }

          searchQuery += key + '=' + encodeURIComponent(params[key]);
        }

        return url + searchQuery;
      }
    }]);

    return HttpRequester;
  }();

  /**
   * Returns the base url for the live api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getLiveApiUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi.yext.com';
  }
  /**
   * Returns the base url for the knowledge api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getKnowledgeApiUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    return env === SANDBOX ? 'https://api-sandbox.yext.com' : 'https://api.yext.com';
  }
  /**
   * Returns the base url for the analytics backend in the desired environment.
   * @param {string} env The desired environment.
   * @param {boolean} conversionTrackingEnabled If conversion tracking has been opted into.
   */

  function getAnalyticsUrl() {
    var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PRODUCTION;
    var conversionTrackingEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (conversionTrackingEnabled) {
      return env === SANDBOX ? 'https://sandbox-realtimeanalytics.yext.com' : 'https://realtimeanalytics.yext.com';
    }

    return env === SANDBOX ? 'https://sandbox-answers.yext-pixel.com' : 'https://answers.yext-pixel.com';
  }

  /**
   * ApiRequest is the base class for all API requests.
   * It defines all of the core properties required to make a request
   */

  var ApiRequest =
  /*#__PURE__*/
  function () {
    // TODO (tmeyer): Create an ApiService interface and pass an implementation to the current
    // consumers of ApiRequest as a dependency.
    function ApiRequest() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, ApiRequest);

      /**
       * An abstraction used for making network request and handling errors
       * @type {HttpRequester}
       * @private
       */
      this._requester = new HttpRequester();
      /**
       * The environment the request should be made to
       * @type {string}
       * @private
       */

      this._environment = opts.environment || PRODUCTION;
      /**
       * The baseUrl to use for making a request
       * @type {string}
       * @private
       */

      this._baseUrl = opts.baseUrl || getLiveApiUrl(this._environment);
      /**
       * The endpoint to use in the url (appended to the {baseUrl})
       * @type {string}
       * @private
       */

      this._endpoint = opts.endpoint || null;
      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */

      this._apiKey = opts.apiKey || null;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = opts.version || 20190101;
      /**
       * Additional data params that are sent along with the request
       * @type {string}
       * @private
       */

      this._params = opts.params || {};

      if (!globalStorage) {
        throw new AnswersBasicError('Must include global storage', 'ApiRequest');
      }
      /**
       * @type {GlobalStorage}
       * @private
       */


      this._globalStorage = globalStorage;
    }
    /**
     * get creates a new `GET` request to the server using the configuration of the request class
     * @returns {Promise<Response>}
     */


    _createClass(ApiRequest, [{
      key: "get",
      value: function get() {
        return this._requester.get(this._baseUrl + this._endpoint, Object.assign({}, this.baseParams(), this.sanitizeParams(this._params)));
      }
      /**
       * @param {Object} opts
       * @returns {Promise<Response>}
       */

    }, {
      key: "post",
      value: function post(opts) {
        return this._requester.post(this._baseUrl + this._endpoint, this.baseParams()
        /* urlParams */
        , this.sanitizeParams(this._params)
        /* jsonBody */
        , opts
        /* requestConfig */
        );
      }
      /**
       * @returns {Object}
       * @private
       */

    }, {
      key: "baseParams",
      value: function baseParams() {
        var baseParams = {
          'v': this._version,
          'api_key': this._apiKey,
          'jsLibVersion': LIB_VERSION,
          'sessionTrackingEnabled': this._globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        };
        var urlParams = new SearchParams(window.location.search.substring(1));

        if (urlParams.has('beta')) {
          baseParams['beta'] = urlParams.get('beta');
        }

        return baseParams;
      }
    }, {
      key: "sanitizeParams",
      value: function sanitizeParams() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Remove any paramaters whos value is `undefined`.
        //
        // NOTE(billy) Probably better to be explicit about how to handle this at the request building level,
        // but I can't see any cases where we'd ever want to send 'undefined' as a value to the server.
        // So it's probably fine to 'clean' the params object here
        Object.keys(params).forEach(function (key) {
          if (params[key] === undefined || params[key] === null) {
            delete params[key];
          }
        });
        return params;
      }
    }]);

    return ApiRequest;
  }();

  /**
   * SearchApi is the API for doing various types of search
   * over the network (e.g. vertical or universal)
   *
   * @implements {SearchService}
   */

  var SearchApi =
  /*#__PURE__*/
  function () {
    function SearchApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchApi);

      /**
       * A local reference to the API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'Search');
      }

      this._apiKey = config.apiKey;
      /**
       * A local reference to the Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'Search');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * A local reference to the locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'Search');
      }

      this._locale = config.locale;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
    }
    /** @inheritdoc */


    _createClass(SearchApi, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger,
            sessionTrackingEnabled = _ref.sessionTrackingEnabled,
            sortBys = _ref.sortBys;

        if (limit > 50) {
          throw new AnswersCoreError('Provided search limit unsupported', 'SearchApi');
        }

        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/vertical/query',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'filters': filter,
            'facetFilters': facetFilter,
            'verticalKey': verticalKey,
            'limit': limit,
            'offset': offset,
            'location': geolocation ? "".concat(geolocation.lat, ",").concat(geolocation.lng) : null,
            'radius': geolocation ? geolocation.radius : null,
            'queryId': id,
            'retrieveFacets': isDynamicFiltersEnabled,
            'locale': this._locale,
            'skipSpellCheck': skipSpellCheck,
            'queryTrigger': queryTrigger,
            'sessionTrackingEnabled': sessionTrackingEnabled,
            'sortBys': sortBys
          }
        };
        var request = new ApiRequest(requestConfig, {
          getState: function getState() {
            return sessionTrackingEnabled;
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/query',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'location': params.geolocation ? "".concat(params.geolocation.lat, ",").concat(params.geolocation.lng) : null,
            'radius': params.geolocation ? params.geolocation.radius : null,
            'version': this._experienceVersion,
            'locale': this._locale,
            'skipSpellCheck': params.skipSpellCheck,
            'queryTrigger': params.queryTrigger
          }
        };
        var request = new ApiRequest(requestConfig, {
          getState: function getState() {
            return params.sessionTrackingEnabled;
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
    }]);

    return SearchApi;
  }();

  /**
   * Model for the analytics event type
   */
  var AnalyticsEvent =
  /*#__PURE__*/
  function () {
    function AnalyticsEvent(type, label) {
      _classCallCheck(this, AnalyticsEvent);

      /**
       * The type of event to report
       * @type {string}
       */
      this.eventType = type.toUpperCase();
      /**
       * An optional label to be provided for the event
       * @type {string}
       */

      if (label) {
        this.label = label;
      }
    }
    /**
     * Adds the provided options to the event
     * @param {object} options Additional options for the event
     */


    _createClass(AnalyticsEvent, [{
      key: "addOptions",
      value: function addOptions(options) {
        Object.assign(this, options);
        return this;
      }
      /**
       * Return the event in the api format, typically for reporting to the api
       */

    }, {
      key: "toApiEvent",
      value: function toApiEvent() {
        return Object.assign({}, this);
      }
    }]);

    return AnalyticsEvent;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * Class for reporting analytics events to the server via HTTP
   *
   * @implements {AnalyticsReporterService}
   */

  var AnalyticsReporter =
  /*#__PURE__*/
  function () {
    function AnalyticsReporter(core, experienceKey, experienceVersion, businessId) {
      var _this = this;

      var globalOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var environment = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : PRODUCTION;

      _classCallCheck(this, AnalyticsReporter);

      /**
       * The internal business identifier used for reporting
       * @type {number}
       */
      this._businessId = businessId;
      /**
       * Options to include with every analytic event reported to the server
       * @type {object}
       * @private
       */

      this._globalOptions = Object.assign({}, globalOptions, {
        experienceKey: experienceKey
      });
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = environment;
      /**
       * Base URL for the analytics API
       * @type {string}
       * @private
       */

      this._baseUrl = getAnalyticsUrl(this._environment);
      /**
       * Boolean indicating if opted in or out of conversion tracking
       * @type {boolean}
       * @private
       */

      this._conversionTrackingEnabled = false;

      if (experienceVersion) {
        this._globalOptions.experienceVersion = experienceVersion;
      } // listen to query id updates


      core.globalStorage.on('update', StorageKeys.QUERY_ID, function (id) {
        return _this.setQueryId(id);
      });
    }

    _createClass(AnalyticsReporter, [{
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this._globalOptions.queryId = queryId;
      }
      /** @inheritdoc */

    }, {
      key: "report",
      value: function report(event) {
        var cookieData = {};

        if (this._conversionTrackingEnabled && typeof ytag === 'function') {
          ytag('optin', true);
          cookieData = ytag('yfpc', null);
        } else if (this._conversionTrackingEnabled) {
          throw new AnswersAnalyticsError('Tried to enable conversion tracking without including ytag');
        }

        if (!(event instanceof AnalyticsEvent)) {
          throw new AnswersAnalyticsError('Tried to send invalid analytics event', event);
        }

        event.addOptions(this._globalOptions);
        return new HttpRequester().beacon("".concat(this._baseUrl, "/realtimeanalytics/data/answers/").concat(this._businessId), _objectSpread({
          data: event.toApiEvent()
        }, cookieData));
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {
        this._conversionTrackingEnabled = isEnabled;
        this._baseUrl = getAnalyticsUrl(this._environment, isEnabled);
      }
    }]);

    return AnalyticsReporter;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @implements {AnalyticsReporterService}
   */
  var NoopAnalyticsReporter =
  /*#__PURE__*/
  function () {
    function NoopAnalyticsReporter() {
      _classCallCheck(this, NoopAnalyticsReporter);
    }

    _createClass(NoopAnalyticsReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(event) {
        return true;
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {}
    }]);

    return NoopAnalyticsReporter;
  }();

  /**
   * ModuleData is used as a generic model for Storage.
   * Typically an instance of ModuleData powers a single component.

   * A data model that exposes an event emitter interface.
   * @extends EventEmitter
   */

  var ModuleData =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(ModuleData, _EventEmitter);

    function ModuleData(id) {
      var _this;

      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ModuleData);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ModuleData).call(this));
      _this._id = id;
      _this._history = [];
      _this._data = data;

      _this.set(data);

      return _this;
    }
    /**
     * replaces the currently held data with the given data
     * @param {*} data the data to replace the current data
     */


    _createClass(ModuleData, [{
      key: "set",
      value: function set(data) {
        this.capturePrevious();

        if (_typeof(data) !== 'object' || Array.isArray(data) || Object.keys(data).length !== Object.keys(this._data).length) {
          this._data = data;
          this.emit('update', this._data);
          return;
        } // check for shallow equality


        for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this._data[key] !== data[key]) {
            this._data = data;
            this.emit('update', this._data);
            return;
          }
        }
      }
    }, {
      key: "capturePrevious",
      value: function capturePrevious() {
        if (this._history === undefined) {
          this._history = [];
        }

        if (this._history.length + 1 > 5) {
          this._history.shift();
        } // If data is ever undefined, we default to empty object


        this._history.push(JSON.stringify(this._data || {}));
      }
    }, {
      key: "undo",
      value: function undo() {
        var previous = {};

        if (this._previous.length > 0) {
          previous = JSON.parse(this._previous.pop());
        }

        this._data.set(previous);
      }
    }, {
      key: "raw",
      value: function raw() {
        return this._data;
      }
    }]);

    return ModuleData;
  }(EventEmitter);

  /**
   * Storage is a container around application state.
   * It exposes an interface for CRUD operations as well as listening
   * for stateful changes.
   */

  var GlobalStorage =
  /*#__PURE__*/
  function () {
    function GlobalStorage() {
      _classCallCheck(this, GlobalStorage);

      this._moduleDataContainer = {};
      this._futureListeners = {};
    }
    /**
     * Set the data in storage with the given key to the provided data,
     * completely overwriting any existing data.
     * @param {string} key the storage key to set
     * @param {*} data the data to set
     */


    _createClass(GlobalStorage, [{
      key: "set",
      value: function set(key, data) {
        this._initDataContainer(key, data);

        this._moduleDataContainer[key].set(data);
      }
      /**
       * Add all key/value pairs in the provided map to the storage
       * @param {*} data The key/value pairs to set in the storage
       */

    }, {
      key: "setAll",
      value: function setAll(data) {
        for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              val = _Object$entries$_i[1];

          if (key === StorageKeys.QUERY) {
            continue;
          }

          this.set(key, val);
        } // Update query last since it triggers a search
        // TODO: move listeners up so all of storage can be updated at the same time


        if (data[StorageKeys.QUERY]) {
          this.set(StorageKeys.QUERY, data[StorageKeys.QUERY]);
        }
      }
    }, {
      key: "_initDataContainer",
      value: function _initDataContainer(key, data) {
        if (key === undefined || key === null || typeof key !== 'string') {
          throw new AnswersStorageError('Invalid storage key provided', key, data);
        }

        if (data === undefined || data === null) {
          throw new AnswersStorageError('No data provided', key, data);
        }

        if (this._moduleDataContainer[key] === undefined) {
          this._moduleDataContainer[key] = new ModuleData(key);

          this._applyFutureListeners(key);
        }
      }
    }, {
      key: "getState",
      value: function getState(moduleId) {
        if (this._moduleDataContainer[moduleId]) {
          return this._moduleDataContainer[moduleId].raw();
        }

        return null;
      }
    }, {
      key: "getAll",
      value: function getAll(key) {
        var data = [];

        for (var _i2 = 0, _Object$keys = Object.keys(this._moduleDataContainer); _i2 < _Object$keys.length; _i2++) {
          var dataKey = _Object$keys[_i2];

          if (dataKey.startsWith(key) && this._moduleDataContainer[dataKey].raw() !== null) {
            data.push(this._moduleDataContainer[dataKey].raw());
          }
        }

        return data;
      }
      /**
       * Remove the data in storage with the given key to the provided data,
       * @param {string} key the storage key to delete
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        // Note: Do we need to clean up listeners here?
        delete this._moduleDataContainer[key];
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] === undefined) {
            this._futureListeners[moduleId] = [];
          }

          this._futureListeners[moduleId].push({
            event: evt,
            cb: cb
          });

          return;
        }

        this._moduleDataContainer[moduleId].on(evt, cb);

        return this;
      }
    }, {
      key: "off",
      value: function off(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] !== undefined) {
            this._futureListeners[moduleId].pop();
          }

          return this;
        }

        this._moduleDataContainer[moduleId].off(evt, cb);

        return this;
      }
    }, {
      key: "_applyFutureListeners",
      value: function _applyFutureListeners(moduleId) {
        var futures = this._futureListeners[moduleId];

        if (!futures) {
          return;
        }

        for (var i = 0; i < futures.length; i++) {
          var future = futures[i];
          this.on(future.event, moduleId, future.cb);
        }

        delete this._futureListeners[moduleId];
      }
    }]);

    return GlobalStorage;
  }();

  /** @module */

  /**
   * Component is an abstraction that encapsulates state, behavior,
   * and view for a particular chunk of functionality on the page.
   *
   * The API exposes event life cycle hooks for when things are rendered,
   * mounted, created, etc.
   */

  var Component =
  /*#__PURE__*/
  function () {
    function Component() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Component);

      this.moduleId = null;
      /**
       * Unique name of this component instance
       * Used to distinguish between other components of the same type
       * @type {String}
       */

      this.name = config.name || this.constructor.type;
      /**
       * Cache the options so that we can propogate properly to child components
       * @type {Object}
       */

      this._config = config;
      /**
       * An identifier used to classify the type of component.
       * The component manager uses this information in order to persist and organize components
       * @type {string|ComponentType}
       */

      this._type = this.constructor.name;
      /**
       * A local reference to the parent component, if exists
       * @type {Component}
       */

      this._parentContainer = config.parentContainer || null;
      /**
       * A container for all the child components
       * @type {Component[]}
       */

      this._children = [];
      /**
       * The state (data) of the component to be provided to the template for rendering
       * @type {object}
       */

      this._state = new State(config.state);
      /**
       * TODO(billy) This should be 'services'
       */

      this.core = systemConfig.core || null;
      /**
       * A local reference to the component manager, which contains all of the component classes
       * eligible to be created
       * @type {ComponentManager}
       */

      this.componentManager = systemConfig.componentManager || null;
      /**
       * A local reference to the analytics reporter, used to report events for this component
       * @type {AnalyticsReporter}
       */

      this.analyticsReporter = systemConfig.analyticsReporter || null;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      this._analyticsOptions = config.analyticsOptions || {};
      /**
       * A reference to the DOM node that the component will be appended to when mounted/rendered.
       * @type {HTMLElement}
       */

      if (this._parentContainer === null) {
        if (typeof config.container === 'string') {
          this._container = DOM.query(config.container) || null;

          if (this._container === null) {
            throw new Error('Cannot find container DOM node: ' + config.container);
          }
        }
      } else {
        this._container = DOM.query(this._parentContainer, config.container); // If we have a parent, and the container is missing from the DOM,
        // we construct the container and append it to the parent

        if (this._container === null) {
          this._container = DOM.createEl('div', {
            "class": config.container.substring(1, config.container.length)
          });
          DOM.append(this._parentContainer, this._container);
        }
      }
      /**
       * A custom class to be applied to {this._container} node
       * @type {string}
       */


      this._className = config["class"] || 'component';
      /**
       * A custom render function to be used instead of using the default renderer
       * @type {Renderer}
       */

      this._render = config.render || null;
      /**
       * A local reference to the default {Renderer} that will be used for rendering the template
       * @type {Renderer}
       */

      this._renderer = systemConfig.renderer || Renderers.Handlebars;
      /**
       * The template string to use for rendering the component
       * If this is left empty, we lookup the template the base templates using the templateName
       * @type {string}
       */

      this._template = config.template ? this._renderer.compile(config.template) : null;
      /**
       * The templateName to use for rendering the component.
       * This is only used if _template is empty.
       * @type {string}
       */

      this._templateName = config.templateName || this.constructor.defaultTemplateName(config);
      /**
       * An internal state indicating whether or not the component has been mounted to the DOM
       * @type {boolean}
       */

      this._isMounted = false;
      /**
       * A local reference to the callback, thats used to transform the internal data
       * models of the components, before it gets applied to the component state.
       * By default, no transformation happens.
       * @type {function}
       */

      this.transformData = config.transformData || this.transformData || function () {};
      /**
       * The a local reference to the callback that will be invoked when a component is created.
       * @type {function}
       */


      this.onCreate = config.onCreateOverride || this.onCreate || function () {};

      this.onCreate = this.onCreate.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a component is Mounted.
       * @type {function}
       */

      this.onMount = config.onMountOverride || this.onMount || function () {};

      this.onMount = this.onMount.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a components state is updated.
       * @type {function}
       */

      this.onUpdate = config.onUpdateOverride || this.onUpdate || function () {};

      this.onUpdate = this.onUpdate.bind(this);
      /**
       * A user provided onCreate callback
       * @type {function}
       */

      this.userOnCreate = config.onCreate || function () {};
      /**
       * A user provided onMount callback
       * @type {function}
       */


      this.userOnMount = config.onMount || function () {};
      /**
       * A user provided onUpdate callback
       * @type {function}
       */


      this.userOnUpdate = config.onUpdate || function () {};
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(Component, [{
      key: "init",
      value: function init(opts) {
        var _this = this;

        try {
          this.setState(opts.data || opts.state || {});
          this.onCreate();
          this.userOnCreate();
        } catch (e) {
          throw new AnswersComponentError('Error initializing component', this.constructor.type, e);
        }

        this._state.on('update', function () {
          try {
            _this.onUpdate();

            _this.userOnUpdate();

            _this.unMount();

            _this.mount();
          } catch (e) {
            throw new AnswersComponentError('Error updating component', _this.constructor.type, e);
          }
        });

        DOM.addClass(this._container, this._className);
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var newState = Object.assign({}, {
          _config: this._config
        }, data);

        this._state.set(newState);

        return this;
      }
    }, {
      key: "getState",
      value: function getState(prop) {
        return this._state.get(prop);
      }
    }, {
      key: "hasState",
      value: function hasState(prop) {
        return this._state.has(prop);
      }
    }, {
      key: "transformData",
      value: function transformData(data) {
        return data;
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        var childComponent = this.componentManager.create(type, Object.assign({
          name: data.name,
          parentContainer: this._container,
          data: data
        }, opts || {}, {
          _parentOpts: this._config
        }));

        this._children.push(childComponent);

        return childComponent;
      }
      /**
       * Unmount and remove this component and its children from the list
       * of active components
       */

    }, {
      key: "remove",
      value: function remove() {
        this._children.forEach(function (c) {
          return c.remove();
        });

        this.componentManager.remove(this);
      }
      /**
       * Set the render method to be used for rendering the component
       * @param {Function} render
       * @return {string}
       */

    }, {
      key: "setRender",
      value: function setRender(render) {
        this._render = render;
        return this;
      }
      /**
       * Set the renderer for the component
       * @param {RendererType} renderer
       */

    }, {
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = Renderers[renderer];
        return this;
      }
      /**
       * Sets the template for the component to use when rendering
       * @param {string} template
       */

    }, {
      key: "setTemplate",
      value: function setTemplate(template) {
        this._template = this._renderer.compile(template);
      }
    }, {
      key: "unMount",
      value: function unMount() {
        if (!this._container) {
          return this;
        }

        this._children.forEach(function (child) {
          child.unMount();
        });

        DOM.empty(this._container);

        this._children.forEach(function (c) {
          return c.remove();
        });

        this._children = [];
        this.onUnMount();
      }
    }, {
      key: "mount",
      value: function mount(container) {
        var _this2 = this;

        if (container) {
          this._container = container;
        }

        if (!this._container) {
          return this;
        }

        if (this.beforeMount() === false) {
          return this;
        }

        DOM.append(this._container, this.render(this._state.asJSON())); // Process the DOM to determine if we should create
        // in-memory sub-components for rendering

        var domComponents = DOM.queryAll(this._container, '[data-component]:not([data-is-component-mounted])');
        var data = this.transformData(JSON.parse(JSON.stringify(this._state.get())));
        domComponents.forEach(function (c) {
          return _this2._createSubcomponent(c, data);
        });

        this._children.forEach(function (child) {
          child.mount();
        }); // Attach analytics hooks as necessary


        if (this.analyticsReporter) {
          var domHooks = DOM.queryAll(this._container, '[data-eventtype]:not([data-is-analytics-attached])');
          domHooks.forEach(this._createAnalyticsHook.bind(this));
        }

        this._isMounted = true;
        this.onMount(this);
        this.userOnMount(this);
        return this;
      }
      /**
       * render the template using the {Renderer} with the current state and template of the component
       * @returns {string}
       */

    }, {
      key: "render",
      value: function render() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._state.get();
        this.beforeRender(); // Temporary fix for passing immutable data to transformData().

        data = this.transformData(JSON.parse(JSON.stringify(data)));
        var html = ''; // Use either the custom render function or the internal renderer
        // dependant on the component configuration

        if (typeof this._render === 'function') {
          html = this._render(data);

          if (typeof html !== 'string') {
            throw new Error('Render method must return HTML as type {string}');
          }
        } else {
          // Render the existing templates as a string
          html = this._renderer.render({
            template: this._template,
            templateName: this._templateName
          }, data);
        } // We create an HTML Document fragment with the rendered string
        // So that we can query it for processing of sub components


        var el = DOM.create(html);
        this.afterRender();
        return el.innerHTML;
      }
    }, {
      key: "_createSubcomponent",
      value: function _createSubcomponent(domComponent, data) {
        var _this3 = this;

        domComponent.dataset.isComponentMounted = true;
        var dataset = domComponent.dataset;
        var type = dataset.component;
        var prop = dataset.prop;
        var opts = dataset.opts ? JSON.parse(dataset.opts) : {};
        var childData = data[prop] || {};
        opts = _objectSpread({}, opts, {
          container: domComponent
        }); // TODO(billy) Right now, if we provide an array as the data prop,
        // the behavior is to create many components for each item in the array.
        // THAT interface SHOULD change to use a different property that defines
        // whether to array data should be used for a single component or
        // to create many components for each item.
        // Overloading and having this side effect is unintuitive and WRONG

        if (!Array.isArray(childData)) {
          // Rendering a sub component should be within the context,
          // of the node that we processed it from
          this.addChild(childData, type, opts);
          return;
        }

        childData.reverse();
        childData.forEach(function (data) {
          _this3.addChild(data, type, opts);
        });
      }
    }, {
      key: "_createAnalyticsHook",
      value: function _createAnalyticsHook(domComponent) {
        var _this4 = this;

        domComponent.dataset.isAnalyticsAttached = true;
        var dataset = domComponent.dataset;
        var type = dataset.eventtype;
        var label = dataset.eventlabel;
        var options = dataset.eventoptions ? JSON.parse(dataset.eventoptions) : {};
        DOM.on(domComponent, 'click', function (e) {
          var event = new AnalyticsEvent(type, label);
          event.addOptions(_this4._analyticsOptions);
          event.addOptions(options);

          _this4.analyticsReporter.report(event);
        });
      }
      /**
       * onCreate is triggered when the component is constructed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onCreate",
      value: function onCreate(cb) {}
      /**
       * onUpdate is triggered when the state of the component changes
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUpdate",
      value: function onUpdate(cb) {}
      /**
       * beforeRender event is triggered before the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeRender",
      value: function beforeRender(cb) {}
      /**
       * afterRender event is triggered after the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "afterRender",
      value: function afterRender(cb) {}
      /**
       * onMount is triggered when the component is appended to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onMount",
      value: function onMount(cb) {}
      /**
       * onUnMount is triggered when the component is removed from the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUnMount",
      value: function onUnMount(cb) {}
      /**
       * beforeMount is triggered before the component is mounted to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeMount",
      value: function beforeMount(cb) {}
      /**
       * onDestroy is triggered when the component is destroyed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onDestroy",
      value: function onDestroy(cb) {}
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'default';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return false;
      }
    }, {
      key: "type",
      get: function get() {
        return 'Component';
      }
    }]);

    return Component;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * ErrorReporter is used for reporting errors to the console and API
   *
   * @implements {ErrorReporterService}
   */

  var ErrorReporter =
  /*#__PURE__*/
  function () {
    function ErrorReporter(config, globalStorage) {
      var _this = this;

      _classCallCheck(this, ErrorReporter);

      /**
       * The apiKey to use for reporting
       * @type {string}
       */
      this.apiKey = config.apiKey;
      /**
       * The experienceKey to use when reporting
       * @type {string}
       */

      this.experienceKey = config.experienceKey;
      /**
       * The answers config version used for api requests
       * @type {string|number}
       */

      this.experienceVersion = config.experienceVersion || 'config1.0';
      /**
       * If true, print entire error objects to the console for inspection
       * @type {boolean}
       */

      this.printVerbose = config.printVerbose;
      /**
       * If true, report the error the server for logging and monitoring
       * @type {boolean}
       */

      this.sendToServer = config.sendToServer;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       */

      if (this.sendToServer && !globalStorage) {
        throw new AnswersBasicError('Must include globalStorage to send errors to server', 'ErrorReporter');
      }

      this.globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this.environment = config.environment; // Attach reporting listeners to window

      window.addEventListener('error', function (e) {
        return _this.report(e.error);
      });
      window.addEventListener('unhandledrejection', function (e) {
        return _this.report(e.error);
      });
    }
    /**
     * report pretty prints the error to the console, optionally
     * prints the entire error if `printVerbose` is true, and sends the
     * error to the server to be logged if `sendToServer` is true
     * @param {AnswersBaseError} err The error to be reported
     * @returns {AnswersBaseError} The reported error
     */


    _createClass(ErrorReporter, [{
      key: "report",
      value: function report(err) {
        if (!(err instanceof AnswersBaseError) || err.reported) {
          return;
        }

        err.reported = true;
        this.printError(err);

        if (this.sendToServer) {
          var requestConfig = {
            endpoint: '/v2/accounts/me/answers/errors',
            apiKey: this.apiKey,
            version: 20190301,
            environment: this.environment,
            params: {
              'libVersion': LIB_VERSION,
              'experienceVersion': this.experienceVersion,
              'experienceKey': this.experienceKey,
              'error': err.toJson()
            }
          };
          var request = new ApiRequest(requestConfig, this.globalStorage); // TODO(amullings): We should probably change this endpoint to POST,
          // ideally using the beacon API. Stack traces will likely easily hit URL
          // length limits.

          request.get()["catch"](console.err);
        }

        return err;
      }
      /**
       * prints the given error to the browser console
       * @param {AnswersBaseError} err The error to be printed
       */

    }, {
      key: "printError",
      value: function printError(err) {
        if (this.printVerbose) {
          console.error("error: ".concat(err.errorMessage, "\ncode: ").concat(err.errorCode, "\nboundary: ").concat(err.boundary, "\nstack: ").concat(err.stack));
        } else {
          console.error(err.toString());
        }
      }
    }]);

    return ErrorReporter;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * @implements {ErrorReporterService}
   */
  var ConsoleErrorReporter =
  /*#__PURE__*/
  function () {
    function ConsoleErrorReporter() {
      _classCallCheck(this, ConsoleErrorReporter);
    }

    _createClass(ConsoleErrorReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(err) {
        console.error(err.toString());
      }
    }]);

    return ConsoleErrorReporter;
  }();

  /** @module PersistentStorage */

  var PersistentStorage =
  /*#__PURE__*/
  function () {
    function PersistentStorage() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, PersistentStorage);

      /**
       * The current params model
       * @type {SearchParams}
       */
      this._params = new SearchParams(window.location.search.substring(1));
      /**
       * The current history edit timer, if any
       * @type {number}
       */

      this._historyTimer = null;
      /**
       * The list of listeners to every storage update
       * @type {function[]}
       */

      this._updateListener = config.updateListener || function () {};
      /**
       * The list of listeners to storage resets
       * @type {function[]}
       */


      this._resetListener = config.resetListener || function () {};

      window.onpopstate = function () {
        _this._params = new SearchParams(window.location.search.substring(1));

        _this._callListener(_this._updateListener);

        _this._callListener(_this._resetListener);
      };
    }
    /**
     * Insert the given key/value pair into storage
     * @param {string} key The key to insert the data in
     * @param {*} data The data to insert
     * @param {boolean} replace history instead of pushing new state
     */


    _createClass(PersistentStorage, [{
      key: "set",
      value: function set(key, data) {
        var replaceHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (typeof key !== 'string') {
          throw new AnswersStorageError('Storage data key must be a string', key, data);
        }

        var newData = data;

        if (typeof data !== 'string') {
          newData = JSON.stringify(data);
        }

        this._params.set(key, newData);

        this._updateHistory(replaceHistory);
      }
      /**
       * Delete the given key from storage
       * @param {string} key The key to delete
       * @param {boolean} replace history instead of pushing new state
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        var replaceHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this._params["delete"](key);

        this._updateHistory(replaceHistory);
      }
    }, {
      key: "_updateHistory",
      value: function _updateHistory() {
        var _this2 = this;

        var replaceHistory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this._historyTimer) {
          clearTimeout(this._historyTimer);
        } // batch update calls across components to avoid updating the url too much


        this._historyTimer = setTimeout(function () {
          _this2._historyTimer = null;

          if (replaceHistory) {
            window.history.replaceState(null, null, "?".concat(_this2._params.toString()));
          } else {
            window.history.pushState(null, null, "?".concat(_this2._params.toString()));
          }

          _this2._callListener(_this2._updateListener);
        });
      }
      /**
       * Invoke the given list of callbacks with the current storage data
       * @param {function[]} listeners The callbacks to invoke
       * @private
       */

    }, {
      key: "_callListener",
      value: function _callListener(listener) {
        listener(this.getAll(), this._params.toString());
      }
      /**
       * Get all the key/value pairs in storage
       */

    }, {
      key: "getAll",
      value: function getAll() {
        var allParams = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._params.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                val = _step$value[1];

            allParams[key] = val;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return allParams;
      }
    }]);

    return PersistentStorage;
  }();

  /** @module SearchConfig */

  var SearchConfig =
  /*#__PURE__*/
  function () {
    function SearchConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchConfig);

      /**
       * The max results per search.
       * Also defines the number of results per page, if pagination is enabled
       * @type {number}
       */
      this.limit = config.limit || 20;
      /**
       * The vertical key to use for all searches
       * @type {string}
       */

      this.verticalKey = config.verticalKey || null;
      /**
       * A default search to use on initialization for vertical searchers, when the user has't provided a query
       * @type {string}
       */

      this.defaultInitialSearch = config.defaultInitialSearch;
      this.validate();
      Object.freeze(this);
    }

    _createClass(SearchConfig, [{
      key: "validate",
      value: function validate() {
        if (typeof this.limit !== 'number' || this.limit < 1 || this.limit > 50) {
          throw new AnswersConfigError('Search Limit must be between 1 and 50', 'SearchConfig');
        }
      }
    }]);

    return SearchConfig;
  }();

  var AutoCompleteData =
  /*#__PURE__*/
  function () {
    function AutoCompleteData() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AutoCompleteData);

      this.sections = data.sections || [];
      this.queryId = data.queryId || '';
      this.inputIntents = data.inputIntents || [];
      Object.freeze(this);
    }

    _createClass(AutoCompleteData, null, [{
      key: "from",
      value: function from(response) {
        var sections;

        if (response.sections) {
          sections = response.sections.map(function (s) {
            return {
              label: s.label,
              results: s.results.map(function (r) {
                return new AutoCompleteResult(r);
              })
            };
          });
        } else {
          sections = [{
            results: response.results.map(function (r) {
              return new AutoCompleteResult(r);
            })
          }];
        }

        var inputIntents = response.input ? response.input.queryIntents : [];
        return new AutoCompleteData({
          sections: sections,
          queryId: response.queryId,
          inputIntents: inputIntents
        });
      }
    }]);

    return AutoCompleteData;
  }();
  var AutoCompleteResult = function AutoCompleteResult() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AutoCompleteResult);

    this.filter = data.filter || {};
    this.highlightedValue = new HighlightedValue(data).getInverted();
    this.key = data.key || '';
    this.matchedSubstrings = data.matchedSubstrings || [];
    this.value = data.value || '';
    this.shortValue = data.shortValue || this.value;
    this.intents = data.queryIntents || [];
    Object.freeze(this);
  };

  /**
   * A Data Transformer that takes the response object from a AutoComplete request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   *
   * TODO(billy) Create our own front-end data models
   */

  var AutoCompleteDataTransformer =
  /*#__PURE__*/
  function () {
    function AutoCompleteDataTransformer() {
      _classCallCheck(this, AutoCompleteDataTransformer);
    }

    _createClass(AutoCompleteDataTransformer, null, [{
      key: "clean",
      value: function clean(moduleId, data) {
        if (data.sections && data.sections.length === 0) {
          delete data.sections;
        }

        if (data.sections && data.sections.length === 1 && data.sections[0].results.length === 0) {
          delete data.sections;
        }

        return _defineProperty({}, moduleId, data);
      }
    }, {
      key: "universal",
      value: function universal(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "filter",
      value: function filter(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "vertical",
      value: function vertical(response) {
        return AutoCompleteData.from(response);
      }
    }]);

    return AutoCompleteDataTransformer;
  }();

  /** @typedef {import('./autocompleteservice').default} AutoCompleteService */

  /**
   * AutoCompleteApi exposes an interface for network related matters
   * for all the autocomplete endpoints.
   *
   * @implements {AutoCompleteService}
   */

  var AutoCompleteApi =
  /*#__PURE__*/
  function () {
    function AutoCompleteApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, AutoCompleteApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'AutoComplete');
      }

      this._apiKey = config.apiKey;
      /**
       * The Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'AutoComplete');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'AutoComplete');
      }

      this._locale = config.locale;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'AutoComplete');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
    }
    /** @inheritdoc */


    _createClass(AutoCompleteApi, [{
      key: "queryFilter",
      value: function queryFilter(input, config) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/filtersearch',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': config.verticalKey,
            'locale': this._locale,
            'search_parameters': JSON.stringify(config.searchParameters)
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.filter(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Filter search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/vertical/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': verticalKey,
            'locale': this._locale
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.vertical(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Vertical search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(queryString) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          environment: this._environment,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'locale': this._locale
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.get(queryString).then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.universal(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Universal search request failed', 'AutoComplete', error);
        });
      }
    }]);

    return AutoCompleteApi;
  }();

  /** @typedef {import('../services/autocompleteservice').default} AutoCompleteService */

  var universalOptions = ['what is yext', 'who is the ceo of yext'];
  var verticalOptions = ['near me', 'in new york', 'available now'];
  /**
   * MockAutoCompleteService serves autocomplete queries with mock data
   *
   * @implements {AutoCompleteService}
   */

  var MockAutoCompleteService =
  /*#__PURE__*/
  function () {
    function MockAutoCompleteService() {
      _classCallCheck(this, MockAutoCompleteService);
    }

    _createClass(MockAutoCompleteService, [{
      key: "queryFilter",

      /** @inheritdoc */
      value: function queryFilter(input, config) {
        // TODO(amullings): Simulate filter search, with sections
        return emptyResults();
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey) {
        return filterOptions(input, verticalOptions.map(function (opt) {
          return "".concat(verticalKey, " ").concat(opt);
        }).concat(universalOptions));
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(input) {
        return filterOptions(input, universalOptions);
      }
    }]);

    return MockAutoCompleteService;
  }();

  function filterOptions(input, options) {
    if (input.length === 0) {
      return emptyResults();
    }

    var lowercase = input.toLowerCase();
    var results = options.filter(function (opt) {
      return opt.includes(lowercase);
    }).map(function (opt) {
      return new AutoCompleteResult({
        value: opt,
        matchedSubstrings: [{
          offset: opt.indexOf(lowercase),
          length: lowercase.length
        }]
      });
    });
    return Promise.resolve(new AutoCompleteData({
      sections: [{
        results: results
      }],
      queryId: randomString()
    }));
  }
  /**
   * @returns {Promise<AutoCompleteData>}
   */


  function emptyResults() {
    return Promise.resolve(new AutoCompleteData({
      sections: [{}],
      queryId: randomString()
    }));
  }
  /**
   * @returns {string}
   */


  function randomString() {
    return Math.random().toString(36).substring(2);
  }

  /** @typedef {import('./questionanswerservice').default} QuestionAnswerService */

  /**
   * QuestionAnswerApi submits questions via the Q&A REST API
   *
   * @implements {QuestionAnswerService}
   */

  var QuestionAnswerApi =
  /*#__PURE__*/
  function () {
    function QuestionAnswerApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var globalStorage = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, QuestionAnswerApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'QuestionAnswerApi');
      }

      this._apiKey = config.apiKey;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'QuestionAnswerApi');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment || PRODUCTION;
    }
    /** @inheritdoc */


    _createClass(QuestionAnswerApi, [{
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var requestConfig = {
          baseUrl: getKnowledgeApiUrl(this._environment),
          endpoint: '/v2/accounts/me/questions',
          apiKey: this._apiKey,
          params: {
            'entityId': question.entityId,
            'site': question.site,
            'name': question.name,
            'email': question.email,
            'questionText': question.questionText,
            'questionDescription': question.questionDescription,
            'questionLanguage': question.questionLanguage
          }
        };
        var request = new ApiRequest(requestConfig, this._globalStorage);
        return request.post({
          mode: 'cors',
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(function (response) {
          return response.json();
        })["catch"](function (error) {
          throw new AnswersEndpointError('Question submit failed', 'QuestionAnswerApi', error);
        });
      }
    }]);

    return QuestionAnswerApi;
  }();

  /** @module MockQuestionAnswerService */

  /** @typedef {import('../services/questionanswerservice').default} QuestionAnswerService */

  /**
   * @implements {QuestionAnswerService}
   */
  var MockQuestionAnswerService =
  /*#__PURE__*/
  function () {
    function MockQuestionAnswerService() {
      _classCallCheck(this, MockQuestionAnswerService);
    }

    _createClass(MockQuestionAnswerService, [{
      key: "submitQuestion",

      /** @inheritdoc */
      value: function submitQuestion(question) {
        // TODO(amullings): Make actual response object once we're using it for
        // something
        return Promise.resolve({});
      }
    }]);

    return MockQuestionAnswerService;
  }();

  /* global fetch */

  /** @typedef {import('../models/section').default} Section */

  /** @typedef {import('../services/searchservice').default} SearchService */

  /**
   * @typedef {Object} ResultData
   * @property {Object} data
   * @property {string } htmlTitle
   */

  /**
   * @callback ResultsModifier
   * @param {ResultData[]} results
   * @returns {ResultData[]}
   */

  /**
   * @callback MockDataConsumer
   * @param {Section[]} sections
   * @returns {Promise<Object>}
   */
  var ARBITRARY_BUSINESS_ID = 919871;
  /**
   * @implements {SearchService}
   */

  var MockSearchService =
  /*#__PURE__*/
  function () {
    function MockSearchService() {
      _classCallCheck(this, MockSearchService);

      /**
       * @type {Promise<string>}
       * @private
       */
      this._getMockDataJson = fetch('https://assets.sitescdn.net/answers/testdata/search/mockdata_v1.json').then(function (resp) {
        return resp.text();
      })["catch"](console.error);
    }
    /** @inheritdoc */


    _createClass(MockSearchService, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger;
        return this.useMockData(function (sections) {
          if (input === '') {
            return delayedResponse(constructVerticalResponse({
              results: [],
              appliedQueryFilters: []
            }));
          } // Either find a section with matching ID, or pick one at random


          var section = sections.find(function (verticalModule) {
            return verticalKey === verticalModule['verticalConfigId'];
          });

          if (section == null) {
            section = sections[Math.floor(Math.random() * sections.length)];
          }

          modifyResults(section, getResultsFilterer(input));

          if (offset != null && limit != null) {
            modifyResults(section, function limit(results) {
              return results.slice(offset, offset + limit);
            });
          }

          var resp = constructVerticalResponse(section);
          return delayedResponse(resp);
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        return this.useMockData(function (sections) {
          if (queryString === '') {
            return delayedResponse(constructUniversalResponse([]));
          }

          sections.forEach(function (section) {
            modifyResults(section, getResultsFilterer(queryString));
          });
          sections = sections.filter(function (section) {
            return section.results.length > 0;
          });
          var resp = constructUniversalResponse(sections);
          return delayedResponse(resp);
        });
      }
      /**
       * @param {MockDataConsumer} consumer
       * @returns {Promise<Object>}
       * @private
       */

    }, {
      key: "useMockData",
      value: function useMockData(consumer) {
        return this._getMockDataJson.then(JSON.parse).then(consumer);
      }
    }]);

    return MockSearchService;
  }();

  function getResultsFilterer(queryString) {
    return function (results) {
      return results.filter(function (result) {
        if (result.htmlTitle && result.htmlTitle.toLowerCase().includes(queryString)) {
          return true;
        }

        for (var prop in result.data) {
          var val = result.data[prop];

          if (typeof val === 'string' && val.toLowerCase().includes(queryString)) {
            return true;
          }
        }

        return false;
      });
    };
  }
  /**
   * @param {Section} section
   * @param {ResultsModifier} modifyFn
   */


  function modifyResults(section, modifyFn) {
    section.results = modifyFn(section.results);
  }
  /**
   * @param {Section[]} sections A list of mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructUniversalResponse(sections) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    sections = sections.map(fillSectionFields);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: {
        businessId: ARBITRARY_BUSINESS_ID,
        modules: sections,
        failedVerticals: [],
        queryId: uuidV4(),
        searchIntents: []
      }
    };
  }
  /**
   * @param {Section} section A mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructVerticalResponse(section) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    section = fillSectionFields(section);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: Object.assign(section, {
        businessId: ARBITRARY_BUSINESS_ID,
        queryId: uuidV4(),
        searchIntents: []
      })
    };
  }
  /**
   * @param {Section}
   * @returns {Section}
   */


  function fillSectionFields(section) {
    return {
      verticalConfigId: section.verticalConfigId,
      resultsCount: section.results.length,
      encodedState: '',
      results: section.results,
      appliedQueryFilters: section.appliedQueryFilters,
      queryDurationMillis: randomInt(50, 1000),
      facets: section.facets,
      source: section.source
    };
  }
  /**
   * @param {Object} resp
   * @returns {Promise<Object>}
   */


  function delayedResponse(resp) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(resp);
      }, randomInt(250, 1000));
    });
  }
  /**
   * Code-golf-y but legit basic UUID v4 implementation. Not cryptographically secure.
   * From https://gist.github.com/jed/982883
   * @returns {string} A v4-compliant UUID
   */


  function uuidV4() {
    return function b(a) {
      return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
    }();
  }
  /**
   * @param {number} min inclusive
   * @param {number} max exclusive
   * @returns {number} A random integer in the specified range
   */


  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }

  /**
   * The debounce duration for resize events
   * @type {number}
   */

  var RESIZE_DEBOUNCE = 100;
  /**
   * The breakpoint for mobile
   * @type {number}
   */

  var MOBILE_BREAKPOINT = 767;
  /**
   * Enum options for mobile overflow beahvior
   * @type {Object.<string, string>}
   */

  var MOBILE_OVERFLOW_BEHAVIOR_OPTION = {
    COLLAPSE: 'COLLAPSE',
    INNERSCROLL: 'INNERSCROLL'
  };
  /**
   * The Tab is a model that is used to power the Navigation tabs in the view.
   * It's initialized through the configuration provided to the component.
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(config) {
      _classCallCheck(this, Tab);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label;

      if (typeof this.label !== 'string') {
        throw new AnswersComponentError('label is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The complete URL, including the params
       * @type {string}
       */


      this.url = config.url;

      if (typeof this.url !== 'string') {
        throw new AnswersComponentError('url is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */


      this.configId = config.configId || null;
      /**
       * The base URL used for constructing the URL with params
       * @type {string}
       */

      this.baseUrl = config.url;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }
    /**
     * from will construct a map of configId to {Tab} from
     * a configuration file
     * @param {object} tabsConfig the configuration to use
     */


    _createClass(Tab, null, [{
      key: "from",
      value: function from(tabsConfig) {
        var tabs = {}; // Parse the options and build out our tabs and

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = tabsConfig[i]; // For tabs without config ids, map their URL to the configID
          // to avoid duplication of renders

          if (tab.configId === null && tabs[tab.configId] === undefined) {
            tab.configId = tab.url;
          }

          tabs[tab.configId] = new Tab(tab);
        }

        return tabs;
      }
    }]);

    return Tab;
  }();
  /**
   * NavigationComponent exposes an interface for building a dynamic
   * navigation that is powered by universal search updates.
   * @extends Component
   */

  var NavigationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(NavigationComponent, _Component);

    function NavigationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, NavigationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NavigationComponent).call(this, config, systemConfig));
      /**
       * The label to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowLabel = config.overflowLabel || 'More';
      /**
       * The optional icon to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowIcon = config.overflowIcon || 'kabob';
      /**
       * The data storage key
       * @type {string}
       */

      _this.moduleId = StorageKeys.NAVIGATION;
      /**
       * Tabs config from global navigation config
       * @type {Array.<object>}
       * @private
       */

      _this._tabsConfig = _this.core.globalStorage.getState(StorageKeys.NAVIGATION_CONFIG).tabsConfig;
      /**
       * Unordered map of each tab, keyed by VS configId
       * @type {Object.<String, Object>}
       * @private
       */

      _this._tabs = Tab.from(_this._tabsConfig);
      /**
       * The order of the tabs, parsed from configuration or URL.
       * This gets updated based on the server results
       * @type {Array.<String>} The list of VS configIds
       * @private
       */

      _this._tabOrder = _this.getDefaultTabOrder(_this._tabsConfig, _this.getUrlParams());
      /**
       * Breakpoints at which navigation items move to the "more" dropdown
       * @type {number[]}
       * @private
       */

      _this._navBreakpoints = [];
      /**
       *  The mobile overflow behavior config
       *  @type {string}
       */

      _this._mobileOverflowBehavior = config.mobileOverflowBehavior || MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE;
      /**
       *  The ARIA label
       *  @type {string}
       */

      _this._ariaLabel = config.ariaLabel || 'Search Page Navigation';
      _this.checkOutsideClick = _this.checkOutsideClick.bind(_assertThisInitialized(_this));
      _this.checkMobileOverflowBehavior = _this.checkMobileOverflowBehavior.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(NavigationComponent, [{
      key: "onCreate",
      value: function onCreate() {
        // TODO: Re-rendering and re-mounting the component every tim e the window changes size
        // is not great.
        DOM.on(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        DOM.off(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        if (this.shouldCollapse()) {
          this._navBreakpoints = [];
          this.bindOverflowHandlers();
          this.refitNav();
          DOM.on(DOM.query(this._container, '.yxt-Nav-more'), 'click', this.toggleMoreDropdown.bind(this));
        }
      }
    }, {
      key: "onUnMount",
      value: function onUnMount() {
        this.unbindOverflowHandlers();
      }
    }, {
      key: "bindOverflowHandlers",
      value: function bindOverflowHandlers() {
        DOM.on(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "unbindOverflowHandlers",
      value: function unbindOverflowHandlers() {
        DOM.off(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "refitNav",
      value: function refitNav() {
        var container = DOM.query(this._container, '.yxt-Nav-container');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        var mainLinks = DOM.query(this._container, '.yxt-Nav-expanded');
        var collapsedLinks = DOM.query(this._container, '.yxt-Nav-modal');
        var navWidth = moreButton.classList.contains('yxt-Nav-item--more') ? container.offsetWidth : container.offsetWidth - moreButton.offsetWidth;
        var numBreakpoints = this._navBreakpoints.length; // sum child widths instead of using parent's width to avoid
        // browser inconsistencies

        var mainLinksWidth = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = mainLinks.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var el = _step.value;
            mainLinksWidth += el.offsetWidth;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (mainLinksWidth > navWidth) {
          this._navBreakpoints.push(mainLinksWidth);

          var lastLink = mainLinks.children.item(mainLinks.children.length - 1);

          if (lastLink === null) {
            return;
          }

          collapsedLinks.prepend(lastLink);

          if (moreButton.classList.contains('yxt-Nav-item--more')) {
            moreButton.classList.remove('yxt-Nav-item--more');
          }
        } else {
          if (numBreakpoints && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
            var firstLink = collapsedLinks.children.item(0);

            if (firstLink === null) {
              return;
            }

            mainLinks.append(firstLink);

            this._navBreakpoints.pop();

            numBreakpoints--;
          }

          if (collapsedLinks.children.length === 0) {
            moreButton.classList.add('yxt-Nav-item--more');
          }
        }

        this.closeMoreDropdown();

        if (mainLinksWidth > navWidth || numBreakpoints > 0 && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
          this.refitNav();
        }
      }
    }, {
      key: "closeMoreDropdown",
      value: function closeMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.remove('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', false);
      }
    }, {
      key: "openMoreDropdown",
      value: function openMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.add('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', true);
      }
    }, {
      key: "toggleMoreDropdown",
      value: function toggleMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.toggle('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', collapsed.classList.contains('is-active'));
      }
    }, {
      key: "checkOutsideClick",
      value: function checkOutsideClick(e) {
        if (e.target.closest('.yxt-Nav-container')) {
          return;
        }

        this.closeMoreDropdown();
      }
    }, {
      key: "checkMobileOverflowBehavior",
      value: function checkMobileOverflowBehavior() {
        if (this._checkMobileOverflowBehaviorTimer) {
          clearTimeout(this._checkMobileOverflowBehaviorTimer);
        }

        this._checkMobileOverflowBehaviorTimer = setTimeout(this.setState.bind(this), RESIZE_DEBOUNCE);
      }
      /**
       * Since the server data only provides a list of
       * VS configIds, we need to compute and transform
       * the data into the proper format for rendering.
       *
       * @override
       */

    }, {
      key: "setState",
      value: function setState() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (data.tabOrder !== undefined) {
          this._tabOrder = this.mergeTabOrder(data.tabOrder, this._tabOrder);
        } // Since the tab ordering can change based on the server data
        // we need to update each tabs URL to include the order as part of their params.
        // This helps with persisting state across verticals.


        var tabs = [];

        for (var i = 0; i < this._tabOrder.length; i++) {
          var tab = this._tabs[this._tabOrder[i]];

          if (tab !== undefined) {
            tab.url = this.generateTabUrl(tab.baseUrl, this.getUrlParams());
            tabs.push(tab);
          }
        }

        return _get(_getPrototypeOf(NavigationComponent.prototype), "setState", this).call(this, {
          tabs: tabs,
          overflowLabel: this.overflowLabel,
          overflowIcon: this.overflowIcon,
          showCollapse: this.shouldCollapse(),
          ariaLabel: this._ariaLabel
        });
      }
    }, {
      key: "getUrlParams",
      value: function getUrlParams() {
        return new SearchParams(window.location.search.substring(1));
      }
    }, {
      key: "shouldCollapse",
      value: function shouldCollapse() {
        switch (this._mobileOverflowBehavior) {
          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE:
            return true;

          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.INNERSCROLL:
            var container = DOM.query(this._container, '.yxt-Nav-container') || this._container;

            var navWidth = container.offsetWidth;
            return navWidth > MOBILE_BREAKPOINT;
        }
      }
      /**
       * getDefaultTabOrder will compute the initial tab ordering based
       * on a combination of the configuration provided directly to the component
       * and the url params.
       * @param {Object[]} tabsConfig
       * @param {SearchParams}
       */

    }, {
      key: "getDefaultTabOrder",
      value: function getDefaultTabOrder(tabsConfig, urlParams) {
        var tabOrder = []; // Use the ordering from the URL as the primary configuration
        // And then merge it with the local configuration, if provided.

        if (urlParams && urlParams.has('tabOrder')) {
          tabOrder = urlParams.get('tabOrder').split(',');
        }

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = tabsConfig[i]; // Some tabs don't have configId, so we map it from URL

          if (tab.configId === undefined) {
            tab.configId = tab.url;
          } // Avoid duplicates if config was provided from URL


          if (tabOrder.includes(tab.configId)) {
            continue;
          } // isFirst should always be the first element in the list


          if (tab.isFirst) {
            tabOrder.unshift(tab.configId);
          } else {
            tabOrder.push(tab.configId);
          }
        }

        return tabOrder;
      }
      /**
       * mergeTabOrder merges two arrays into one
       * by appending additional tabs to the end of the original array
       * @param {string[]} tabOrder Tab order provided by the server
       * @param {string[]} otherTabOrder Tab order provided by configuration
       * @return {string[]}
       */

    }, {
      key: "mergeTabOrder",
      value: function mergeTabOrder(tabOrder, otherTabOrder) {
        for (var i = 0; i < otherTabOrder.length; i++) {
          var tabConfig = otherTabOrder[i];

          if (tabOrder.includes(tabConfig)) {
            continue;
          } // isFirst should be an override to dynamic tab ordering.


          if (this._tabs[tabConfig] && this._tabs[tabConfig].isFirst) {
            tabOrder.unshift(tabConfig);
          } else {
            tabOrder.push(tabConfig);
          }
        }

        return tabOrder;
      }
    }, {
      key: "generateTabUrl",
      value: function generateTabUrl(baseUrl) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();
        // We want to persist the params from the existing URL to the new
        // URLS we create.
        params.set('tabOrder', this._tabOrder);
        return baseUrl + '?' + params.toString();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'navigation/navigation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Navigation';
      }
    }]);

    return NavigationComponent;
  }(Component);

  /**
   * SearchComponent exposes an interface in order to create
   * a UI Search experience for vertical and universal search.
   *
   * @extends Component
   */

  var SearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SearchComponent, _Component);

    function SearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchComponent).call(this, config, systemConfig));
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, auto-complete and search will be based on universal
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided. If not provided, no title will be included.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The label text is used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.labelText = config.labelText || 'Conduct a search';
      /**
       * The submit text is used for labeling the submit button, also provided to the template.
       * @type {string}
       */

      _this.submitText = config.submitText || 'Submit';
      /**
       * The clear text is used for labeling the clear button, also provided to the template.
       * @type {string}
       */

      _this.clearText = config.clearText || 'Clear';
      /**
       * The submit icon is an icon for the submit button, if provided it will be displayed and the
       * submit text will be used for screen readers.
       * @type {string|null}
       */

      _this.submitIcon = config.submitIcon || null;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * If true, show an "x" that allows the user to clear the current
       * query
       * @type {boolean}
       */

      _this.clearButton = config.clearButton === undefined ? true : config.clearButton;
      /**
       * When autofocusing on load, optionally open the autocomplete
       * (preset prompts)
       * @type {boolean}
       */

      _this.autocompleteOnLoad = config.autocompleteOnLoad || false;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * true if there is another search bar present on the page.
       * Twins only update the query, and do not search
       */

      _this._isTwin = config.isTwin;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string|null}
       */

      _this.query = config.query || _this.core.globalStorage.getState(StorageKeys.QUERY);

      _this.core.globalStorage.on('update', StorageKeys.QUERY, function (q) {
        _this.query = q;

        _this.setState();

        _this.debouncedSearch(q);
      });
      /**
       * The minimum time allowed in milliseconds between searches to prevent
       * many duplicate searches back-to-back
       * @type {number}
       * @private
       */


      _this._searchCooldown = config.searchCooldown || 300;
      /**
       * When true and "near me" intent is expressed, prompt the user for their geolocation
       * @type {boolean}
       * @private
       */

      _this._promptForLocation = config.promptForLocation === undefined ? true : Boolean(config.promptForLocation);
      /**
       * Controls showing and hiding the search clear button
       */

      _this._showClearButton = _this.clearButton && _this.query;
      /**
       * For vertical search bars, whether or not to allow empty searches.
       * @type {boolean}
       * @private
       */

      _this._allowEmptySearch = !!config.allowEmptySearch;
      /**
       * The name of the child AutoComplete component.
       * @type {string}
       * @private
       */

      _this._autoCompleteName = "".concat(_this.name, ".autocomplete");
      return _this;
    }

    _createClass(SearchComponent, [{
      key: "onCreate",
      value: function onCreate() {
        if (this.query != null && !this.redirectUrl) {
          this.core.setQuery(this.query);
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        // NOTE(amullings): If autocompleteOnLoad is false, we focus the input
        // element before loading the autocomplete component so that its focus
        // handler won't be triggered
        if (this.autoFocus === true && !this.query && !this.autocompleteOnLoad) {
          this.focusInputElement();
        } // Wire up our search handling and auto complete


        this.initSearch(this._formEl);
        this.initAutoComplete(this._inputEl);

        if (this.clearButton) {
          this.initClearButton();
        }

        if (this.autoFocus === true && !this.query && this.autocompleteOnLoad) {
          this.focusInputElement();
        }
      }
    }, {
      key: "remove",
      value: function remove() {
        this._autocomplete.remove();

        _get(_getPrototypeOf(SearchComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "initClearButton",
      value: function initClearButton() {
        var _this2 = this;

        var button = DOM.query(this._container, '.js-yxt-SearchBar-clear');
        this._showClearButton = this._showClearButton || this.query;
        button.classList.toggle('yxt-SearchBar--hidden', !this._showClearButton);
        DOM.on(button, 'click', function () {
          _this2.query = '';
          _this2._showClearButton = false;
          button.classList.add('yxt-SearchBar--hidden');

          _this2.setState({});

          _this2.core.persistentStorage.set(StorageKeys.QUERY, _this2.query);

          _this2.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this2.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this2.core.setQuery(_this2.query); // Focus the input element after clearing the query, regardless of whether
          // or not the autoFocus option is enabled.
          // NOTE(amullings): This depends heavily on the fact that the re-renders
          // triggered by setState and core.setQuery happen synchronously; if this
          // stops being the case at some point, we'll need an alternative solution


          _this2.focusInputElement();
        });
        var input = DOM.query(this._container, this._inputEl);
        DOM.on(input, 'input', function (e) {
          var input = e.target.value;

          if (!_this2._showClearButton && input.length > 0) {
            _this2._showClearButton = true;
            button.classList.remove('yxt-SearchBar--hidden');
          } else if (_this2._showClearButton && input.length === 0) {
            _this2._showClearButton = false;
            button.classList.add('yxt-SearchBar--hidden');
          }
        });
      }
      /**
       * A helper method to use for wiring up searching on form submission
       * @param {string} formSelector CSS selector to bind our submit handling to
       */

    }, {
      key: "initSearch",
      value: function initSearch(formSelector) {
        var _this3 = this;

        this._formEl = formSelector;

        this._container.classList.add('yxt-SearchBar-wrapper');

        var form = DOM.query(this._container, formSelector);

        if (!form) {
          throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._formEl, '`.');
        }

        DOM.on(form, 'submit', function (e) {
          e.preventDefault();
          var inputEl = form.querySelector(_this3._inputEl);
          var query = inputEl.value;
          var params = new SearchParams(window.location.search.substring(1));
          params.set('query', query); // If we have a redirectUrl, we want the form to be
          // serialized and submitted.

          if (typeof _this3.redirectUrl === 'string') {
            window.location.href = _this3.redirectUrl + '?' + params.toString();
            return false;
          }

          inputEl.blur();

          _this3.core.persistentStorage.set(StorageKeys.QUERY, query);

          _this3.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this3.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this3.core.setQuery(query);

          _this3.debouncedSearch(query);

          return false;
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this4 = this;

        this._inputEl = inputSelector;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: this._autoCompleteName,
          container: '.yxt-SearchBar-autocomplete',
          autoFocus: this.autoFocus && !this.autocompleteOnLoad,
          verticalKey: this._verticalKey,
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          inputEl: inputSelector,
          onSubmit: function onSubmit() {
            DOM.trigger(DOM.query(_this4._container, _this4._formEl), 'submit');
          },
          onChange: function onChange() {
            DOM.trigger(DOM.query(_this4._container, inputSelector), 'input');
          }
        });
      }
      /**
       * Performs a debounced query using the provided string input. Specifically, a new search is not
       * performed if we recently searched, if there's no query for universal search, or if this
       * is a twin searchbar.
       * @param {string} query The string to query against.
       * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
       */

    }, {
      key: "debouncedSearch",
      value: function debouncedSearch(query) {
        var _this5 = this;

        if (this._throttled || !query && !this._verticalKey || !query && this._verticalKey && !this._allowEmptySearch || this._isTwin) {
          return;
        }

        this._throttled = true;
        setTimeout(function () {
          _this5._throttled = false;
        }, this._searchCooldown); // If _promptForLocation is enabled, we will compute the query's intent and, from there,
        // determine if it's necessary to prompt the user for their location information. It will
        // be unnecessary if the query does not have near me intent or we already have their location
        // stored.

        if (this._promptForLocation) {
          this.fetchQueryIntents(query).then(function (queryIntents) {
            return queryIntents.includes('NEAR_ME');
          }).then(function (queryHasNearMeIntent) {
            if (queryHasNearMeIntent && !_this5.core.globalStorage.getState(StorageKeys.GEOLOCATION)) {
              return new Promise(function (resolve, reject) {
                return navigator.geolocation.getCurrentPosition(function (position) {
                  _this5.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    radius: position.coords.accuracy
                  });

                  resolve(_this5.search(query));
                }, function () {
                  return resolve(_this5.search(query));
                });
              });
            } else {
              return _this5.search(query);
            }
          });
        } else {
          return this.search(query);
        }
      }
      /**
       * Performs a query using the provided string input.
       * @param {string} query The string to query against.
       * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
       */

    }, {
      key: "search",
      value: function search(query) {
        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          return this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0
          });
        } else {
          // NOTE(billy) Temporary hack for DEMO
          // Remove me after the demo
          var nav = this.componentManager.getActiveComponent('Navigation');

          if (nav) {
            var tabs = nav.getState('tabs');
            var urls = {};

            if (tabs && Array.isArray(tabs)) {
              for (var i = 0; i < tabs.length; i++) {
                var params = new SearchParams(tabs[i].url.split('?')[1]);
                params.set('query', query);
                var url = tabs[i].baseUrl;

                if (params.toString().length > 0) {
                  url += '?' + params.toString();
                }

                urls[tabs[i].configId] = url;
              }
            }

            return this.core.search(query, urls);
          }

          return this.core.search(query);
        }
      }
      /**
       * A helper method that computes the intents of the provided query. If the query was entered
       * manually into the search bar or selected via autocomplete, its intents will have been stored
       * already in globalStorage. Otherwise, a new API call will have to be issued to determine
       * intent.
       * @param {string} query The query whose intent is needed.
       * @returns {Promise} A promise containing the intents of the query.
       */

    }, {
      key: "fetchQueryIntents",
      value: function fetchQueryIntents(query) {
        var autocompleteData = this.core.globalStorage.getState("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(this._autoCompleteName));

        if (!autocompleteData) {
          var autocompleteRequest = this._verticalKey ? this.core.autoCompleteVertical(query, this._autoCompleteName, this._verticalKey) : this.core.autoCompleteUniversal(query, this._autoCompleteName);
          return autocompleteRequest.then(function (data) {
            return data.inputIntents;
          });
        } else {
          // There are two alternatives to consider here. The user could have selected the query
          // as an autocomplete option or manually input it themselves. If the former, use the intents
          // of the corresponding autocomplete option. If the latter, use the inputIntents of the
          // autocompleteData.
          var results = autocompleteData.sections.flatMap(function (section) {
            return section.results;
          });
          var matchingResult = results.find(function (result) {
            return result.value === query;
          });
          var queryIntents = matchingResult ? matchingResult.intents : autocompleteData.inputIntents;
          return Promise.resolve(queryIntents);
        }
      }
      /**
       * A helper method that constructs the meta information needed by the SEARCH_CLEAR_BUTTON
       * analytics event.
       */

    }, {
      key: "eventOptions",
      value: function eventOptions() {
        var queryId = this.core.globalStorage.getState(StorageKeys.QUERY_ID);
        var options = Object.assign({}, queryId && {
          queryId: queryId
        }, this._verticalKey && {
          verticalKey: this._verticalKey
        });
        return JSON.stringify(options);
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(SearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          labelText: this.labelText,
          submitIcon: this.submitIcon,
          submitText: this.submitText,
          clearText: this.clearText,
          showClearButton: this._showClearButton,
          query: this.query || '',
          eventOptions: this.eventOptions()
        }, data));
      }
    }, {
      key: "focusInputElement",
      value: function focusInputElement() {
        DOM.query(this._container, this._inputEl).focus();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/search';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SearchBar';
      }
    }]);

    return SearchComponent;
  }(Component);

  /** @module SearchParamsParser */
  function buildSearchParameters(searchParameterConfigs) {
    var searchParameters = {
      sectioned: false,
      fields: []
    };

    if (searchParameterConfigs === undefined) {
      return searchParameters;
    }

    if (searchParameterConfigs.sectioned) {
      searchParameters.sectioned = searchParameterConfigs.sectioned;
    }

    searchParameters.fields = buildFields(searchParameterConfigs.fields);
    return searchParameters;
  }

  function buildFields(fieldConfigs) {
    if (fieldConfigs === undefined) {
      return [];
    }

    return fieldConfigs.map(function (fc) {
      return _objectSpread({
        fetchEntities: false
      }, fc);
    });
  }

  /**
   * FilterSearchComponent is used for autocomplete using the FilterSearch backend.
   * It'll allow you to pick pre-set filters that are setup on the backend within
   * a vertical search context.
   *
   * @extends Component
   */

  var FilterSearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterSearchComponent, _Component);

    function FilterSearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterSearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterSearchComponent).call(this, config, systemConfig));
      /**
       * The vertical key for vertical search configuration
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * If true, store the filter value but do not search on change
       * @type {boolean}
       * @private
       */

      _this._storeOnChange = config.storeOnChange || false;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The search text used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.searchText = config.searchText || 'What are you interested in?';
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string}
       */

      _this.query = config.query || _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.search();
      });
      /**
       * The filter string to use for the provided query
       * Optionally provided
       * @type {string}
       */


      _this.filter = config.filter || _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || '';

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.searchParameters = buildSearchParameters(config.searchParameters);

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      return _this;
    }

    _createClass(FilterSearchComponent, [{
      key: "onCreate",
      value: function onCreate() {
        if (this.query && this.filter) {
          this.search();
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        // Wire up our search handling and auto complete
        this.initAutoComplete(this._inputEl);

        if (this.autoFocus === true && this.query.length === 0) {
          DOM.query(this._container, this._inputEl).focus();
        }
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this2 = this;

        this._inputEl = inputSelector;
        this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.yxt-SearchBar-autocomplete',
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._verticalKey,
          searchParameters: this.searchParameters,
          onSubmit: function onSubmit(query, filter) {
            var params = new SearchParams(window.location.search.substring(1));
            params.set("".concat(_this2.name, ".query"), query);
            params.set("".concat(_this2.name, ".filter"), filter); // If we have a redirectUrl, we want the params to be
            // serialized and submitted.

            if (typeof _this2.redirectUrl === 'string') {
              window.location.href = _this2.redirectUrl + '?' + params.toString();
              return false;
            } // save the filter to storage for the next search


            _this2.query = query;
            _this2.filter = Filter.fromResponse(filter);

            _this2.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(_this2.name), _this2.query);

            _this2.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(_this2.name), _this2.filter);

            _this2.core.setFilter(_this2.name, _this2.filter);

            _this2.search();
          }
        });
      }
      /**
       * Perform the vertical search with all saved filters and query,
       * optionally redirecting based on config
       */

    }, {
      key: "search",
      value: function search() {
        if (this._storeOnChange) {
          return;
        }

        var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = filters[0];

        if (filters.length > 1) {
          totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
        }

        var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: searchQuery,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(FilterSearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          searchText: this.searchText,
          query: this.query,
          filter: this.filter
        }, data));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/filtersearch';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterSearch';
      }
    }]);

    return FilterSearchComponent;
  }(Component);

  var Keys = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESCAPE: 27,
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DELETE: 46,
    DOWN: 40,
    LEFT_OS_KEY: 91,
    RIGHT_OS_KEY: 92,
    SELECT_KEY: 93
  };

  var AutoCompleteComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AutoCompleteComponent, _Component);

    function AutoCompleteComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AutoCompleteComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AutoCompleteComponent).call(this, opts, systemOpts));
      /**
       * Whether autocomplete is simple or filter
       * @type {boolean}
       */

      _this.isFilterSearch = opts.isFilterSearch || false;
      /**
       * The `verticalKey` of the vertical search to use for auto-complete
       * @type {string}
       */

      _this._verticalKey = opts.verticalKey || null;
      /**
       * A reference to the input el selector for auto complete
       * @type {string}
       */

      _this._inputEl = opts.inputEl || '.js-yext-query';
      /**
       * A selector for the autocomplete elementes
       * @type {string}
       */

      _this._autocompleteEls = opts.autoCompleteEls || '.js-yext-autocomplete-option';
      /**
       * An internal reference for the data-storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = "".concat(StorageKeys.AUTOCOMPLETE, ".").concat(_this.name);
      /**
       * An internal reference to the input value when typing.
       * We use this for resetting the state of the input value when other interactions (e.g. result navigation)
       * change based on interactions. For instance, hitting escape should reset the value to the original typed query.
       * @type {string}
       */

      _this._originalQuery = opts.originalQuery || '';
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current section we're navigating in.
       * @type {number}
       */

      _this._sectionIndex = 0;
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current result index we're navigating on.
       * @type {number}
       */

      _this._resultIndex = -1;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = opts.promptHeader || null;
      /**
       * Whether the input is autocomatically focused or not
       * @type {boolean}
       */

      _this._autoFocus = opts.autoFocus || false;
      /**
       * Callback invoked when the `Enter` key is pressed on auto complete.
       */

      _this._onSubmit = opts.onSubmit || function () {};
      /**
       * Callback invoked when keys are used to navigate through the auto complete. Note that this is
       * not called when either the `Enter` key is pressed or the mouse is used to select an
       * autocomplete option.
       */


      _this._onChange = opts.onChange || function () {};

      _this._searchParameters = opts.searchParameters || null;
      return _this;
    }
    /**
     * The aliased used by the component manager for creation.
     */


    _createClass(AutoCompleteComponent, [{
      key: "setState",

      /**
       * setState is overridden so that we can provide additional meta data
       * to the template (e.g. the sectionIndex and resultIndex), since
       * those are client-interaction specific values and aren't returned from the server.
       */
      value: function setState(data) {
        if (!this.isQueryInputFocused()) {
          this._sectionIndex = 0;
          this._resultIndex = -1;
          data = {};
        }

        _get(_getPrototypeOf(AutoCompleteComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          hasResults: this.hasResults(data),
          sectionIndex: this._sectionIndex,
          resultIndex: this._resultIndex,
          promptHeader: this._originalQuery.length === 0 ? this.promptHeader : null
        }));
      }
    }, {
      key: "isQueryInputFocused",
      value: function isQueryInputFocused() {
        return document.activeElement && document.activeElement.className.includes(this._inputEl.substring(1));
      }
      /**
       * updateState is a helper to apply the current state with new client-state.
       */

    }, {
      key: "updateState",
      value: function updateState() {
        this.setState(this._state.get());
      }
      /**
       * onCreate is triggered when the component is constructed from the framework.
       * Once we're initalized, we wire up all of our user interactions
       */

    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        // Use the context of the parent component to find the input node.
        var queryInput = DOM.query(this._parentContainer, this._inputEl);

        if (!queryInput) {
          throw new Error('Could not initialize AutoComplete. Can not find {HTMLElement} `', this._inputEl, '`.');
        } // Disable the native autocomplete, autocorrect & spellcheck


        DOM.attributes(queryInput, {
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: 'false'
        }); // The user exits the input, so we want to reset the state and close
        // the auto complete
        // TODO(jdelerme): Close logic to be moved to parent

        DOM.on(document, 'click', function (e) {
          if (e.target.matches('.js-yxt-AutoComplete-wrapper *') || e.target.matches(_this2._inputEl)) {
            return;
          }

          _this2.close();
        }); // When a user focuses the input, we should populate the autocomplete based
        // on the current value

        DOM.on(queryInput, 'focus', function () {
          _this2.reset();

          _this2.autoComplete(queryInput.value);
        }); // Allow the user to navigate between the results using the keyboard

        DOM.on(queryInput, 'keydown', function (e) {
          _this2.handleNavigateResults(e.keyCode, e);

          _this2.handleSubmitResult(e.keyCode, queryInput.value, e);
        });

        if (this._autoFocus) {
          DOM.once(queryInput, 'click', function () {
            _this2.autoComplete(queryInput.value);
          });
        } // Allow the user to select a result with the mouse


        DOM.delegate(this._container, '.js-yext-autocomplete-option', 'click', function (evt, target) {
          var data = target.dataset;
          var val = data["short"];

          _this2.updateQuery(val);

          _this2._onSubmit(val, data.filter);

          _this2.close();
        }); // When the user is typing in the input, process the auto complete.

        DOM.on(queryInput, 'keyup', function (e) {
          _this2.handleTyping(e.keyCode, queryInput.value, e);
        });
      }
      /**
       * close will hide the auto complete results and reset the state.
       */

    }, {
      key: "close",
      value: function close() {
        this.setState({});
        this.reset();
      }
      /**
       * resets the client state to their original values and triggers
       * a template-rerender via updateState
       */

    }, {
      key: "reset",
      value: function reset() {
        this._sectionIndex = 0;
        this._resultIndex = -1;
        this.updateState();
      }
      /**
       * Helper method to update the input text
       * @param {string} optValue Option value provided.
       * If no value provided, we'll try to find it based on the selection indexes.
       */

    }, {
      key: "updateQuery",
      value: function updateQuery(optValue) {
        // Only want to update the query string if theres a value.
        // If one is provided, great.
        // Otherwise, lets try to find it from the current selection in the results.
        if (optValue === undefined) {
          var sections = this._state.get('sections');

          var results = sections[this._sectionIndex].results;
          optValue = results[this._resultIndex].shortValue;
        }

        var queryEl = DOM.query(this._parentContainer, this._inputEl);
        queryEl.value = optValue;
      }
    }, {
      key: "handleTyping",
      value: function handleTyping(key, value, e) {
        var ignoredKeys = [Keys.DOWN, Keys.UP, Keys.CTRL, Keys.ALT, Keys.SHIFT, Keys.LEFT, Keys.RIGHT, Keys.LEFT_OS_KEY, Keys.RIGHT_OS_KEY, Keys.ENTER, Keys.TAB, Keys.SELECT_KEY];

        if (ignoredKeys.indexOf(key) > -1) {
          return;
        } // User escapes out of auto complete, so we reset it to the original input


        if (key === Keys.ESCAPE) {
          this.updateQuery(this._originalQuery);
          this.close();
          return;
        } // Update the original value based on the user input


        this._originalQuery = value;
        this.reset();
        this.autoComplete(value);
      }
    }, {
      key: "autoComplete",
      value: function autoComplete(input) {
        if (this.isFilterSearch) {
          this.core.autoCompleteFilter(input, {
            namespace: this.name,
            verticalKey: this._verticalKey,
            searchParameters: this._searchParameters
          });
        } else if (this._verticalKey) {
          this.core.autoCompleteVertical(input, this.name, this._verticalKey);
        } else {
          this.core.autoCompleteUniversal(input, this.name);
        }
      }
      /**
       * returns true if we have results in any section
       * @returns boolean
       */

    }, {
      key: "hasResults",
      value: function hasResults(data) {
        if (!data) {
          return false;
        }

        var sections = data['sections'];

        if (!sections) {
          return false;
        }

        for (var i = 0; i < sections.length; i++) {
          var _data = sections[i];

          if (!_data) {
            continue;
          }

          var results = _data.results;

          if (!results) {
            continue;
          }

          if (results.length > 0) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "handleNavigateResults",
      value: function handleNavigateResults(key, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          return;
        } // Tabbing out or enter should close the auto complete.


        if (key === Keys.TAB) {
          this.close();
          return;
        }

        var results = sections[this._sectionIndex].results;

        if (key === Keys.UP) {
          e.preventDefault();

          if (this._resultIndex <= 0) {
            if (this._sectionIndex > 0) {
              this._sectionIndex--;
              this._resultIndex = sections[this._sectionIndex].results.length - 1;
            } else {
              this.updateQuery(this._originalQuery);
              this.reset();
              return;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex--;
          this.updateState();
          this.updateQuery();
          return;
        }

        if (key === Keys.DOWN) {
          e.preventDefault();

          if (this._resultIndex >= results.length - 1) {
            if (this._sectionIndex < sections.length - 1) {
              this._sectionIndex++;
              this._resultIndex = 0;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex++;
          this.updateQuery();
          this.updateState();
        }
      }
    }, {
      key: "handleSubmitResult",
      value: function handleSubmitResult(key, value, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          if (this.isFilterSearch) {
            this.autoComplete(value);
          }

          return;
        } // submit the search on enter


        if (key === Keys.ENTER) {
          e.preventDefault();

          if (this.isFilterSearch && this._resultIndex === -1) {
            return;
          }

          var filter = '';

          if (this._sectionIndex >= 0 && this._resultIndex >= 0) {
            filter = JSON.stringify(sections[this._sectionIndex].results[this._resultIndex].filter);
          }

          this.updateQuery(value);
          this._originalQuery = value;

          this._onSubmit(value, filter);

          this.close();
        } else {
          this._onChange();
        }
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'search/autocomplete';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AutoComplete';
      }
    }]);

    return AutoCompleteComponent;
  }(Component);

  /**
   * SpellCheckComponent will support displaying suggestion, autocorrect and combined(maybe in the future)
   * provided from spelling correction.
   *
   * @extends Component
   */

  var SpellCheckComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SpellCheckComponent, _Component);

    function SpellCheckComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SpellCheckComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SpellCheckComponent).call(this, config, systemConfig));
      _this.moduleId = StorageKeys.SPELL_CHECK;
      return _this;
    }

    _createClass(SpellCheckComponent, [{
      key: "onCreate",
      value: function onCreate() {
        this.core.persistentStorage["delete"]('skipSpellCheck', true);
        this.core.persistentStorage["delete"]('queryTrigger', true);
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        return _get(_getPrototypeOf(SpellCheckComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          shouldShow: data.correctedQuery !== undefined,
          correctedQueryUrl: this._buildRedirectQueryUrl(data.correctedQuery, data.type),
          helpText: this._getHelpText(data.type)
        }, val));
      }
    }, {
      key: "_buildRedirectQueryUrl",
      value: function _buildRedirectQueryUrl(query, type) {
        if (query === undefined) {
          return '';
        }

        var params = new SearchParams(window.location.search.substring(1));
        params.set('query', query.value);
        params.set('skipSpellCheck', true);
        params.set('queryTrigger', type.toLowerCase());
        return '?' + params.toString();
      }
    }, {
      key: "_getHelpText",
      value: function _getHelpText(type) {
        switch (type) {
          case 'SUGGEST':
            return 'Did you mean:';

          default:
            return '';
        }
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/spellcheck';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SpellCheck';
      }
    }]);

    return SpellCheckComponent;
  }(Component);

  /**
   * LocationBiasComponent will show the user where is used for location bias and allow user to
   * improve accuracy with HTML5 geolocation.
   *
   * @extends Component
   */

  var LocationBiasComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(LocationBiasComponent, _Component);

    function LocationBiasComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LocationBiasComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationBiasComponent).call(this, config, systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.LOCATION_BIAS;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, when location updated,
       * a universal search will be triggered.
       * @type {string}
       */
      // TODO: Remove config.verticalKey

      _this._verticalKey = config.verticalKey || _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey || null;
      /**
       * The element used for updating location
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._updateLocationEl = config.updateLocationEl || '.js-locationBias-update-location';
      _this._locationDisplayName = '';
      _this._accuracy = '';
      _this._allowUpdate = true;
      return _this;
    }

    _createClass(LocationBiasComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (!this._allowUpdate) {
          return;
        }

        this._disableLocationUpdateIfGeolocationDenied();

        DOM.on(this._updateLocationEl, 'click', function (e) {
          if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(function (position) {
              _this2.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                radius: position.coords.accuracy
              });

              _this2._doSearch();
            }, function (err) {
              if (err.code === 1) {
                _this2._disableLocationUpdate();
              }
            });
          } // TODO: Should we throw error or warning here if no geolocation?

        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        this._locationDisplayName = data.locationDisplayName;
        this._accuracy = data.accuracy;
        return _get(_getPrototypeOf(LocationBiasComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          locationDisplayName: this._getLocationDisplayName(data),
          accuracyText: this._getAccuracyHelpText(data.accuracy),
          isPreciseLocation: data.accuracy === 'DEVICE' && this._allowUpdate,
          isUnknownLocation: data.accuracy === 'UNKNOWN',
          shouldShow: data.accuracy !== undefined,
          allowUpdate: this._allowUpdate
        }, val));
      }
    }, {
      key: "_getLocationDisplayName",
      value: function _getLocationDisplayName(data) {
        if (data.accuracy === 'UNKNOWN') {
          return 'Unknown Location';
        }

        return data.locationDisplayName;
      }
    }, {
      key: "_getAccuracyHelpText",
      value: function _getAccuracyHelpText(accuracy) {
        switch (accuracy) {
          case 'IP':
            return 'based on your internet address';

          case 'DEVICE':
            return 'based on your device';

          default:
            return '';
        }
      }
    }, {
      key: "_doSearch",
      value: function _doSearch() {
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0,
            facetFilter: JSON.stringify(facetFilter)
          });
        } else {
          this.core.search(query);
        }
      }
    }, {
      key: "_disableLocationUpdateIfGeolocationDenied",
      value: function _disableLocationUpdateIfGeolocationDenied() {
        var _this3 = this;

        if ('permissions' in navigator) {
          navigator.permissions.query({
            name: 'geolocation'
          }).then(function (result) {
            if (result.state === 'denied') {
              _this3._disableLocationUpdate();
            }
          });
        }
      }
    }, {
      key: "_disableLocationUpdate",
      value: function _disableLocationUpdate() {
        this.core.globalStorage["delete"](StorageKeys.GEOLOCATION);
        this._allowUpdate = false;
        this.setState({
          locationDisplayName: this._locationDisplayName,
          accuracy: this._accuracy
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/locationbias';
      }
    }, {
      key: "type",
      get: function get() {
        return 'LocationBias';
      }
    }]);

    return LocationBiasComponent;
  }(Component);

  /** @module Facet */

  /**
   * Model representing a facet filter with the format of
   * {
   *   "field_name": [ Filters... ],
   *   ...
   * }
   *
   * @see {@link Filter}
   */
  var Facet =
  /*#__PURE__*/
  function () {
    function Facet() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Facet);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Create a facet filter from a list of Filters
     * @param  {...Filter} filters The filters to use in this facet
     * @returns {Facet}
     */


    _createClass(Facet, null, [{
      key: "fromFilters",
      value: function fromFilters(availableFieldIds) {
        var groups = {};
        availableFieldIds.forEach(function (fieldId) {
          groups[fieldId] = [];
        });

        for (var _len = arguments.length, filters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          filters[_key - 1] = arguments[_key];
        }

        var flatFilters = filters.flatMap(function (f) {
          return f.$or || f;
        });
        flatFilters.forEach(function (f) {
          var key = Object.keys(f)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(f);
        });
        return new Facet(groups);
      }
    }]);

    return Facet;
  }();

  var FilterBoxConfig =
  /*#__PURE__*/
  function () {
    function FilterBoxConfig(config) {
      _classCallCheck(this, FilterBoxConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFilter = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFilterLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFilters = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFiltersLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The selector of the apply button
       * @type {string}
       */

      this.applyButtonSelector = config.applyButtonSelector || '.js-yext-filterbox-apply';
      /**
       * The list of filters to display and control, ignoring empty sections
       * @type {object[]}
       */

      this.filterConfigs = config.filters.filter(function (f) {
        return f.options.length !== 0;
      });
      /**
       * Whether or not this filterbox contains facets. This affects the
       * the way the filters are used in the search
       * @type {boolean}
       */

      this.isDynamic = config.isDynamic || false;
      this.validate();
    }

    _createClass(FilterBoxConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FilterBoxConfig;
  }();
  /**
   * Renders a set of filters, and searches with them when applied.
   * Multiple FilterBox components will AND together but will not share state.
   * @extends Component
   */


  var FilterBoxComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterBoxComponent, _Component);

    function FilterBoxComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterBoxComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterBoxComponent).call(this, config, systemConfig));
      _this.config = new FilterBoxConfig(config);

      if (!config.filters || !(config.filters instanceof Array)) {
        throw new AnswersComponentError('FilterBox requires filters to be provided as an array', 'FilterBox');
      }
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */


      _this._verticalKey = config.verticalKey || null;
      /**
       * The components created for each filter config
       * @type {Component[]}
       * @private
       */

      _this._filterComponents = [];
      /**
       * The current state of the filter components in the box
       * @type {Filter}
       * @private
       */

      _this._filters = [];

      if (!_this.config.showCount) {
        _this.config.filterConfigs.forEach(function (config) {
          config.options.forEach(function (option) {
            option.countLabel = null;
          });
        });
      }

      return _this;
    }

    _createClass(FilterBoxComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(FilterBoxComponent.prototype), "setState", this).call(this, Object.assign({}, data, this.config, {
          showReset: this.config.resetFilters,
          resetLabel: this.config.resetFiltersLabel,
          showApplyButton: !this.config.searchOnChange
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._filterComponents.length) {
          this._filterComponents.forEach(function (c) {
            return c.remove();
          });

          this._filterComponents = [];
          this._filters = [];
        } // Initialize filters from configs


        var _loop = function _loop(i) {
          var config = _this2.config.filterConfigs[i];

          var component = _this2.componentManager.create(config.type, Object.assign({}, config, _this2.config, {
            parentContainer: _this2._container,
            name: "".concat(_this2.name, ".filter").concat(i),
            storeOnChange: false,
            container: ".js-yext-filterbox-filter".concat(i),
            showReset: _this2.config.resetFilter,
            resetLabel: _this2.config.resetFilterLabel,
            showExpand: _this2.config.expand,
            onChange: function onChange(filter) {
              _this2.onFilterChange(i, filter);
            }
          }));

          component.mount();

          _this2._filterComponents.push(component);

          _this2._filters[i] = component.getFilter();

          _this2._saveFiltersToStorage();
        };

        for (var i = 0; i < this.config.filterConfigs.length; i++) {
          _loop(i);
        } // Initialize apply button


        if (!this.config.searchOnChange) {
          var button = DOM.query(this._container, this.config.applyButtonSelector);

          if (button) {
            DOM.on(button, 'click', function () {
              _this2._saveFiltersToStorage();

              _this2._search();
            });
          }
        } // Initialize reset button


        if (this.config.resetFilters) {
          DOM.on(DOM.query(this._container, '.js-yxt-FilterBox-reset'), 'click', this.resetFilters.bind(this));
        }
      }
    }, {
      key: "resetFilters",
      value: function resetFilters() {
        this._filterComponents.forEach(function (filter) {
          return filter.clearOptions();
        });
      }
      /**
       * Handle changes to child filter components
       * @param {number} index The index of the changed filter
       * @param {Filter} filter The new filter
       */

    }, {
      key: "onFilterChange",
      value: function onFilterChange(index, filter) {
        this._filters[index] = filter;

        if (this.config.searchOnChange) {
          this._saveFiltersToStorage();

          this._search();
        }
      }
      /**
       * Remove all filter components along with this component
       */

    }, {
      key: "remove",
      value: function remove() {
        this._filterComponents.forEach(function (c) {
          return c.remove();
        });

        _get(_getPrototypeOf(FilterBoxComponent.prototype), "remove", this).call(this);
      }
      /**
       * Save current filters to storage to be used in the next search
       * @private
       */

    }, {
      key: "_saveFiltersToStorage",
      value: function _saveFiltersToStorage() {
        var validFilters = this._filters.filter(function (f) {
          return f !== undefined && f !== null && Object.keys(f).length > 0;
        });

        if (this.config.isDynamic) {
          var availableFieldIds = this.config.filterConfigs.map(function (config) {
            return config.fieldId;
          });
          var combinedFilter = Facet.fromFilters.apply(Facet, [availableFieldIds].concat(_toConsumableArray(validFilters)));
          this.core.setFacetFilter(this.name, combinedFilter || {});
        } else {
          var _combinedFilter = validFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(validFilters)) : validFilters[0];

          this.core.setFilter(this.name, _combinedFilter || {});
        }
      }
      /**
       * Trigger a search with all filters in storage
       */

    }, {
      key: "_search",
      value: function _search() {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: query,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'filters/filterbox';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterBox';
      }
    }]);

    return FilterBoxComponent;
  }(Component);

  /**
   * The currently supported controls
   * @type {string[]}
   */

  var SUPPORTED_CONTROLS = ['singleoption', 'multioption'];

  var FilterOptionsConfig =
  /*#__PURE__*/
  function () {
    function FilterOptionsConfig(config) {
      _classCallCheck(this, FilterOptionsConfig);

      /**
       * The type of control to display
       * @type {string}
       */
      this.control = config.control;
      /**
       * The list of filter options to display with checked status
       * @type {object[]}
       */

      this.options = config.options;
      /**
       * The label to be used in the legend
       * @type {string}
       */

      this.label = config.label || 'Filters';
      /**
       * The callback function to call when changed
       * @type {function}
       */

      this.onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       */


      this.storeOnChange = config.storeOnChange || false;
      /**
       * If true, show a button to reset the current filter selection
       * @type {boolean}
       */

      this.showReset = config.showReset && this.options.length > 0;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetLabel = config.resetLabel || 'reset';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      this.showMore = this.showMore && this.options.length > this.showMoreLimit;
      /**
       * If true, allow expanding and collapsing the group of facets
       * @type {boolean}
       */

      this.showExpand = config.showExpand === undefined ? true : config.showExpand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * The selector used for options in the template
       * @type {string}
       */

      this.optionSelector = config.optionSelector || '.js-yext-filter-option';
      this.validate();

      if (typeof config.previousOptions === 'string') {
        try {
          config.previousOptions = JSON.parse(config.previousOptions);
        } catch (e) {
          config.previousOptions = [];
        }
      }

      var selectedOptions = config.previousOptions || [];
      this.options = this.setDefaultSelectedValues(this.options, selectedOptions);
    }

    _createClass(FilterOptionsConfig, [{
      key: "setDefaultSelectedValues",
      value: function setDefaultSelectedValues(options, selectedOptions) {
        return options.map(function (o) {
          return _objectSpread({}, o, {
            selected: selectedOptions.length ? selectedOptions.includes(o.label) : o.selected
          });
        });
      }
    }, {
      key: "getSelectedCount",
      value: function getSelectedCount() {
        return this.options.reduce(function (numSelected, option) {
          return option.selected ? numSelected + 1 : numSelected;
        }, 0);
      }
    }, {
      key: "validate",
      value: function validate() {
        if (!this.control || !SUPPORTED_CONTROLS.includes(this.control)) {
          throw new AnswersComponentError('FilterOptions requires a valid "control" to be provided', 'FilterOptions');
        }

        if (!this.options) {
          throw new AnswersComponentError('FilterOptions component requires options to be provided', 'FilterOptions');
        }
      }
    }]);

    return FilterOptionsConfig;
  }();
  /**
   * Renders a set of options, each one representing a filter in a search.
   */


  var FilterOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterOptionsComponent, _Component);

    function FilterOptionsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterOptionsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterOptionsComponent).call(this, config, systemConfig));

      var previousOptions = _this.core.globalStorage.getState(_this.name);

      _this.core.globalStorage["delete"](_this.name);
      /**
       * The component config
       * @type {FilterOptionsConfig}
       */


      _this.config = new FilterOptionsConfig(_objectSpread({
        previousOptions: previousOptions
      }, config));

      var selectedCount = _this.config.getSelectedCount();
      /**
       * True if the option list is expanded and visible
       * @type {boolean}
       */


      _this.expanded = _this.config.showExpand ? selectedCount > 0 : true;
      /**
       * True if all options are shown, false if some are hidden based on config
       * @type {boolean}
       */

      _this.allShown = false;
      return _this;
    }

    _createClass(FilterOptionsComponent, [{
      key: "setState",
      value: function setState(data) {
        var options = this.config.options;

        if (this.config.showMore && !this.allShown) {
          options = this.config.options.slice(0, this.config.showMoreLimit);
        }

        var selectedCount = this.config.getSelectedCount();

        _get(_getPrototypeOf(FilterOptionsComponent.prototype), "setState", this).call(this, Object.assign({}, data, _objectSpread({
          name: this.name.toLowerCase()
        }, this.config, {
          showReset: this.config.showReset && selectedCount > 0,
          expanded: this.expanded,
          allShown: this.allShown,
          selectedCount: selectedCount,
          isSingleOption: this.config.control === 'singleoption',
          options: options
        })));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        DOM.delegate(DOM.query(this._container, ".yxt-FilterOptions-options"), this.config.optionSelector, 'click', function (event) {
          _this2._updateOption(parseInt(event.target.dataset.index), event.target.checked);
        });
        var selectedCount = this.config.getSelectedCount(); // reset button

        if (this.config.showReset && selectedCount > 0) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-reset'), 'click', this.clearOptions.bind(this));
        } // show more/less button


        if (this.config.showMore) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-showToggle'), 'click', function () {
            _this2.allShown = !_this2.allShown;

            _this2.setState();
          });
        } // expand button


        if (this.config.showExpand) {
          var legend = DOM.query(this._container, '.yxt-FilterOptions-clickableLegend');
          DOM.on(legend, 'mousedown', function (click) {
            if (click.button === 0) {
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
          DOM.on(legend, 'keydown', function (key) {
            if (key.key === ' ' || key.key === 'Enter') {
              key.preventDefault();
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
        }
      }
    }, {
      key: "clearOptions",
      value: function clearOptions() {
        this.config.options = this.config.options.map(function (o) {
          return Object.assign({}, o, {
            selected: false
          });
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "updateListeners",
      value: function updateListeners() {
        var filter = this._buildFilter();

        if (this.config.storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.config.onChange(filter);
      }
    }, {
      key: "_updateOption",
      value: function _updateOption(index, selected) {
        if (this.config.control === 'singleoption') {
          this.config.options = this.config.options.map(function (o) {
            return Object.assign({}, o, {
              selected: false
            });
          });
        }

        this.config.options[index] = Object.assign({}, this.config.options[index], {
          selected: selected
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Clear all options
       */

    }, {
      key: "clear",
      value: function clear() {
        var elements = DOM.queryAll(this._container, this.config.optionSelector);
        elements.forEach(function (e) {
          return e.setAttribute('checked', 'false');
        });

        this._applyFilter();
      }
      /**
       * Build and return the Filter that represents the current state
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        var filters = this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.filter ? o.filter : Filter.equal(o.field, o.value);
        });
        this.core.persistentStorage.set(this.name, this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.label;
        }));
        return filters.length > 0 ? Filter.group.apply(Filter, _toConsumableArray(filters)) : {};
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render, based on the control
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return "controls/filteroptions";
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterOptions';
      }
    }]);

    return FilterOptionsComponent;
  }(Component);

  var RangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(RangeFilterComponent, _Component);

    function RangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, RangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeFilterComponent).call(this, config, systemConfig));
      /**
       * The field to filter on
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The callback function to call when the filter value changes
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;

      var minVal = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      if (typeof minVal === 'string') {
        try {
          minVal = Number.parseInt(minVal);
        } catch (e) {}
      }

      var maxVal = _this.core.globalStorage.getState("".concat(_this.name, ".max"));

      if (typeof minVal === 'string') {
        try {
          maxVal = Number.parseInt(maxVal);
        } catch (e) {}
      }
      /**
       * The current range represented
       * @type {object}
       * @private
       */


      _this._range = {
        min: minVal || config.initialMin || 0,
        max: maxVal || config.initialMax || 10
      };
      /**
       * The title to display for the range control
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to display for the min input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to display for the max input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The template to render
       * @type {string}
       * @private
       */

      _this._templateName = "controls/range";
      return _this;
    }

    _createClass(RangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(RangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          minValue: this._range.min,
          maxValue: this._range.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-range', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, Number.parseInt(event.target.value));
        });
      }
    }, {
      key: "setMin",
      value: function setMin(value) {
        this._updateRange('min', value);
      }
    }, {
      key: "setMax",
      value: function setMax(value) {
        this._updateRange('max', value);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Update the current range state
       * @param {string} key The range key to update
       * @param {number} value The new value for the key
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._range = Object.assign({}, this._range, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._range.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._range.max);

        this._onChange(filter);
      }
      /**
       * Build the filter representation of the current state
       * @returns {Filter}
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        return Filter.inclusiveRange(this._field, this._range.min, this._range.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RangeFilter';
      }
    }]);

    return RangeFilterComponent;
  }(Component);

  /**
   * A filter for a range of dates
   */

  var DateRangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DateRangeFilterComponent, _Component);

    function DateRangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DateRangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DateRangeFilterComponent).call(this, config, systemConfig));
      /**
       * The api field this filter controls
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The title to display for the date range
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to show for the min date input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to show for the max date input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The callback used when a date is changed
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
      /**
       * If true, this filter represents an exclusive range, rather than an inclusive one
       * @type {boolean}
       * @private
       */

      _this._isExclusive = config.isExclusive;
      /**
       * The template for this component
       * @private
       */

      _this._templateName = "controls/date";
      var today = new Date();
      var todayString = "".concat(today.getFullYear(), "-").concat("".concat(today.getMonth() + 1).padStart(2, '0'), "-").concat("".concat(today.getDate()).padStart(2, '0'));

      var minDate = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      var maxDate = _this.core.globalStorage.getState("".concat(_this.name, ".max"));
      /**
       * The current date range
       * @private
       */


      _this._date = {
        min: minDate || config.initialMin || todayString,
        max: maxDate || config.initialMax || todayString
      };
      return _this;
    }

    _createClass(DateRangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(DateRangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          dateMin: this._date.min,
          dateMax: this._date.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-date', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, event.target.value);
        });
      }
      /**
       * Set the min date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMin",
      value: function setMin(date) {
        this._updateRange('min', date);
      }
      /**
       * Set the max date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMax",
      value: function setMax(date) {
        this._updateRange('max', date);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Updates the current state of the date range
       * @param {string} key The key for the date value
       * @param {string} value The string date value
       * @private
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._date = Object.assign({}, this._date, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._date.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._date.max);

        this._onChange(filter);
      }
      /**
       * Construct an api filter with the current date state
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        if (this._date.min === '' || this._date.max === '') {
          return {};
        }

        return this._isExclusive ? Filter.exclusiveRange(this._field, this._date.min, this._date.max) : Filter.inclusiveRange(this._field, this._date.min, this._date.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'DateRangeFilter';
      }
    }]);

    return DateRangeFilterComponent;
  }(Component);

  var FacetsConfig =
  /*#__PURE__*/
  function () {
    function FacetsConfig(config) {
      _classCallCheck(this, FacetsConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFacet = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFacetLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFacets = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFacetsLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The controls to use for each field. Each type of filter has a default
       * $eq : multioption (checkbox)
       * @type {Object}
       */

      this.fieldControls = config.fieldControls || {};
      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      this.applyButtonSelector = config.applyButtonSelector || null;
      this.validate();
    }

    _createClass(FacetsConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FacetsConfig;
  }();
  /**
   * Displays a set of dynamic filters returned from the backend
   * @extends Component
   */


  var FacetsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FacetsComponent, _Component);

    function FacetsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FacetsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FacetsComponent).call(this, config, systemConfig));
      _this.config = new FacetsConfig(config);
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */

      _this._verticalKey = config.verticalKey; // config.verticalKey || null;

      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      _this._applyButtonSelector = config.applyButtonSelector || null;
      /**
       * An internal reference for the data storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
      /**
       * The filter box that displays the dynamic filters
       * @type {FilterBoxComponent}
       * @private
       */

      _this._filterbox = null;
      return _this;
    }

    _createClass(FacetsComponent, [{
      key: "remove",
      value: function remove() {
        if (this._filterbox) {
          this._filterbox.remove();
        }

        _get(_getPrototypeOf(FacetsComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this.core.enableDynamicFilters();

        if (this._filterbox) {
          this._filterbox.remove();
        }

        var _this$_state$get = this._state.get(),
            filters = _this$_state$get.filters;

        if (!filters) {
          return;
        }

        filters = filters.map(function (f) {
          return Object.assign({}, f, {
            type: 'FilterOptions',
            control: _this2.config.fieldControls[f.fieldId] || 'multioption'
          });
        });
        this._filterbox = this.componentManager.create('FilterBox', Object.assign({}, this.config, {
          parentContainer: this._container,
          name: "".concat(this.name, ".filterbox"),
          container: '.js-yxt-Facets',
          verticalKey: this._verticalKey,
          resetFilter: this.config.resetFacet,
          resetFilters: this.config.resetFacets,
          resetFilterLabel: this.config.resetFacetLabel,
          resetFiltersLabel: this.config.resetFacetsLabel,
          isDynamic: true,
          filters: filters
        }));

        this._filterbox.mount();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'filters/facets';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Facets';
      }
    }]);

    return FacetsComponent;
  }(Component);

  var METERS_PER_MILE = 1609.344;
  var DEFAULT_CONFIG = {
    /**
     * The radius, in miles, around the user's location to find results.
     * If location accuracy is low, a larger radius may be used automatically
     * @type {number}
     */
    radius: 50,

    /**
     * The vertical key to use
     * @type {string}
     */
    verticalKey: null,

    /**
     * If true, submits a search when the value is changed
     * @type {boolean}
     */
    searchOnChange: false,

    /**
     * The title to display
     * @type {string}
     */
    title: 'Location',

    /**
     * The label to display
     * @type {string}
     */
    label: 'Location',

    /**
     * The icon url to show in the geo button
     * @type {string}
     */
    geoButtonIcon: '',

    /**
     * The text to show in the geo button
     * @type {string}
     */
    geoButtonText: 'Use My Location',

    /**
     * The text to show when geolocation is enabled
     * @type {string}
     */
    enabledText: 'Current Location',

    /**
     * The text to show when loading the user's location
     * @type {string}
     */
    loadingText: 'Finding Your Location...',

    /**
     * The text to show if the user's location cannot be found
     * @type {string}
     */
    errorText: 'Could Not Find Your Location',

    /**
     * The CSS selector of the toggle button
     * @type {string}
     */
    buttonSelector: '.js-yxt-GeoLocationFilter-button',

    /**
     * The CSS selector of the query input
     * @type {string}
     */
    inputSelector: '.js-yxt-GeoLocationFilter-input'
  };
  /**
   * Renders a button that when clicked adds a static filter representing the user's location
   * @extends Component
   */

  var GeoLocationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(GeoLocationComponent, _Component);

    function GeoLocationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, GeoLocationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GeoLocationComponent).call(this, _objectSpread({}, DEFAULT_CONFIG, {}, config), systemConfig));
      /**
       * The query string to use for the input box, provided to template for rendering.
       * @type {string}
       */

      _this.query = _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.setState();
      });
      /**
       * The filter to use for the current query
       * @type {Filter}
       */


      _this.filter = _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || {};

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      _this.searchParameters = buildSearchParameters(config.searchParameters);
      return _this;
    }

    _createClass(GeoLocationComponent, [{
      key: "setState",
      value: function setState(data) {
        var placeholder = '';

        if (this._enabled) {
          placeholder = this._config.enabledText;
        }

        if (data.geoLoading) {
          placeholder = this._config.loadingText;
        }

        if (data.geoError) {
          placeholder = this._config.errorText;
        }

        _get(_getPrototypeOf(GeoLocationComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          title: this._config.title,
          geoEnabled: this._enabled,
          query: this.query,
          labelText: this._config.label,
          enabledText: this._config.enabledText,
          loadingText: this._config.loadingText,
          errorText: this._config.errorText,
          geoButtonIcon: this._config.geoButtonIcon,
          geoValue: this._enabled || data.geoLoading || data.geoError ? '' : this.query,
          geoPlaceholder: placeholder,
          geoButtonText: this._config.geoButtonText
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._initAutoComplete(this._config.inputSelector);

        DOM.on(this._config.buttonSelector, 'click', function () {
          return _this2._toggleGeoFilter();
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       * @private
       */

    }, {
      key: "_initAutoComplete",
      value: function _initAutoComplete(inputSelector) {
        var _this3 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.js-yxt-GeoLocationFilter-autocomplete',
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._config.verticalKey,
          searchParameters: this.searchParameters,
          onSubmit: function onSubmit(query, filter) {
            _this3.query = query;
            _this3.filter = Filter.fromResponse(filter);

            _this3._saveDataToStorage(query, _this3.filter);

            _this3._enabled = false;
          }
        });
      }
      /**
       * Toggles the static filter representing the user's location
       * @private
       */

    }, {
      key: "_toggleGeoFilter",
      value: function _toggleGeoFilter() {
        var _this4 = this;

        if (!navigator.geolocation) {
          this.setState({
            geoError: true
          });
          return;
        }

        if (!this._enabled) {
          this.setState({
            geoLoading: true
          });
          navigator.geolocation.getCurrentPosition(function (position) {
            var filter = _this4._buildFilter(position);

            _this4._saveDataToStorage('', filter, position);

            _this4._enabled = true;

            _this4.setState({});

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.QUERY, ".").concat(_this4.name));

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.FILTER, ".").concat(_this4.name));
          }, function () {
            return _this4.setState({
              geoError: true
            });
          });
        }
      }
      /**
       * Saves the provided filter under this component's name
       * @param {string} query The query to save
       * @param {Filter} filter The filter to save
       * @param {Object} position The position to save
       * @private
       */

    }, {
      key: "_saveDataToStorage",
      value: function _saveDataToStorage(query, filter, position) {
        this.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(this.name), query);
        this.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(this.name), filter);
        this.core.setFilter(this.name, filter);

        if (position) {
          this.core.globalStorage.set(StorageKeys.GEOLOCATION, {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            radius: position.coords.accuracy
          });
        }

        if (this._config.searchOnChange) {
          var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = filters[0];

          if (filters.length > 1) {
            totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
          }

          var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.verticalSearch(this._config.verticalKey, {
            input: searchQuery,
            filter: JSON.stringify(totalFilter),
            facetFilter: JSON.stringify(facetFilter)
          });
        }
      }
      /**
       * Given a position, construct a Filter object
       * @param {Postition} position The position
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter(position) {
        var _position$coords = position.coords,
            latitude = _position$coords.latitude,
            longitude = _position$coords.longitude,
            accuracy = _position$coords.accuracy;
        var radius = Math.max(accuracy, this._config.radius * METERS_PER_MILE);
        return Filter.position(latitude, longitude, radius);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'controls/geolocation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'GeoLocationFilter';
      }
    }]);

    return GeoLocationComponent;
  }(Component);

  /**
   * Renders configuration options for sorting Vertical Results.
   * TODO: how to deal with multiple instances of this component (and filters in general),
   * ideally "identical" filters/sorts would be synced up.
   */

  var SortOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SortOptionsComponent, _Component);

    function SortOptionsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SortOptionsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SortOptionsComponent).call(this, assignDefaults(config), systemConfig));
      _this.options = _this._config.options;
      _this.selectedOptionIndex = parseInt(_this.core.globalStorage.getState(_this.name)) || 0;
      _this.options[_this.selectedOptionIndex].isSelected = true;
      _this.hideExcessOptions = _this._config.showMore && _this.selectedOptionIndex <= _this._config.showMoreLimit;
      _this.showReset = _this._config.showReset && _this.selectedOptionIndex !== 0;
      return _this;
    }

    _createClass(SortOptionsComponent, [{
      key: "setState",
      value: function setState(data) {
        var options = this.options;

        if (this.hideExcessOptions) {
          options = this.options.slice(0, this._config.showMoreLimit);
        }

        _get(_getPrototypeOf(SortOptionsComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          options: options,
          hideExcessOptions: this.hideExcessOptions,
          name: this.name,
          showReset: this.showReset
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        // Handle radio button selections
        DOM.on(DOM.query(this._container, '.yxt-SortOptions-fieldSet'), 'change', function (evt) {
          return _this2.handleOptionSelection(parseInt(evt.target.value));
        }); // Register more/less button

        if (this._config.showMore) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-showToggle'), 'click', function () {
            _this2.hideExcessOptions = !_this2.hideExcessOptions;

            _this2.setState();
          });
        } // Register show reset button


        if (this.showReset) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-reset'), 'click', function () {
            return _this2.handleOptionSelection(0);
          });
        } // Register apply button


        if (!this._config.searchOnChange) {
          DOM.on(DOM.query(this._container, '.yxt-SortOptions-apply'), 'click', function () {
            return _this2._sortResults();
          });
        }
      }
    }, {
      key: "handleOptionSelection",
      value: function handleOptionSelection(optionIndex) {
        this._updateSelectedOption(optionIndex);

        if (this._config.searchOnChange) {
          this._sortResults();
        }
      }
    }, {
      key: "_updateSelectedOption",
      value: function _updateSelectedOption(optionIndex) {
        this.options[this.selectedOptionIndex].isSelected = false;
        this.options[optionIndex].isSelected = true;
        this.selectedOptionIndex = optionIndex;
        this.showReset = this._config.showReset && optionIndex !== 0;
        this.setState();
      }
    }, {
      key: "_sortResults",
      value: function _sortResults() {
        var optionIndex = this.selectedOptionIndex;
        var option = this.options[optionIndex]; // searchOnChange really means sort on change here, just that the sort is done through a search,
        // This was done to have a consistent option name between filters.

        this.core.persistentStorage.set(this.name, optionIndex);

        if (this._config.storeOnChange && optionIndex === 0) {
          this.core.clearSortBys();
        } else if (this._config.storeOnChange) {
          this.core.setSortBys(option);
        }

        this._search();

        this._config.onChange(option);

        this.setState();
      }
      /**
       * Trigger a search with all filters in storage
       */

    }, {
      key: "_search",
      value: function _search() {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var input = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._config.verticalKey, {
          input: input,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'controls/sortoptions';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SortOptions';
      }
    }]);

    return SortOptionsComponent;
  }(Component);

  function assignDefaults(config) {
    var updatedConfig = Object.assign({}, config); // Optional, The label used for the default sort (aka the sort specified by the experience config").

    updatedConfig.defaultSortLabel = config.defaultSortLabel || 'Best Match'; // Array of search options, where an option has type, label, and if is type FIELD also a label and direction

    if (!config.options) {
      throw new AnswersBasicError('config.options are required', 'SortOptions');
    }

    var OPTION_TYPES = ['FIELD', 'RELEVANCE', 'ENTITY_DISTANCE'];

    if (!Array.isArray(config.options)) {
      throw new AnswersBasicError('options must be an array of objects', 'SortOptions');
    }

    updatedConfig.options = config.options.map(function (option) {
      if (!option.label || !option.type) {
        throw new AnswersBasicError("option.label and option.type are required option ".concat(option), 'SortOptions');
      }

      var newOption = {
        isSelected: false
      };
      newOption.label = option.label;
      newOption.type = option.type;
      var isField = OPTION_TYPES.indexOf(newOption.type) === 0;

      if (isField && option.field && option.direction) {
        newOption.field = option.field;
        newOption.direction = option.direction;
      } else if (isField) {
        throw new AnswersBasicError("option.field and option.direction are required for option: ".concat(option), 'SortOptions');
      }

      return newOption;
    }); // Add default option to the front of the options array

    updatedConfig.options.unshift({
      label: updatedConfig.defaultSortLabel,
      isSelected: false
    }); // Optional, the selector used for options in the template

    updatedConfig.optionSelector = config.optionSelector || 'yxt-SortOptions-optionSelector'; // Optional, if true, triggers a search on each change to a filter,
    // if false the component also renders an apply button, defaults to false

    updatedConfig.searchOnChange = config.searchOnChange === undefined ? true : config.searchOnChange; // Optional, show a reset button. Clicking it will always return the user to the default sorting option.

    updatedConfig.showReset = config.showReset || false; // Optional, the label to use for the reset button

    updatedConfig.resetLabel = config.resetLabel || 'reset'; // Optional, the max number of filter options to show before collapsing extras

    updatedConfig.showMoreLimit = config.showMoreLimit || 5; // Optional, allow collapsing excess sort options after a limit

    updatedConfig.showMore = config.showMore === undefined ? true : config.showMore;
    updatedConfig.showMore = updatedConfig.showMore && updatedConfig.options.length > updatedConfig.showMoreLimit; // Optional, the label to show for displaying more options

    updatedConfig.showMoreLabel = config.showMoreLabel || 'Show more'; // Optional, the label to show for displaying less options

    updatedConfig.showLessLabel = config.showLessLabel || 'Show less'; // Optional, the callback function to call when changed

    updatedConfig.onChange = config.onChange || function () {}; // Optional, Top title for the sorting component


    updatedConfig.label = config.label || 'Sorting'; // Optional, when true component does not update globalStorage
    // possibly delegating that to a higher-order/composite component

    updatedConfig.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
    updatedConfig.applyLabel = config.applyLabel || 'Apply';
    updatedConfig.verticalKey = config.verticalKey || this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

    if (!updatedConfig.verticalKey) {
      throw new AnswersBasicError('vertical key is required', 'SortOptions');
    } // note: showExpand and showNumberApplied explicitly not included, on the grounds that
    // sorting should always be exposed to the user if added.


    return updatedConfig;
  }

  /**
   * EventTypes are explicit strings defined
   * for what the server expects for analytics.
   *
   * @enum
   */

  var EventTypes = {
    THUMBS_UP: 'THUMBS_UP',
    THUMBS_DOWN: 'THUMBS_DOWN'
  };

  var DirectAnswerComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DirectAnswerComponent, _Component);

    function DirectAnswerComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DirectAnswerComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectAnswerComponent).call(this, config, systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.DIRECT_ANSWER;
      /**
       * The form used for submitting the feedback
       * @type {string}
       */

      _this._formEl = config.formEl || '.js-directAnswer-feedback-form';
      /**
       * The `thumbs up` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsUpSelector = config.thumbsUpSelector || '.js-directAnswer-thumbUp';
      /**
       * The `thumbs down` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsDownSelector = config.thumbsDownSelector || '.js-directAnswer-thumbDown';
      /**
       * The display text for the View Details click to action link
       * @type {string}
       */

      _this._viewDetailsText = config.viewDetailsText || 'View Details';
      return _this;
    }

    _createClass(DirectAnswerComponent, [{
      key: "beforeMount",

      /**
       * beforeMount, only display the direct answer component if it has data
       */
      value: function beforeMount() {
        if (!this.hasState('answer')) {
          return false;
        }

        return true;
      }
      /**
       * When the DOM is constructed,
       * we want to wire up the behavior for interacting with the quality feedback reporting (thumbsup/down)
       */

    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        // Avoid bindings if the feedback has previously been submitted
        if (this.getState('feedbackSubmitted') === true) {
          return this;
        } // For WCAG compliance, the feedback should be a submittable form


        DOM.on(this._formEl, 'submit', function (e) {
          var formEl = e.target;
          var checkedValue = DOM.query(formEl, 'input:checked').value === 'true';

          _this2.reportQuality(checkedValue);

          _this2.updateState({
            'feedbackSubmitted': true
          });
        }); // Is this actually necessary? I guess it's only necessary if the
        // submit button is hidden.

        DOM.on(this._thumbsUpSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
        DOM.on(this._thumbsDownSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
      }
      /**
       * updateState enables for partial updates (the delta between the old and new)
       * @type {object} The new state to apply to the old
       */

    }, {
      key: "updateState",
      value: function updateState() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var newState = Object.assign({}, this.getState(), state);
        this.setState(newState);
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(DirectAnswerComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          eventOptions: this.eventOptions(data),
          viewDetailsText: this._viewDetailsText
        }));
      }
    }, {
      key: "eventOptions",
      value: function eventOptions(data) {
        if (!data || Object.keys(data).length === 0) {
          return data;
        }

        return JSON.stringify({
          verticalConfigId: data.relatedItem.verticalConfigId,
          searcher: 'UNIVERSAL',
          entityId: data.relatedItem.data.id,
          ctaLabel: this._viewDetailsText.toUpperCase().replace(' ', '_')
        });
      }
      /**
       * reportQuality will send the quality feedback to analytics
       * @param {boolean} isGood true if the answer is what you were looking for
       */

    }, {
      key: "reportQuality",
      value: function reportQuality(isGood) {
        var eventType = isGood === true ? EventTypes.THUMBS_UP : EventTypes.THUMBS_DOWN;
        var event = new AnalyticsEvent(eventType).addOptions({
          'directAnswer': true
        });
        this.analyticsReporter.report(event);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/directanswer';
      }
    }, {
      key: "type",
      get: function get() {
        return 'DirectAnswer';
      }
    }]);

    return DirectAnswerComponent;
  }(Component);

  var ResultsItemComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ResultsItemComponent, _Component);

    function ResultsItemComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ResultsItemComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultsItemComponent).call(this, opts, systemConfig));
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = opts.verticalConfigId;
      /**
       * isUniversal is used for analytics and passed to children and is set to
       * true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = opts.isUniversal || false;
      return _this;
    }

    _createClass(ResultsItemComponent, [{
      key: "eventOptions",

      /**
       * helper to construct the eventOptions object for the title link
       * @param entityId The ID of the result item, if present
       * @param url The url of the result item, if present
       * @returns {string}
       */
      value: function eventOptions(entityId, url) {
        var options = {
          verticalConfigId: this._verticalConfigId,
          searcher: this._isUniversal ? 'UNIVERSAL' : 'VERTICAL'
        };

        if (entityId) {
          options.entityId = entityId;
        } else {
          options.url = url;
        }

        return JSON.stringify(options);
      }
      /**
       * passes eventOptions to the viewModel
       * @override
       * @param data
       * @returns {ResultsItemComponent}
       */

    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(ResultsItemComponent.prototype), "setState", this).call(this, Object.assign(data, {
          eventOptions: this.eventOptions(data.id, data.link)
        }));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'ResultsItemComponent';
      }
    }]);

    return ResultsItemComponent;
  }(Component);

  var LocationResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(LocationResultsItemComponent, _ResultsItemComponent);

    function LocationResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LocationResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(LocationResultsItemComponent).call(this, opts, systemConfig));
    }

    _createClass(LocationResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/locationresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'LocationResultsItemComponent';
      }
    }]);

    return LocationResultsItemComponent;
  }(ResultsItemComponent);

  var EventResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(EventResultsItemComponent, _ResultsItemComponent);

    function EventResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, EventResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(EventResultsItemComponent).call(this, opts, systemConfig));
    }

    _createClass(EventResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/eventresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'EventResultsItemComponent';
      }
    }]);

    return EventResultsItemComponent;
  }(ResultsItemComponent);

  var PeopleResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(PeopleResultsItemComponent, _ResultsItemComponent);

    function PeopleResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PeopleResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(PeopleResultsItemComponent).call(this, opts, systemOpts));
    }

    _createClass(PeopleResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/peopleresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'PeopleResultsItemComponent';
      }
    }]);

    return PeopleResultsItemComponent;
  }(ResultsItemComponent);

  /** @module MapProvider */

  /**
   * A MapProvider is an interface that represents that should be implemented
   * in order to integrate with a Third Party Map provider for
   * interactive maps. MapProviders are used by the MapComponent.
   *
   * Implementations should extend this interface.
   */
  var MapProvider =
  /*#__PURE__*/
  function () {
    function MapProvider() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MapProvider);

      /**
       * The API Key used for interacting with the map provider
       * @type {string}
       */
      this._apiKey = config.apiKey;
      /**
       * The zoom level of the map, defaults to 14
       * @type {number}
       */

      this._zoom = config.zoom || 14;
      /**
       * The default coordinates to display if there are no results returned
       * Only used if showEmptyMap is set to true
       * @type {Object}
       */

      this._defaultPosition = config.defaultPosition || {
        lat: 37.0902,
        lng: -95.7129
      };
      /**
       * Determines if an empty map should be shown when there are no results
       * @type {boolean}
       */

      this._showEmptyMap = config.showEmptyMap || false;
      /**
       * A reference to the underlying map instance, created by the external lib.
       * @type {number}
       */

      this._map = null;
      /**
       * Temporary boolean tracking whether or not the external JS library is loaded (see TODO below)
       * @type {boolean}
       */

      this._isLoaded = false;
      /**
       * Callback to invoke when a pin is clicked. The clicked item(s) are passed to the callback
       * @type {function}
       */

      this._onPinClick = config.onPinClick || null;
      /**
       * Callback to invoke once the Javascript is loaded
       * @type {function}
       */

      this._onLoaded = config.onLoaded || function () {};
      /**
       * The custom configuration override to use for the map markers
       * @type {Object|Function}
       */


      this._pinConfig = typeof config.pin === 'function' ? config.pin : Object.assign(MapProvider.DEFAULT_PIN_CONFIG, config.pin);
      /**
       * Determines whether or not to collapse pins at the same lat/lng
       * @type {boolean}
       */

      this._collapsePins = config.collapsePins || false;
    }
    /**
     * The default configuration to use for the map markers
     * @type {Object}
     * TODO(billy) Create a configuration model
     */


    _createClass(MapProvider, [{
      key: "onLoaded",
      value: function onLoaded(cb) {
        if (typeof cb !== 'function') {
          return;
        }

        this._onLoaded = cb;

        if (this.isLoaded()) {
          this._onLoaded();
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return this._isLoaded;
      }
    }, {
      key: "loadJS",
      value: function loadJS() {
        throw new Error('Unimplemented Method: loadJS');
      }
    }, {
      key: "init",
      value: function init(mapData) {
        // TODO(billy) This should be based off a promise that gets created from loadJS
        throw new Error('Unimplemented Method: init');
      }
      /**
       * Given a list of markers, combine markers with the same lat/lng into a single marker
       * @param {object[]} markers The markers to collapse
       */

    }, {
      key: "_collapseMarkers",
      value: function _collapseMarkers(markers) {
        var locationToItem = {};
        markers.forEach(function (m) {
          locationToItem["".concat(m.latitude).concat(m.longitude)] ? locationToItem["".concat(m.latitude).concat(m.longitude)].push(m) : locationToItem["".concat(m.latitude).concat(m.longitude)] = [m];
        });
        var collapsedMarkers = [];

        for (var _i = 0, _Object$entries = Object.entries(locationToItem); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              _markers = _Object$entries$_i[1];

          if (_markers.length > 1) {
            var collapsedMarker = {
              item: _markers.map(function (m) {
                return m.item;
              }),
              label: _markers.length,
              latitude: _markers[0].latitude,
              longitude: _markers[0].longitude
            };
            collapsedMarkers.push(collapsedMarker);
          } else {
            collapsedMarkers.push(_markers[0]);
          }
        }

        return collapsedMarkers;
      }
    }], [{
      key: "DEFAULT_PIN_CONFIG",
      get: function get() {
        return {
          icon: {
            anchor: null,
            // e.g. { x: 1, y: 1 }
            svg: null,
            url: null,
            scaledSize: null // e.g. { w: 20, h: 20 }

          },
          labelType: 'numeric'
        };
      }
    }]);

    return MapProvider;
  }();

  /* global google */

  /**
   * GoogleMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var GoogleMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(GoogleMapProvider, _MapProvider);

    function GoogleMapProvider(opts) {
      var _this;

      _classCallCheck(this, GoogleMapProvider);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GoogleMapProvider).call(this, opts)); // normalize because google's zoom is effectively 1 unit of difference away from mapbox zoom

      _this._zoomOffset = 1;
      _this._zoom += _this._zoomOffset;
      _this._clientId = opts.clientId;
      _this._signature = opts.signature;

      if (!_this.hasValidClientCredentials() && !_this._apiKey) {
        throw new Error('GoogleMapsProvider: Missing `apiKey` or {`clientId`, `signature`}');
      }

      return _this;
    }

    _createClass(GoogleMapProvider, [{
      key: "loadJS",
      value: function loadJS(onLoad) {
        var _this2 = this;

        if (DOM.query('#yext-map-js')) {
          this._isLoaded = true;

          if (typeof onLoad === 'function') {
            onLoad();
          }

          return;
        }

        var script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            _this2._isLoaded = true;

            _this2._onLoaded();
          },
          async: true,
          src: "https://maps.googleapis.com/maps/api/js?".concat(this.generateCredentials())
        });
        DOM.append('body', script);
      }
    }, {
      key: "generateCredentials",
      value: function generateCredentials() {
        if (this.hasValidClientCredentials()) {
          return "client=".concat(this._clientId);
        } else {
          return "key=".concat(this._apiKey);
        }
      }
    }, {
      key: "hasValidClientCredentials",
      value: function hasValidClientCredentials() {
        return this._clientId;
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this3 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        } // NOTE(billy) This timeout is a hack for dealing with async nature.
        // Only here for demo purposes, so we'll fix later.


        setTimeout(function () {
          var container = DOM.query(el);
          _this3.map = new google.maps.Map(container, {
            zoom: _this3._zoom,
            center: _this3.getCenterMarker(mapData)
          }); // Apply our search data to our GoogleMap

          if (mapData && mapData.mapMarkers.length) {
            (function () {
              var collapsedMarkers = _this3._collapsePins ? _this3._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
              var googleMapMarkerConfigs = GoogleMapMarkerConfig.from(collapsedMarkers, _this3._pinConfig, _this3.map);
              var bounds = new google.maps.LatLngBounds();

              var _loop = function _loop(i) {
                var marker = new google.maps.Marker(googleMapMarkerConfigs[i]);

                if (_this3._onPinClick) {
                  marker.addListener('click', function () {
                    return _this3._onPinClick(collapsedMarkers[i].item);
                  });
                }

                bounds.extend(marker.position);
              };

              for (var i = 0; i < googleMapMarkerConfigs.length; i++) {
                _loop(i);
              }

              if (googleMapMarkerConfigs.length >= 2) {
                _this3.map.fitBounds(bounds);
              }
            })();
          }
        }, 100);
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? {
          lng: mapData.mapCenter.longitude,
          lat: mapData.mapCenter.latitude
        } : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return GoogleMapProvider;
  }(MapProvider); // TODO(billy) Move to own class
  var GoogleMapMarkerConfig =
  /*#__PURE__*/
  function () {
    function GoogleMapMarkerConfig(opts) {
      _classCallCheck(this, GoogleMapMarkerConfig);

      /**
       * A reference to the google map, that the marker is appended to
       * @type {GoogleMap}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        lat: undefined,
        lng: undefined
      };
      /**
       * The properties/settings of the icon used for the marker
       * e.g. {
       *        anchor: { x: 0, y: 0 }
       *        url: 'path/to/url.jpg'
       *        scaledSize: { w: 0, h: 0 }
       *       }
       *
       * @type {object}
       */

      this.icon = opts.icon || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {GoogleMapMarkerConfig[]} googleMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(GoogleMapMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(googleMapMarkerConfigs) {
        var serializedMarkers = [];
        googleMapMarkerConfigs.forEach(function (marker) {
          serializedMarkers.push("markers=label:".concat(marker.label, "|").concat(marker.position.lat, ",").concat(marker.position.lng));
        });
        return serializedMarkers.join('&');
      }
      /**
       * Converts the storage data model of markers into GoogleAPIMarker
       * @param {object[]} markers The data of the marker
       * @param {(Object|function)} pinConfig The configuration to apply to the marker
       * @param {GoogleMap} map reference to the google map to apply the marker to
       * @returns {GoogleMapMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var googleMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          } // Transform our Configuration Object into the expected
          // Google API format.


          var icon = {};

          if (pinConfigObj.anchor) {
            icon.anchor = google.maps.Point(pinConfigObj.anchor.x, pinConfigObj.anchor.y);
          }

          if (pinConfigObj.scaledSize) {
            icon.scaledSize = new google.maps.Size(pinConfigObj.scaledSize.w, pinConfigObj.scaledSize.h);
          }

          if (pinConfigObj.url) {
            icon.url = pinConfigObj.url;
          }

          if (pinConfigObj.svg) {
            icon.url = "data:image/svg+xml;charset=utf-8, ".concat(encodeURIComponent(pinConfigObj.svg));
          }

          var label;

          if (pinConfigObj.label) {
            label = pinConfigObj.label;
          } else {
            label = marker.label.toString();
          } // NOTE(billy) Google maps doesn't handle empty icon objects nicely
          // Make google maps happy if no settings for icon are provided;


          if (Object.keys(icon).length === 0) {
            icon = undefined;
          }

          googleMapMarkerConfigs.push(new GoogleMapMarkerConfig({
            map: map,
            position: {
              lat: marker.latitude,
              lng: marker.longitude
            },
            icon: icon,
            label: label
          }));
        });
        return googleMapMarkerConfigs;
      }
    }]);

    return GoogleMapMarkerConfig;
  }();

  /* global mapboxgl */

  /**
   * MapBoxMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var MapBoxMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(MapBoxMapProvider, _MapProvider);

    function MapBoxMapProvider() {
      _classCallCheck(this, MapBoxMapProvider);

      return _possibleConstructorReturn(this, _getPrototypeOf(MapBoxMapProvider).apply(this, arguments));
    }

    _createClass(MapBoxMapProvider, [{
      key: "loadJS",

      /**
       * Load the external JS Library
       * @param {function} onLoad An optional callback to invoke once the JS is loaded.
       */
      value: function loadJS(onLoad) {
        var _this = this;

        var script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            _this._isLoaded = true;
            mapboxgl.accessToken = _this._apiKey;

            if (typeof onLoad === 'function') {
              onLoad();
            }

            if (typeof _this._onLoaded === 'function') {
              _this._onLoaded();
            }
          },
          async: true,
          src: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'
        });
        var css = DOM.createEl('link', {
          id: 'yext-map-css',
          rel: 'stylesheet',
          href: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css'
        });
        DOM.append('body', css);
        DOM.append('body', script);
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this2 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        }

        var container = DOM.query(el);
        this._map = new mapboxgl.Map({
          container: container,
          zoom: this._zoom,
          style: 'mapbox://styles/mapbox/streets-v9',
          center: this.getCenterMarker(mapData)
        });

        if (mapData && mapData.mapMarkers.length) {
          (function () {
            var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
            var mapboxMapMarkerConfigs = MapBoxMarkerConfig.from(collapsedMarkers, _this2._pinConfig, _this2._map);
            var bounds = new mapboxgl.LngLatBounds();

            var _loop = function _loop(i) {
              var wrapper = mapboxMapMarkerConfigs[i].wrapper;
              var coords = new mapboxgl.LngLat(mapboxMapMarkerConfigs[i].position.longitude, mapboxMapMarkerConfigs[i].position.latitude);
              var marker = new mapboxgl.Marker(wrapper).setLngLat(coords);
              bounds.extend(marker.getLngLat());
              marker.addTo(_this2._map);

              if (_this2._onPinClick) {
                marker.getElement().addEventListener('click', function () {
                  return _this2._onPinClick(collapsedMarkers[i].item);
                });
              }
            };

            for (var i = 0; i < mapboxMapMarkerConfigs.length; i++) {
              _loop(i);
            }

            if (mapboxMapMarkerConfigs.length >= 2) {
              _this2._map.fitBounds(bounds, {
                padding: 50
              });
            }
          })();
        }
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? [mapData.mapCenter.longitude, mapData.mapCenter.latitude] : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return MapBoxMapProvider;
  }(MapProvider);
  var MapBoxMarkerConfig =
  /*#__PURE__*/
  function () {
    function MapBoxMarkerConfig(opts) {
      _classCallCheck(this, MapBoxMarkerConfig);

      /**
       * A reference to the mapbox map, that the marker is appended to
       * @type {MapBox}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        latitude: undefined,
        longitude: undefined
      };
      /**
       * The html element to be used as the map marker
       * @type {object}
       */

      this.wrapper = opts.wrapper || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
      /**
       * The url of the pin for the static map
       * @type {string}
       */

      this.staticMapPin = opts.staticMapPin || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {MapBoxMarkerConfig[]} mapboxMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(MapBoxMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(mapboxMapMarkerConfigs) {
        var serializedMarkers = [];
        mapboxMapMarkerConfigs.forEach(function (marker) {
          if (marker.staticMapPin) {
            serializedMarkers.push("url-".concat(marker.staticMapPin, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          } else {
            serializedMarkers.push("pin-s-".concat(marker.label, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          }
        });
        return serializedMarkers.join(',');
      }
      /**
       * Converts the storage data model of markers into MapBoxMarkerConfig
       * @param {MapBox} A reference to the mapbox map to apply the marker to
       * @param {object[]} markers The data of the marker
       * @param {Object} pinConfig The configuration to apply to the marker
       * @returns {MapBoxMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var mapboxMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          }

          var wrapper = pinConfigObj.wrapper ? pinConfigObj.wrapper : null;
          var staticMapPin = pinConfigObj.staticMapPin ? pinConfigObj.staticMapPin : null;
          mapboxMapMarkerConfigs.push(new MapBoxMarkerConfig({
            map: map,
            position: {
              latitude: marker.latitude,
              longitude: marker.longitude
            },
            wrapper: wrapper,
            label: marker.label,
            staticMapPin: staticMapPin
          }));
        });
        return mapboxMapMarkerConfigs;
      }
    }]);

    return MapBoxMarkerConfig;
  }();

  var ProviderTypes = {
    'google': GoogleMapProvider,
    'mapbox': MapBoxMapProvider
  };

  var MapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(MapComponent, _Component);

    function MapComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, MapComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapComponent).call(this, opts, systemOpts));
      /**
       * Bind this component to listen to the storage based on this key
       */

      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      /**
       * An aliased used to determine the type of map provider to use
       * @type {string}
       */

      _this._mapProvider = opts.mapProvider;

      if (!_this._mapProvider || !(_this._mapProvider.toLowerCase() in ProviderTypes)) {
        throw new Error('MapComponent: Invalid Map Provider; must be `google` or `mapBox`');
      }
      /**
       * A reference to an instance of the {MapProvider} that's constructed
       * @type {MapProvider}
       */


      _this._map = null;
      return _this;
    }

    _createClass(MapComponent, [{
      key: "getProviderInstance",
      // TODO(billy) Make ProviderTypes a factory class
      value: function getProviderInstance(type) {
        return new ProviderTypes[type.toLowerCase()](this._config);
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        this._map = this.getProviderInstance(this._mapProvider);

        this._map.loadJS();
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this._map.onLoaded(function () {
          _this2._map.init(_this2._container, _this2.getState('map'));
        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        if (Object.keys(data).length === 0) {
          return this;
        }

        return _get(_getPrototypeOf(MapComponent.prototype), "setState", this).call(this, data, val);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/map';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Map';
      }
    }]);

    return MapComponent;
  }(Component);

  var ResultType = {
    EVENT: 'event',
    LOCATION: 'location',
    PEOPLE: 'people'
  };

  var ResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ResultsComponent, _Component);

    function ResultsComponent() {
      var _this$_itemConfig;

      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultsComponent).call(this, config, systemConfig));
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = config.verticalConfigId;
      /**
       * isUniversal is set to true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = config.isUniversal || false;
      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      _this._itemConfig = (_this$_itemConfig = {
        global: {
          render: null,
          template: null
        }
      }, _defineProperty(_this$_itemConfig, EventResultsItemComponent.type, {
        render: null,
        template: null
      }), _defineProperty(_this$_itemConfig, LocationResultsItemComponent.type, {
        render: null,
        template: null
      }), _defineProperty(_this$_itemConfig, PeopleResultsItemComponent.type, {
        render: null,
        template: null
      }), _this$_itemConfig);

      if (config.renderItem === undefined && config._parentOpts !== undefined) {
        config.renderItem = config._parentOpts.renderItem;
      }

      if (config.itemTemplate === undefined && config._parentOpts !== undefined) {
        config.itemTemplate = config._parentOpts.itemTemplate;
      }

      _this.configureItem({
        render: config.renderItem,
        template: config.itemTemplate
      });
      /**
       * The url to the universal page for the no results page to link back to with current query
       * @type {string|null}
       */


      _this._universalUrl = config.universalUrl;
      return _this;
    }

    _createClass(ResultsComponent, [{
      key: "mount",
      value: function mount() {
        if (Object.keys(this.getState()).length > 0) {
          _get(_getPrototypeOf(ResultsComponent.prototype), "mount", this).call(this);
        }

        return this;
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        var results = data.results || [];
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        return _get(_getPrototypeOf(ResultsComponent.prototype), "setState", this).call(this, Object.assign({
          results: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          includeMap: this._config.includeMap,
          mapConfig: this._config.mapConfig,
          eventOptions: this.eventOptions(),
          universalUrl: this._universalUrl ? this._universalUrl + window.location.search : '',
          showNoResults: results.length === 0,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }), val);
      }
      /**
       * helper to construct the eventOptions object for the view all link
       * @returns {string}
       */

    }, {
      key: "eventOptions",
      value: function eventOptions() {
        return JSON.stringify({
          verticalConfigId: this._verticalConfigId
        });
      }
    }, {
      key: "configureItem",
      value: function configureItem(config) {
        if (typeof config.render === 'function') {
          this._itemConfig.global.render = config.render;
        } else {
          for (var key in config.render) {
            this.setItemRender(key, config.render[key]);
          }
        }

        if (typeof config.template === 'string') {
          this._itemConfig.global.template = config.template;
        } else {
          for (var _key in config.template) {
            this.setItemTemplate(_key, config.template[_key]);
          }
        }
      }
    }, {
      key: "setItemTemplate",
      value: function setItemTemplate(type, template) {
        var clazz = this.getItemComponent(type);
        this._itemConfig[clazz.type].template = template;
      }
    }, {
      key: "setItemRender",
      value: function setItemRender(type, render) {
        var clazz = this.getItemComponent(type);
        this._itemConfig[clazz.type].render = render;
      }
    }, {
      key: "getItemComponent",
      value: function getItemComponent(type) {
        var comp = ResultsItemComponent;

        switch (type) {
          case ResultType.EVENT:
            comp = EventResultsItemComponent;
            break;

          case ResultType.LOCATION:
            comp = LocationResultsItemComponent;
            break;

          case ResultType.PEOPLE:
            comp = PeopleResultsItemComponent;
            break;
        }

        return comp;
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        // TODO(billy) Refactor the way configuration and data flows
        // through top level components to child components.
        if (type === ResultsItemComponent.type) {
          var clazz = this.getItemComponent(data.type);

          if (clazz) {
            type = clazz.type;
          }
        } else if (type === MapComponent.type) {
          data = {
            map: data
          };
          var newOpts = Object.assign({}, this._config.mapConfig, opts);
          return _get(_getPrototypeOf(ResultsComponent.prototype), "addChild", this).call(this, data, type, newOpts);
        } // Apply the proper item renders to the the components
        // have just been constructed. Prioritize global over individual items.


        var comp = _get(_getPrototypeOf(ResultsComponent.prototype), "addChild", this).call(this, data, type, Object.assign(opts, {
          verticalConfigId: this._verticalConfigId,
          isUniversal: this._isUniversal
        }));

        var globalConfig = this._itemConfig.global;
        var itemConfig = this._itemConfig[comp.type];
        var hasGlobalRender = typeof globalConfig.render === 'function';
        var hasGlobalTemplate = typeof globalConfig.template === 'string';

        if (hasGlobalRender) {
          comp.setRender(globalConfig.render);
        }

        if (hasGlobalTemplate) {
          comp.setTemplate(globalConfig.template);
        }

        if (!itemConfig) {
          return comp;
        }

        if (!hasGlobalRender && itemConfig.render) {
          comp.setRender(itemConfig.render);
        } // Apply template specific situation


        if (!hasGlobalTemplate && itemConfig.template) {
          comp.setTemplate(itemConfig.template);
        }

        return comp;
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/results';
      }
    }, {
      key: "duplicatesAllowed",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'VerticalResults';
      }
    }]);

    return ResultsComponent;
  }(Component);

  var AccordionResultsComponent =
  /*#__PURE__*/
  function (_ResultsComponent) {
    _inherits(AccordionResultsComponent, _ResultsComponent);

    function AccordionResultsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AccordionResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AccordionResultsComponent).call(this, config, systemConfig));
      /**
       * base selector to use when finding DOM targets
       * @type {string}
       */

      _this._selectorBase = config.selectorBase || '.js-yxt-AccordionResult';
      /**
       * collapsed state class
       * @type {string}
       */

      _this.collapsedClass = config.collapsedClass || 'is-collapsed';
      /**
       * vertical config id is required for analytics
       * @type {string|null}
       */

      _this.verticalConfigId = config.verticalConfigId || config._parentOpts.verticalConfigId || null;
      return _this;
    }
    /**
     * the component type
     * @returns {string}
     * @override
     */


    _createClass(AccordionResultsComponent, [{
      key: "onMount",

      /**
       * overrides onMount to add bindings to change the height on click
       * @returns {AccordionResultsComponent}
       * @override
       */
      value: function onMount() {
        var _this2 = this;

        _get(_getPrototypeOf(AccordionResultsComponent.prototype), "onMount", this).call(this); // NOTE(amullings): This is a hack, since currently components with siblings
        // have no way of referring to their own element. We have to grab the first
        // element since sections get added in reverse.


        var selfEl = this._container.firstElementChild;
        var accordionEls = DOM.queryAll(selfEl, this._selectorBase);
        accordionEls.forEach(function (accordionEl) {
          var toggleEl = DOM.query(accordionEl, _this2.toggleSelector());
          var contentEl = DOM.query(accordionEl, _this2.bodySelector());

          _this2.changeHeight(contentEl, accordionEl);

          toggleEl.addEventListener('click', function () {
            _this2.handleClick(accordionEl, toggleEl, contentEl);
          });
        });
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(AccordionResultsComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          modifier: this.verticalConfigId
        }));
      }
      /**
       * click handler for the accordion toggle button
       * @param wrapperEl {HTMLElement} the toggle container
       * @param toggleEl {HTMLElement} the button
       * @param contentEl {HTMLElement} the toggle target
       */

    }, {
      key: "handleClick",
      value: function handleClick(wrapperEl, toggleEl, contentEl) {
        var event = new AnalyticsEvent(this.isCollapsed(wrapperEl) ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
          verticalConfigId: this.verticalConfigId,
          entityId: toggleEl.dataset.entityId
        });
        wrapperEl.classList.toggle(this.collapsedClass);
        this.changeHeight(contentEl, wrapperEl);
        toggleEl.setAttribute('aria-expanded', this.isCollapsed(wrapperEl) ? 'false' : 'true');
        this.analyticsReporter.report(event);
      }
      /**
       * returns true if the element is currently collapsed
       * @param wrapperEl {HTMLElement} the toggle container
       * @returns {boolean}
       */

    }, {
      key: "isCollapsed",
      value: function isCollapsed(wrapperEl) {
        if (!wrapperEl) {
          return false;
        }

        return wrapperEl.classList.contains(this.collapsedClass);
      }
      /**
       * toggles the height between 0 and the content height for smooth animation
       * @param targetEl {HTMLElement}
       * @param wrapperEl {HTMLElement}
       */

    }, {
      key: "changeHeight",
      value: function changeHeight(targetEl, wrapperEl) {
        targetEl.style.height = "".concat(this.isCollapsed(wrapperEl) ? 0 : targetEl.scrollHeight, "px");
      }
      /**
       * helper for composing child element selectors
       * @param child {string}
       * @returns {string}
       */

    }, {
      key: "buildSelector",
      value: function buildSelector(child) {
        return "".concat(this._selectorBase).concat(child);
      }
      /**
       * helper for the toggle button selector
       * @returns {string}
       */

    }, {
      key: "toggleSelector",
      value: function toggleSelector() {
        return this.buildSelector('-toggle');
      }
      /**
       * helper for the content element selector
       * @returns {string}
       */

    }, {
      key: "bodySelector",
      value: function bodySelector() {
        return this.buildSelector('-body');
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsaccordion';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AccordionResults';
      }
    }]);

    return AccordionResultsComponent;
  }(ResultsComponent);

  var UniversalResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(UniversalResultsComponent, _Component);

    function UniversalResultsComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, UniversalResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UniversalResultsComponent).call(this, opts, systemOpts));
      _this.moduleId = StorageKeys.UNIVERSAL_RESULTS;
      _this._limit = opts.limit || 10;
      return _this;
    }

    _createClass(UniversalResultsComponent, [{
      key: "init",
      value: function init(opts) {
        _get(_getPrototypeOf(UniversalResultsComponent.prototype), "init", this).call(this, opts);

        return this;
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        var sections = data.sections || [];
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "setState", this).call(this, Object.assign({
          sections: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          showNoResults: sections.length === 0,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }), val);
      }
    }, {
      key: "addChild",
      value: function addChild() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var type = arguments.length > 1 ? arguments[1] : undefined;
        var opts = arguments.length > 2 ? arguments[2] : undefined;

        var childOpts = _objectSpread({}, opts, {}, this.getChildConfig([data['verticalConfigId']]));

        if (childOpts.useAccordion === true) {
          return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, AccordionResultsComponent.type, childOpts);
        }

        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, type, childOpts);
      }
    }, {
      key: "getChildConfig",
      value: function getChildConfig(configId) {
        var defaultConfig = {
          verticalConfigId: configId,
          isUniversal: true
        };
        var config = this._config.config;

        if (config === undefined) {
          return defaultConfig;
        }

        return Object.assign(defaultConfig, this._config['config'][configId] || this._config['config']);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/universalresults';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'UniversalResults';
      }
    }]);

    return UniversalResultsComponent;
  }(Component);

  var PaginationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(PaginationComponent, _Component);

    function PaginationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PaginationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PaginationComponent).call(this, config, systemConfig));
      /**
       * The vertical key to use for searches
       * @type {string}
       * @private
       */

      _this._verticalKey = _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

      if (typeof _this._verticalKey !== 'string') {
        throw new AnswersComponentError('verticalKey not provided, but necessary for pagination', 'PaginationComponent');
      }
      /**
       * If true, displays the first page button
       * @type {boolean}
       * @private
       */


      _this._firstPageButtonEnabled = config.showFirst === undefined ? true : config.showFirst;
      /**
       * If true, displays the last page button
       * @type {boolean}
       * @private
       */

      _this._lastPageButtonEnabled = config.showLast === undefined ? true : config.showLast;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      _this._analyticsOptions = {
        verticalKey: _this._verticalKey
      };
      var offset = _this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

      _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));

      _this.core.globalStorage.on('update', StorageKeys.SEARCH_OFFSET, function (offset) {
        if (typeof offset === 'number') {
          return;
        }

        _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));
      });

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, function (results) {
        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
          _this.setState();
        }
      });

      return _this;
    }

    _createClass(PaginationComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

        if (!showControls) {
          return;
        }

        var previousPageButton = DOM.query(this._container, '.js-yxt-Pagination-previous');
        var nextPageButton = DOM.query(this._container, '.js-yxt-Pagination-next');
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        DOM.on(previousPageButton, 'click', function () {
          return _this2.updatePage(offset - limit);
        });
        DOM.on(nextPageButton, 'click', function () {
          return _this2.updatePage(offset + limit);
        });

        if (this._firstPageButtonEnabled) {
          var firstPageButton = DOM.query(this._container, '.js-yxt-Pagination-first');
          DOM.on(firstPageButton, 'click', function () {
            return _this2.updatePage(0);
          });
        }

        if (this._lastPageButtonEnabled) {
          var lastPageButton = DOM.query(this._container, '.js-yxt-Pagination-last');
          DOM.on(lastPageButton, 'click', function () {
            return _this2.updatePage(maxPage * limit);
          });
        }
      }
    }, {
      key: "updatePage",
      value: function updatePage(offset) {
        this.scrollToTop();
        this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.persistentStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.verticalPage(this._verticalKey, offset);
      }
    }, {
      key: "scrollToTop",
      value: function scrollToTop() {
        document.documentElement.scrollTop = 0; // Safari

        document.body.scrollTop = 0;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var pageNumber = offset / limit;
        var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
        var isMoreResults = results.resultsCount > offset + limit;
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        return _get(_getPrototypeOf(PaginationComponent.prototype), "setState", this).call(this, _objectSpread({
          showControls: showControls,
          firstPageButtonEnabled: this._firstPageButtonEnabled,
          lastPageButtonEnabled: this._lastPageButtonEnabled,
          pageNumber: pageNumber + 1,
          showFirstPageButton: pageNumber > 1,
          showPreviousPageButton: pageNumber > 0,
          showNextPageButton: isMoreResults,
          showLastPageButton: pageNumber < maxPage - 1
        }, data));
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'results/pagination';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Pagination';
      }
    }]);

    return PaginationComponent;
  }(Component);

  /**
   * Configurable options for the component
   * @type {Object}
   */

  var DEFAULT_CONFIG$1 = {
    /**
     * The entity identifier that the question is associated with.
     * This is typically an organization object
     * @type {number}
     */
    'entityId': null,

    /**
     * The main CSS selector used to reference the form for the component.
     * @type {string} CSS selector
     */
    'formSelector': 'form',

    /**
     * An optional label to use for the e-mail address input
     * @type {string}
     */
    'emailLabel': 'Email',

    /**
     * An optional label to use for the name input
     * @type {string}
     */
    'nameLabel': 'Name',

    /**
     * An optional label to use for the question
     * @type {string}
     */
    'questionLabel': 'Question',

    /**
     * An optional label to use for the Privacy Policy
     * @type {string}
     */
    'privacyPolicyText': 'By submitting my email address, I consent to being contacted via email at the address provided.',

    /**
     * The label to use for the Submit button
     * @type {string}
     */
    'buttonLabel': 'Submit',

    /**
     * The title to display in the title bar
     * @type {string}
     */
    'sectionTitle': 'Ask a Question',

    /**
     * The description to display in the title bar
     * @type {string}
     */
    'teaser': 'Cant find what you\'re looking for? Ask a question below.',

    /**
     * The name of the icon to use in the title bar
     * @type {string}
     */
    'sectionTitleIconName': 'support',

    /**
     * The text to display in the feedback form ahead of the Question input
     * @type {string}
     */
    'description': 'Enter your question and contact information, and we\'ll get back to you with a response shortly.',

    /**
     * The placeholder text for required inputs
     * @type {string}
     */
    'requiredInputPlaceholder': '(required)',

    /**
     * The placeholder text for the question text area
     * @type {string}
     */
    'questionInputPlaceholder': 'Enter your question here',

    /**
     * The confirmation text to display after successfully submitting feedback
     * @type {string}
     */
    'questionSubmissionConfirmationText': 'Thank you for your question!',

    /**
     * The default privacy policy url label
     * @type {string}
    */
    'privacyPolicyUrlLabel': 'Learn more here.',

    /**
     * The default privacy policy url
     * @type {string}
     */
    'privacyPolicyUrl': '',

    /**
     * The default privacy policy error text, shown when the user does not agree
     * @type {string}
     */
    'privacyPolicyErrorText': '* You must agree to the privacy policy to submit a question.',

    /**
     * The default email format error text, shown when the user submits an invalid email
     * @type {string}
     */
    'emailFormatErrorText': '* Please enter a valid email address.',

    /**
     * Whether or not this component is expanded by default.
     * @type {boolean}
     */
    'expanded': true
  };
  /**
   * QuestionSubmissionComponent is a component that creates a form
   * thats displayed whenever a query is run. It enables the user
   * to submit questions that they cant find the answer for.
   */

  var QuestionSubmissionComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(QuestionSubmissionComponent, _Component);

    function QuestionSubmissionComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, QuestionSubmissionComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(QuestionSubmissionComponent).call(this, Object.assign({}, DEFAULT_CONFIG$1, config), systemConfig));
      /**
       * Reference to the storage model
       * @type {string}
       */

      _this.moduleId = StorageKeys.QUESTION_SUBMISSION;
      /**
       * Reference to the locale as set in the global config
       * @type {string}
       */

      _this.locale = _this.core.globalStorage.getState(StorageKeys.LOCALE);
      /**
       * NOTE(billy) if this is a pattern we want to follow for configuration
       * we should bake it into the core class.
       */

      _this.validateConfig();
      /**
       * The QuestionSubmission component should be rendered only once a search has completed. If the
       * search results are still loading, the component should not be displayed.
       */


      var onResultsUpdate = function onResultsUpdate(results) {
        if (results.searchState !== SearchStates.SEARCH_LOADING) {
          var questionText = _this.core.globalStorage.getState(StorageKeys.QUERY);

          _this.setState(new QuestionSubmission({
            questionText: questionText,
            expanded: _this._config.expanded
          }));
        } else {
          _this.unMount();
        }
      };

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, onResultsUpdate);

      _this.core.globalStorage.on('update', StorageKeys.UNIVERSAL_RESULTS, onResultsUpdate);

      return _this;
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(QuestionSubmissionComponent, [{
      key: "validateConfig",

      /**
       * validationConfig contains a bunch of rules
       * that are used to validate aginst configuration provided by the user
       */
      value: function validateConfig() {
        if (this._config.entityId === null || this._config.entityId === undefined) {
          throw new AnswersComponentError('`entityId` is a required configuration option for Question Submission', 'QuestionSubmission');
        }
      }
    }, {
      key: "beforeMount",
      value: function beforeMount() {
        // Avoid mounting the component if theres no data
        // Note, 1 because `config` is always part of the state.
        return Object.keys(this.getState()).length > 1;
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var triggerEl = DOM.query(this._container, '.js-content-visibility-toggle');

        if (triggerEl !== null) {
          this.bindFormToggle(triggerEl);
        }

        var formEl = DOM.query(this._container, this._config.formSelector);

        if (formEl === null) {
          return;
        }

        this.bindFormFocus(formEl);
        this.bindFormSubmit(formEl);
      }
      /**
       * bindFormFocus will wire up the DOM focus event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormFocus",
      value: function bindFormFocus(formEl) {
        var _this2 = this;

        if (this.analyticsReporter === null) {
          return;
        }

        var questionText = DOM.query(formEl, '.js-question-text');
        DOM.on(questionText, 'focus', function () {
          _this2.analyticsReporter.report(_this2.getAnalyticsEvent('QUESTION_FOCUS'));
        });
      }
      /**
       * bindFormSubmit handles submitting the question to the server,
       * and submits an event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormSubmit",
      value: function bindFormSubmit(formEl) {
        var _this3 = this;

        DOM.on(formEl, 'submit', function (e) {
          e.preventDefault();

          _this3.analyticsReporter.report(_this3.getAnalyticsEvent('QUESTION_SUBMIT')); // TODO(billy) we probably want to disable the form from being submitted twice


          var errors = _this3.validate(formEl);

          var formData = _this3.parse(formEl);

          if (Object.keys(errors).length) {
            return _this3.setState(new QuestionSubmission(formData, errors));
          }

          _this3.core.submitQuestion({
            'entityId': _this3._config.entityId,
            'questionLanguage': _this3.locale,
            'site': 'FIRSTPARTY',
            'name': formData.name,
            'email': formData.email,
            'questionText': formData.questionText,
            'questionDescription': formData.questionDescription
          })["catch"](function (error) {
            _this3.setState(new QuestionSubmission(formData, {
              'network': 'We\'re sorry, an error occurred.'
            }));

            throw error;
          });
        });
      }
      /**
       * bindFormToggle handles expanding and mimimizing the component's form.
       * @param {HTMLElement} triggerEl
       */

    }, {
      key: "bindFormToggle",
      value: function bindFormToggle(triggerEl) {
        var _this4 = this;

        DOM.on(triggerEl, 'click', function (e) {
          var formData = _this4.getState();

          _this4.setState(new QuestionSubmission(_objectSpread({}, formData, {
            'expanded': !formData.questionExpanded,
            'submitted': formData.questionSubmitted
          }), formData.errors));
        });
      }
      /**
       * Takes the form, and builds a object that represents the input names
       * and text fields.
       * @param {HTMLElement} formEl
       * @returns {object}
       */

    }, {
      key: "parse",
      value: function parse(formEl) {
        var inputFields = DOM.queryAll(formEl, '.js-question-field');

        if (!inputFields || inputFields.length === 0) {
          return {};
        }

        var obj = {};

        for (var i = 0; i < inputFields.length; i++) {
          var val = inputFields[i].value;

          if (inputFields[i].type === 'checkbox') {
            val = inputFields[i].checked;
          }

          obj[inputFields[i].name] = val;
        }

        return obj;
      }
      /**
       * Validates the fields for correct formatting
       * @param {HTMLElement} formEl
       * @returns {Object} errors object if any errors found
       */

    }, {
      key: "validate",
      value: function validate(formEl) {
        var errors = {};
        var fields = DOM.queryAll(formEl, '.js-question-field');

        for (var i = 0; i < fields.length; i++) {
          if (!fields[i].checkValidity()) {
            if (i === 0) {
              // set focus state on first error
              fields[i].focus();
            }

            switch (fields[i].name) {
              case 'email':
                errors['emailError'] = true;

                if (!fields[i].validity.valueMissing) {
                  errors['emailErrorText'] = this._config.emailFormatErrorText;
                }

                break;

              case 'name':
                errors['nameError'] = true;
                break;

              case 'privacyPolicy':
                errors['privacyPolicyErrorText'] = this._config.privacyPolicyErrorText;
                errors['privacyPolicyError'] = true;
                break;

              case 'questionText':
                errors['questionTextError'] = true;
                break;
            }
          }
        }

        return errors;
      }
      /**
       * Returns an options object describing the context of a reportable event
       */

    }, {
      key: "getAnalyticsEvent",
      value: function getAnalyticsEvent(eventType) {
        var analyticsEvent = new AnalyticsEvent(eventType);
        analyticsEvent.addOptions({
          verticalConfigId: this._verticalKey,
          searcher: this._verticalKey ? 'VERTICAL' : 'UNIVERSAL'
        });
        return analyticsEvent;
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'questions/questionsubmission';
      }
      /**
       * The public interface alias for the component
       * @returns {string}
       * @override
       */

    }, {
      key: "type",
      get: function get() {
        return 'QASubmission';
      }
    }]);

    return QuestionSubmissionComponent;
  }(Component);

  var SVGIcon =
  /*#__PURE__*/
  function () {
    /**
     * @param config
     * @param config.name
     * @param config.path
     * @param config.complexContents
     * @param config.viewBox
     * @constructor
     */
    function SVGIcon(config) {
      _classCallCheck(this, SVGIcon);

      /**
       * the name of the icon
       */
      this.name = config.name;
      /**
       * an svg path definition
       */

      this.path = config.path;
      /**
       * if not using a path, a the markup for a complex SVG
       */

      this.complexContents = config.complexContents;
      /**
       * the view box definition, defaults to 24x24
       * @type {string}
       */

      this.viewBox = config.viewBox || '0 0 24 24';
      /**
       * actual contents used
       */

      this.contents = this.pathDefinition();
    }

    _createClass(SVGIcon, [{
      key: "pathDefinition",
      value: function pathDefinition() {
        if (this.complexContents) {
          return this.complexContents;
        }

        return "<path d=\"".concat(this.path, "\"></path>");
      }
      /**
       * returns the svg markup
       */

    }, {
      key: "markup",
      value: function markup() {
        return "<svg viewBox=\"".concat(this.viewBox, "\" xmlns=\"http://www.w3.org/2000/svg\">").concat(this.contents, "</svg>");
      }
    }]);

    return SVGIcon;
  }();

  var thumbIcon = new SVGIcon({
    name: 'thumb',
    viewBox: '0 0 24 22',
    path: 'M15.273 1H5.455c-.906 0-1.68.55-2.008 1.342L.153 10.097A2.19 2.19 0 000 10.9v2.2c0 1.21.982 2.2 2.182 2.2h6.883L8.03 20.327l-.033.352c0 .451.186.869.48 1.166L9.633 23l7.178-7.249a2.16 2.16 0 00.644-1.551v-11c0-1.21-.982-2.2-2.182-2.2zm0 13.2l-4.735 4.774L11.75 13.1H2.182v-2.2l3.273-7.7h9.818v11zM19.636 1H24v13.2h-4.364V1z'
  });

  var receiptIcon = new SVGIcon({
    name: 'receipt',
    path: 'M14.606 9.5c-.671-.515-1.591-.833-2.606-.833 1.015 0 1.935.318 2.606.833zm-7.985 0H1.655A1.66 1.66 0 010 7.833V3.667C0 2.747.741 2 1.655 2h20.69A1.66 1.66 0 0124 3.667v4.166A1.66 1.66 0 0122.345 9.5h-4.966V22H6.621V9.5h2.773H6.62zm10.758-1.667h4.966V3.667H1.655v4.166h4.966v-2.5h10.758v2.5z'
  });

  var pantheonIcon = new SVGIcon({
    name: 'pantheon',
    path: 'M9.947 16.598h.252V9.412h-.252a.432.432 0 01-.23-.065c-.07-.043-.106-.093-.106-.15L9.15 7.82v-.15c0-.044.028-.08.084-.109a.691.691 0 01.105-.086.254.254 0 01.146-.043H13.6c.056 0 .104.015.146.043.042.03.091.058.147.086a.271.271 0 01.063.108c.014.043.007.093-.02.15l-.42 1.378a.374.374 0 01-.147.15.37.37 0 01-.19.065h-.251v7.186h.252a.37.37 0 01.189.065c.07.043.119.093.147.15l.42 1.378c.027.028.034.071.02.129a.275.275 0 01-.063.129 1.364 1.364 0 00-.147.086.254.254 0 01-.146.043H9.485a.254.254 0 01-.146-.043.691.691 0 01-.105-.086c-.056-.029-.084-.072-.084-.13v-.128l.461-1.377c0-.058.035-.108.105-.151a.432.432 0 01.231-.065zm5.792 0h.252V9.412h-.252a.432.432 0 01-.23-.065.374.374 0 01-.148-.15l-.42-1.377c-.027-.029-.034-.072-.02-.13a.275.275 0 01.063-.129c.056-.028.105-.057.146-.086a.254.254 0 01.147-.043h4.114c.055 0 .104.015.146.043a.691.691 0 01.105.086c.056.03.084.072.084.13v.129l-.42 1.377a.374.374 0 01-.146.15.432.432 0 01-.231.065h-.21v7.186h.21a.43.43 0 01.23.065c.07.043.12.093.148.15l.42 1.378v.15c0 .043-.029.08-.085.108a.691.691 0 01-.105.086.254.254 0 01-.146.043h-4.114a.254.254 0 01-.147-.043 1.364 1.364 0 00-.146-.086.271.271 0 01-.063-.108c-.014-.043-.007-.093.02-.15l.42-1.377a.374.374 0 01.147-.151.432.432 0 01.231-.065zm-11.794-.086h.252V9.498h-.252a.334.334 0 01-.21-.065.386.386 0 01-.126-.193l-.42-1.377a.248.248 0 01-.02-.172.854.854 0 01.063-.173c.028-.057.07-.1.126-.129a.365.365 0 01.168-.043h4.07c.057 0 .113.015.169.043a.278.278 0 01.126.13.854.854 0 01.062.172.248.248 0 01-.02.172l-.42 1.377a.386.386 0 01-.126.193.334.334 0 01-.21.065h-.21v7.014h.21c.084 0 .154.029.21.086a.673.673 0 01.126.172l.42 1.378a.248.248 0 01.02.172.854.854 0 01-.062.172.278.278 0 01-.126.129.365.365 0 01-.168.043H3.526a.365.365 0 01-.168-.043.278.278 0 01-.126-.13.854.854 0 01-.063-.171.248.248 0 01.02-.172l.42-1.378a.673.673 0 01.126-.172.281.281 0 01.21-.086zM1.763 6.658a.717.717 0 01-.504-.194.644.644 0 01-.21-.495v-.43a.73.73 0 01.105-.387.68.68 0 01.273-.259C4.309 3.402 6.54 2.276 8.121 1.515 9.702.755 10.493.361 10.493.332c.531-.258.972-.366 1.322-.323.35.043.734.165 1.154.366l8.31 4.518c.14.058.245.144.315.259a.73.73 0 01.105.387v.43c0 .201-.07.366-.21.495a.717.717 0 01-.504.194H1.763zm-.714 13.34a.54.54 0 01.168-.387.516.516 0 01.378-.172h19.642c.168 0 .308.057.42.172a.541.541 0 01.168.387v.818a.522.522 0 01-.168.408.605.605 0 01-.42.151H1.595a.551.551 0 01-.378-.15.522.522 0 01-.168-.41v-.817zm21.405 2.022c.14 0 .266.058.378.173a.592.592 0 01.168.43v.818a.541.541 0 01-.168.387.516.516 0 01-.378.172L.546 23.957a.516.516 0 01-.378-.172.541.541 0 01-.168-.387v-.818a.59.59 0 01.168-.43.516.516 0 01.378-.173l21.908.043z'
  });

  var micIcon = new SVGIcon({
    name: 'mic',
    path: 'M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z'
  });

  var directionsIcon = new SVGIcon({
    name: 'directions',
    path: 'M23.649 11.154L12.846.35a1.195 1.195 0 00-1.692 0L.35 11.154a1.195 1.195 0 000 1.692L11.154 23.65a1.195 1.195 0 001.692 0L23.65 12.846c.468-.456.468-1.212 0-1.692zm-9.254 3.853v-3.001H9.593v3.6h-2.4v-4.8c0-.66.54-1.2 1.2-1.2h6.002V6.604l4.2 4.2-4.2 4.202z'
  });

  var calendarIcon = new SVGIcon({
    name: 'calendar',
    path: 'M18.111 13.2H12v6h6.111v-6zM16.89 0v2.4H7.11V0H4.667v2.4H3.444c-1.356 0-2.432 1.08-2.432 2.4L1 21.6C1 22.92 2.088 24 3.444 24h17.112C21.9 24 23 22.92 23 21.6V4.8c0-1.32-1.1-2.4-2.444-2.4h-1.223V0H16.89zm3.667 21.6H3.444V8.4h17.112v13.2z'
  });

  var calloutIcon = new SVGIcon({
    name: 'callout',
    path: 'M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z'
  });

  var infoIcon = new SVGIcon({
    name: 'info',
    path: 'M12 8.4A1.2 1.2 0 1012 6a1.2 1.2 0 000 2.4zM12 0c6.624 0 12 5.376 12 12s-5.376 12-12 12S0 18.624 0 12 5.376 0 12 0zm0 18c.66 0 1.2-.54 1.2-1.2V12c0-.66-.54-1.2-1.2-1.2-.66 0-1.2.54-1.2 1.2v4.8c0 .66.54 1.2 1.2 1.2z'
  });

  var briefcaseIcon = new SVGIcon({
    name: 'briefcase',
    path: 'M20 7h-4V5c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 20c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V9c0-1.11-.89-2-2-2zm-6 0h-4V5h4v2z'
  });

  var kabobIcon = new SVGIcon({
    name: 'kabob',
    viewBox: '0 0 3 11',
    complexContents: "<circle cx=\"1.5\" cy=\"1.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"5.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"9.5\" r=\"1.5\"/>"
  });

  var personIcon = new SVGIcon({
    name: 'person',
    viewBox: '0 0 18 18',
    path: 'M9 9c2.486 0 4.5-2.014 4.5-4.5S11.486 0 9 0a4.499 4.499 0 00-4.5 4.5C4.5 6.986 6.514 9 9 9zm0 2.25c-3.004 0-9 1.508-9 4.5v1.125C0 17.494.506 18 1.125 18h15.75c.619 0 1.125-.506 1.125-1.125V15.75c0-2.992-5.996-4.5-9-4.5z'
  });

  var magnifyingGlassIcon = new SVGIcon({
    name: 'magnifying_glass',
    path: 'M16.124 13.051a5.154 5.154 0 110-10.308 5.154 5.154 0 010 10.308M16.114 0a7.886 7.886 0 00-6.46 12.407L0 22.06 1.94 24l9.653-9.653A7.886 7.886 0 1016.113 0'
  });

  var officeIcon = new SVGIcon({
    name: 'office',
    path: 'M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z'
  });

  var linkIcon = new SVGIcon({
    name: 'link',
    path: 'M2.28 12A3.723 3.723 0 016 8.28h4.8V6H6c-3.312 0-6 2.688-6 6s2.688 6 6 6h4.8v-2.28H6A3.723 3.723 0 012.28 12zm4.92 1.2h9.6v-2.4H7.2v2.4zM18 6h-4.8v2.28H18A3.723 3.723 0 0121.72 12 3.723 3.723 0 0118 15.72h-4.8V18H18c3.312 0 6-2.688 6-6s-2.688-6-6-6z'
  });

  var windowIcon = new SVGIcon({
    name: 'window',
    path: 'M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z'
  });

  var phoneIcon = new SVGIcon({
    name: 'phone',
    path: 'M4.827 10.387a20.198 20.198 0 008.786 8.786l2.934-2.933c.36-.36.893-.48 1.36-.32a15.21 15.21 0 004.76.76c.733 0 1.333.6 1.333 1.333v4.654C24 23.4 23.4 24 22.667 24 10.147 24 0 13.853 0 1.333 0 .6.6 0 1.333 0H6c.733 0 1.333.6 1.333 1.333 0 1.667.267 3.267.76 4.76.147.467.04.987-.333 1.36l-2.933 2.934z'
  });

  var tagIcon = new SVGIcon({
    name: 'tag',
    viewBox: '0 0 18 18',
    path: 'M17.469 8.622l-8.1-8.1A1.789 1.789 0 008.1 0H1.8C.81 0 0 .81 0 1.8v6.3c0 .495.198.945.531 1.278l8.1 8.1c.324.324.774.522 1.269.522a1.76 1.76 0 001.269-.531l6.3-6.3A1.76 1.76 0 0018 9.9c0-.495-.207-.954-.531-1.278zM3.15 4.5c-.747 0-1.35-.603-1.35-1.35 0-.747.603-1.35 1.35-1.35.747 0 1.35.603 1.35 1.35 0 .747-.603 1.35-1.35 1.35z'
  });

  var documentIcon = new SVGIcon({
    name: 'document',
    path: 'M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z'
  });

  var chevronIcon = new SVGIcon({
    name: 'chevron',
    viewBox: '0 0 7 9',
    complexContents: "<g fill-rule=\"evenodd\" transform=\"translate(-1 -8)\"><path d=\"m2.6417004 8-1.1417004 1.0575 3.70850202 3.4425-3.70850202 3.4425 1.1417004 1.0575 4.8582996-4.5z\"/></g>"
  });

  var supportIcon = new SVGIcon({
    name: 'support',
    path: 'M12,0 C5.376,0 0,5.376 0,12 C0,18.624 5.376,24 12,24 C18.624,24 24,18.624 24,12 C24,5.376 18.624,0 12,0 Z M13,19 L11,19 L11,17 L13,17 L13,19 Z M15.07,11.25 L14.17,12.17 C13.45,12.9 13,13.5 13,15 L11,15 L11,14.5 C11,13.4 11.45,12.4 12.17,11.67 L13.41,10.41 C13.78,10.05 14,9.55 14,9 C14,7.9 13.1,7 12,7 C10.9,7 10,7.9 10,9 L8,9 C8,6.79 9.79,5 12,5 C14.21,5 16,6.79 16,9 C16,9.88 15.64,10.68 15.07,11.25 Z'
  });

  var yextIcon = new SVGIcon({
    name: 'yext',
    viewBox: '0 0 30 30',
    path: 'M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z'
  });

  var pinIcon = new SVGIcon({
    name: 'pin',
    viewBox: '0 0 13 18',
    path: 'm9.375 0c-3.52446429 0-6.375 2.817-6.375 6.3 0 4.725 6.375 11.7 6.375 11.7s6.375-6.975 6.375-11.7c0-3.483-2.8505357-6.3-6.375-6.3zm.00000018 8.55000007c-1.25678576 0-2.27678579-1.008-2.27678579-2.25s1.02000003-2.25 2.27678579-2.25c1.25678572 0 2.27678582 1.008 2.27678582 2.25s-1.0200001 2.25-2.27678582 2.25z'
  });

  var gearIcon = new SVGIcon({
    name: 'gear',
    path: 'M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42a.353.353 0 01.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16a.353.353 0 01-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z'
  });

  var lightBulbIcon = new SVGIcon({
    name: 'light_bulb',
    viewBox: '0 0 32 35',
    path: 'M11.585 31.056l8.38-.493v-.986l-8.38.493zM11.585 33.028L15.775 35l4.19-1.972V31.55l-8.38.493v.986zm6.926-.407l-2.736 1.29-2.13-1.004 4.866-.286zM15.775 7.394c-4.63 0-8.38 3.205-8.38 8.38 0 5.177 4.19 6.902 4.19 12.818v.493l8.38-.493c0-5.916 4.19-8.188 4.19-12.817a8.38 8.38 0 00-8.38-8.38zm5.617 13.48c-1.025 1.837-2.174 3.892-2.381 6.786l-6.44.38c-.129-3.01-1.29-5.021-2.32-6.808-.493-.8-.928-1.636-1.299-2.5h13.556c-.325.708-.704 1.403-1.116 2.142zm1.479-3.128H8.627a7.793 7.793 0 01-.247-1.971c0-4.353 3.042-7.395 7.395-7.395a7.394 7.394 0 017.394 7.395 6.739 6.739 0 01-.3 1.971h.002zM26.62 15.282h4.93v1h-4.93zM23.094 7.756l2.091-2.091.698.697-2.092 2.092zM15.282 0h1v4.93h-1zM5.666 6.362l.697-.697 2.091 2.091-.697.697zM0 15.282h4.93v1H0z'
  });

  var starIcon = new SVGIcon({
    name: 'receipt',
    viewBox: '0 0 18 18',
    path: 'M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z'
  });

  var close = new SVGIcon({
    name: 'close',
    complexContents: "\n    <path d=\"M7 8l9.716 9.716m0-9.716L7 17.716\" \n          stroke=\"currentColor\" \n          stroke-width=\"2\"/>\n  "
  });

  var elements = new SVGIcon({
    name: 'elements',
    path: 'M13,15 L13,17 L21,17 L21,19 L13,19 L13,21 L11,21 L11,15 L13,15 Z M9,17 L9,19 L3,19 L3,17 L9,17 Z M9,15 L7,15 L7,13 L3,13 L3,11 L7,11 L7,9 L9,9 L9,15 Z M21,11 L21,13 L11,13 L11,11 L21,11 Z M17,3 L17,5 L21,5 L21,7 L17,7 L17,9 L15,9 L15,3 L17,3 Z M13,5 L13,7 L3,7 L3,5 L13,5 Z'
  });

  var iconsArray = [thumbIcon, receiptIcon, pantheonIcon, micIcon, directionsIcon, calendarIcon, calloutIcon, infoIcon, briefcaseIcon, kabobIcon, personIcon, magnifyingGlassIcon, officeIcon, linkIcon, windowIcon, phoneIcon, tagIcon, documentIcon, chevronIcon, supportIcon, yextIcon, pinIcon, gearIcon, lightBulbIcon, elements, close];
  var Icons = {};
  iconsArray.forEach(function (icon) {
    Icons[icon.name] = icon.markup();
  });
  Icons["default"] = starIcon.markup();

  var IconComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(IconComponent, _Component);

    /**
     * IconComponent
     * @param opts
     * @param opts.iconName {string}
     * @param opts.customIcon {string}
     * @param opts.iconUrl {string}
     */
    function IconComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, IconComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(IconComponent).call(this, opts, systemOpts));
      /**
       * name of an icon from the default icon set
       * @type {string}
       */

      _this.iconName = opts.iconName || 'default';
      /**
       * the markup for a fully custom icon
       * @type {*|null}
       */

      _this.customIcon = opts.customIcon || null;
      /**
       * the url to a custom image icon
       * @type {null}
       */

      _this.iconUrl = opts.iconUrl || null;
      return _this;
    }
    /**
     * getter for the image pasted to handlebars
     * @returns {string}
     */


    _createClass(IconComponent, [{
      key: "setState",

      /**
       * overrides default functionality to provide name and markup
       * @param data
       * @returns {IconComponent}
       */
      value: function setState(data) {
        return _get(_getPrototypeOf(IconComponent.prototype), "setState", this).call(this, Object.assign(data, {
          image: this.image,
          name: this.iconName ? this.iconName : 'custom'
        }));
      }
    }, {
      key: "image",
      get: function get() {
        if (this.customIcon) {
          return this.customIcon;
        }

        if (this.iconUrl) {
          return "<img src=\"".concat(this.iconUrl, "\" alt=\"\" class=\"Icon-image\">");
        }

        if (Icons[this.iconName]) {
          return Icons[this.iconName];
        }

        return Icons["default"];
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'icons/icon';
      }
      /**
       * allowing duplicates
       * @returns {boolean}
       * @override
       */

    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'IconComponent';
      }
    }]);

    return IconComponent;
  }(Component);

  /** @module */
  var COMPONENT_CLASS_LIST = [// Core Component
  Component, // Navigation Components
  NavigationComponent, // Search Components
  SearchComponent, FilterSearchComponent, AutoCompleteComponent, SpellCheckComponent, LocationBiasComponent, // Filter Components
  FilterBoxComponent, FilterOptionsComponent, RangeFilterComponent, DateRangeFilterComponent, FacetsComponent, GeoLocationComponent, SortOptionsComponent, // Results Components
  DirectAnswerComponent, UniversalResultsComponent, ResultsComponent, PaginationComponent, ResultsItemComponent, AccordionResultsComponent, LocationResultsItemComponent, EventResultsItemComponent, PeopleResultsItemComponent, MapComponent, // Questions Components
  QuestionSubmissionComponent, // Helper Components
  IconComponent];
  /**
   * The component registry is a map that contains
   * all available component classes used for creation or extension.
   * Each component class has a unique type, which is used as the key for the registry
   * @type {Object.<string, Component>}
   */

  var COMPONENT_REGISTRY = COMPONENT_CLASS_LIST.reduce(function (registry, clazz) {
    registry[clazz.type] = clazz;
    return registry;
  }, {});

  /**
   * ComponentManager is a Singletone that contains both an internal registry of
   * eligible components to be created, as well as keeps track of the current
   * instantiated and active components.
   *
   * ALL components should be constructed using the {ComponentManager} via its `create` method.
   */

  var ComponentManager =
  /*#__PURE__*/
  function () {
    function ComponentManager() {
      _classCallCheck(this, ComponentManager);

      /**
       * The active components is an internal container to keep track
       * of all of the components that have been constructed
       */
      this._activeComponents = [];
      /**
       * A local reference to the core library dependency
       *
       * The Core contains both the storage AND services that are needed for performing operations
       * like search and auto complete.
       *
       * The storage is the source of truth for the state of ALL components.
       * Whenever the storage is updated, the state gets pushed down to the necessary components.
       * @type {Core}
       */

      this._core = null;
      /**
       * The primary renderer to use for all components
       * @type {HandlebarsRenderer}
       */

      this._renderer = null;
      /**
       * A local reference to the analytics reporter dependency
       */

      this._analyticsReporter = null;
    }

    _createClass(ComponentManager, [{
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = renderer;
        return this;
      }
    }, {
      key: "setCore",
      value: function setCore(core) {
        this._core = core;
        return this;
      }
    }, {
      key: "setAnalyticsReporter",
      value: function setAnalyticsReporter(reporter) {
        this._analyticsReporter = reporter;
        return this;
      }
      /**
       * registers a component to be eligible for creation and override.
       * @param {Component} The Component Class to register
       */

    }, {
      key: "register",
      value: function register(componentClazz) {
        COMPONENT_REGISTRY[componentClazz.type] = componentClazz;
        return this;
      }
      /**
       * create is the entry point for constructing any and all components.
       * It will instantiate a new instance of the component, and both apply
       * initial state from the storage and bind it to the storage for updates.
       * @param {string} componentType The component type to create
       * @param {Object} opts The options to pipe to the construction of the component
       */

    }, {
      key: "create",
      value: function create(componentType, opts) {
        // Every component needs local access to the component manager
        // because sometimes components have subcomponents that need to be
        // constructed during creation
        var systemOpts = {
          core: this._core,
          renderer: this._renderer,
          analyticsReporter: this._analyticsReporter,
          componentManager: this
        };
        var componentClass = COMPONENT_REGISTRY[componentType];

        if (!componentClass.areDuplicateNamesAllowed() && this._activeComponents.some(function (c) {
          return c.name === opts.name;
        })) {
          throw new AnswersComponentError("Another component with name ".concat(opts.name, " already exists"), componentType);
        }

        var config = _objectSpread({
          isTwin: this._activeComponents.some(function (component) {
            return component.constructor.type === componentType;
          })
        }, opts); // Instantiate our new component and keep track of it


        var component = new COMPONENT_REGISTRY[componentType](config, systemOpts).init(config);

        this._activeComponents.push(component); // If there is a global storage to power state, apply the state
        // from the storage to the component, and then bind the component
        // state to the storage via its updates


        if (this._core && this._core.globalStorage !== null) {
          if (component.moduleId === undefined || component.moduleId === null) {
            return component;
          }

          this._core.globalStorage.on('update', component.moduleId, function (data) {
            component.setState(data);
          });
        }

        return component;
      }
      /**
       * Remove the provided component from the list of active components and remove
       * the associated storage event listener
       * @param {Component} component The component to remove
       */

    }, {
      key: "remove",
      value: function remove(component) {
        this._core.globalStorage.off('update', component.moduleId);

        var index = this._activeComponents.findIndex(function (c) {
          return c.name === component.name;
        });

        this._activeComponents.splice(index, 1);
      }
      /**
       * Remove the component with the given name
       * @param {string} name The name of the compnent to remove
       */

    }, {
      key: "removeByName",
      value: function removeByName(name) {
        var component = this._activeComponents.find(function (c) {
          return c.name === name;
        });

        component.remove();
        DOM.empty(component._container);
      }
    }, {
      key: "getActiveComponent",
      value: function getActiveComponent(type) {
        return this._activeComponents.find(function (c) {
          return c.constructor.type === type;
        });
      }
    }], [{
      key: "getInstance",
      value: function getInstance() {
        if (!this.instance) {
          this.instance = new ComponentManager();
        }

        return this.instance;
      }
    }]);

    return ComponentManager;
  }();

  /** @module NavigationConfig */
  var TabConfig =
  /*#__PURE__*/
  function () {
    function TabConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, TabConfig);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label || null;
      /**
       * The complete URL, including the params
       * @type {string}
       */

      this.url = config.url || null;
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */

      this.configId = config.configId || null;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }

    _createClass(TabConfig, [{
      key: "validate",
      value: function validate() {}
    }], [{
      key: "from",
      value: function from(tabs) {
        var tabConfigs = [];

        if (tabs === undefined) {
          return tabConfigs;
        }

        for (var i = 0; i < tabs.length; i++) {
          var tab = tabs[i];
          tabConfigs.push(new TabConfig(tab));
        }

        return tabConfigs;
      }
    }]);

    return TabConfig;
  }();

  var NavigationConfig = function NavigationConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NavigationConfig);

    this.tabsConfig = TabConfig.from(config.tabs);
  };

  /** @typedef {import('./core/services/searchservice').default} SearchService */

  /** @typedef {import('./core/services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./core/services/questionanswerservice').default} QuestionAnswerService */

  /** @typedef {import('./core/services/errorreporterservice').default} ErrorReporterService */

  /** @typedef {import('./core/services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @typedef Services
   * @property {SearchService} searchService
   * @property {AutoCompleteService} autoCompleteService
   * @property {QuestionAnswerService} questionAnswerService
   * @property {ErrorReporterService} errorReporterService
   */

  var DEFAULTS = {
    locale: 'en'
  };
  /**
   * The main Answers interface
   */

  var Answers =
  /*#__PURE__*/
  function () {
    function Answers() {
      _classCallCheck(this, Answers);

      if (!Answers.setInstance(this)) {
        return Answers.getInstance();
      }
      /**
       * A reference to the Component base class for custom
       * components to extend
       */


      this.Component = Component;
      /**
       * A reference to the AnalyticsEvent base class for reporting
       * custom analytics
       */

      this.AnalyticsEvent = AnalyticsEvent;
      /**
       * A reference of the renderer to use for the components
       * This is provided during initialization.
       * @type {Renderer}
       */

      this.renderer = new Renderers.Handlebars();
      /**
       * A local reference to the component manager
       * @type {ComponentManager}
       */

      this.components = ComponentManager.getInstance();
      /**
       * A local reference to the core api
       * @type {Core}
       */

      this.core = null;
      /**
       * A callback function to invoke once the library is ready.
       * Typically fired after templates are fetched from server for rendering.
       */

      this._onReady = function () {};
      /**
       * @type {boolean}
       * @private
       */


      this._eligibleForAnalytics = false;
      /**
       * @type {Services}
       * @private
       */

      this._services = null;
      /**
       * @type {AnalyticsReporterService}
       * @private
       */

      this._analyticsReporterService = null;
    }

    _createClass(Answers, [{
      key: "init",
      value: function init(config) {
        var _this = this;

        var parsedConfig = this.parseConfig(config);
        this.validateConfig(parsedConfig);
        parsedConfig.search = new SearchConfig(parsedConfig.search);
        parsedConfig.navigation = new NavigationConfig(parsedConfig.navigation);
        var globalStorage = new GlobalStorage();
        var persistentStorage = new PersistentStorage({
          updateListener: parsedConfig.onStateChange,
          resetListener: function resetListener(data) {
            return globalStorage.setAll(data);
          }
        });
        globalStorage.setAll(persistentStorage.getAll());
        globalStorage.set(StorageKeys.SEARCH_CONFIG, parsedConfig.search);
        globalStorage.set(StorageKeys.NAVIGATION_CONFIG, parsedConfig.navigation);
        globalStorage.set(StorageKeys.LOCALE, parsedConfig.locale);
        globalStorage.set(StorageKeys.SESSIONS_OPT_IN, parsedConfig.sessionTrackingEnabled);
        this._services = parsedConfig.mock ? getMockServices() : getServices(parsedConfig, globalStorage);
        this.core = new Core({
          apiKey: parsedConfig.apiKey,
          globalStorage: globalStorage,
          persistentStorage: persistentStorage,
          experienceKey: parsedConfig.experienceKey,
          fieldFormatters: parsedConfig.fieldFormatters,
          experienceVersion: parsedConfig.experienceVersion,
          locale: parsedConfig.locale,
          searchService: this._services.searchService,
          autoCompleteService: this._services.autoCompleteService,
          questionAnswerService: this._services.questionAnswerService
        });

        if (parsedConfig.onStateChange && typeof parsedConfig.onStateChange === 'function') {
          parsedConfig.onStateChange(persistentStorage.getAll(), window.location.search.substr(1));
        }

        this.components.setCore(this.core).setRenderer(this.renderer);
        this._eligibleForAnalytics = parsedConfig.businessId != null;

        if (this._eligibleForAnalytics) {
          // TODO(amullings): Initialize with other services
          var reporter = parsedConfig.mock ? new NoopAnalyticsReporter() : new AnalyticsReporter(this.core, parsedConfig.experienceKey, parsedConfig.experienceVersion, parsedConfig.businessId, parsedConfig.analyticsOptions, parsedConfig.environment);
          this._analyticsReporterService = reporter;
          this.components.setAnalyticsReporter(reporter);
          initScrollListener(reporter);
        }

        this._setDefaultInitialSearch(parsedConfig.search);

        this._onReady = parsedConfig.onReady || function () {};

        if (parsedConfig.useTemplates === false || parsedConfig.templateBundle) {
          if (parsedConfig.templateBundle) {
            this.renderer.init(parsedConfig.templateBundle);
          }

          this._onReady();

          return this;
        } // Templates are currently downloaded separately from the CORE and UI bundle.
        // Future enhancement is to ship the components with templates in a separate bundle.


        this.templates = new TemplateLoader({
          templateUrl: parsedConfig.templateUrl
        }).onLoaded(function (templates) {
          _this.renderer.init(templates);

          _this._onReady();
        });
        return this;
      }
    }, {
      key: "domReady",
      value: function domReady(cb) {
        DOM.onReady(cb);
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        this._onReady = cb;
        return this;
      }
      /**
       * Parses the config provided by the user. In the parsed config, any options not supplied by the
       * user are given default values.
       * @param {Object} config The user supplied config.
       */

    }, {
      key: "parseConfig",
      value: function parseConfig(config) {
        var parsedConfig = Object.assign({}, DEFAULTS, config);
        var sessionTrackingEnabled = true;

        if (typeof config.sessionTrackingEnabled === 'boolean') {
          sessionTrackingEnabled = config.sessionTrackingEnabled;
        }

        parsedConfig.sessionTrackingEnabled = sessionTrackingEnabled;
        var sandboxPrefix = "".concat(SANDBOX, "-");
        parsedConfig.apiKey.includes(sandboxPrefix) ? parsedConfig.environment = SANDBOX : parsedConfig.environment = PRODUCTION;
        parsedConfig.apiKey = parsedConfig.apiKey.replace(sandboxPrefix, '');
        return parsedConfig;
      }
      /**
       * Validates the Answers config object to ensure things like api key and experience key are
       * properly set.
       * @param {Object} config The Answers config.
       */

    }, {
      key: "validateConfig",
      value: function validateConfig(config) {
        // TODO (tmeyer): Extract this method into it's own class. Investigate the use of JSON schema
        // to validate these configs.
        if (typeof config.apiKey !== 'string') {
          throw new Error('Missing required `apiKey`. Type must be {string}');
        }

        if (typeof config.experienceKey !== 'string') {
          throw new Error('Missing required `experienceKey`. Type must be {string}');
        }
      }
      /**
       * Register a custom component type so it can be created via
       * addComponent and used as a child component
       * @param {Component} componentClass
       */

    }, {
      key: "registerComponentType",
      value: function registerComponentType(componentClass) {
        this.components.register(componentClass);
      }
    }, {
      key: "addComponent",
      value: function addComponent(type, opts) {
        if (typeof opts === 'string') {
          opts = {
            container: opts
          };
        }

        try {
          this.components.create(type, opts).mount();
        } catch (e) {
          throw new AnswersComponentError('Failed to add component', type, e);
        }

        return this;
      }
      /**
       * Remove the component - and all of its children - with the given name
       * @param {string} name The name of the component to remove
       */

    }, {
      key: "removeComponent",
      value: function removeComponent(name) {
        this.components.removeByName(name);
      }
    }, {
      key: "createComponent",
      value: function createComponent(opts) {
        return this.components.create('Component', opts).mount();
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this.renderer.registerHelper(name, cb);
        return this;
      }
      /**
       * Opt in or out of convertion tracking analytics
       * @param {boolean} optIn
       */

    }, {
      key: "setConversionsOptIn",
      value: function setConversionsOptIn(optIn) {
        if (this._eligibleForAnalytics) {
          this._analyticsReporterService.setConversionTrackingEnabled(optIn);
        }
      }
      /**
       * Opt in or out of session cookies
       * @param {boolean} optIn
       */

    }, {
      key: "setSessionsOptIn",
      value: function setSessionsOptIn(optIn) {
        this.core.globalStorage.set(StorageKeys.SESSIONS_OPT_IN, optIn);
      }
      /**
       * Sets a search query on initialization for vertical searchers that have a
       * defaultInitialSearch provided, if the user hasn't already provided their
       * own via URL param.
       * @param {SearchConfig} searchConfig
       * @private
       */

    }, {
      key: "_setDefaultInitialSearch",
      value: function _setDefaultInitialSearch(searchConfig) {
        if (searchConfig.defaultInitialSearch == null || !searchConfig.verticalKey) {
          return;
        }

        var prepopulatedQuery = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (prepopulatedQuery != null) {
          return;
        }

        this.core.globalStorage.set('queryTrigger', 'initialize');
        this.core.setQuery(searchConfig.defaultInitialSearch);
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return Answers;
  }();
  /**
   * @param {Object} config
   * @param {GlobalStorage} globalStorage
   * @returns {Services}
   */


  function getServices(config, globalStorage) {
    return {
      searchService: new SearchApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }),
      autoCompleteService: new AutoCompleteApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }, globalStorage),
      questionAnswerService: new QuestionAnswerApi({
        apiKey: config.apiKey,
        environment: config.environment
      }, globalStorage),
      errorReporterService: new ErrorReporter({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        printVerbose: config.debug,
        sendToServer: !config.suppressErrorReports,
        environment: config.environment
      }, globalStorage)
    };
  }
  /**
   * @returns {Services}
   */


  function getMockServices() {
    return {
      searchService: new MockSearchService(),
      autoCompleteService: new MockAutoCompleteService(),
      questionAnswerService: new MockQuestionAnswerService(),
      errorReporterService: new ConsoleErrorReporter()
    };
  }
  /**
   * Initialize the scroll event listener to send analytics events
   * when the user scrolls to the bottom. Debounces scroll events so
   * they are processed after the user stops scrolling
   */


  function initScrollListener(reporter) {
    var DEBOUNCE_TIME = 100;
    var timeout = null;

    var sendEvent = function sendEvent() {
      if (window.innerHeight + window.pageYOffset >= document.body.scrollHeight) {
        var event = new AnalyticsEvent('SCROLL_TO_BOTTOM_OF_PAGE');
        reporter.report(event);
      }
    };

    document.addEventListener('scroll', function () {
      clearTimeout(timeout);
      timeout = setTimeout(sendEvent, DEBOUNCE_TIME);
    });
  }

  var ANSWERS = new Answers();

  return ANSWERS;

}));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5zd2Vycy11bWQuanMiLCJzb3VyY2VzIjpbInNyYy9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3Jlc3VsdC5qcyIsInNyYy9jb3JlL21vZGVscy9oaWdobGlnaHRlZHZhbHVlLmpzIiwic3JjL2NvcmUvZXJyb3JzL2Vycm9ycy5qcyIsInNyYy9jb3JlL21vZGVscy9yZXN1bHRmYWN0b3J5LmpzIiwic3JjL2NvcmUvbW9kZWxzL3NlY3Rpb24uanMiLCJzcmMvY29yZS9tb2RlbHMvdW5pdmVyc2FscmVzdWx0cy5qcyIsInNyYy9jb3JlL21vZGVscy9kaXJlY3RhbnN3ZXIuanMiLCJzcmMvY29yZS9tb2RlbHMvbmF2aWdhdGlvbi5qcyIsInNyYy9jb3JlL21vZGVscy92ZXJ0aWNhbHJlc3VsdHMuanMiLCJzcmMvY29yZS9tb2RlbHMvc3BlbGxjaGVjay5qcyIsInNyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMuanMiLCJzcmMvY29yZS9tb2RlbHMvZHluYW1pY2ZpbHRlcnMuanMiLCJzcmMvY29yZS9tb2RlbHMvc2VhcmNoaW50ZW50cy5qcyIsInNyYy9jb3JlL21vZGVscy9sb2NhdGlvbmJpYXMuanMiLCJzcmMvY29yZS9zZWFyY2gvc2VhcmNoZGF0YXRyYW5zZm9ybWVyLmpzIiwic3JjL2NvcmUvbW9kZWxzL3F1ZXN0aW9uc3VibWlzc2lvbi5qcyIsInNyYy9jb3JlL21vZGVscy9maWx0ZXIuanMiLCJzcmMvY29yZS9jb3JlLmpzIiwic3JjL3VpL2RvbS9kb20uanMiLCJzcmMvdWkvZG9tL3NlYXJjaHBhcmFtcy5qcyIsInNyYy91aS9yZW5kZXJpbmcvcmVuZGVyZXIuanMiLCJzcmMvdWkvcmVuZGVyaW5nL2hhbmRsZWJhcnNyZW5kZXJlci5qcyIsInNyYy91aS9yZW5kZXJpbmcvY29uc3QuanMiLCJzcmMvY29yZS9jb25zdGFudHMuanMiLCJzcmMvdWkvcmVuZGVyaW5nL3RlbXBsYXRlbG9hZGVyLmpzIiwic3JjL3VpL2luZGV4LmpzIiwic3JjL2NvcmUvZXZlbnRlbWl0dGVyL2V2ZW50ZW1pdHRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL3N0YXRlLmpzIiwic3JjL2NvcmUvaHR0cC9odHRwcmVxdWVzdGVyLmpzIiwic3JjL2NvcmUvdXRpbHMvdXJsdXRpbHMuanMiLCJzcmMvY29yZS9odHRwL2FwaXJlcXVlc3QuanMiLCJzcmMvY29yZS9zZWFyY2gvc2VhcmNoYXBpLmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50LmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc3JlcG9ydGVyLmpzIiwic3JjL2NvcmUvYW5hbHl0aWNzL25vb3BhbmFseXRpY3NyZXBvcnRlci5qcyIsInNyYy9jb3JlL3N0b3JhZ2UvbW9kdWxlZGF0YS5qcyIsInNyYy9jb3JlL3N0b3JhZ2UvZ2xvYmFsc3RvcmFnZS5qcyIsInNyYy9jb3JlL2luZGV4LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY29tcG9uZW50LmpzIiwic3JjL2NvcmUvZXJyb3JzL2Vycm9ycmVwb3J0ZXIuanMiLCJzcmMvY29yZS9lcnJvcnMvY29uc29sZWVycm9ycmVwb3J0ZXIuanMiLCJzcmMvdWkvc3RvcmFnZS9wZXJzaXN0ZW50c3RvcmFnZS5qcyIsInNyYy9jb3JlL21vZGVscy9zZWFyY2hjb25maWcuanMiLCJzcmMvY29yZS9tb2RlbHMvYXV0b2NvbXBsZXRlZGF0YS5qcyIsInNyYy9jb3JlL3NlYXJjaC9hdXRvY29tcGxldGVkYXRhdHJhbnNmb3JtZXIuanMiLCJzcmMvY29yZS9zZWFyY2gvYXV0b2NvbXBsZXRlYXBpLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2thdXRvY29tcGxldGVzZXJ2aWNlLmpzIiwic3JjL2NvcmUvc2VhcmNoL3F1ZXN0aW9uYW5zd2VyYXBpLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2txdWVzdGlvbmFuc3dlcnNlcnZpY2UuanMiLCJzcmMvY29yZS9zZWFyY2gvbW9ja3NlYXJjaHNlcnZpY2UuanMiLCJzcmMvdWkvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvc2VhcmNoY29tcG9uZW50LmpzIiwic3JjL3VpL3Rvb2xzL3NlYXJjaHBhcmFtc3BhcnNlci5qcyIsInNyYy91aS9jb21wb25lbnRzL3NlYXJjaC9maWx0ZXJzZWFyY2hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvYXV0b2NvbXBsZXRlY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL3NwZWxsY2hlY2tjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvbG9jYXRpb25iaWFzY29tcG9uZW50LmpzIiwic3JjL2NvcmUvbW9kZWxzL2ZhY2V0LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXJib3hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlcm9wdGlvbnNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL3JhbmdlZmlsdGVyY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9kYXRlcmFuZ2VmaWx0ZXJjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZhY2V0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ZpbHRlcnMvZ2VvbG9jYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL3NvcnRvcHRpb25zY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9kaXJlY3RhbnN3ZXJjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL3Jlc3VsdHNpdGVtY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9sb2NhdGlvbnJlc3VsdHNpdGVtY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9ldmVudHJlc3VsdHNpdGVtY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9wZW9wbGVyZXN1bHRzaXRlbWNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL21hcC9wcm92aWRlcnMvbWFwcHJvdmlkZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvcHJvdmlkZXJzL2dvb2dsZW1hcHByb3ZpZGVyLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbWFwL3Byb3ZpZGVycy9tYXBib3htYXBwcm92aWRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL21hcC9tYXBjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL3Jlc3VsdHNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL2FjY29yZGlvbnJlc3VsdHNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL3VuaXZlcnNhbHJlc3VsdHNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL3BhZ2luYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9xdWVzdGlvbnMvcXVlc3Rpb25zdWJtaXNzaW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2ljb25zL2ljb24uanMiLCJzcmMvdWkvaWNvbnMvdGh1bWIuanMiLCJzcmMvdWkvaWNvbnMvcmVjZWlwdC5qcyIsInNyYy91aS9pY29ucy9wYW50aGVvbi5qcyIsInNyYy91aS9pY29ucy9taWMuanMiLCJzcmMvdWkvaWNvbnMvZGlyZWN0aW9ucy5qcyIsInNyYy91aS9pY29ucy9jYWxlbmRhci5qcyIsInNyYy91aS9pY29ucy9jYWxsb3V0LmpzIiwic3JjL3VpL2ljb25zL2luZm8uanMiLCJzcmMvdWkvaWNvbnMvYnJpZWZjYXNlLmpzIiwic3JjL3VpL2ljb25zL2thYm9iLmpzIiwic3JjL3VpL2ljb25zL3BlcnNvbi5qcyIsInNyYy91aS9pY29ucy9tYWduaWZ5aW5nX2dsYXNzLmpzIiwic3JjL3VpL2ljb25zL29mZmljZS5qcyIsInNyYy91aS9pY29ucy9saW5rLmpzIiwic3JjL3VpL2ljb25zL3dpbmRvdy5qcyIsInNyYy91aS9pY29ucy9waG9uZS5qcyIsInNyYy91aS9pY29ucy90YWcuanMiLCJzcmMvdWkvaWNvbnMvZG9jdW1lbnQuanMiLCJzcmMvdWkvaWNvbnMvY2hldnJvbi5qcyIsInNyYy91aS9pY29ucy9zdXBwb3J0LmpzIiwic3JjL3VpL2ljb25zL3lleHQuanMiLCJzcmMvdWkvaWNvbnMvcGluLmpzIiwic3JjL3VpL2ljb25zL2dlYXIuanMiLCJzcmMvdWkvaWNvbnMvbGlnaHRfYnVsYi5qcyIsInNyYy91aS9pY29ucy9zdGFyLmpzIiwic3JjL3VpL2ljb25zL2Nsb3NlLmpzIiwic3JjL3VpL2ljb25zL2VsZW1lbnRzLmpzIiwic3JjL3VpL2ljb25zL2luZGV4LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvaWNvbnMvaWNvbmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3JlZ2lzdHJ5LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvY29tcG9uZW50bWFuYWdlci5qcyIsInNyYy9jb3JlL21vZGVscy9uYXZpZ2F0aW9uY29uZmlnLmpzIiwic3JjL2Fuc3dlcnMtdW1kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIFNlYXJjaFN0YXRlcyAqL1xuXG4vKipcbiAqIFNlYXJjaFN0YXRlcyBpcyBhbiBFTlVNIGZvciB0aGUgdmFyaW91cyBzdGFnZXMgb2Ygc2VhcmNoaW5nLFxuICogdXNlZCB0byBzaG93IGRpZmZlcmVudCB0ZW1wbGF0ZXNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUFJFX1NFQVJDSDogJ3ByZS1zZWFyY2gnLFxuICBTRUFSQ0hfTE9BRElORzogJ3NlYXJjaC1sb2FkaW5nJyxcbiAgU0VBUkNIX0NPTVBMRVRFOiAnc2VhcmNoLWNvbXBsZXRlJ1xufTtcbiIsIi8qKiBAbW9kdWxlIFJlc3VsdCAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN1bHQge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJhdyBwcm9maWxlIGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmF3ID0gZGF0YS5yYXcgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXR0ZWQgcHJvZmlsZSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Zvcm1hdHRlZCA9IGRhdGEuZm9ybWF0dGVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhpZ2hsaWdodGVkIHByb2ZpbGUgZGF0YSB3aXRoIGhpZ2hsaWdodHMgYXBwbGllZCB0byBhcHBsaWNhYmxlIGZpZWxkc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oaWdobGlnaHRlZCA9IGRhdGEuaGlnaGxpZ2h0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggbnVtYmVyIG9mIHRoZSByZXN1bHRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3JkaW5hbCA9IGRhdGEub3JkaW5hbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoZSByZXN1bHQgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gZGF0YS50aXRsZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgb2YgdGhlIGRldGFpbHMgc2VjdGlvbiBvZiB0aGUgcmVzdWx0IGNhcmQsIGNhbiBjb250YWluIEhUTUxcbiAgICAgKiBAdHlwZSB7c3RyaW5nfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc3RpbmF0aW9uIGxpbmsgZm9yIHRoZSB0aXRsZSBvZiB0aGUgcmVzdWx0IGNhcmRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5saW5rID0gZGF0YS5saW5rIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRW50aXR5IElELCBvciBvdGhlciB1bmlxdWUgaWRlbnRpZmllciwgdXNlZCBmb3IgdG8gcG93ZXIgaW50ZXJhY3Rpdml0eVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1YnRpdGxlIG9uIHRoZSByZXN1bHQgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN1YnRpdGxlID0gZGF0YS5zdWJ0aXRsZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIG1vZGlmaWVyLCB1c3VhbGx5IGRlcml2ZWQgZnJvbSB0aGUgdmVydGljYWwgY29uZmlndXJhdGlvbiBJRFxuICAgICAqIFVzZWQgdG8gYXBwbHkgZGlmZmVyZW50IHN0eWxpbmcgdG8gZGlmZmVyZW50IHJlc3VsdCBjYXJkIHR5cGVzXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMubW9kaWZpZXIgPSBkYXRhLm1vZGlmaWVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxhcmdlIGRhdGUsIG9mIHRoZSBmb3JtYXQgeyBtb250aDogJ0phbicsIGRheTogJzAxJyB9XG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuYmlnRGF0ZSA9IGRhdGEuYmlnRGF0ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW1hZ2UgcHJvZmlsZSBvYmplY3QsIGV4cGVjdGVkIHRvIGhhdmUgYSB1cmwgcHJvcGVydHlcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZSA9IGRhdGEuaW1hZ2UgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGNhbGxzIHRvIGFjdGlvbiwgb2YgdGhlIGZvcm1hdDpcbiAgICAgKiB7IGljb246ICcnLCB1cmw6ICcnLCB0ZXh0OiAnJywgZXZlbnRUeXBlOiAnJywgZXZlbnRPcHRpb25zOiB7fX1cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jYWxsc1RvQWN0aW9uID0gZGF0YS5jYWxsc1RvQWN0aW9uIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBhY2NvcmRpYW4gcmVzdWx0IHNob3VsZCBiZSBjb2xsYXBzZWQgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2VkID0gZGF0YS5jb2xsYXBzZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkYXRhLmNvbGxhcHNlZDtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgSGlnaGxpZ2h0ZWRWYWx1ZSAqL1xuXG4vKipcbiAqIE1vZGVsIHJlcHJlc2VudGluZyBhIGhpZ2hsaWdodGVkIHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaWdobGlnaHRlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlIHx8IGRhdGEuc2hvcnRWYWx1ZSB8fCAnJztcbiAgICB0aGlzLm1hdGNoZWRTdWJzdHJpbmdzID0gZGF0YS5tYXRjaGVkU3Vic3RyaW5ncyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaGlnaGxpZ2h0ZWQgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgKCkge1xuICAgIHRoaXMuX3NvcnRNYXRjaGVkU3Vic3RyaW5ncygpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZSh0aGlzLnZhbHVlLCB0aGlzLm1hdGNoZWRTdWJzdHJpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaW52ZXJ0ZWQgaGlnaGxpZ2h0ZWQgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRJbnZlcnRlZCAoKSB7XG4gICAgdGhpcy5fc29ydE1hdGNoZWRTdWJzdHJpbmdzKCk7XG4gICAgY29uc3QgaW52ZXJ0ZWRTdWJzdHJpbmdzID0gdGhpcy5fZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzKHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MsIHRoaXMudmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZEhpZ2hsaWdodGVkVmFsdWUodGhpcy52YWx1ZSwgaW52ZXJ0ZWRTdWJzdHJpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbnRyb2R1Y2VzIGhpZ2hsaWdodGluZyB0byBpbnB1dCBkYXRhIGFjY29yZGluZyB0byBoaWdobGlnaHRpbmcgc3BlY2lmaWVyc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsIGlucHV0IG9iamVjdCB0byBhcHBseSBoaWdobGlnaHRpbmcgdG9cbiAgICpcbiAgICogIGV4YW1wbGUgb2JqZWN0IDpcbiAgICogIHtcbiAgICogICAgbmFtZTogJ0FUTScsXG4gICAqICAgIGZlYXR1cmVkTWVzc2FnZToge1xuICAgKiAgICAgIGRlc2NyaXB0aW9uOiAnU2F2ZSB0aW1lICYgYmFuayBvbiB5b3VyIHRlcm1zIGF0IG92ZXIgMSw4MDAgQVRNcydcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzIGhpZ2hsaWdodGluZyBzcGVjaWZpZXJzIHRvIGFwcGx5IHRvIGlucHV0IG9iamVjdFxuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiB7XG4gICAqICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAqICAgICAgICBsZW5ndGg6IDMsXG4gICAqICAgICAgICBvZmZzZXQ6IDBcbiAgICogICAgICB9XSxcbiAgICogICAgICB2YWx1ZTogJ0FUTSdcbiAgICogICAgfSxcbiAgICogICAgZmVhdHVyZWRNZXNzYWdlOiB7XG4gICAqICAgICAgZGVzY3JpcHRpb246IHtcbiAgICogICAgICAgIG1hdGNoZWRTdWJzdHJpbmdzOiBbe1xuICAgKiAgICAgICAgICBsZW5ndGg6IDQsXG4gICAqICAgICAgICAgIG9mZnNldDogNDVcbiAgICogICAgICAgIH1dLFxuICAgKiAgICAgICAgdmFsdWU6ICdTYXZlIHRpbWUgJiBiYW5rIG9uIHlvdXIgdGVybXMgYXQgb3ZlciAxLDgwMCBBVE1zJ1xuICAgKiAgICAgIH1cbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb3B5IG9mIGlucHV0IHZhbHVlIHdpdGggaGlnaGxpZ2h0aW5nIGFwcGxpZWRcbiAgICpcbiAgICogIGV4YW1wbGUgb2JqZWN0IDpcbiAgICogIHtcbiAgICogICAgbmFtZTogJzxzdHJvbmc+QVRNPC9zdHJvbmc+JyxcbiAgICogICAgZmVhdHVyZWRNZXNzYWdlOiB7XG4gICAqICAgICAgZGVzY3JpcHRpb246ICdTYXZlIHRpbWUgJiBiYW5rIG9uIHlvdXIgdGVybXMgYXQgb3ZlciAxLDgwMCA8c3Ryb25nPkFUTXM8L3N0cm9uZz4nXG4gICAqICAgIH1cbiAgICogIH1cbiAgICpcbiAgICovXG4gIGJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZSAodmFsLCBoaWdobGlnaHRlZFN1YnN0cmluZ3MpIHtcbiAgICBsZXQgaGlnaGxpZ2h0ZWRWYWx1ZSA9ICcnO1xuICAgIGxldCBuZXh0U3RhcnQgPSAwO1xuXG4gICAgaWYgKGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBoaWdobGlnaHRlZFN1YnN0cmluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBzdGFydCA9IE51bWJlcihoaWdobGlnaHRlZFN1YnN0cmluZ3Nbal0ub2Zmc2V0KTtcbiAgICAgIGxldCBlbmQgPSBzdGFydCArIGhpZ2hsaWdodGVkU3Vic3RyaW5nc1tqXS5sZW5ndGg7XG5cbiAgICAgIGhpZ2hsaWdodGVkVmFsdWUgKz0gW3ZhbC5zbGljZShuZXh0U3RhcnQsIHN0YXJ0KSwgJzxzdHJvbmc+JywgdmFsLnNsaWNlKHN0YXJ0LCBlbmQpLCAnPC9zdHJvbmc+J10uam9pbignJyk7XG5cbiAgICAgIGlmIChqID09PSBoaWdobGlnaHRlZFN1YnN0cmluZ3MubGVuZ3RoIC0gMSAmJiBlbmQgPCB2YWwubGVuZ3RoKSB7XG4gICAgICAgIGhpZ2hsaWdodGVkVmFsdWUgKz0gdmFsLnNsaWNlKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGFydCA9IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWRWYWx1ZTtcbiAgfVxuXG4gIF9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MgKCkge1xuICAgIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3Muc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEub2Zmc2V0IDwgYi5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5vZmZzZXQgPiBiLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzIChtYXRjaGVkU3Vic3RyaW5ncywgdmFsdWVMZW5ndGgpIHtcbiAgICBjb25zdCBpbnZlcnRlZFN1YnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZWRTdWJzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJzdHJpbmcgPSBtYXRjaGVkU3Vic3RyaW5nc1tpXTtcbiAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBzdWJzdHJpbmcub2Zmc2V0ICsgc3Vic3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwICYmIHN1YnN0cmluZy5vZmZzZXQgIT09IDApIHtcbiAgICAgICAgaW52ZXJ0ZWRTdWJzdHJpbmdzLnB1c2goeyBvZmZzZXQ6IDAsIGxlbmd0aDogc3Vic3RyaW5nLm9mZnNldCB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlTGVuZ3RoID4gbmV4dE9mZnNldCkge1xuICAgICAgICBpbnZlcnRlZFN1YnN0cmluZ3MucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBuZXh0T2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogaSA8IG1hdGNoZWRTdWJzdHJpbmdzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgID8gbWF0Y2hlZFN1YnN0cmluZ3NbaSArIDFdLm9mZnNldCAtIG5leHRPZmZzZXRcbiAgICAgICAgICAgIDogdmFsdWVMZW5ndGggLSBuZXh0T2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW52ZXJ0ZWRTdWJzdHJpbmdzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBFcnJvcnMgKi9cblxuLyoqXG4gKiBBbnN3ZXJzQmFzZUVycm9yIGlzIGFuIGV4dGVuc2lvbiBvZiB0aGUgYmFzZSBFcnJvciBvYmplY3QuXG4gKiBUaGlzIGlzIHRoZSBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHdoZW4gcmVwb3J0aW5nIHRvIHRoZSBzZXJ2ZXIuXG4gKiBAZXh0ZW5kcyBFcnJvclxuICpcbiAqIEVycm9yIGNvZGVzIGZhbGwgaW50byBvbmUgb2YgZm91ciBjYXRlZ29yaWVzOlxuICogMVhYIGVycm9yczogQmFzaWMgZXJyb3JzXG4gKiAyWFggZXJyb3JzOiBVSSBlcnJvcnNcbiAqIDNYWCBlcnJvcnM6IEVuZHBvaW50IGVycm9yc1xuICogNFhYIGVycm9yczogQ29yZSBlcnJvcnNcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChlcnJvckNvZGUsIG1lc3NhZ2UsIGJvdW5kYXJ5ID0gJ3Vua25vd24nLCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgdGhpcy5yZXBvcnRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhdXNlZEJ5KSB7XG4gICAgICB0aGlzLmNhdXNlZEJ5ID0gY2F1c2VkQnkgaW5zdGFuY2VvZiBBbnN3ZXJzQmFzZUVycm9yXG4gICAgICAgID8gY2F1c2VkQnlcbiAgICAgICAgOiBBbnN3ZXJzQmFzZUVycm9yLmZyb20oY2F1c2VkQnkpO1xuICAgICAgdGhpcy5zdGFjayA9IGAke3RoaXMuc3RhY2t9XFxuQ2F1c2VkIEJ5OiAke3RoaXMuY2F1c2VkQnkuc3RhY2t9YDtcbiAgICB9XG4gIH1cblxuICB0b0pzb24gKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyaW5nID0gYCR7dGhpcy5lcnJvck1lc3NhZ2V9ICgke3RoaXMuYm91bmRhcnl9KWA7XG4gICAgaWYgKHRoaXMuY2F1c2VkQnkpIHtcbiAgICAgIHN0cmluZyArPSBgXFxuICBDYXVzZWQgQnk6ICR7dGhpcy5jYXVzZWRCeS50b1N0cmluZygpfWA7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAoYnVpbHRpbkVycm9yLCBib3VuZGFyeSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEFuc3dlcnNCYXNpY0Vycm9yKGJ1aWx0aW5FcnJvci5tZXNzYWdlLCBib3VuZGFyeSk7XG4gICAgZXJyb3Iuc3RhY2sgPSBidWlsdGluRXJyb3Iuc3RhY2s7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc0Jhc2ljRXJyb3IgaXMgYSB3cmFwcGVyIGFyb3VuZCBhbGwgdGhlIGJ1aWx0LWluIGVycm9yc1xuICogZS5nLiB1bmRlZmluZWQgdmFyaWFibGVzLCBpbmNvcnJlY3Qgc3ludGF4LCB0eXBlcywgbWlzc2luZyBtZXRob2RzLCBldGMuXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQmFzaWNFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoMTAwLCBtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc1VpRXJyb3IgdXNlZCBmb3IgdGhpbmdzIGxpa2UgRE9NIGVycm9ycy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNDb25maWdFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoMTAxLCBtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc1VpRXJyb3IgdXNlZCBmb3IgdGhpbmdzIGxpa2UgRE9NIGVycm9ycy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNVaUVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigyMDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgaXMgdXNlZCBmb3IgQ29tcG9uZW50IG9yaWVudGVkIGVycm9yc1xuICogZS5nLiBmYWlsdXJlIHRvIHJlbmRlciwgb3IgY2F0Y2hpbmcgdW5rbm93bnMuXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvbXBvbmVudCwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigyMDEsIG1lc3NhZ2UsIGNvbXBvbmVudCwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc0VuZHBvaW50RXJyb3IgcmVwcmVzZW50cyBhbGwgbmV0d29yayByZWxhdGVkIGVycm9ycy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNFbmRwb2ludEVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigzMDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzQ29yZUVycm9yIHJlcHJlc2VudHMgZXJyb3JzIGZvciBwcmVjb25kaXRpb24gZmFpbHVyZXMgaW4gdGhlIGNvcmUgbGlicmFyeVxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0NvcmVFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoNDAwLCBtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc1N0b3JhZ2VFcnJvciByZXByZXNlbnRzIHN0b3JhZ2UgcmVsYXRlZCBlcnJvcnNcbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNTdG9yYWdlRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHN0b3JhZ2VLZXksIGRhdGEsIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoNDAxLCBtZXNzYWdlLCAnU3RvcmFnZScsIGNhdXNlZEJ5KTtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IgaXMgdXNlZCBmb3IgZXJyb3JzIHdoZW4gcmVwb3J0aW5nIGFuYWx5dGljc1xuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0FuYWx5dGljc0Vycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBldmVudCwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcig0MDIsIG1lc3NhZ2UsICdBbmFseXRpY3MnLCBjYXVzZWRCeSk7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBSZXN1bHRGYWN0b3J5ICovXG5cbmltcG9ydCBSZXN1bHQgZnJvbSAnLi9yZXN1bHQnO1xuaW1wb3J0IEhpZ2hsaWdodGVkVmFsdWUgZnJvbSAnLi9oaWdobGlnaHRlZHZhbHVlJztcbmltcG9ydCB7IEFuc3dlcnNDb3JlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdWx0RmFjdG9yeSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgUmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIEluY2x1ZGVzIGRlZmF1bHQgbWFwcGluZ3Mgb2YgR29vZ2xlQ3VzdG9tU2VhcmNoRW5naW5lIHJlc3VsdHMgdG9cbiAgICogdGhlIGZpZWxkcyBleHBvc2VkIGJ5IHRoZSB0ZW1wbGF0ZS5cbiAgICogQHBhcmFtIHJlc3VsdHNEYXRhICB7QXJyYXl9IGV4cGVjdGVkIGZvcm1hdDogeyBkYXRhOiB7IC4uLiB9LCBoaWdobGlnaHRlZEZpZWxkczogeyAuLi4gfX1cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmb3JtYXR0ZXJzIHRvIGFwcGx5IHRvIHRoZSByZXN1bHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsSWQgVGhlIHZlcnRpY2FsIG9mIHRoZXNlIHJlc3VsdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBCYWNrZW5kIHNvdXJjZSBvZiB0aGVzZSByZXN1bHRzXG4gICAqIEByZXR1cm5zIHtSZXN1bHRbXX1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXN1bHRzRGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgc291cmNlKSB7XG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0c0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzRGF0YVtpXS5kYXRhIHx8IHJlc3VsdHNEYXRhW2ldO1xuXG4gICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlICdHT09HTEVfQ1NFJzpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tR29vZ2xlQ3VzdG9tU2VhcmNoRW5naW5lKGRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQklOR19DU0UnOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lKGRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWkVOREVTSyc6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBTEdPTElBJzpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tQWxnb2xpYVNlYXJjaEVuZ2luZShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tOT1dMRURHRV9NQU5BR0VSJzpcbiAgICAgICAgICBjb25zdCBoaWdobGlnaHRlZEZpZWxkcyA9IHJlc3VsdHNEYXRhW2ldLmhpZ2hsaWdodGVkRmllbGRzIHx8IHt9O1xuXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUtub3dsZWRnZU1hbmFnZXIoXG4gICAgICAgICAgICBkYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBoaWdobGlnaHRlZEZpZWxkcywgaSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21HZW5lcmljKGRhdGEsIGkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGZpZWxkIGZvcm1hdHRlcnMgdG8gS25vd2xlZGdlIE1hbmFnZXIgRW50aXR5IFByb2ZpbGUgRGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5UHJvZmlsZURhdGEgRW50aXR5IFByb2ZpbGUgRGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0dGVycyBEZXZlbG9wZXIgc3BlY2lmaWVkIEZpZWxkIEZvcm1hdHRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsSWQgSWRlbnRpZmllciBmb3IgVmVydGljYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEgU3Vic2V0IG9mIEVudGl0eSBQcm9maWxlIERhdGEgd2l0aCBoaWdobGlnaHRpbmcgYXBwbGllZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBTdWJzZXQgb2YgRW50aXR5IFByb2ZpbGUgRGF0YSBGaWVsZHMgd2l0aCBmaWVsZCBmb3JtYXR0ZXJzIGFwcGxpZWRcbiAgICovXG4gIHN0YXRpYyBjb21wdXRlRm9ybWF0dGVkRGF0YSAoZW50aXR5UHJvZmlsZURhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEpIHtcbiAgICAvLyBpZiBubyBmaWVsZCBmb3JtYXR0ZXJzIHNwZWNpZmllZCwgbm90aGluZyB0byBmb3JtYXRcbiAgICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0dGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IHt9O1xuXG4gICAgT2JqZWN0LmVudHJpZXMoZW50aXR5UHJvZmlsZURhdGEpLmZvckVhY2goKFtmaWVsZE5hbWUsIGZpZWxkVmFsXSkgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgYSBmaWVsZCBmb3JtYXR0ZXIgZXhpc3RzIGZvciB0aGUgY3VycmVudCBlbnRpdHkgcHJvZmlsZSBmaWVsZFxuICAgICAgaWYgKGZvcm1hdHRlcnNbZmllbGROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHZlcmlmeSB0aGUgZmllbGQgZm9ybWF0dGVyIHByb3ZpZGVkIGlzIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIGFzIGV4cGVjdGVkXG4gICAgICBpZiAodHlwZW9mIGZvcm1hdHRlcnNbZmllbGROYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignRmllbGQgZm9ybWF0dGVyIGlzIG5vdCBvZiBleHBlY3RlZCB0eXBlIGZ1bmN0aW9uJywgJ1Jlc3VsdEZhY3RvcnknKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgaGlnaGxpZ2h0ZWQgdmVyc2lvbiBvZiBmaWVsZCB2YWx1ZSBpcyBhdmFpbGFibGUsIG1ha2UgaXQgYXZhaWxhYmxlIHRvIGZpZWxkIGZvcm1hdHRlclxuICAgICAgbGV0IGhpZ2hsaWdodGVkRmllbGRWYWwgPSBudWxsO1xuICAgICAgaWYgKGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEgJiYgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YVtmaWVsZE5hbWVdKSB7XG4gICAgICAgIGhpZ2hsaWdodGVkRmllbGRWYWwgPSBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhW2ZpZWxkTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGwgZm9ybWF0dGVyIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmllbGQgbmFtZVxuICAgICAgLy8gdGhlIGlucHV0IG9iamVjdCBkZWZpbmVzIHRoZSBpbnRlcmZhY2UgdGhhdCBmaWVsZCBmb3JtYXR0ZXIgZnVuY3Rpb25zIHdvcmsgd2l0aFxuICAgICAgZm9ybWF0dGVkRGF0YVtmaWVsZE5hbWVdID0gZm9ybWF0dGVyc1tmaWVsZE5hbWVdKHtcbiAgICAgICAgZW50aXR5UHJvZmlsZURhdGE6IGVudGl0eVByb2ZpbGVEYXRhLFxuICAgICAgICBlbnRpdHlGaWVsZFZhbHVlOiBmaWVsZFZhbCxcbiAgICAgICAgaGlnaGxpZ2h0ZWRFbnRpdHlGaWVsZFZhbHVlOiBoaWdobGlnaHRlZEZpZWxkVmFsLFxuICAgICAgICB2ZXJ0aWNhbElkOiB2ZXJ0aWNhbElkLFxuICAgICAgICBpc0RpcmVjdEFuc3dlcjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlZERhdGE7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gc3Vic3RyaW5ncyB3aXRoaW4gS25vd2xlZGdlIE1hbmFnZXIgRW50aXR5IEZpZWxkIFZhbHVlc1xuICAgKiBhY2NvcmRpbmcgdG8gaGlnaGxpZ2h0aW5nIHNwZWNpZmllcnMgcmV0dXJuZWQgZnJvbSB0aGUgS25vd2xlZGdlIE1hbmFnZXIgU2VhcmNoIEJhY2tlbmRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVByb2ZpbGVEYXRhIEVudGl0eSBQcm9maWxlIERhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZ2hsaWdodGVkRmllbGRzIEtNIHNwZWNpZmllZCBoaWdobGlnaHRpbmcgaW5zdHJ1Y3Rpb25zIHRvIGhpZ2hsaWdodCBjZXJ0YWluIEZpZWxkc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBTdWJzZXQgb2YgRW50aXR5IFByb2ZpbGUgRGF0YSBGaWVsZHMgd2l0aCBoaWdobGlnaHRpbmcgYXBwbGllZFxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVIaWdobGlnaHRlZERhdGEgKGVudGl0eVByb2ZpbGVEYXRhLCBoaWdobGlnaHRlZEZpZWxkcykge1xuICAgIC8vIGlmIG5vIGhpZ2hsaWdodGVkIGZpZWxkcyBzcGVjaWZpZWQsIG5vdGhpbmcgdG8gaGlnaGxpZ2h0XG4gICAgaWYgKE9iamVjdC5rZXlzKGhpZ2hsaWdodGVkRmllbGRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBoaWdobGlnaHRlZERhdGEgPSB7fTtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlbnRpdHkgZmllbGRzIHRoYXQgaGF2ZSBoaWdobGlnaHRpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgT2JqZWN0LmVudHJpZXMoaGlnaGxpZ2h0ZWRGaWVsZHMpLmZvckVhY2goKFtoaWdobGlnaHRlZEZpZWxkTmFtZV0pID0+IHtcbiAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBoaWdobGlnaHRlZCBmaWVsZCBuYW1lIGNvcnJlc3BvbmRzIHRvIGFuIGV4aXN0aW5nIGVudGl0eSBwcm9maWxlIGZpZWxkXG4gICAgICBpZiAoZW50aXR5UHJvZmlsZURhdGFbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb3JlRXJyb3IoJ0hpZ2hsaWdodGVkIEZpZWxkIE5hbWUgZG9lcyBub3QgZXhpc3QgaW4gRW50aXR5IFByb2ZpbGUnLCAnUmVzdWx0RmFjdG9yeScpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaGlnaGxpZ2h0ZWRGaWVsZCA9IGhpZ2hsaWdodGVkRmllbGRzW2hpZ2hsaWdodGVkRmllbGROYW1lXTtcblxuICAgICAgLy8gY2hlY2sgZm9yIG5lc3RlZCBmaWVsZHNcbiAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0ZWRGaWVsZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBPYmplY3Qua2V5cyhoaWdobGlnaHRlZEZpZWxkKS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZFsnbWF0Y2hlZFN1YnN0cmluZ3MnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJlY3Vyc2UgdG8gY2hpbGRyZW4gZmllbGRzXG4gICAgICAgIGhpZ2hsaWdodGVkRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0gPSBSZXN1bHRGYWN0b3J5LmNvbXB1dGVIaWdobGlnaHRlZERhdGEoXG4gICAgICAgICAgZW50aXR5UHJvZmlsZURhdGFbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdLFxuICAgICAgICAgIGhpZ2hsaWdodGVkRmllbGRzW2hpZ2hsaWdodGVkRmllbGROYW1lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaGlnaGxpZ2h0ZWREYXRhVmFsdWUgPSBuZXcgSGlnaGxpZ2h0ZWRWYWx1ZShlbnRpdHlQcm9maWxlRGF0YSkuYnVpbGRIaWdobGlnaHRlZFZhbHVlKFxuICAgICAgICAgIGhpZ2hsaWdodGVkRmllbGQudmFsdWUsXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZC5tYXRjaGVkU3Vic3RyaW5ncyk7XG4gICAgICAgIGhpZ2hsaWdodGVkRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0gPSBoaWdobGlnaHRlZERhdGFWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoaWdobGlnaHRlZERhdGE7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIGdlbmVyaWMgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21HZW5lcmljIChkYXRhLCBpbmRleCkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLm5hbWUsXG4gICAgICBkZXRhaWxzOiB0aGlzLnRydW5jYXRlKGRhdGEuZGVzY3JpcHRpb24pLFxuICAgICAgbGluazogZGF0YS53ZWJzaXRlLFxuICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICBvcmRpbmFsOiBpbmRleCArIDFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgS25vd2xlZGdlIE1hbmFnZXIgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXR0ZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbElkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZEZpZWxkc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tS25vd2xlZGdlTWFuYWdlciAoZGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgaGlnaGxpZ2h0ZWRGaWVsZHMsIGluZGV4KSB7XG4gICAgLy8gY29tcHV0ZSBoaWdobGlnaHRlZCBlbnRpdHkgcHJvZmlsZSBkYXRhXG4gICAgbGV0IGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEgPSBSZXN1bHRGYWN0b3J5LmNvbXB1dGVIaWdobGlnaHRlZERhdGEoZGF0YSwgaGlnaGxpZ2h0ZWRGaWVsZHMpO1xuICAgIC8vIGNvbXB1dGUgZm9ybWF0dGVkIGVudGl0eSBwcm9maWxlIGRhdGFcbiAgICBjb25zdCBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YSA9IFJlc3VsdEZhY3RvcnkuY29tcHV0ZUZvcm1hdHRlZERhdGEoXG4gICAgICBkYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhKTtcblxuICAgIC8vIHNldCByZXN1bHQgZGV0YWlscyBjaGVja2luZyB0aGUgZm9sbG93aW5nIGluIG9yZGVyIG9mIHByaW9yaXR5IDogZm9ybWF0dGVkLCBoaWdobGlnaHRlZCwgcmF3XG4gICAgbGV0IHJlc3VsdERldGFpbHMgPSBudWxsO1xuICAgIGlmIChmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHREZXRhaWxzID0gZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEuZGVzY3JpcHRpb247XG4gICAgfSBlbHNlIGlmIChoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdERldGFpbHMgPSB0aGlzLnRydW5jYXRlKGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEuZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHREZXRhaWxzID0gdGhpcy50cnVuY2F0ZShkYXRhLmRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICBmb3JtYXR0ZWQ6IGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhLFxuICAgICAgaGlnaGxpZ2h0ZWQ6IGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEsXG4gICAgICB0aXRsZTogZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEubmFtZSB8fCBkYXRhLm5hbWUsXG4gICAgICBkZXRhaWxzOiByZXN1bHREZXRhaWxzLFxuICAgICAgbGluazogZGF0YS53ZWJzaXRlLFxuICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICBvcmRpbmFsOiBpbmRleCArIDFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIE1hcHMgdmlldyBtb2RlbCBmaWVsZHMgYmFzZWQgb24gdGhlIEFQSSBkYXRhIGZvciBhIEdvb2dsZSBDdXN0b20gU2VhcmNoIEVuZ2luZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLmh0bWxUaXRsZS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpLFxuICAgICAgZGV0YWlsczogZGF0YS5odG1sU25pcHBldCxcbiAgICAgIGxpbms6IGRhdGEubGlua1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgQmluZyBDdXN0b20gU2VhcmNoIEVuZ2luZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUJpbmdDdXN0b21TZWFyY2hFbmdpbmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICB0aXRsZTogZGF0YS5uYW1lLFxuICAgICAgZGV0YWlsczogZGF0YS5zbmlwcGV0LFxuICAgICAgbGluazogZGF0YS51cmxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIE1hcHMgdmlldyBtb2RlbCBmaWVsZHMgYmFzZWQgb24gdGhlIEFQSSBkYXRhIGZvciBhIFplbmRlc2sgU2VhcmNoIEVuZ2luZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgIGRldGFpbHM6IGRhdGEuc25pcHBldCxcbiAgICAgIGxpbms6IGRhdGEuaHRtbF91cmxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIE1hcHMgdmlldyBtb2RlbCBmaWVsZHMgYmFzZWQgb24gdGhlIEFQSSBkYXRhIGZvciBhIEFsZ29saWEgU2VhcmNoIEVuZ2luZSBvYmplY3QuXG4gICAqIERldGFpbHMgZmllbGQgaXMgc2V0IHRvIG9iamVjdElEIHNpbmNlIHJlc3BvbnNlIGhhcyBvbmx5IG9uZSBnZW5lcmFsIGZpZWxkIG9iamVjdElELlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21BbGdvbGlhU2VhcmNoRW5naW5lIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgZGV0YWlsczogZGF0YS5vYmplY3RJRCxcbiAgICAgIGlkOiBkYXRhLm9iamVjdElEXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1bmNhdGVzIHN0cmluZ3MgdG8gMjUwIGNoYXJhY3RlcnMsIGF0dGVtcHRpbmcgdG8gcHJlc2VydmUgd2hvbGUgd29yZHNcbiAgICogQHBhcmFtIHN0ciB7c3RyaW5nfSB0aGUgc3RyaW5nIHRvIHRydW5jYXRlXG4gICAqIEBwYXJhbSBsaW1pdCB7TnVtYmVyfSB0aGUgbWF4aW11bSBjaGFyYWN0ZXIgbGVuZ3RoIHRvIHJldHVyblxuICAgKiBAcGFyYW0gdHJhaWxpbmcge3N0cmluZ30gYSB0cmFpbGluZyBzdHJpbmcgdG8gZGVub3RlIHRydW5jYXRpb24sIGUuZy4gJy4uLidcbiAgICogQHBhcmFtIHNlcCB7c3RyaW5nfSB0aGUgd29yZCBzZXBhcmF0b3JcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyB0cnVuY2F0ZSAoc3RyLCBsaW1pdCA9IDI1MCwgdHJhaWxpbmcgPSAnLi4uJywgc2VwID0gJyAnKSB7XG4gICAgaWYgKCFzdHIgfHwgc3RyLmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIChibWNnaW5uaXMpOiBzcGxpdCBwdW5jdHVhdGlvbiB0b28gc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGggXCJmb28sLi4uXCJcbiAgICBjb25zdCB3b3JkcyA9IHN0ci5zcGxpdChzZXApO1xuICAgIGNvbnN0IG1heCA9IGxpbWl0IC0gdHJhaWxpbmcubGVuZ3RoO1xuICAgIGxldCB0cnVuY2F0ZWQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHdvcmQgPSB3b3Jkc1tpXTtcbiAgICAgIGlmICh0cnVuY2F0ZWQubGVuZ3RoICsgd29yZC5sZW5ndGggPiBtYXggfHxcbiAgICAgICAgKGkgIT09IDAgJiYgdHJ1bmNhdGVkLmxlbmd0aCArIHdvcmQubGVuZ3RoICsgc2VwLmxlbmd0aCA+IG1heCkpIHtcbiAgICAgICAgdHJ1bmNhdGVkICs9IHRyYWlsaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdHJ1bmNhdGVkICs9IGkgPT09IDAgPyB3b3JkIDogc2VwICsgd29yZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1bmNhdGVkO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWN0aW9uICovXG5cbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuaW1wb3J0IFJlc3VsdEZhY3RvcnkgZnJvbSAnLi9yZXN1bHRmYWN0b3J5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdGlvbiB7XG4gIGNvbnN0cnVjdG9yIChkYXRhLCB1cmwsIGZvcm1hdHRlcnMpIHtcbiAgICB0aGlzLnNlYXJjaFN0YXRlID0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURTtcbiAgICB0aGlzLnZlcnRpY2FsQ29uZmlnSWQgPSBkYXRhLnZlcnRpY2FsQ29uZmlnSWQgfHwgbnVsbDtcbiAgICB0aGlzLnJlc3VsdHNDb3VudCA9IGRhdGEucmVzdWx0c0NvdW50IHx8IDA7XG4gICAgdGhpcy5lbmNvZGVkU3RhdGUgPSBkYXRhLmVuY29kZWRTdGF0ZSB8fCAnJztcbiAgICB0aGlzLmFwcGxpZWRRdWVyeUZpbHRlcnMgPSBBcHBsaWVkUXVlcnlGaWx0ZXIuZnJvbShkYXRhLmFwcGxpZWRRdWVyeUZpbHRlcnMpO1xuICAgIHRoaXMuZmFjZXRzID0gZGF0YS5mYWNldHMgfHwgbnVsbDtcbiAgICB0aGlzLnJlc3VsdHMgPSBSZXN1bHRGYWN0b3J5LmZyb20oZGF0YS5yZXN1bHRzLCBmb3JtYXR0ZXJzLCB0aGlzLnZlcnRpY2FsQ29uZmlnSWQsIGRhdGEuc291cmNlKTtcbiAgICB0aGlzLm1hcCA9IFNlY3Rpb24ucGFyc2VNYXAoZGF0YS5yZXN1bHRzKTtcbiAgICB0aGlzLnZlcnRpY2FsVVJMID0gdXJsIHx8IG51bGw7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXAgKHJlc3VsdHMpIHtcbiAgICBsZXQgbWFwTWFya2VycyA9IFtdO1xuXG4gICAgbGV0IGNlbnRlckNvb3JkaW5hdGVzID0ge307XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIFRPRE8oYmlsbHkpIFJlbW92ZSBsZWdhY3kgZmFsbGJhY2sgZnJvbSBhbGwgZGF0YSBmb3JtYXRcbiAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2pdLmRhdGEgfHwgcmVzdWx0c1tqXTtcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZSkge1xuICAgICAgICBpZiAoIWNlbnRlckNvb3JkaW5hdGVzLmxhdGl0dWRlKSB7XG4gICAgICAgICAgY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICBsYXRpdHVkZTogcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZS5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZS5sb25naXR1ZGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1hcE1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgaXRlbTogcmVzdWx0LFxuICAgICAgICAgIGxhYmVsOiBtYXBNYXJrZXJzLmxlbmd0aCArIDEsXG4gICAgICAgICAgbGF0aXR1ZGU6IHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUubGF0aXR1ZGUsXG4gICAgICAgICAgbG9uZ2l0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxvbmdpdHVkZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgJ21hcENlbnRlcic6IGNlbnRlckNvb3JkaW5hdGVzLFxuICAgICAgJ21hcE1hcmtlcnMnOiBtYXBNYXJrZXJzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzZWN0aW9uIGZyb20gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG1vZHVsZXMgVGhlIHJlc3VsdCBtb2R1bGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cmxzIFRoZSB0YWIgdXJsc1xuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgRmllbGQgZm9ybWF0dGVycyBmb3IgcmVzdWx0c1xuICAgKi9cbiAgc3RhdGljIGZyb20gKG1vZHVsZXMsIHVybHMsIGZvcm1hdHRlcnMpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kdWxlcykpIHtcbiAgICAgIHJldHVybiBuZXcgU2VjdGlvbihtb2R1bGVzLCBudWxsLCBmb3JtYXR0ZXJzKTtcbiAgICB9XG5cbiAgICAvLyBPdXIgc2VjdGlvbnMgc2hvdWxkIGNvbnRhaW4gYSBwcm9wZXJ0eSBvZiBtYXBNYXJrZXIgb2JqZWN0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VjdGlvbnMucHVzaChcbiAgICAgICAgbmV3IFNlY3Rpb24oXG4gICAgICAgICAgbW9kdWxlc1tpXSxcbiAgICAgICAgICB1cmxzW21vZHVsZXNbaV0udmVydGljYWxDb25maWdJZF0sXG4gICAgICAgICAgZm9ybWF0dGVyc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9ucztcbiAgfVxufVxuXG5jbGFzcyBBcHBsaWVkUXVlcnlGaWx0ZXIge1xuICAvLyBTdXBwb3J0IGxlZ2FjeSBtb2RlbCBhbmQgbmV3IG1vZGVsIHVudGlsIGZ1bGx5IG1pZ3JhdGVkLlxuICAvLyBUT0RPKGJpbGx5KSBSZW1vdmUgdGhlIGxlZnQgZXhwcmVzc2lvbiBkdXJpbmcgYXNzaWdubWVudCB3aGVuIG1pZ3JhdGVkLlxuICBjb25zdHJ1Y3RvciAoYXBwbGllZFF1ZXJ5RmlsdGVyKSB7XG4gICAgdGhpcy5rZXkgPSBhcHBsaWVkUXVlcnlGaWx0ZXIua2V5IHx8IGFwcGxpZWRRdWVyeUZpbHRlci5kaXNwbGF5S2V5O1xuICAgIHRoaXMudmFsdWUgPSBhcHBsaWVkUXVlcnlGaWx0ZXIudmFsdWUgfHwgYXBwbGllZFF1ZXJ5RmlsdGVyLmRpc3BsYXlWYWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChhcHBsaWVkUXVlcnlGaWx0ZXJzKSB7XG4gICAgbGV0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcGxpZWRRdWVyeUZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZpbHRlcnMucHVzaChuZXcgQXBwbGllZFF1ZXJ5RmlsdGVyKGFwcGxpZWRRdWVyeUZpbHRlcnNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcnM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFVuaXZlcnNhbFJlc3VsdHMgKi9cblxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnLi9zZWN0aW9uJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbml2ZXJzYWxSZXN1bHRzIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLnF1ZXJ5SWQgPSBkYXRhLnF1ZXJ5SWQgfHwgbnVsbDtcbiAgICB0aGlzLnNlY3Rpb25zID0gZGF0YS5zZWN0aW9ucyB8fCBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzZWFyY2gsIHVzZWQgdG8gcmVuZGVyIGRpZmZlcmVudCB0ZW1wbGF0ZXMgYmVmb3JlLCBkdXJpbmcsXG4gICAgICogYW5kIGFmdGVyIGxvYWRpbmdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoU3RhdGUgPSBkYXRhLnNlYXJjaFN0YXRlIHx8IFNlYXJjaFN0YXRlcy5TRUFSQ0hfQ09NUExFVEU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHVuaXZlcnNhbCByZXN1bHRzIGZyb20gc2VydmVyIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHVybHMgVGhlIHRhYiB1cmxzXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBUaGUgZmllbGQgZm9ybWF0dGVycyB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSwgdXJscywgZm9ybWF0dGVycykge1xuICAgIHJldHVybiBuZXcgVW5pdmVyc2FsUmVzdWx0cyh7XG4gICAgICBxdWVyeUlkOiByZXNwb25zZS5xdWVyeUlkLFxuICAgICAgc2VjdGlvbnM6IFNlY3Rpb24uZnJvbShyZXNwb25zZS5tb2R1bGVzLCB1cmxzLCBmb3JtYXR0ZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFVuaXZlcnZhbFJlc3VsdHMgb2JqZWN0IHJlcHJlc2VudGluZyBsb2FkaW5nIHJlc3VsdHNcbiAgICogQHJldHVybiB7VW5pdmVyc2FsUmVzdWx0c31cbiAgICovXG4gIHN0YXRpYyBzZWFyY2hMb2FkaW5nICgpIHtcbiAgICByZXR1cm4gbmV3IFVuaXZlcnNhbFJlc3VsdHMoeyBzZWFyY2hTdGF0ZTogU2VhcmNoU3RhdGVzLlNFQVJDSF9MT0FESU5HIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBEaXJlY3RBbnN3ZXIgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0QW5zd2VyIHtcbiAgY29uc3RydWN0b3IgKGRpcmVjdEFuc3dlciA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkaXJlY3RBbnN3ZXIpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGlyZWN0QW5zd2VyIG1vZGVsIGZyb20gdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCBmb3JtYXR0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIGRpcmVjdCBhbnN3ZXJcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmb3JtYXR0ZXJzIHRvIGFwcGx5IHRvIHRoaXMgZGlyZWN0IGFuc3dlclxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlLCBmb3JtYXR0ZXJzKSB7XG4gICAgY29uc3QgZGF0YSA9IHsgLi4ucmVzcG9uc2UgfTtcbiAgICBjb25zdCB7IGFuc3dlciwgcmVsYXRlZEl0ZW0gfSA9IGRhdGE7XG5cbiAgICBpZiAoYW5zd2VyICYmIGZvcm1hdHRlcnNbYW5zd2VyLmZpZWxkQXBpTmFtZV0pIHtcbiAgICAgIGFuc3dlci52YWx1ZSA9IGZvcm1hdHRlcnNbYW5zd2VyLmZpZWxkQXBpTmFtZV0oXG4gICAgICAgIGFuc3dlci52YWx1ZSxcbiAgICAgICAgcmVsYXRlZEl0ZW0uZGF0YS5maWVsZFZhbHVlcyxcbiAgICAgICAgcmVsYXRlZEl0ZW0udmVydGljYWxDb25maWdJZCxcbiAgICAgICAgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEaXJlY3RBbnN3ZXIoZGF0YSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE5hdmlnYXRpb24gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbiB7XG4gIGNvbnN0cnVjdG9yICh0YWJPcmRlcikge1xuICAgIHRoaXMudGFiT3JkZXIgPSB0YWJPcmRlciB8fCBbXTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGZyb20gKG1vZHVsZXMpIHtcbiAgICBsZXQgbmF2ID0gW107XG4gICAgaWYgKCFtb2R1bGVzIHx8ICFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICByZXR1cm4gbmF2O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hdi5wdXNoKG1vZHVsZXNbaV0udmVydGljYWxDb25maWdJZCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbihuYXYpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBWZXJ0aWNhbFJlc3VsdHMgKi9cblxuaW1wb3J0IFNlY3Rpb24gZnJvbSAnLi9zZWN0aW9uJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0aWNhbFJlc3VsdHMge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IHNlYXJjaFN0YXRlOiBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFIH0sIGRhdGEpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwcm92aWRlZCByZXN1bHRzIHRvIHRoZSBjdXJyZW50IHJlc3VsdHNcbiAgICogQHBhcmFtIHtWZXJ0aWNhbFJlc3VsdHN9IHJlc3VsdHMgdGhlIHJlc3VsdHMgdG8gYXBwZW5kIHRvIHRoZSBjdXJyZW50IHJlc3VsdHNcbiAgICovXG4gIGFwcGVuZCAocmVzdWx0cykge1xuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4udGhpcyB9O1xuICAgIG1lcmdlZC5yZXN1bHRzID0gdGhpcy5yZXN1bHRzLmNvbmNhdChyZXN1bHRzLnJlc3VsdHMpO1xuICAgIG1lcmdlZC5tYXAubWFwTWFya2VycyA9IHRoaXMubWFwLm1hcE1hcmtlcnMuY29uY2F0KHJlc3VsdHMubWFwLm1hcE1hcmtlcnMpO1xuICAgIHJldHVybiBuZXcgVmVydGljYWxSZXN1bHRzKG1lcmdlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHZlcnRpY2FsIHJlc3VsdHMgZnJvbSBzZXJ2ZXIgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZpZWxkIGZvcm1hdHRlcnMgdG8gdXNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UsIGZvcm1hdHRlcnMpIHtcbiAgICByZXR1cm4gbmV3IFZlcnRpY2FsUmVzdWx0cyhTZWN0aW9uLmZyb20ocmVzcG9uc2UsIG51bGwsIGZvcm1hdHRlcnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBWZXJ0aWNhbFJlc3VsdHMgb2JqZWN0IHJlcHJlc2VudGluZyBsb2FkaW5nIHJlc3VsdHNcbiAgICogQHJldHVybiB7VmVydGljYWxSZXN1bHRzfVxuICAgKi9cbiAgc3RhdGljIHNlYXJjaExvYWRpbmcgKCkge1xuICAgIHJldHVybiBuZXcgVmVydGljYWxSZXN1bHRzKHsgc2VhcmNoU3RhdGU6IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTcGVsbENoZWNrICovXG5cbmltcG9ydCBIaWdobGlnaHRlZFZhbHVlIGZyb20gJy4vaGlnaGxpZ2h0ZWR2YWx1ZSc7XG5cbi8qKlxuICogU3BlbGxDaGVjayBpcyB0aGUgY29yZSBzdGF0ZSBtb2RlbFxuICogdG8gcG93ZXIgdGhlIFNwZWxsQ2hlY2sgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWxsQ2hlY2sge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IGRhdGEucXVlcnkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JyZWN0ZWQgcXVlcnlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29ycmVjdGVkUXVlcnkgPSBkYXRhLmNvcnJlY3RlZFF1ZXJ5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ycmVjdGVkIHF1ZXJ5IHdpdGggaGlnaGxpZ2h0ZWQgdGFnc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb3JyZWN0ZWRRdWVyeURpc3BsYXkgPSBkYXRhLmNvcnJlY3RlZFF1ZXJ5RGlzcGxheSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWxsIGNoZWNrIHR5cGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHNob3cgc3BlbGwgY2hlY2sgb3Igbm90XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG91bGRTaG93ID0gdGhpcy5jb3JyZWN0ZWRRdWVyeSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzcGVsbCBjaGVjayBtb2RlbCBmcm9tIHRoZSBwcm92aWRlZCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc3BlbGwgY2hlY2sgcmVzcG9uc2VcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNwZWxsQ2hlY2soe1xuICAgICAgcXVlcnk6IHJlc3BvbnNlLm9yaWdpbmFsUXVlcnksXG4gICAgICBjb3JyZWN0ZWRRdWVyeTogcmVzcG9uc2UuY29ycmVjdGVkUXVlcnksXG4gICAgICBjb3JyZWN0ZWRRdWVyeURpc3BsYXk6IG5ldyBIaWdobGlnaHRlZFZhbHVlKHJlc3BvbnNlLmNvcnJlY3RlZFF1ZXJ5KS5nZXQoKSxcbiAgICAgIHR5cGU6IHJlc3BvbnNlLnR5cGVcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3RvcmFnZUtleXMgKi9cblxuLyoqXG4gKiBTdG9yYWdlS2V5cyBpcyBhbiBFTlVNIGFyZSBjb25zaWRlcmVkIHRoZSByb290IGNvbnRleHRcbiAqIGZvciBob3cgZGF0YSBpcyBzdG9yZWQgYW5kIHNjb3BlZCBpbiB0aGUgc3RvcmFnZS5cbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE5BVklHQVRJT046ICduYXZpZ2F0aW9uJyxcbiAgVU5JVkVSU0FMX1JFU1VMVFM6ICd1bml2ZXJzYWwtcmVzdWx0cycsXG4gIFZFUlRJQ0FMX1JFU1VMVFM6ICd2ZXJ0aWNhbC1yZXN1bHRzJyxcbiAgQVVUT0NPTVBMRVRFOiAnYXV0b2NvbXBsZXRlJyxcbiAgRElSRUNUX0FOU1dFUjogJ2RpcmVjdC1hbnN3ZXInLFxuICBGSUxURVI6ICdmaWx0ZXInLFxuICBRVUVSWTogJ3F1ZXJ5JyxcbiAgUVVFUllfSUQ6ICdxdWVyeS1pZCcsXG4gIEZBQ0VUX0ZJTFRFUjogJ2ZhY2V0LWZpbHRlcicsXG4gIERZTkFNSUNfRklMVEVSUzogJ2R5bmFtaWMtZmlsdGVycycsXG4gIFBBUkFNUzogJ3BhcmFtcycsXG4gIEdFT0xPQ0FUSU9OOiAnZ2VvbG9jYXRpb24nLFxuICBJTlRFTlRTOiAnaW50ZW50cycsXG4gIFFVRVNUSU9OX1NVQk1JU1NJT046ICdxdWVzdGlvbi1zdWJtaXNzaW9uJyxcbiAgU0VBUkNIX0NPTkZJRzogJ3NlYXJjaC1jb25maWcnLFxuICBTRUFSQ0hfT0ZGU0VUOiAnc2VhcmNoLW9mZnNldCcsXG4gIFNQRUxMX0NIRUNLOiAnc3BlbGwtY2hlY2snLFxuICBMT0NBVElPTl9CSUFTOiAnbG9jYXRpb24tYmlhcycsXG4gIFNFU1NJT05TX09QVF9JTjogJ3Nlc3Npb25zLW9wdC1pbicsXG4gIE5BVklHQVRJT05fQ09ORklHOiAnbmF2aWdhdGlvbi1jb25maWcnLFxuICBMT0NBTEU6ICdsb2NhbGUnLFxuICBTT1JUX0JZUzogJ3NvcnQtYnlzJ1xufTtcbiIsIi8qKiBAbW9kdWxlIER5bmFtaWNGaWx0ZXJzICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgc2V0IG9mIGR5bmFtaWMgZmlsdGVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEeW5hbWljRmlsdGVycyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVycyB0aGlzIG1vZGVsIGhvbGRzXG4gICAgICogQHR5cGUge3tsYWJlbDogc3RyaW5nLCBmaWVsZElkOiBzdHJpbmcsIG9wdGlvbnM6IG9iamVjdFtdfX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcnMgPSBkYXRhLmZpbHRlcnMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcmdhbml6ZSAnZmFjZXRzJyBmcm9tIHRoZSBhcGkgcmVzcG9uc2UgaW50byBkeW5hbWljIGZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIGR5bmFtaWMgZmlsdGVyIHJlc3BvbnNlIGZyb20gdGhlIGFwaVxuICAgKiBAcmV0dXJucyB7RHluYW1pY0ZpbHRlcnN9XG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IGZhY2V0cyB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3QgZHluYW1pY0ZpbHRlcnMgPSBmYWNldHMubWFwKGYgPT4gKHtcbiAgICAgIGxhYmVsOiBmWydkaXNwbGF5TmFtZSddLFxuICAgICAgZmllbGRJZDogZlsnZmllbGRJZCddLFxuICAgICAgb3B0aW9uczogZi5vcHRpb25zLm1hcChvID0+ICh7XG4gICAgICAgIGxhYmVsOiBvWydkaXNwbGF5TmFtZSddLFxuICAgICAgICBjb3VudExhYmVsOiBvWydjb3VudCddLFxuICAgICAgICBzZWxlY3RlZDogb1snc2VsZWN0ZWQnXSxcbiAgICAgICAgZmlsdGVyOiBvWydmaWx0ZXInXVxuICAgICAgfSkpXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIG5ldyBEeW5hbWljRmlsdGVycyh7IGZpbHRlcnM6IGR5bmFtaWNGaWx0ZXJzIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hJbnRlbnRzICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEludGVudHMge1xuICBjb25zdHJ1Y3RvciAoaW50ZW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlbnQgdG8gZmluZCByZXN1bHRzIGJhc2VkIG9uIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5lYXJNZSA9IGludGVudHMubmVhck1lO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgU2VhcmNoSW50ZW50cyBmcm9tIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciByZXNwb25zZSBpbnRlbnRzXG4gICAqIEByZXR1cm5zIHtTZWFyY2hJbnRlbnRzfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgaW50ZW50cyA9IHJlc3BvbnNlIHx8IFtdO1xuXG4gICAgcmV0dXJuIG5ldyBTZWFyY2hJbnRlbnRzKHtcbiAgICAgIG5lYXJNZTogaW50ZW50cy5pbmNsdWRlcygnTkVBUl9NRScpXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIExvY2F0aW9uQmlhcyAqL1xuXG4vKipcbiAqIExvY2F0aW9uQmlhcyBpcyB0aGUgY29yZSBzdGF0ZSBtb2RlbFxuICogdG8gcG93ZXIgdGhlIExvY2F0aW9uQmlhcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25CaWFzIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gYmlhcyBhY2N1cmFjeSB3aGljaCBhcmUgSVAsIERFVklDRSBhbmQgVU5LTldPTlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hY2N1cmFjeSA9IGRhdGEuYWNjdXJhY3kgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZSB1c2VkIGZvciBsb2NhdGlvbiBiaWFzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhdGl0dWRlID0gZGF0YS5sYXRpdHVkZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvbmdpdHVkZSB1c2VkIGZvciBsb2NhdGlvbiBiaWFzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvbmdpdHVkZSA9IGRhdGEubG9uZ2l0dWRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gZGlzcGxheSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxvY2F0aW9uRGlzcGxheU5hbWUgPSBkYXRhLmxvY2F0aW9uRGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhdGlvbiBiaWFzIG1vZGVsIGZyb20gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBsb2NhdGlvbiBiaWFzIHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbmV3IExvY2F0aW9uQmlhcyh7XG4gICAgICAgIGFjY3VyYWN5OiAnVU5LTk9XTidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9jYXRpb25CaWFzKHtcbiAgICAgIGFjY3VyYWN5OiByZXNwb25zZS5hY2N1cmFjeSxcbiAgICAgIGxhdGl0dWRlOiByZXNwb25zZS5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogcmVzcG9uc2UubG9uZ2l0dWRlLFxuICAgICAgbG9jYXRpb25EaXNwbGF5TmFtZTogcmVzcG9uc2UubG9jYXRpb25EaXNwbGF5TmFtZVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hEYXRhVHJhbnNmb3JtZXIgKi9cblxuaW1wb3J0IFVuaXZlcnNhbFJlc3VsdHMgZnJvbSAnLi4vbW9kZWxzL3VuaXZlcnNhbHJlc3VsdHMnO1xuaW1wb3J0IERpcmVjdEFuc3dlciBmcm9tICcuLi9tb2RlbHMvZGlyZWN0YW5zd2VyJztcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uL21vZGVscy9uYXZpZ2F0aW9uJztcbmltcG9ydCBWZXJ0aWNhbFJlc3VsdHMgZnJvbSAnLi4vbW9kZWxzL3ZlcnRpY2FscmVzdWx0cyc7XG5pbXBvcnQgU3BlbGxDaGVjayBmcm9tICcuLi9tb2RlbHMvc3BlbGxjaGVjayc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRHluYW1pY0ZpbHRlcnMgZnJvbSAnLi4vbW9kZWxzL2R5bmFtaWNmaWx0ZXJzJztcbmltcG9ydCBTZWFyY2hJbnRlbnRzIGZyb20gJy4uL21vZGVscy9zZWFyY2hpbnRlbnRzJztcbmltcG9ydCBMb2NhdGlvbkJpYXMgZnJvbSAnLi4vbW9kZWxzL2xvY2F0aW9uYmlhcyc7XG5cbi8qKlxuICogQSBEYXRhIFRyYW5zZm9ybWVyIHRoYXQgdGFrZXMgdGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIGEgU2VhcmNoIHJlcXVlc3RcbiAqIEFuZCB0cmFuc2Zvcm1zIGluIHRvIGEgZnJvbnQtZW5kIG9yaWVudGVkIGRhdGEgc3RydWN0dXJlIHRoYXQgb3VyXG4gKiBjb21wb25lbnQgbGlicmFyeSBhbmQgY29yZSBzdG9yYWdlIHVuZGVyc3RhbmQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaERhdGFUcmFuc2Zvcm1lciB7XG4gIHN0YXRpYyB0cmFuc2Zvcm0gKGRhdGEsIHVybHMgPSB7fSwgZm9ybWF0dGVycykge1xuICAgIGxldCByZXNwb25zZSA9IGRhdGEucmVzcG9uc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTdG9yYWdlS2V5cy5RVUVSWV9JRF06IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBbU3RvcmFnZUtleXMuTkFWSUdBVElPTl06IE5hdmlnYXRpb24uZnJvbShyZXNwb25zZS5tb2R1bGVzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSXTogRGlyZWN0QW5zd2VyLmZyb20ocmVzcG9uc2UuZGlyZWN0QW5zd2VyLCBmb3JtYXR0ZXJzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU106IFVuaXZlcnNhbFJlc3VsdHMuZnJvbShyZXNwb25zZSwgdXJscywgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuSU5URU5UU106IFNlYXJjaEludGVudHMuZnJvbShyZXNwb25zZS5zZWFyY2hJbnRlbnRzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS106IFNwZWxsQ2hlY2suZnJvbShyZXNwb25zZS5zcGVsbENoZWNrKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXTogTG9jYXRpb25CaWFzLmZyb20ocmVzcG9uc2UubG9jYXRpb25CaWFzKVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdHJhbnNmb3JtVmVydGljYWwgKGRhdGEsIGZvcm1hdHRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1N0b3JhZ2VLZXlzLlFVRVJZX0lEXTogZGF0YS5yZXNwb25zZS5xdWVyeUlkLFxuICAgICAgW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dOiBuZXcgTmF2aWdhdGlvbigpLCAvLyBWZXJ0aWNhbCBkb2Vzbid0IHJlc3BvbmQgd2l0aCBvcmRlcmluZywgc28gdXNlIGVtcHR5IG5hdi5cbiAgICAgIFtTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTXTogVmVydGljYWxSZXN1bHRzLmZyb20oZGF0YS5yZXNwb25zZSwgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTXTogRHluYW1pY0ZpbHRlcnMuZnJvbShkYXRhLnJlc3BvbnNlKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5JTlRFTlRTXTogU2VhcmNoSW50ZW50cy5mcm9tKGRhdGEucmVzcG9uc2Uuc2VhcmNoSW50ZW50cyksXG4gICAgICBbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdOiBTcGVsbENoZWNrLmZyb20oZGF0YS5yZXNwb25zZS5zcGVsbENoZWNrKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXTogTG9jYXRpb25CaWFzLmZyb20oZGF0YS5yZXNwb25zZS5sb2NhdGlvbkJpYXMpXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUXVlc3Rpb25TdWJtaXNzaW9uICovXG5cbi8qKlxuICogUXVlc3Rpb25TdWJtaXNzaW9uIGlzIHRoZSBjb3JlIHN0YXRlIG1vZGVsXG4gKiB0byBwb3dlciB0aGUgUXVlc3Rpb25TdWJtaXNzaW9uIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVzdGlvblN1Ym1pc3Npb24ge1xuICBjb25zdHJ1Y3RvciAocXVlc3Rpb24gPSB7fSwgZXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGF1dGhvciBvZiB0aGUgcXVlc3Rpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IHF1ZXN0aW9uLm5hbWUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSBxdWVzdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5lbWFpbCA9IHF1ZXN0aW9uLmVtYWlsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwcml2YWN5IHBvbGljeSB3YXMgYXBwcm92ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByaXZhY3lQb2xpY3kgPSBxdWVzdGlvbi5wcml2YWN5UG9saWN5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlc3Rpb24gdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uVGV4dCA9IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQWx0ZXJuYXRpdmUgcXVlc3Rpb24gbWV0YSBpbmZvcm1hdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvbkRlc2NyaXB0aW9uID0gcXVlc3Rpb24ucXVlc3Rpb25EZXNjcmlwdGlvbiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZm9ybSBpcyBleHBhbmRlZCBvciBub3QuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvbkV4cGFuZGVkID0gdHlwZW9mIHF1ZXN0aW9uLmV4cGFuZGVkICE9PSAnYm9vbGVhbicgfHwgcXVlc3Rpb24uZXhwYW5kZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhbnkgZXJyb3JzIGFib3V0IHRoZSBxdWVzdGlvbiBzdWJtaXNzaW9uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZm9ybSBoYXMgYmVlbiBzdWJtaXR0ZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uU3VibWl0dGVkID0gcXVlc3Rpb24uc3VibWl0dGVkIHx8IGZhbHNlO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBzdWJtaXR0ZWQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBxdWVzdGlvblN1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgIHF1ZXN0aW9uRXhwYW5kZWQ6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGVycm9ycyAocXVlc3Rpb24sIGVycm9ycykge1xuICAgIHJldHVybiBRdWVzdGlvblN1Ym1pc3Npb24ocXVlc3Rpb24sIGVycm9ycyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlciAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXBpIGZpbHRlciBhbmQgcHJvdmlkZXMgc3RhdGljIG1ldGhvZHMgZm9yIGVhc2lseSBjb25zdHJ1Y3RpbmcgRmlsdGVycy5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci55ZXh0LmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvI29wZXJhdGlvbi9saXN0RW50aXRpZXMgZm9yIHN0cnVjdHVyZSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBKU09OIGZvcm1hdCBmaWx0ZXIgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGludG8gYSBGaWx0ZXJcbiAgICogQHBhcmFtIHsqfSByZXNwb25zZUZpbHRlciBBIGZpbHRlciBpbiBKU09OIGZvcm1hdCByZXR1cm5lZCBmcm9tIHRoZSBiYWNrZW5kXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlc3BvbnNlIChyZXNwb25zZUZpbHRlcikge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKEpTT04ucGFyc2UocmVzcG9uc2VGaWx0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgRmlsdGVyIHJlcHJlc2VudGluZyB0aGUgT1Igb2YgYWxsIHByb3ZpZGVkIGZpbHRlcnNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIE9SIHRvZ2V0aGVyXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgb3IgKC4uLmZpbHRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICAnJG9yJzogZmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBGaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSBBTkQgb2YgYWxsIHByb3ZpZGVkIGZpbHRlcnNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIEFORCB0b2dldGhlclxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGFuZCAoLi4uZmlsdGVycykge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgICckYW5kJzogZmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9SIGZpbHRlcnMgd2l0aCB0aGUgc2FtZSBrZXlzLCB0aGVuIEFORCB0aGUgcmVzdWx0aW5nIGdyb3Vwc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gZ3JvdXBcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBncm91cCAoLi4uZmlsdGVycykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKGZpbHRlcilbMF07XG4gICAgICBpZiAoIWdyb3Vwc1trZXldKSB7XG4gICAgICAgIGdyb3Vwc1trZXldID0gW107XG4gICAgICB9XG4gICAgICBncm91cHNba2V5XS5wdXNoKGZpbHRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBGaWx0ZXJzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3Qua2V5cyhncm91cHMpKSB7XG4gICAgICBncm91cEZpbHRlcnMucHVzaChncm91cHNbZmllbGRdLmxlbmd0aCA+IDEgPyBGaWx0ZXIub3IoLi4uZ3JvdXBzW2ZpZWxkXSkgOiBncm91cHNbZmllbGRdWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBGaWx0ZXJzLmxlbmd0aCA+IDEgPyBGaWx0ZXIuYW5kKC4uLmdyb3VwRmlsdGVycykgOiBncm91cEZpbHRlcnNbMF07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwiZXF1YWwgdG9cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBlcXVhbCB0b1xuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGVxdWFsIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRlcScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJsZXNzIHRoYW5cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW5cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBsZXNzVGhhbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckbHQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgbGVzc1RoYW5FcXVhbCAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckbGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwiZ3JlYXRlciB0aGFuXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ3JlYXRlclRoYW4gKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGd0JywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1wiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGdyZWF0ZXJUaGFuRXF1YWwgKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGdlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmNsdXNpdmUgcmFuZ2UgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgaW5jbHVzaXZlUmFuZ2UgKGZpZWxkLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgJyRnZSc6IG1pbixcbiAgICAgICAgJyRsZSc6IG1heFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBleGNsdXNpdmUgcmFuZ2UgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZXhjbHVzaXZlUmFuZ2UgKGZpZWxkLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgJyRndCc6IG1pbixcbiAgICAgICAgJyRsdCc6IG1heFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiBmaWx0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgb2YgdGhlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsbmcgVGhlIGxvbmdpdHVkZSBvZiB0aGUgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc2VhcmNoIHJhZGl1cyAoaW4gbWV0ZXJzKVxuICAgKi9cbiAgc3RhdGljIHBvc2l0aW9uIChsYXQsIGxuZywgcmFkaXVzKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoJ2J1aWx0aW4ubG9jYXRpb24nLCAnJG5lYXInLCB7IGxhdCwgbG5nLCByYWRpdXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZpbHRlciB3aXRoIHRoZSBnaXZlbiBtYXRjaGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaGVyIFRoZSBtYXRjaGVyIGZvciB0aGUgZmlsZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBmaWx0ZXJcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBfZnJvbU1hdGNoZXIgKGZpZWxkLCBtYXRjaGVyLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgW21hdGNoZXJdOiB2YWx1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBDb3JlICovXG5cbmltcG9ydCBTZWFyY2hEYXRhVHJhbnNmb3JtZXIgZnJvbSAnLi9zZWFyY2gvc2VhcmNoZGF0YXRyYW5zZm9ybWVyJztcblxuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgVmVydGljYWxSZXN1bHRzIGZyb20gJy4vbW9kZWxzL3ZlcnRpY2FscmVzdWx0cyc7XG5pbXBvcnQgVW5pdmVyc2FsUmVzdWx0cyBmcm9tICcuL21vZGVscy91bml2ZXJzYWxyZXN1bHRzJztcbmltcG9ydCBRdWVzdGlvblN1Ym1pc3Npb24gZnJvbSAnLi9tb2RlbHMvcXVlc3Rpb25zdWJtaXNzaW9uJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9tb2RlbHMvZmlsdGVyJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2VydmljZXMvc2VhcmNoc2VydmljZScpLmRlZmF1bHR9IFNlYXJjaFNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlcnZpY2VzL2F1dG9jb21wbGV0ZXNlcnZpY2UnKS5kZWZhdWx0fSBBdXRvQ29tcGxldGVTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zZXJ2aWNlcy9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBDb3JlIGlzIHRoZSBtYWluIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBuZXR3b3JrIGFuZCBzdG9yYWdlXG4gKiByZWxhdGVkIGJlaGF2aW9ycyBvZiB0aGUgYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmUge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2xpZW50IEFQSSBLZXkgdXNlZCBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2xpZW50IEFuc3dlcnMgS2V5IHVzZWQgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlS2V5ID0gY29uZmlnLmV4cGVyaWVuY2VLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGllbnQgbG9jYWxlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cy4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gXCJlblwiIChmb3JcbiAgICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBmaWVsZCBmb3JtYXR0ZXJzIHVzZWQgdG8gZm9ybWF0IHJlc3VsdHMsIGlmIHByZXNlbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkRm9ybWF0dGVycyA9IGNvbmZpZy5maWVsZEZvcm1hdHRlcnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29yZSBkYXRhIHN0b3JhZ2UgdGhhdCBwb3dlcnMgdGhlIFVJXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2UgPSBjb25maWcuZ2xvYmFsU3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqIEB0eXBlIHtQZXJzaXN0ZW50U3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGVyc2lzdGVudFN0b3JhZ2UgPSBjb25maWcucGVyc2lzdGVudFN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiBjb250YWluaW5nIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBSRVNUZnVsIHNlYXJjaCBBUElcbiAgICAgKiBGb3IgYm90aCB2ZXJ0aWNhbCBhbmQgdW5pdmVyc2FsIHNlYXJjaFxuICAgICAqIEB0eXBlIHtTZWFyY2hTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoZXIgPSBjb25maWcuc2VhcmNoU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFic3RyYWN0aW9uIGNvbnRhaW5pbmcgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIFJFU1RmdWwgYXV0b2NvbXBsZXRlIEFQSVxuICAgICAqIEZvciBmaWx0ZXIgc2VhcmNoLCB2ZXJ0aWNhbCBhdXRvY29tcGxldGUsIGFuZCB1bml2ZXJzYWwgYXV0b2NvbXBsZXRlXG4gICAgICogQHR5cGUge0F1dG9Db21wbGV0ZVNlcnZpY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hdXRvQ29tcGxldGUgPSBjb25maWcuYXV0b0NvbXBsZXRlU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFic3RyYWN0aW9uIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBRJkEgcmVzdCBpbnRlcmZhY2VcbiAgICAgKiBAdHlwZSB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcXVlc3Rpb25BbnN3ZXIgPSBjb25maWcucXVlc3Rpb25BbnN3ZXJTZXJ2aWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBpbiB0aGUgY29udGV4dCBvZiBhIHZlcnRpY2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSB2ZXJ0aWNhbCBJRCBmb3IgdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgVGhlIHF1ZXJ5IGRldGFpbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmlucHV0IFRoZSBpbnB1dCB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeS5maWx0ZXIgVGhlIGZpbHRlciB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkuZmFjZXRGaWx0ZXIgVGhlIGZhY2V0IGZpbHRlciB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVlcnkubGltaXQgVGhlIG1heCBudW1iZXIgb2YgcmVzdWx0cyB0byBpbmNsdWRlLCBtYXggb2YgNTBcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1ZXJ5Lm9mZnNldCBUaGUgcmVzdWx0cyBvZmZzZXQsIGZvciBmZXRjaGluZyBtb3JlIHJlc3VsdHMgb2YgdGhlIHNhbWUgcXVlcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmlkIFRoZSBxdWVyeSBJRCB0byB1c2UuIElmIHBhZ2luZyB3aXRoaW4gYSBxdWVyeSwgdGhlIHNhbWUgSUQgc2hvdWxkIGJlIHVzZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBxdWVyeS5hcHBlbmQgSWYgdHJ1ZSwgYWRkcyB0aGUgcmVzdWx0cyBvZiB0aGlzIHF1ZXJ5IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmVzdWx0cywgZGVmYXVsdHMgZmFsc2VcbiAgICovXG4gIHZlcnRpY2FsU2VhcmNoICh2ZXJ0aWNhbEtleSwgcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5LmFwcGVuZCkge1xuICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTLCBWZXJ0aWNhbFJlc3VsdHMuc2VhcmNoTG9hZGluZygpKTtcbiAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0ssIHt9KTtcbiAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUywge30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZWFyY2hlclxuICAgICAgLnZlcnRpY2FsU2VhcmNoKHZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGxpbWl0OiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQsXG4gICAgICAgIGdlb2xvY2F0aW9uOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04pLFxuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQ6IHRoaXMuX2lzRHluYW1pY0ZpbHRlcnNFbmFibGVkLFxuICAgICAgICBza2lwU3BlbGxDaGVjazogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdza2lwU3BlbGxDaGVjaycpLFxuICAgICAgICBxdWVyeVRyaWdnZXI6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSgncXVlcnlUcmlnZ2VyJyksXG4gICAgICAgIHNlc3Npb25UcmFja2luZ0VuYWJsZWQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRVNTSU9OU19PUFRfSU4pLFxuICAgICAgICBzb3J0QnlzOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU09SVF9CWVMpXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gU2VhcmNoRGF0YVRyYW5zZm9ybWVyLnRyYW5zZm9ybVZlcnRpY2FsKHJlc3BvbnNlLCB0aGlzLl9maWVsZEZvcm1hdHRlcnMpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIGRhdGFbU3RvcmFnZUtleXMuUVVFUllfSURdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OLCBkYXRhW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5JTlRFTlRTLCBkYXRhW1N0b3JhZ2VLZXlzLklOVEVOVFNdKTtcblxuICAgICAgICBpZiAocXVlcnkuYXBwZW5kKSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkUmVzdWx0cyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTKVxuICAgICAgICAgICAgLmFwcGVuZChkYXRhW1N0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFNdKTtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIG1lcmdlZFJlc3VsdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlMsIGRhdGFbU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TUEVMTF9DSEVDSywgZGF0YVtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCBkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdza2lwU3BlbGxDaGVjaycpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdxdWVyeVRyaWdnZXInKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhZ2Ugd2l0aGluIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSBUaGUgdmVydGljYWwga2V5IHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKi9cbiAgdmVydGljYWxQYWdlICh2ZXJ0aWNhbEtleSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgdGhpcy52ZXJ0aWNhbFNlYXJjaCh2ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSksXG4gICAgICBpZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZX0lEKSxcbiAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKSxcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG5cbiAgc2VhcmNoIChxdWVyeVN0cmluZywgdXJscykge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuRElSRUNUX0FOU1dFUiwge30pO1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFMsIFVuaXZlcnNhbFJlc3VsdHMuc2VhcmNoTG9hZGluZygpKTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT04sIHt9KTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCB7fSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCB7fSk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoZXJcbiAgICAgIC51bml2ZXJzYWxTZWFyY2gocXVlcnlTdHJpbmcsIHtcbiAgICAgICAgZ2VvbG9jYXRpb246IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiksXG4gICAgICAgIHNraXBTcGVsbENoZWNrOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3NraXBTcGVsbENoZWNrJyksXG4gICAgICAgIHF1ZXJ5VHJpZ2dlcjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdxdWVyeVRyaWdnZXInKSxcbiAgICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTilcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBTZWFyY2hEYXRhVHJhbnNmb3JtZXIudHJhbnNmb3JtKHJlc3BvbnNlLCB1cmxzLCB0aGlzLl9maWVsZEZvcm1hdHRlcnMpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIGRhdGFbU3RvcmFnZUtleXMuUVVFUllfSURdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OLCBkYXRhW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSLCBkYXRhW1N0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVJdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU10sIHVybHMpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLklOVEVOVFMsIGRhdGFbU3RvcmFnZUtleXMuSU5URU5UU10pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCBkYXRhW1N0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUywgZGF0YVtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3NraXBTcGVsbENoZWNrJyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3F1ZXJ5VHJpZ2dlcicpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHF1ZXJ5IGZvciBhIGxpc3Qgb2Ygc2ltaWxhciByZXN1bHRzIGFuZCBzZXQgaW50byBzdG9yYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAgICAgdGhlIHN0cmluZyB0byBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqL1xuICBhdXRvQ29tcGxldGVVbml2ZXJzYWwgKGlucHV0LCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlXG4gICAgICAucXVlcnlVbml2ZXJzYWwoaW5wdXQpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7bmFtZXNwYWNlfWAsIGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGlucHV0LCBxdWVyeSBmb3IgYSBsaXN0IG9mIHNpbWlsYXIgcmVzdWx0cyBpbiB0aGUgcHJvdmlkZWQgdmVydGljYWxcbiAgICogYW5kIHNldCBpbnRvIHN0b3JhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICAgICAgIHRoZSBzdHJpbmcgdG8gYXV0b2NvbXBsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBzdG9yYWdlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxLZXkgdGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIGV4cGVyaWVuY2VcbiAgICovXG4gIGF1dG9Db21wbGV0ZVZlcnRpY2FsIChpbnB1dCwgbmFtZXNwYWNlLCB2ZXJ0aWNhbEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvQ29tcGxldGVcbiAgICAgIC5xdWVyeVZlcnRpY2FsKGlucHV0LCB2ZXJ0aWNhbEtleSlcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHtuYW1lc3BhY2V9YCwgZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHByb3ZpZGUgYSBsaXN0IG9mIHN1aXRhYmxlIGZpbHRlcnMgZm9yIGF1dG9jb21wbGV0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAgdGhlIHN0cmluZyB0byBzZWFyY2ggZm9yIGZpbHRlcnMgd2l0aFxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnICB0aGUgY29uZmlnIHRvIHNlcmFjaCBmb3IgZmlsdGVycyB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcubmFtZXNwYWNlICB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcudmVydGljYWxLZXkgdGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIGNvbmZpZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnLnNlYXJjaFBhcmFtZXRlcnMgIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBmb3IgdGhlIGNvbmZpZyB2MlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9Db21wbGV0ZVxuICAgICAgLnF1ZXJ5RmlsdGVyKGlucHV0LCBjb25maWcpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7Y29uZmlnLm5hbWVzcGFjZX1gLCBkYXRhKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYSBxdWVzdGlvbiB0byB0aGUgc2VydmVyIGFuZCB1cGRhdGVzIHRoZSB1bmRlcmx5aW5nIHF1ZXN0aW9uIG1vZGVsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVzdGlvbiBUaGUgcXVlc3Rpb24gb2JqZWN0IHRvIHN1Ym1pdCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWVzdGlvbi5lbnRpdHlJZCBUaGUgZW50aXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBxdWVzdGlvbiAocmVxdWlyZWQpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVzdGlvbi5sYW51YWdlIFRoZSBsYW5ndWFnZSBvZiB0aGUgcXVlc3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnNpdGUgVGhlIFwicHVibGlzaGVyXCIgb2YgdGhlIChlLmcuICdGSVJTVF9QQVJUWScpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVzdGlvbi5uYW1lIFRoZSBuYW1lIG9mIHRoZSBhdXRob3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLmVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSBhdXRob3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCBUaGUgcXVlc3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLnF1ZXN0aW9uRGVzY3JpcHRpb24gQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcXVlc3Rpb25cbiAgICovXG4gIHN1Ym1pdFF1ZXN0aW9uIChxdWVzdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9xdWVzdGlvbkFuc3dlclxuICAgICAgLnN1Ym1pdFF1ZXN0aW9uKHF1ZXN0aW9uKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoXG4gICAgICAgICAgU3RvcmFnZUtleXMuUVVFU1RJT05fU1VCTUlTU0lPTixcbiAgICAgICAgICBRdWVzdGlvblN1Ym1pc3Npb24uc3VibWl0dGVkKCkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBzb3J0QnkgaW50byBzdG9yYWdlLCB0byBiZSB1c2VkIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvcnRCeU9wdGlvbnNcbiAgICovXG4gIHNldFNvcnRCeXMgKC4uLnNvcnRCeU9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3J0QnlzID0gc29ydEJ5T3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IG9wdGlvbi50eXBlLFxuICAgICAgICBmaWVsZDogb3B0aW9uLmZpZWxkLFxuICAgICAgICBkaXJlY3Rpb246IG9wdGlvbi5kaXJlY3Rpb25cbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TT1JUX0JZUywgSlNPTi5zdHJpbmdpZnkoc29ydEJ5cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgc29ydEJ5cyBrZXkgaW4gZ2xvYmFsIHN0b3JhZ2UuXG4gICAqL1xuICBjbGVhclNvcnRCeXMgKCkge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU09SVF9CWVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gcXVlcnkgaW50byBzdG9yYWdlLCB0byBiZSB1c2VkIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBxdWVyeSB0byBzdG9yZVxuICAgKi9cbiAgc2V0UXVlcnkgKHF1ZXJ5KSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWSwgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgcXVlcnkgSUQsIHRvIGJlIHVzZWQgaW4gYW5hbHl0aWNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeUlkIFRoZSBxdWVyeSBpZCB0byBzdG9yZVxuICAgKi9cbiAgc2V0UXVlcnlJZCAocXVlcnlJZCkge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIHF1ZXJ5SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gZmlsdGVyIGludG8gc3RvcmFnZSwgdG8gYmUgdXNlZCBmb3IgdGhlIG5leHQgc2VhcmNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBzdG9yYWdlIGtleVxuICAgKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyICAgIHRoZSBmaWx0ZXIgdG8gc2V0XG4gICAqL1xuICBzZXRGaWx0ZXIgKG5hbWVzcGFjZSwgZmlsdGVyKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7bmFtZXNwYWNlfWAsIGZpbHRlcik7XG4gIH1cblxuICBzZXRGYWNldEZpbHRlciAobmFtZXNwYWNlLCBmaWx0ZXIpIHtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUn0uJHtuYW1lc3BhY2V9YCwgZmlsdGVyKTtcbiAgfVxuXG4gIGVuYWJsZUR5bmFtaWNGaWx0ZXJzICgpIHtcbiAgICB0aGlzLl9pc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBvbiAoZXZ0LCBtb2R1bGVJZCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxTdG9yYWdlLm9uKGV2dCwgbW9kdWxlSWQsIGNiKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRE9NICovXG5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCwgSFRNTERvY3VtZW50LCBXaW5kb3csIEV2ZW50ICovXG5cbmxldCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuLyoqXG4gKiBTdGF0aWMgaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBET00gQVBJLlxuICogQG5hbWVzcGFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET00ge1xuICBzdGF0aWMgc2V0dXAgKGQsIHApIHtcbiAgICBkb2N1bWVudCA9IGQ7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGEgSFRNTEVsZW1lbnQgZnJvbSBhbmQgSFRNTCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIEhUTUwgdG8gcGFyc2UgdG8gYSBET00gbm9kZS5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlIChodG1sKSB7XG4gICAgaWYgKCdjcmVhdGVSYW5nZScgaW4gZG9jdW1lbnQpIHtcbiAgICAgIC8vIHByZWZlciB0aGlzIGltcGxlbWVudGF0aW9uIGFzIGl0IGhhcyB3aWRlciBicm93c2VyIHN1cHBvcnRcbiAgICAgIC8vIGFuZCBpdCdzIGJldHRlciBwZXJmb3JtaW5nLlxuICAgICAgLy8gc2VlIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2NvbnZlcnQtaHRtbC1zdGluZ3MtZG9tLW5vZGVzXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuXG4gICAgLy8gZmFsbGJhY2sgdG8gdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIGpzZG9tIHRoYXQgY2F1c2VzIHRlc3RzIHRvIGZhaWxcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2RvbS9qc2RvbS9pc3N1ZXMvMzk5XG4gICAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpLmJvZHk7XG4gIH1cblxuICAvKipcbiAgICogcXVlcnkgdGhlIERPTSBmb3IgYSBnaXZlbiBjc3Mgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IE9wdGlvbmFsIGNvbnRleHQgdG8gdXNlIGZvciBhIHNlYXJjaC4gRGVmYXVsdHMgdG8gZG9jdW1lbnQgaWYgbm90IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgdGhlIENTUyBzZWxlY3RvciB0byBxdWVyeSBmb3JcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aGUgRklSU1Qgbm9kZSBpdCBmaW5kcywgaWYgYW55XG4gICAqL1xuICBzdGF0aWMgcXVlcnkgKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAvLyBGYWNhZGUsIHNoaWZ0aW5nIHRoZSBzZWxlY3RvciB0byB0aGUgcGFyZW50IGFyZ3VtZW50IGlmIG9ubHkgb25lXG4gICAgLy8gYXJndW1lbnQgaXMgcHJvdmlkZWRcbiAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZWN0b3IgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIFdpbmRvdyB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogcXVlcnkgdGhlIERPTSBmb3IgYSBnaXZlbiBjc3Mgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IE9wdGlvbmFsIGNvbnRleHQgdG8gdXNlIGZvciBhIHNlYXJjaC4gRGVmYXVsdHMgdG8gZG9jdW1lbnQgaWYgbm90IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgdGhlIENTUyBzZWxlY3RvciB0byBxdWVyeSBmb3JcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgRklSU1Qgbm9kZSBpdCBmaW5kcywgaWYgYW55XG4gICAqL1xuICBzdGF0aWMgcXVlcnlBbGwgKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICAvLyBGYWNhZGUsIHNoaWZ0aW5nIHRoZSBzZWxlY3RvciB0byB0aGUgcGFyZW50IGFyZ3VtZW50IGlmIG9ubHkgb25lXG4gICAgLy8gYXJndW1lbnQgaXMgcHJvdmlkZWRcbiAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VsZWN0b3IgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgY2xpZW50IGNvZGUgaXMgdXNpbmcgYSBwb2ludGVyIHRvIGEgZG9tIG5vZGUgYW5kIGl0J3MgbnVsbCwgZS5nLiB0aGlzLl9jb250YWluZXJcbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgSFRNTERvY3VtZW50IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICByZXR1cm4gW3NlbGVjdG9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9XG5cbiAgc3RhdGljIG9uUmVhZHkgKGNiKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBET00ub24oZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZUVsZSB3aWxsIGNyZWF0ZSBhIHtIVE1MRWxlbWVudH0gYW5kIGFwcGx5IHRoZSBwcm9wZXJ0aWVzIGF0dHJpYnV0ZXMgdGhyb3VnaCBhbiBvYmplY3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbCBUaGUgZWxlbWVudCBgdGFnYCBuYW1lIHRvIGNvbnN0cnVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c19kYXRhIE9wdGlvbmFsIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIG5ldyBIVE1MRWxlbWVudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUVsIChlbCwgb3B0c19kYXRhID0ge30pIHtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwpO1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5rZXlzKG9wdHNfZGF0YSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcHNbaV0gPT09ICdjbGFzcycpIHtcbiAgICAgICAgRE9NLmFkZENsYXNzKG5vZGUsIG9wdHNfZGF0YVtwcm9wc1tpXV0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZVtwcm9wc1tpXV0gPSBvcHRzX2RhdGFbcHJvcHNbaV1dO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc3RhdGljIGFwcGVuZCAocGFyZW50LCBub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyZW50ID0gRE9NLnF1ZXJ5KHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBIVE1MIGluamVjdGlvbiBhcyB3ZWxsIGFzIEhUTUxFbGVtZW50IGFwcGVuZHNcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlckJlZ2luJywgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYWRkQ2xhc3MgKG5vZGUsIGNsYXNzTmFtZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcsJyk7XG4gICAgbGV0IGxlbiA9IGNsYXNzZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBlbXB0eSAocGFyZW50KSB7XG4gICAgcGFyZW50LmlubmVySFRNTCA9ICcnO1xuICB9XG5cbiAgc3RhdGljIGNzcyAoc2VsZWN0b3IsIHN0eWxlcykge1xuICAgIGxldCBub2RlID0gRE9NLnF1ZXJ5KHNlbGVjdG9yKTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICBub2RlLnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhdHRyIChzZWxlY3RvciwgYXR0ciwgdmFsKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKTtcbiAgfVxuXG4gIHN0YXRpYyBhdHRyaWJ1dGVzIChzZWxlY3RvciwgYXR0cnMpIHtcbiAgICBPYmplY3QuZW50cmllcyhhdHRycylcbiAgICAgIC5mb3JFYWNoKChbYXR0ciwgdmFsXSkgPT4gdGhpcy5hdHRyKHNlbGVjdG9yLCBhdHRyLCB2YWwpKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmlnZ2VyIChzZWxlY3RvciwgZXZlbnQsIHNldHRpbmdzKSB7XG4gICAgbGV0IGUgPSBuZXcgRXZlbnQoZXZlbnQsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgJ2NhbmNlbGFibGUnOiB0cnVlXG4gICAgfSwgc2V0dGluZ3MgfHwge30pKTtcblxuICAgIERPTS5xdWVyeShzZWxlY3RvcikuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIHN0YXRpYyBvbiAoc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIERPTS5xdWVyeShzZWxlY3RvcikuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgc3RhdGljIG9uY2UgKHNlbGVjdG9yLCBldnQsIGhhbmRsZXIpIHtcbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gIH1cblxuICBzdGF0aWMgb2ZmIChzZWxlY3RvciwgZXZ0LCBoYW5kbGVyKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcik7XG4gIH1cblxuICBzdGF0aWMgZGVsZWdhdGUgKGN0eHQsIHNlbGVjdG9yLCBldnQsIGhhbmRsZXIpIHtcbiAgICBsZXQgZWwgPSBET00ucXVlcnkoY3R4dCk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIHdoaWxlICghdGFyZ2V0LmlzRXF1YWxOb2RlKGVsKSkge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgaGFuZGxlcihldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoUGFyYW1zICovXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuLyoqXG4gKiBTZWFyY2hQYXJhbXMgaXMgYSBjbGFzcyB0byBnZXQgdGhlIHNlYXJjaCBwYXJhbXMgaW4gYSBVUkwuXG4gKiBJdCBpcyBhIHJlcGxhY2VtZW50IGZvciBVUkwuc2VhcmNoUGFyYW1zIGFuZCBVUkxTZWFyY2hQYXJhbXMgZm9yIGJyb3dzZXJzIGxpa2UgSUUxMVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hQYXJhbXMge1xuICBjb25zdHJ1Y3RvciAodXJsKSB7XG4gICAgLyoqXG4gICAgICogTWFwcGluZyBvZiBhbGwgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgZ2l2ZW4gdXJsLCBxdWVyeSBwYXJhbSAtPiB2YWx1ZVxuICAgICAqIE9ubHkgdXNlZCBpZiBVUkxTZWFyY2hQYXJhbXMgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHdpbmRvd1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXMgPSB7fTtcblxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LlVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyYW1zID0gdGhpcy5wYXJzZSh1cmwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBjcmVhdGVzIGEgbWFwcGluZyBvZiBhbGwgcXVlcnkgcGFyYW1zIGluIGEgZ2l2ZW4gdXJsXG4gICAqIFRoZSBxdWVyeSBwYXJhbSB2YWx1ZXMgYXJlIGRlY29kZWQgYmVmb3JlIGJlaW5nIHB1dCBpbiB0aGUgbWFwXG4gICAqIFRocmVlIHR5cGVzIG9mIGlucHV0IGFyZSBzdXBwb3J0ZWRcbiAgICogICAoMSkgZnVsbCBVUkwgZS5nLiBodHRwOi8vd3d3LnlleHQuY29tLz9xPWhlbGxvXG4gICAqICAgKDIpIHBhcmFtcyB3aXRoID8gZS5nLiA/cT1oZWxsb1xuICAgKiAgICgxKSBwYXJhbXMgd2l0aG91dCA/IGUuZy4gcT1oZWxsb1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmxcbiAgICogQHJldHVybnMge09iamVjdH0gbWFwcGluZyBmcm9tIHF1ZXJ5IHBhcmFtIC0+IHZhbHVlIHdoZXJlIHZhbHVlIGlzICcnIGlmIG5vIHZhbHVlIGlzIHByb3ZpZGVkXG4gICAqL1xuICBwYXJzZSAodXJsKSB7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIGxldCBzZWFyY2ggPSB1cmw7XG5cbiAgICBpZiAoc2VhcmNoID09PSAnJykge1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgYWxsIHVybCBpbnB1dHMgdG8gc3RyaW5nIG9mIHF1ZXJ5IHBhcmFtcyBzZXBhcmF0ZWQgYnkgJlxuICAgIGlmICh1cmwuaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgIHNlYXJjaCA9IHVybC5zbGljZSh1cmwuaW5kZXhPZignPycpICsgMSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IHNlYXJjaC5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5VmFsID0gZW5jb2RlZFBhcmFtc1tpXS5zcGxpdCgnPScpO1xuICAgICAgaWYgKGtleVZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcmFtc1trZXlWYWxbMF1dID0gU2VhcmNoUGFyYW1zLmRlY29kZShrZXlWYWxbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zW2tleVZhbFswXV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcXVlcnkgcGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBxdWVyeSBwYXJhbSBrZXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhcmFtIHZhbHVlLCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0IChxdWVyeSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcGFyYW1zW1N0cmluZyhxdWVyeSldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYXJhbXNbcXVlcnldO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHF1ZXJ5IHBhcmFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBxdWVyeSBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgcXVlcnkgcGFyYW0gdXBkYXRlIHdpdGhcbiAgICovXG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9wYXJhbXNbU3RyaW5nKG5hbWUpXSA9IFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogaGFzIGNoZWNrcyB0byBzZWUgaWYgdGhlIGdpdmVuIHF1ZXJ5IHBhcmFtIGtleSBleGlzdHMgaW4gdGhlIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBxdWVyeSBwYXJhbSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBxdWVyeSBwYXJhbSBpcyBpbiB0aGUgcGFyYW1zIG9iamVjdCwgZmFsc2Ugby93XG4gICAqL1xuICBoYXMgKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5IGluIHRoaXMuX3BhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWxldGUgcmVtb3ZlcyB0aGUgZ2l2ZW4gcXVlcnkgcGFyYW0gYW5kIGl0cyBhc3NvY2lhdGVkIHZhbHVlIGZyb20gdGhlIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHF1ZXJ5IHBhcmFtIGtleVxuICAgKi9cbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuX3BhcmFtc1tTdHJpbmcobmFtZSldO1xuICB9XG5cbiAgLyoqXG4gICAqIHRvU3RyaW5nIHJldHVybnMgYSB1cmwgd2l0aCBhbGwgdGhlIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgcGFyYW1zIG9iamVjdCAod2l0aG91dCBhID8pXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyaW5nID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuX3BhcmFtcykge1xuICAgICAgc3RyaW5nLnB1c2goYCR7a2V5fT0ke1NlYXJjaFBhcmFtcy5lbmNvZGUodGhpcy5fcGFyYW1zW2tleV0pfWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGVudHJpZXMgKCkge1xuICAgIGxldCBlbnRyaWVzID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuX3BhcmFtcykge1xuICAgICAgZW50cmllcy5wdXNoKFtrZXksIHRoaXMuX3BhcmFtc1trZXldXSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZSByZXR1cm5zIHRoZSBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0aGUgc3RyaW5nIHRvIGRlY29kZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlIChzdHJpbmcpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cmluZy5yZXBsYWNlKC9bICtdL2csICclMjAnKSk7XG4gIH1cblxuICAvKipcbiAgICogZGVjb2RlIHJldHVybnMgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZyAoZS5nLiArIC0+ICUyQilcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0aGUgc3RyaW5nIHRvIGVuY29kZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZW5jb2RlIChzdHJpbmcpIHtcbiAgICBsZXQgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICclMjAnOiAnKydcbiAgICB9O1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKS5yZXBsYWNlKC9bIScoKV18JTIwL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VbbWF0Y2hdO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBSZW5kZXJlciAqL1xuXG4vKipcbiAqIFJlbmRlcmVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIHRoYXQgYWxsIFJlbmRlcmVycyBzaG91bGQgZXh0ZW5kIGFuZCBpbXBsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZXIge1xuICAvKipcbiAgICogcmVuZGVyIGlzIGEgY29yZSBtZXRob2QgZm9yIGFsbCByZW5kZXJlcnMuXG4gICAqIEFsbCBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgY2xhc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAqL1xuICByZW5kZXIgKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgcmVnaXN0ZXJIZWxwZXIgKG5hbWUsIGNiKSB7XG5cbiAgfVxuXG4gIGNvbXBpbGUgKHRlbXBsYXRlKSB7XG5cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgSGFuZGxlYmFyc1JlbmRlcmVyICovXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyJztcblxuLyoqXG4gKiBIYW5kbGViYXJzUmVuZGVyZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZhdGUgaGFuZGxlYmFycyByZW5kZXJlci5cbiAqIEBleHRlbmRzIFJlbmRlcmVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhhbmRsZWJhcnNSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IgKHRlbXBsYXRlcyA9IHt9LCBvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGhhbmRsZWJhcnMgY29tcGlsZXJcbiAgICAgKiBAdHlwZSB7SGFuZGxlYmFyc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hhbmRsZWJhcnMgPSB0ZW1wbGF0ZXMuX2hiIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgcHJlLWNvbXBpbGVkIGhhbmRsZWJhcnMgdGVtcGxhdGVzXG4gICAgICogQHR5cGUge0hhbmRsZWJhcnN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXMgfHwge307XG4gIH1cblxuICBpbml0ICh0ZW1wbGF0ZXMpIHtcbiAgICAvLyBBc3NpZ24gdGhlIGhhbmRsZWJhcnMgY29tcGlsZXIgYW5kIHRlbXBsYXRlcyBiYXNlZCBvblxuICAgIC8vIGluZm9ybWF0aW9uIHByb3ZpZGVkIGZyb20gZXh0ZXJuYWwgZGVwIChpbiBkZWZhdWx0IGNhc2UsIGl0IGNvbWVzIGZyb20gZXh0ZXJuYWwgc2VydmVyIHJlcXVlc3QpXG4gICAgdGhpcy5faGFuZGxlYmFycyA9IHRlbXBsYXRlcy5faGI7XG4gICAgdGhpcy5fdGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuXG4gICAgLy8gVE9ETyhiaWxseSkgT25jZSB3ZSByZS13cml0ZSB0ZW1wbGF0ZXMgdXNpbmcgdGhlIG5ldyBoZWxwZXJzIGxpYnJhcnlcbiAgICAvLyB3ZSBwcm9iYWJseSBkb24ndCBuZWVkIHRoZXNlIGN1c3RvbSBoZWxwZXJzIGFueW1vcmVcbiAgICB0aGlzLl9yZWdpc3RlckN1c3RvbUhlbHBlcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWdpc3RlckhlbHBlciBpcyBhIHB1YmxpYyBpbnRlcmZhY2UgZm9yIGV4dGVybmFsIGRlcGVuZGVuY2llcyB0b1xuICAgKiByZWdpc3RlciB0aGVpciBvd24gY3VzdG9tIGhlbHBlcnMgdG8gb3VyIGludGVybmFsIEhhbmRsZWJhcnMgQ29tcGlsZXJcbiAgICovXG4gIHJlZ2lzdGVySGVscGVyIChuYW1lLCBjYikge1xuICAgIHRoaXMuX2hhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIobmFtZSwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvbXBpbGUgYSBoYW5kbGViYXJzIHRlbXBsYXRlIHNvIHRoYXQgaXQgY2FuIGJlIHJlbmRlcmVkLFxuICAgKiB1c2luZyB0aGUge0hhbmRsZWJhcnN9IGNvbXBpbGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgc3RyaW5nIHRvIGNvbXBpbGVcbiAgICovXG4gIGNvbXBpbGUgKHRlbXBsYXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hhbmRsZWJhcnMuY29tcGlsZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogcmVuZGVyIHdpbGwgcmVuZGVyIGEgdGVtcGxhdGUgd2l0aCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgUHJvdmlkZSBlaXRoZXIgYSB0ZW1wbGF0ZU5hbWUgb3IgYSBwcmUtY29tcGlsZWQgdGVtcGxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gcHJvdmlkZSB0byB0aGUgdGVtcGxhdGVcbiAgICovXG4gIHJlbmRlciAoY29uZmlnLCBkYXRhKSB7XG4gICAgLy8gSWYgYSBjdXN0b20gdGVtcGxhdGUgaXMgcHJvdmlkZWQsIHVzZSBpdCxcbiAgICAvLyBvdGhlcndpc2UgZmFsbCBiYWNrIHRvIHRoZSB0ZW1wbGF0ZSBuYW1lXG4gICAgLy8gVE9ETyhiaWxseSkgVGhpcyBpbnRlcmZhY2Ugc2hvdWxkIHByb2JhYmx5IGJlIGxlc3MgdWdseVxuICAgIGlmIChjb25maWcudGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb25maWcudGVtcGxhdGUoZGF0YSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZXNbY29uZmlnLnRlbXBsYXRlTmFtZV0oZGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGZpbmQvcmVuZGVyIHRlbXBsYXRlOiAnICsgY29uZmlnLnRlbXBsYXRlTmFtZSwgZSk7XG4gICAgfVxuICB9XG5cbiAgX3JlZ2lzdGVyQ3VzdG9tSGVscGVycyAoKSB7XG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignaWZlcScsIGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKGFyZzEgPT09IGFyZzIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2lmbm90ZXEnLCBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIChhcmcxICE9PSBhcmcyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdmb3JtYXRQaG9uZU51bWJlcicsIGZ1bmN0aW9uIChwaG9uZU51bWJlclN0cmluZykge1xuICAgICAgdmFyIGNsZWFuZWQgPSAoJycgKyBwaG9uZU51bWJlclN0cmluZykucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgIHZhciBtYXRjaCA9IGNsZWFuZWQubWF0Y2goL14oMXwpPyhcXGR7M30pKFxcZHszfSkoXFxkezR9KSQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgaW50bENvZGUgPSAobWF0Y2hbMV0gPyAnKzEgJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIFtpbnRsQ29kZSwgJygnLCBtYXRjaFsyXSwgJykgJywgbWF0Y2hbM10sICctJywgbWF0Y2hbNF1dLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdhc3NpZ24nLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGxldCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCFvcHRpb25zLmRhdGEucm9vdCkge1xuICAgICAgICBvcHRpb25zLmRhdGEucm9vdCA9IHt9O1xuICAgICAgfVxuXG4gICAgICBsZXQgdiA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2ID0gdiArIGFyZ3NbaV07XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZGF0YS5yb290W25hbWVdID0gdjtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2pzb24nLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuYW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG5hbWUpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcic7XG5pbXBvcnQgSGFuZGxlYmFyc1JlbmRlcmVyIGZyb20gJy4vaGFuZGxlYmFyc3JlbmRlcmVyJztcblxuLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyB3aWxsIGNvbnRhaW4gYWxsIGRpZmZlcmVudCB0eXBlcyBvZiByZW5kZXJlcnNcbi8vIEUuZy4gTXVzdGFjaGUsIFNPWSwgSGFuZGxlQmFycywgUmVhY3QsIGV0Yy5cbmV4cG9ydCBjb25zdCBSZW5kZXJlcnMgPSB7XG4gIFNPWTogUmVuZGVyZXIsXG4gIEhhbmRsZWJhcnM6IEhhbmRsZWJhcnNSZW5kZXJlclxufTtcbiIsIi8qKiBAbW9kdWxlICovXG5cbi8qKiBUaGUgY3VycmVudCBsaWIgdmVyc2lvbiwgcmVwb3J0ZWQgd2l0aCBlcnJvcnMgYW5kIGFuYWx5dGljcyAqL1xuZXhwb3J0IGNvbnN0IExJQl9WRVJTSU9OID0gJ3YwLjEyLjEnO1xuXG4vKiogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQgKi9cbmV4cG9ydCBjb25zdCBQUk9EVUNUSU9OID0gJ3Byb2R1Y3Rpb24nO1xuXG4vKiogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHNhbmRib3ggZW52aXJvbm1lbnQgKi9cbmV4cG9ydCBjb25zdCBTQU5EQk9YID0gJ3NhbmRib3gnO1xuXG4vKiogVGhlIGRlZmF1bHQgdXJsIGZvciBjb21waWxlZCBjb21wb25lbnQgdGVtcGxhdGVzICovXG5leHBvcnQgY29uc3QgQ09NUElMRURfVEVNUExBVEVTX1VSTCA9IGBodHRwczovL2Fzc2V0cy5zaXRlc2Nkbi5uZXQvYW5zd2Vycy8ke0xJQl9WRVJTSU9OfS9hbnN3ZXJzdGVtcGxhdGVzLmNvbXBpbGVkLm1pbi5qc2A7XG4iLCIvKiogQG1vZHVsZSBUZW1wbGF0ZUxvYWRlciAqL1xuXG5pbXBvcnQgRE9NIGZyb20gJy4uL2RvbS9kb20nO1xuaW1wb3J0IHsgQ09NUElMRURfVEVNUExBVEVTX1VSTCB9IGZyb20gJy4uLy4uL2NvcmUvY29uc3RhbnRzJztcblxuLyoqXG4gKiBUZW1wbGF0ZUxvYWRlciBleHBvc2VzIGFuIGludGVyZmFjZSBmb3IgbG9hZGluZyB0ZW1wbGF0ZXMgYXN5bmNocm9ub3VzbHlcbiAqIGZyb20gdGhlIHNlcnZlciBhbmQgcmVnaXN0ZXJzIHRoZW0gd2l0aCB0aGUgcHJvcGVyIHJlbmRlcmVyLlxuICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIGFzc2lnbiB0aGVtIHN5bmNocm9ub3VzbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIGlmICghVGVtcGxhdGVMb2FkZXIuc2V0SW5zdGFuY2UodGhpcykpIHtcbiAgICAgIHJldHVybiBUZW1wbGF0ZUxvYWRlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSB1cmwgdG8gZmV0Y2ggY29tcGlsZWQgdGVtcGxhdGVzIGZyb21cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGVVcmwgPSBjb25maWcudGVtcGxhdGVVcmwgfHwgQ09NUElMRURfVEVNUExBVEVTX1VSTDtcblxuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHt9O1xuICAgIHRoaXMuX29uTG9hZGVkID0gZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgc3RhdGljIHNldEluc3RhbmNlIChpbnN0YW5jZSkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBfaW5pdCAoKSB7XG4gICAgdGhpcy5mZXRjaFRlbXBsYXRlcygpO1xuICB9XG5cbiAgZmV0Y2hUZW1wbGF0ZXMgKCkge1xuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0ZW1wbGF0ZXMgbG9hZGVkLCBkbyBub3RoaW5nXG4gICAgbGV0IG5vZGUgPSBET00ucXVlcnkoJyN5ZXh0LWFuc3dlcnMtdGVtcGxhdGVzJyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgYSBzY3JpcHQgdG8gZmV0Y2ggdGhlIGNvbXBpbGVkIHRlbXBsYXRlcyxcbiAgICAvLyB3cmFwcGluZyBpdCBhIFByb21pc2UgZm9yIGNsZWFubGluZXNzXG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHNjcmlwdCA9IERPTS5jcmVhdGVFbCgnc2NyaXB0Jywge1xuICAgICAgICBpZDogJ3lleHQtYW5zd2Vycy10ZW1wbGF0ZXMnLFxuICAgICAgICBvbmxvYWQ6IHJlc29sdmUsXG4gICAgICAgIG9uZXJyb3I6IHJlamVjdCxcbiAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgIHNyYzogdGhpcy5fdGVtcGxhdGVVcmxcbiAgICAgIH0pO1xuXG4gICAgICBET00uYXBwZW5kKCdib2R5Jywgc2NyaXB0KTtcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBUT0RPKGJpbGx5KSBJbXBsbWVuZXQgZXJyb3IgaGFuZGxpbmcgaGVyZSAoZS5nLiByZXF1ZXN0IGNvdWxkIGZhaWwpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSEnKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIHRoZSB0ZW1wbGF0ZXMgaW50ZXJuYWxseSBzbyB0aGF0IHRoZXkgY2FuIGJlIGxhdGVyIGNvbnN1bWVkXG4gICAqIChlLmcuIGJ5IGNvbXBvbmVudHMgYW5kIHJlbmRlcmVycykgd2l0aCBjb252aWVuaWVuY2UuXG4gICAqXG4gICAqIGBmZXRjaFRlbXBsYXRlc2Agd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGwgdGhpcywgcHJvdmlkaW5nIHRoZSBjb21waWxlZCB0ZW1wbGF0ZXMgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgcmVnaXN0ZXIgKHRlbXBsYXRlcykge1xuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHRlbXBsYXRlcztcblxuICAgIC8vIE5vdGlmeSBvdXIgY29uc3VtZXJzIHRoYXQgdGhlIHRlbXBsYXRlcyBhcmUgaGVyZSA6KVxuICAgIHRoaXMuX29uTG9hZGVkKHRoaXMuX3RlbXBsYXRlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbkxvYWRlZCAoY2IpIHtcbiAgICB0aGlzLl9vbkxvYWRlZCA9IGNiO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0ICh0ZW1wbGF0ZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBUaGUgaW50ZXJuYWwgdGVtcGxhdGUgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0VGVtcGxhdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIERPTSB9IGZyb20gJy4vZG9tL2RvbSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vZG9tL3NlYXJjaHBhcmFtcyc7XG5cbmV4cG9ydCB7IFJlbmRlcmVycyB9IGZyb20gJy4vcmVuZGVyaW5nL2NvbnN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGVtcGxhdGVMb2FkZXIgfSBmcm9tICcuL3JlbmRlcmluZy90ZW1wbGF0ZWxvYWRlcic7XG4iLCIvKiogQG1vZHVsZSBFdmVudEVtaXR0ZXIgKi9cblxuLyoqXG4gKiBFdmVudEVtaXR0ZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBhbnkgb2JqZWN0IHRoYXQgd2FudHMgdG8gZXhwb3NlXG4gKiBhIHB1Yi9zdWIgaW50ZXJmYWNlLCBmb3IgZW1pdHRpbmcgbWVzc2FnZXMgYW5kIHByb3ZpZGluZyBsaXN0ZW5lcnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc3Vic2NyaWJlcnMgb2YgbWVzc2FnZXNcbiAgICAgKiBAdHlwZSB7b2JqZWN0W119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbiBpcyB0aGUgcHVibGljIGludGVyZmFjZSBmb3Igc3Vic2NyaWJpbmcgZXZlbnRzIHRoYXQgYXJlIGVtaXR0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUge2V2dH0gaXMgZW1pdHRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgT3B0aW9uYWwgdmFsdWUgd2hpY2ggd2lsbCBvbmx5IGhhbmRsZSB0aGUgbWVzc2FnZSBvbmNlXG4gICAqL1xuICBvbiAoZXZ0LCBjYiwgb25jZSkge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaGFuZGxlciBzaG91bGQgYmUgb2YgdHlwZSB7ZnVuY3Rpb259Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tldnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0ucHVzaCh7XG4gICAgICBldmVudDogZXZ0LFxuICAgICAgY2I6IGNiLFxuICAgICAgb25jZTogb25jZSB8fCBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogb25jZSBpcyB0aGUgcHVibGljIGludGVyZmFjZSBmb3Igc3Vic2NyaWJpbmcgZXZlbnRzIHRoYXQgYXJlIGVtaXR0ZWQuXG4gICAqIFRoZSBoYW5kbGVyIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgb25jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCB0aGUgZXZlbnQgbmFtZSB0byBsaXN0ZW4gdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSB7ZXZ0fSBpcyBlbWl0dGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSBPcHRpb25hbCB2YWx1ZSB3aGljaCB3aWxsIG9ubHkgaGFuZGxlIHRoZSBtZXNzYWdlIG9uY2VcbiAgICovXG4gIG9uY2UgKGV2dCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldnQsIGNiLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvZmYgaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIHVuc3Vic2NyaWJpbmcgZnJvbSBhbiBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IHRoZSBldmVudCBuYW1lIHRvIHVuc3Vic2NyaWJlIGZyb21cbiAgICovXG4gIG9mZiAoZXZ0KSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIGVtaXQgaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIGJyb2FkY2FzdGluZyBtZXNzYWdlcy9ldmVudHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCB0aGUgZXZlbnQgbmFtZSB0byBwdWJsaXNoIGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gc2VuZCBhbG9uZyB0byB0aGUgc3Vic2NyaWJlcnNcbiAgICovXG4gIGVtaXQgKGV2dCwgZGF0YSkge1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbnZva2UgZWFjaCBvZiBhbGwgdGhlIGxpc3RlbmVyIGhhbmRsZXJzIGFuZCByZW1vdmUgdGhlIG9uZXMgdGhhdCBzaG91bGQgZmlyZSBvbmx5IG9uY2UuXG4gICAgbGV0IGtlZXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmNiKGRhdGEpO1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnN0ZWFkIG9mIGhhdmluZyBhICdkaXJ0eScgYXJyYXkgd2l0aCBkZWxldGVkIG9yICd1bmRlZmluZWQnIGVudHJpZXMsXG4gICAgICAvLyB3ZSBqdXN0IGNyZWF0ZSBhIGJyYW5kIG5ldyBhcnJheSB3aXRob3V0IHRoZSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHJlbW92ZWRcbiAgICAgIGtlZXAucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBvdXIgb2xkIGxpc3Qgb2YgbGlzdGVuZXJzIHRvIHRoZSBuZXdseSBjcmVhdGVkIGFycmF5XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBrZWVwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTdGF0ZSAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uLy4uL2NvcmUvZXZlbnRlbWl0dGVyL2V2ZW50ZW1pdHRlcic7XG5cbi8qKlxuICogU3RhdGUgY29udGFpbnMgdGhlIGRhdGEgZm9yIHRoZSBjb21wb25lbnRcbiAqIGFuZCBleHBvc2VzIGFuIHtFdmVudEVtaXR0ZXJ9IGludGVyZmFjZSBzbyB0aGF0IGV4dGVybmFsXG4gKiBkZXBlbmRlbmNpZXMgY2FuIGxpc3Rlbi9ob29rIHN1YnNjcmliZSB0byBtZXNzYWdlcy91cGRhdGVzLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdGF0ZSA9IGRhdGEgfHwge307XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIE5PVEUoYmlsbHkpOiBEb2VzIG5vdCBmaXJlIGFuIHVwZGF0ZSBtZXNzYWdlXG4gICAqL1xuICBpbml0IChwcm9wLCBvcHRWYWwpIHtcbiAgICB0aGlzLl9zZXQocHJvcCwgb3B0VmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXR0ZXIgZm9yIHRoZSBzdGF0ZVxuICAgKiBAcGFyYW0gcHJvcCB7c3RyaW5nfE9iamVjdH0gVGhlIHByb3BlcnR5IHRvIHNldFxuICAgKiBAcGFyYW0gb3B0VmFsIE9wdGlvbmFsLCBpZiBwcm9wIGlzIGEge3N0cmluZ30sIGl0IHdpbGwgYXNzaWduIHRoZSB2YWx1ZSB0byB0aGF0IHByb3BlcnR5XG4gICAqL1xuICBzZXQgKHByb3AsIG9wdFZhbCkge1xuICAgIHRoaXMuX3NldChwcm9wLCBvcHRWYWwpO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogc2V0dGVyIGZvciB0aGUgc3RhdGUgZW5hYmxlcyB5b3UgdG8gdXBkYXRlIGEgc2luZ2xlIHByb3BlcnR5LCBvciBjb21wbGV0ZSBzdGF0ZVxuICAgKiBkZXBlbmRpbmcgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAgICogQHBhcmFtIHByb3Age3N0cmluZ3xPYmplY3R9IFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIG9wdFZhbCBJZiBwcm9wIGlzIGEge3N0cmluZ30sIHByb3ZpZGUgaXRzIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0IChwcm9wLCBvcHRWYWwpIHtcbiAgICBpZiAob3B0VmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGVbcHJvcF0gPSBvcHRWYWw7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlIChkYXRhKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBkYXRhO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBwcm9wZXJ0aWVzIHZhbHVlIGZyb20gdGhlIHN0YXRlXG4gICAqIElmIG5vIHByb3BlcnR5IHByb3ZpZGVkLCByZXR1cm4gdGhlIGZ1bGwgc3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdFByb3Agb3B0aW9uYWwgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICovXG4gIGdldCAob3B0UHJvcCkge1xuICAgIGlmIChvcHRQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlW29wdFByb3BdO1xuICB9XG5cbiAgaGFzIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlW3Byb3BdICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBhc0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgSHR0cFJlcXVlc3RlciAqL1xuXG4vKiBnbG9iYWwgZmV0Y2ggKi9cblxuLyoqXG4gKiBUeXBlcyBvZiBIVFRQIHJlcXVlc3RzXG4gKi9cbmNvbnN0IE1ldGhvZHMgPSB7XG4gIEdFVDogJ2dldCcsXG4gIFBPU1Q6ICdwb3N0JyxcbiAgUFVUOiAncHV0JyxcbiAgREVMRVRFOiAnZGVsZXRlJ1xufTtcblxuLyoqXG4gKiBIdHRwUmVxdWVzdGVyIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBBSkFYXG4gKiByZWxhdGVkIG1hdHRlcnMuIEl0J3MgdXNlZCB0byBtYWtlIGFsbCB0eXBlcyBvZiBuZXR3b3JrIHJlcXVlc3RzXG4gKiBhbmQgZXhwb3NlcyBhIHByb21pc2UgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdHRwUmVxdWVzdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIEdFVCBIVFRQIHJlcXVlc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIHByb3ZpZGUgKGdldHMgZW5jb2RlZCBpbnRvIHRoZSBVUkwpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAqL1xuICBnZXQgKHVybCwgZGF0YSwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoTWV0aG9kcy5HRVQsIHRoaXMuZW5jb2RlUGFyYW1zKHVybCwgZGF0YSksIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFBPU1QgSFRUUCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gdXJsUGFyYW1zIFRoZSBwYXJhbXMgdG8gZW5jb2RlIGludG8gdGhlIFVSTFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbkJvZHkgVGhlIHJlcXVlc3QgYm9keSAoanNvbikgdG8gcHJvdmlkZSB3aXRoIHRoZSBQT1NUIHJlcXVlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RDb25maWcgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICovXG4gIHBvc3QgKHVybCwgdXJsUGFyYW1zLCBqc29uQm9keSwgcmVxdWVzdENvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBNZXRob2RzLlBPU1QsXG4gICAgICB0aGlzLmVuY29kZVBhcmFtcyh1cmwsIHVybFBhcmFtcyksXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25Cb2R5KSxcbiAgICAgICAgY3JlZGVudGlhbHM6IHVuZGVmaW5lZFxuICAgICAgfSwgcmVxdWVzdENvbmZpZylcbiAgICApO1xuICB9XG5cbiAgcmVxdWVzdCAobWV0aG9kLCB1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZXFBcmdzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgJ21ldGhvZCc6IG1ldGhvZCxcbiAgICAgICdjcmVkZW50aWFscyc6ICdpbmNsdWRlJ1xuICAgIH0sIG9wdHMpO1xuXG4gICAgcmV0dXJuIGZldGNoKHVybCwgcmVxQXJncyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGJlYWNvbiB0byB0aGUgcHJvdmlkZWQgdXJsIHdoaWNoIHdpbGwgc2VuZCBhIG5vbi1ibG9ja2luZyByZXF1ZXN0XG4gICAqIHRvIHRoZSBzZXJ2ZXIgdGhhdCBpcyBndWFyYW50ZWVkIHRvIHNlbmQgYmVmb3JlIHBhZ2UgbG9hZC4gTm8gcmVzcG9uc2UgaXMgcmV0dXJuZWQsXG4gICAqIHNvIGJlYWNvbnMgYXJlIHByaW1hcmlseSB1c2VkIGZvciBhbmFseXRpY3MgcmVwb3J0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gc2VuZCB0aGUgYmVhY29uIHRvXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBkYXRhIHBheWxvYWQgdG8gc2VuZCBpbiB0aGUgYmVhY29uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHF1ZXVlZFxuICAgKi9cbiAgYmVhY29uICh1cmwsIGRhdGEpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnNlbmRCZWFjb24odXJsLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIH1cblxuICBlbmNvZGVQYXJhbXMgKHVybCwgcGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhhc1BhcmFtID0gdXJsLmluZGV4T2YoJz8nKSA+IC0xO1xuXG4gICAgbGV0IHNlYXJjaFF1ZXJ5ID0gJyc7XG4gICAgZm9yIChsZXQga2V5IGluIHBhcmFtcykge1xuICAgICAgaWYgKCFoYXNQYXJhbSkge1xuICAgICAgICBoYXNQYXJhbSA9IHRydWU7XG4gICAgICAgIHNlYXJjaFF1ZXJ5ICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaFF1ZXJ5ICs9ICcmJztcbiAgICAgIH1cblxuICAgICAgc2VhcmNoUXVlcnkgKz0ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybCArIHNlYXJjaFF1ZXJ5O1xuICB9XG59XG4iLCJpbXBvcnQgeyBQUk9EVUNUSU9OLCBTQU5EQk9YIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIHVybCBmb3IgdGhlIGxpdmUgYXBpIGJhY2tlbmQgaW4gdGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52IFRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGl2ZUFwaVVybCAoZW52ID0gUFJPRFVDVElPTikge1xuICByZXR1cm4gZW52ID09PSBTQU5EQk9YID8gJ2h0dHBzOi8vbGl2ZWFwaS1zYW5kYm94LnlleHQuY29tJyA6ICdodHRwczovL2xpdmVhcGkueWV4dC5jb20nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdXJsIGZvciB0aGUga25vd2xlZGdlIGFwaSBiYWNrZW5kIGluIHRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGVudiBUaGUgZGVzaXJlZCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtub3dsZWRnZUFwaVVybCAoZW52ID0gUFJPRFVDVElPTikge1xuICByZXR1cm4gZW52ID09PSBTQU5EQk9YID8gJ2h0dHBzOi8vYXBpLXNhbmRib3gueWV4dC5jb20nIDogJ2h0dHBzOi8vYXBpLnlleHQuY29tJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIHVybCBmb3IgdGhlIGFuYWx5dGljcyBiYWNrZW5kIGluIHRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGVudiBUaGUgZGVzaXJlZCBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCBJZiBjb252ZXJzaW9uIHRyYWNraW5nIGhhcyBiZWVuIG9wdGVkIGludG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmFseXRpY3NVcmwgKGVudiA9IFBST0RVQ1RJT04sIGNvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgPSBmYWxzZSkge1xuICBpZiAoY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCkge1xuICAgIHJldHVybiBlbnYgPT09IFNBTkRCT1hcbiAgICAgID8gJ2h0dHBzOi8vc2FuZGJveC1yZWFsdGltZWFuYWx5dGljcy55ZXh0LmNvbSdcbiAgICAgIDogJ2h0dHBzOi8vcmVhbHRpbWVhbmFseXRpY3MueWV4dC5jb20nO1xuICB9XG4gIHJldHVybiBlbnYgPT09IFNBTkRCT1hcbiAgICA/ICdodHRwczovL3NhbmRib3gtYW5zd2Vycy55ZXh0LXBpeGVsLmNvbSdcbiAgICA6ICdodHRwczovL2Fuc3dlcnMueWV4dC1waXhlbC5jb20nO1xufVxuIiwiLyoqIEBtb2R1bGUgQXBpUmVxdWVzdCAqL1xuXG5pbXBvcnQgSHR0cFJlcXVlc3RlciBmcm9tICcuL2h0dHByZXF1ZXN0ZXInO1xuaW1wb3J0IHsgTElCX1ZFUlNJT04sIFBST0RVQ1RJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi91aS9kb20vc2VhcmNocGFyYW1zJzsgLy8gVE9ETyBpZGVhbGx5IHRoaXMgd291bGQgYmUgcGFzc2VkIGluIGFzIGEgcGFyYW1cbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgeyBnZXRMaXZlQXBpVXJsIH0gZnJvbSAnLi4vdXRpbHMvdXJsdXRpbHMnO1xuXG4vKipcbiAqIEFwaVJlcXVlc3QgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBBUEkgcmVxdWVzdHMuXG4gKiBJdCBkZWZpbmVzIGFsbCBvZiB0aGUgY29yZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIG1ha2UgYSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwaVJlcXVlc3Qge1xuICAvLyBUT0RPICh0bWV5ZXIpOiBDcmVhdGUgYW4gQXBpU2VydmljZSBpbnRlcmZhY2UgYW5kIHBhc3MgYW4gaW1wbGVtZW50YXRpb24gdG8gdGhlIGN1cnJlbnRcbiAgLy8gY29uc3VtZXJzIG9mIEFwaVJlcXVlc3QgYXMgYSBkZXBlbmRlbmN5LlxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBnbG9iYWxTdG9yYWdlKSB7XG4gICAgLyoqXG4gICAgICogQW4gYWJzdHJhY3Rpb24gdXNlZCBmb3IgbWFraW5nIG5ldHdvcmsgcmVxdWVzdCBhbmQgaGFuZGxpbmcgZXJyb3JzXG4gICAgICogQHR5cGUge0h0dHBSZXF1ZXN0ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXF1ZXN0ZXIgPSBuZXcgSHR0cFJlcXVlc3RlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IHRoZSByZXF1ZXN0IHNob3VsZCBiZSBtYWRlIHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Vudmlyb25tZW50ID0gb3B0cy5lbnZpcm9ubWVudCB8fCBQUk9EVUNUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2VVcmwgdG8gdXNlIGZvciBtYWtpbmcgYSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Jhc2VVcmwgPSBvcHRzLmJhc2VVcmwgfHwgZ2V0TGl2ZUFwaVVybCh0aGlzLl9lbnZpcm9ubWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kcG9pbnQgdG8gdXNlIGluIHRoZSB1cmwgKGFwcGVuZGVkIHRvIHRoZSB7YmFzZVVybH0pXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VuZHBvaW50ID0gb3B0cy5lbmRwb2ludCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEFQSSBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hcGlLZXkgPSBvcHRzLmFwaUtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIEFQSSB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gb3B0cy52ZXJzaW9uIHx8IDIwMTkwMTAxO1xuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBkYXRhIHBhcmFtcyB0aGF0IGFyZSBzZW50IGFsb25nIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0gb3B0cy5wYXJhbXMgfHwge307XG5cbiAgICBpZiAoIWdsb2JhbFN0b3JhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignTXVzdCBpbmNsdWRlIGdsb2JhbCBzdG9yYWdlJywgJ0FwaVJlcXVlc3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9nbG9iYWxTdG9yYWdlID0gZ2xvYmFsU3RvcmFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgY3JlYXRlcyBhIG5ldyBgR0VUYCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHJlcXVlc3QgY2xhc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdGVyLmdldChcbiAgICAgIHRoaXMuX2Jhc2VVcmwgKyB0aGlzLl9lbmRwb2ludCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVBhcmFtcygpLCB0aGlzLnNhbml0aXplUGFyYW1zKHRoaXMuX3BhcmFtcykpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAqL1xuICBwb3N0IChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Rlci5wb3N0KFxuICAgICAgdGhpcy5fYmFzZVVybCArIHRoaXMuX2VuZHBvaW50LFxuICAgICAgdGhpcy5iYXNlUGFyYW1zKCkgLyogdXJsUGFyYW1zICovLFxuICAgICAgdGhpcy5zYW5pdGl6ZVBhcmFtcyh0aGlzLl9wYXJhbXMpIC8qIGpzb25Cb2R5ICovLFxuICAgICAgb3B0cyAvKiByZXF1ZXN0Q29uZmlnICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmFzZVBhcmFtcyAoKSB7XG4gICAgbGV0IGJhc2VQYXJhbXMgPSB7XG4gICAgICAndic6IHRoaXMuX3ZlcnNpb24sXG4gICAgICAnYXBpX2tleSc6IHRoaXMuX2FwaUtleSxcbiAgICAgICdqc0xpYlZlcnNpb24nOiBMSUJfVkVSU0lPTixcbiAgICAgICdzZXNzaW9uVHJhY2tpbmdFbmFibGVkJzogdGhpcy5fZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRVNTSU9OU19PUFRfSU4pXG4gICAgfTtcblxuICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgIGlmICh1cmxQYXJhbXMuaGFzKCdiZXRhJykpIHtcbiAgICAgIGJhc2VQYXJhbXNbJ2JldGEnXSA9IHVybFBhcmFtcy5nZXQoJ2JldGEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZVBhcmFtcztcbiAgfVxuXG4gIHNhbml0aXplUGFyYW1zIChwYXJhbXMgPSB7fSkge1xuICAgIC8vIFJlbW92ZSBhbnkgcGFyYW1hdGVycyB3aG9zIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgIC8vXG4gICAgLy8gTk9URShiaWxseSkgUHJvYmFibHkgYmV0dGVyIHRvIGJlIGV4cGxpY2l0IGFib3V0IGhvdyB0byBoYW5kbGUgdGhpcyBhdCB0aGUgcmVxdWVzdCBidWlsZGluZyBsZXZlbCxcbiAgICAvLyBidXQgSSBjYW4ndCBzZWUgYW55IGNhc2VzIHdoZXJlIHdlJ2QgZXZlciB3YW50IHRvIHNlbmQgJ3VuZGVmaW5lZCcgYXMgYSB2YWx1ZSB0byB0aGUgc2VydmVyLlxuICAgIC8vIFNvIGl0J3MgcHJvYmFibHkgZmluZSB0byAnY2xlYW4nIHRoZSBwYXJhbXMgb2JqZWN0IGhlcmVcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChwYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtc1trZXldID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaEFwaSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuXG5pbXBvcnQgQXBpUmVxdWVzdCBmcm9tICcuLi9odHRwL2FwaXJlcXVlc3QnO1xuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IsIEFuc3dlcnNDb3JlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcblxuLyoqXG4gKiBTZWFyY2hBcGkgaXMgdGhlIEFQSSBmb3IgZG9pbmcgdmFyaW91cyB0eXBlcyBvZiBzZWFyY2hcbiAqIG92ZXIgdGhlIG5ldHdvcmsgKGUuZy4gdmVydGljYWwgb3IgdW5pdmVyc2FsKVxuICpcbiAqIEBpbXBsZW1lbnRzIHtTZWFyY2hTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hBcGkge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBcGkgS2V5IGlzIHJlcXVpcmVkJywgJ1NlYXJjaCcpO1xuICAgIH1cbiAgICB0aGlzLl9hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIEFuc3dlcnMgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuZXhwZXJpZW5jZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBbnN3ZXJzIEtleSBpcyByZXF1aXJlZCcsICdTZWFyY2gnKTtcbiAgICB9XG4gICAgdGhpcy5fZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuc3dlcnMgY29uZmlnIHZlcnNpb24gdG8gdXNlIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24gPSBjb25maWcuZXhwZXJpZW5jZVZlcnNpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgQVBJIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSBjb25maWcudmVyc2lvbiB8fCAyMDE5MDEwMSB8fCAyMDE5MDMwMTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBsb2NhbGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignTG9jYWxlIGlzIHJlcXVpcmVkJywgJ1NlYXJjaCcpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBjb25maWcubG9jYWxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBBbnN3ZXJzIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW52aXJvbm1lbnQgPSBjb25maWcuZW52aXJvbm1lbnQ7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmVydGljYWxTZWFyY2ggKHZlcnRpY2FsS2V5LCB7IGlucHV0LCBmaWx0ZXIsIGZhY2V0RmlsdGVyLCBsaW1pdCwgb2Zmc2V0LCBpZCwgZ2VvbG9jYXRpb24sIGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkLCBza2lwU3BlbGxDaGVjaywgcXVlcnlUcmlnZ2VyLCBzZXNzaW9uVHJhY2tpbmdFbmFibGVkLCBzb3J0QnlzIH0pIHtcbiAgICBpZiAobGltaXQgPiA1MCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb3JlRXJyb3IoJ1Byb3ZpZGVkIHNlYXJjaCBsaW1pdCB1bnN1cHBvcnRlZCcsICdTZWFyY2hBcGknKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvdmVydGljYWwvcXVlcnknLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuX2Vudmlyb25tZW50LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IGlucHV0LFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICdmaWx0ZXJzJzogZmlsdGVyLFxuICAgICAgICAnZmFjZXRGaWx0ZXJzJzogZmFjZXRGaWx0ZXIsXG4gICAgICAgICd2ZXJ0aWNhbEtleSc6IHZlcnRpY2FsS2V5LFxuICAgICAgICAnbGltaXQnOiBsaW1pdCxcbiAgICAgICAgJ29mZnNldCc6IG9mZnNldCxcbiAgICAgICAgJ2xvY2F0aW9uJzogZ2VvbG9jYXRpb24gPyBgJHtnZW9sb2NhdGlvbi5sYXR9LCR7Z2VvbG9jYXRpb24ubG5nfWAgOiBudWxsLFxuICAgICAgICAncmFkaXVzJzogZ2VvbG9jYXRpb24gPyBnZW9sb2NhdGlvbi5yYWRpdXMgOiBudWxsLFxuICAgICAgICAncXVlcnlJZCc6IGlkLFxuICAgICAgICAncmV0cmlldmVGYWNldHMnOiBpc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCxcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgJ3NraXBTcGVsbENoZWNrJzogc2tpcFNwZWxsQ2hlY2ssXG4gICAgICAgICdxdWVyeVRyaWdnZXInOiBxdWVyeVRyaWdnZXIsXG4gICAgICAgICdzZXNzaW9uVHJhY2tpbmdFbmFibGVkJzogc2Vzc2lvblRyYWNraW5nRW5hYmxlZCxcbiAgICAgICAgJ3NvcnRCeXMnOiBzb3J0QnlzXG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHJlcXVlc3RDb25maWcsIHsgZ2V0U3RhdGU6ICgpID0+IHNlc3Npb25UcmFja2luZ0VuYWJsZWQgfSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB1bml2ZXJzYWxTZWFyY2ggKHF1ZXJ5U3RyaW5nLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9xdWVyeScsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBlbnZpcm9ubWVudDogdGhpcy5fZW52aXJvbm1lbnQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogcXVlcnlTdHJpbmcsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ2xvY2F0aW9uJzogcGFyYW1zLmdlb2xvY2F0aW9uID8gYCR7cGFyYW1zLmdlb2xvY2F0aW9uLmxhdH0sJHtwYXJhbXMuZ2VvbG9jYXRpb24ubG5nfWAgOiBudWxsLFxuICAgICAgICAncmFkaXVzJzogcGFyYW1zLmdlb2xvY2F0aW9uID8gcGFyYW1zLmdlb2xvY2F0aW9uLnJhZGl1cyA6IG51bGwsXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICdsb2NhbGUnOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICdza2lwU3BlbGxDaGVjayc6IHBhcmFtcy5za2lwU3BlbGxDaGVjayxcbiAgICAgICAgJ3F1ZXJ5VHJpZ2dlcic6IHBhcmFtcy5xdWVyeVRyaWdnZXJcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgeyBnZXRTdGF0ZTogKCkgPT4gcGFyYW1zLnNlc3Npb25UcmFja2luZ0VuYWJsZWQgfSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBNb2RlbCBmb3IgdGhlIGFuYWx5dGljcyBldmVudCB0eXBlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuYWx5dGljc0V2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGxhYmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVwb3J0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50VHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIGJlIHByb3ZpZGVkIGZvciB0aGUgZXZlbnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBwcm92aWRlZCBvcHRpb25zIHRvIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBldmVudFxuICAgKi9cbiAgYWRkT3B0aW9ucyAob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBldmVudCBpbiB0aGUgYXBpIGZvcm1hdCwgdHlwaWNhbGx5IGZvciByZXBvcnRpbmcgdG8gdGhlIGFwaVxuICAgKi9cbiAgdG9BcGlFdmVudCAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBbmFseXRpY3NSZXBvcnRlciAqL1xuXG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCB7IFBST0RVQ1RJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEh0dHBSZXF1ZXN0ZXIgZnJvbSAnLi4vaHR0cC9odHRwcmVxdWVzdGVyJztcbmltcG9ydCB7IGdldEFuYWx5dGljc1VybCB9IGZyb20gJy4uL3V0aWxzL3VybHV0aWxzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2FuYWx5dGljc3JlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEFuYWx5dGljc1JlcG9ydGVyU2VydmljZSAqL1xuXG4vKipcbiAqIENsYXNzIGZvciByZXBvcnRpbmcgYW5hbHl0aWNzIGV2ZW50cyB0byB0aGUgc2VydmVyIHZpYSBIVFRQXG4gKlxuICogQGltcGxlbWVudHMge0FuYWx5dGljc1JlcG9ydGVyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5hbHl0aWNzUmVwb3J0ZXIge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgY29yZSxcbiAgICBleHBlcmllbmNlS2V5LFxuICAgIGV4cGVyaWVuY2VWZXJzaW9uLFxuICAgIGJ1c2luZXNzSWQsXG4gICAgZ2xvYmFsT3B0aW9ucyA9IHt9LFxuICAgIGVudmlyb25tZW50ID0gUFJPRFVDVElPTikge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBidXNpbmVzcyBpZGVudGlmaWVyIHVzZWQgZm9yIHJlcG9ydGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fYnVzaW5lc3NJZCA9IGJ1c2luZXNzSWQ7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRvIGluY2x1ZGUgd2l0aCBldmVyeSBhbmFseXRpYyBldmVudCByZXBvcnRlZCB0byB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBnbG9iYWxPcHRpb25zLCB7IGV4cGVyaWVuY2VLZXkgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIEFuc3dlcnMgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBVUkwgZm9yIHRoZSBhbmFseXRpY3MgQVBJXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Jhc2VVcmwgPSBnZXRBbmFseXRpY3NVcmwodGhpcy5fZW52aXJvbm1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIG9wdGVkIGluIG9yIG91dCBvZiBjb252ZXJzaW9uIHRyYWNraW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhwZXJpZW5jZVZlcnNpb24pIHtcbiAgICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMuZXhwZXJpZW5jZVZlcnNpb24gPSBleHBlcmllbmNlVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBsaXN0ZW4gdG8gcXVlcnkgaWQgdXBkYXRlc1xuICAgIGNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuUVVFUllfSUQsIGlkID0+IHRoaXMuc2V0UXVlcnlJZChpZCkpO1xuICB9XG5cbiAgc2V0UXVlcnlJZCAocXVlcnlJZCkge1xuICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcmVwb3J0IChldmVudCkge1xuICAgIGxldCBjb29raWVEYXRhID0ge307XG4gICAgaWYgKHRoaXMuX2NvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgJiYgdHlwZW9mIHl0YWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHl0YWcoJ29wdGluJywgdHJ1ZSk7XG4gICAgICBjb29raWVEYXRhID0geXRhZygneWZwYycsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNBbmFseXRpY3NFcnJvcignVHJpZWQgdG8gZW5hYmxlIGNvbnZlcnNpb24gdHJhY2tpbmcgd2l0aG91dCBpbmNsdWRpbmcgeXRhZycpO1xuICAgIH1cblxuICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgQW5hbHl0aWNzRXZlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0FuYWx5dGljc0Vycm9yKCdUcmllZCB0byBzZW5kIGludmFsaWQgYW5hbHl0aWNzIGV2ZW50JywgZXZlbnQpO1xuICAgIH1cblxuICAgIGV2ZW50LmFkZE9wdGlvbnModGhpcy5fZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbmV3IEh0dHBSZXF1ZXN0ZXIoKS5iZWFjb24oXG4gICAgICBgJHt0aGlzLl9iYXNlVXJsfS9yZWFsdGltZWFuYWx5dGljcy9kYXRhL2Fuc3dlcnMvJHt0aGlzLl9idXNpbmVzc0lkfWAsXG4gICAgICB7IGRhdGE6IGV2ZW50LnRvQXBpRXZlbnQoKSwgLi4uY29va2llRGF0YSB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBzZXRDb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIChpc0VuYWJsZWQpIHtcbiAgICB0aGlzLl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkID0gaXNFbmFibGVkO1xuICAgIHRoaXMuX2Jhc2VVcmwgPSBnZXRBbmFseXRpY3NVcmwodGhpcy5fZW52aXJvbm1lbnQsIGlzRW5hYmxlZCk7XG4gIH1cbn1cbiIsIi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9hbmFseXRpY3NyZXBvcnRlcnNlcnZpY2UnKS5kZWZhdWx0fSBBbmFseXRpY3NSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb29wQW5hbHl0aWNzUmVwb3J0ZXIge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcmVwb3J0IChldmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgKGlzRW5hYmxlZCkge31cbn1cbiIsIi8qKiBAbW9kdWxlIE1vZHVsZURhdGEgKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9ldmVudGVtaXR0ZXIvZXZlbnRlbWl0dGVyJztcblxuLyoqXG4gKiBNb2R1bGVEYXRhIGlzIHVzZWQgYXMgYSBnZW5lcmljIG1vZGVsIGZvciBTdG9yYWdlLlxuICogVHlwaWNhbGx5IGFuIGluc3RhbmNlIG9mIE1vZHVsZURhdGEgcG93ZXJzIGEgc2luZ2xlIGNvbXBvbmVudC5cblxuICogQSBkYXRhIG1vZGVsIHRoYXQgZXhwb3NlcyBhbiBldmVudCBlbWl0dGVyIGludGVyZmFjZS5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2R1bGVEYXRhIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGlkLCBkYXRhID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faWQgPSBpZDtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogcmVwbGFjZXMgdGhlIGN1cnJlbnRseSBoZWxkIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gZGF0YVxuICAgKiBAcGFyYW0geyp9IGRhdGEgdGhlIGRhdGEgdG8gcmVwbGFjZSB0aGUgY3VycmVudCBkYXRhXG4gICAqL1xuICBzZXQgKGRhdGEpIHtcbiAgICB0aGlzLmNhcHR1cmVQcmV2aW91cygpO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGRhdGEpIHx8IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXModGhpcy5fZGF0YSkubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5fZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHNoYWxsb3cgZXF1YWxpdHlcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX2RhdGFba2V5XSAhPT0gZGF0YVtrZXldKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuX2RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FwdHVyZVByZXZpb3VzICgpIHtcbiAgICBpZiAodGhpcy5faGlzdG9yeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoICsgMSA+IDUpIHtcbiAgICAgIHRoaXMuX2hpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvLyBJZiBkYXRhIGlzIGV2ZXIgdW5kZWZpbmVkLCB3ZSBkZWZhdWx0IHRvIGVtcHR5IG9iamVjdFxuICAgIHRoaXMuX2hpc3RvcnkucHVzaChKU09OLnN0cmluZ2lmeSh0aGlzLl9kYXRhIHx8IHt9KSk7XG4gIH1cblxuICB1bmRvICgpIHtcbiAgICBsZXQgcHJldmlvdXMgPSB7fTtcbiAgICBpZiAodGhpcy5fcHJldmlvdXMubGVuZ3RoID4gMCkge1xuICAgICAgcHJldmlvdXMgPSBKU09OLnBhcnNlKHRoaXMuX3ByZXZpb3VzLnBvcCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhLnNldChwcmV2aW91cyk7XG4gIH1cblxuICByYXcgKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBHbG9iYWxTdG9yYWdlICovXG5cbmltcG9ydCBNb2R1bGVEYXRhIGZyb20gJy4vbW9kdWxlZGF0YSc7XG5pbXBvcnQgeyBBbnN3ZXJzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi9zdG9yYWdla2V5cyc7XG5cbi8qKlxuICogU3RvcmFnZSBpcyBhIGNvbnRhaW5lciBhcm91bmQgYXBwbGljYXRpb24gc3RhdGUuXG4gKiBJdCBleHBvc2VzIGFuIGludGVyZmFjZSBmb3IgQ1JVRCBvcGVyYXRpb25zIGFzIHdlbGwgYXMgbGlzdGVuaW5nXG4gKiBmb3Igc3RhdGVmdWwgY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xvYmFsU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyID0ge307XG4gICAgdGhpcy5fZnV0dXJlTGlzdGVuZXJzID0ge307XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkYXRhIGluIHN0b3JhZ2Ugd2l0aCB0aGUgZ2l2ZW4ga2V5IHRvIHRoZSBwcm92aWRlZCBkYXRhLFxuICAgKiBjb21wbGV0ZWx5IG92ZXJ3cml0aW5nIGFueSBleGlzdGluZyBkYXRhLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBzdG9yYWdlIGtleSB0byBzZXRcbiAgICogQHBhcmFtIHsqfSBkYXRhIHRoZSBkYXRhIHRvIHNldFxuICAgKi9cbiAgc2V0IChrZXksIGRhdGEpIHtcbiAgICB0aGlzLl9pbml0RGF0YUNvbnRhaW5lcihrZXksIGRhdGEpO1xuICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJba2V5XS5zZXQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFsbCBrZXkvdmFsdWUgcGFpcnMgaW4gdGhlIHByb3ZpZGVkIG1hcCB0byB0aGUgc3RvcmFnZVxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGtleS92YWx1ZSBwYWlycyB0byBzZXQgaW4gdGhlIHN0b3JhZ2VcbiAgICovXG4gIHNldEFsbCAoZGF0YSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgaWYgKGtleSA9PT0gU3RvcmFnZUtleXMuUVVFUlkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChrZXksIHZhbCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHF1ZXJ5IGxhc3Qgc2luY2UgaXQgdHJpZ2dlcnMgYSBzZWFyY2hcbiAgICAvLyBUT0RPOiBtb3ZlIGxpc3RlbmVycyB1cCBzbyBhbGwgb2Ygc3RvcmFnZSBjYW4gYmUgdXBkYXRlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgaWYgKGRhdGFbU3RvcmFnZUtleXMuUVVFUlldKSB7XG4gICAgICB0aGlzLnNldChTdG9yYWdlS2V5cy5RVUVSWSwgZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV0pO1xuICAgIH1cbiAgfVxuXG4gIF9pbml0RGF0YUNvbnRhaW5lciAoa2V5LCBkYXRhKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNTdG9yYWdlRXJyb3IoJ0ludmFsaWQgc3RvcmFnZSBrZXkgcHJvdmlkZWQnLCBrZXksIGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzU3RvcmFnZUVycm9yKCdObyBkYXRhIHByb3ZpZGVkJywga2V5LCBkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJba2V5XSA9IG5ldyBNb2R1bGVEYXRhKGtleSk7XG4gICAgICB0aGlzLl9hcHBseUZ1dHVyZUxpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGdldFN0YXRlIChtb2R1bGVJZCkge1xuICAgIGlmICh0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdLnJhdygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEFsbCAoa2V5KSB7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAoY29uc3QgZGF0YUtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyKSkge1xuICAgICAgaWYgKGRhdGFLZXkuc3RhcnRzV2l0aChrZXkpICYmIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbZGF0YUtleV0ucmF3KCkgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5wdXNoKHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbZGF0YUtleV0ucmF3KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGRhdGEgaW4gc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBrZXkgdG8gdGhlIHByb3ZpZGVkIGRhdGEsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHN0b3JhZ2Uga2V5IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICAvLyBOb3RlOiBEbyB3ZSBuZWVkIHRvIGNsZWFuIHVwIGxpc3RlbmVycyBoZXJlP1xuICAgIGRlbGV0ZSB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2tleV07XG4gIH1cblxuICBvbiAoZXZ0LCBtb2R1bGVJZCwgY2IpIHtcbiAgICBsZXQgbW9kdWxlRGF0YSA9IHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdO1xuICAgIGlmIChtb2R1bGVEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdLnB1c2goe1xuICAgICAgICBldmVudDogZXZ0LFxuICAgICAgICBjYjogY2JcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0ub24oZXZ0LCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvZmYgKGV2dCwgbW9kdWxlSWQsIGNiKSB7XG4gICAgbGV0IG1vZHVsZURhdGEgPSB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXTtcbiAgICBpZiAobW9kdWxlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0ucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdLm9mZihldnQsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9hcHBseUZ1dHVyZUxpc3RlbmVycyAobW9kdWxlSWQpIHtcbiAgICBsZXQgZnV0dXJlcyA9IHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF07XG4gICAgaWYgKCFmdXR1cmVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZnV0dXJlID0gZnV0dXJlc1tpXTtcbiAgICAgIHRoaXMub24oZnV0dXJlLmV2ZW50LCBtb2R1bGVJZCwgZnV0dXJlLmNiKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF07XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VhcmNoQXBpIH0gZnJvbSAnLi9zZWFyY2gvc2VhcmNoYXBpJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuL2FuYWx5dGljcy9hbmFseXRpY3NyZXBvcnRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vb3BBbmFseXRpY3NSZXBvcnRlciB9IGZyb20gJy4vYW5hbHl0aWNzL25vb3BhbmFseXRpY3NyZXBvcnRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vZHVsZURhdGEgfSBmcm9tICcuL3N0b3JhZ2UvbW9kdWxlZGF0YSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3JhZ2UgfSBmcm9tICcuL3N0b3JhZ2UvZ2xvYmFsc3RvcmFnZSc7XG4iLCIvKiogQG1vZHVsZSBDb21wb25lbnQgKi9cblxuaW1wb3J0IHsgUmVuZGVyZXJzIH0gZnJvbSAnLi4vcmVuZGVyaW5nL2NvbnN0JztcblxuaW1wb3J0IERPTSBmcm9tICcuLi9kb20vZG9tJztcbmltcG9ydCBTdGF0ZSBmcm9tICcuL3N0YXRlJztcbmltcG9ydCB7IEFuYWx5dGljc1JlcG9ydGVyIH0gZnJvbSAnLi4vLi4vY29yZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuLi8uLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuXG4vKipcbiAqIENvbXBvbmVudCBpcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVuY2Fwc3VsYXRlcyBzdGF0ZSwgYmVoYXZpb3IsXG4gKiBhbmQgdmlldyBmb3IgYSBwYXJ0aWN1bGFyIGNodW5rIG9mIGZ1bmN0aW9uYWxpdHkgb24gdGhlIHBhZ2UuXG4gKlxuICogVGhlIEFQSSBleHBvc2VzIGV2ZW50IGxpZmUgY3ljbGUgaG9va3MgZm9yIHdoZW4gdGhpbmdzIGFyZSByZW5kZXJlZCxcbiAqIG1vdW50ZWQsIGNyZWF0ZWQsIGV0Yy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHRoaXMubW9kdWxlSWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIG5hbWUgb2YgdGhpcyBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgKiBVc2VkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gb3RoZXIgY29tcG9uZW50cyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBjb25maWcubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgb3B0aW9ucyBzbyB0aGF0IHdlIGNhbiBwcm9wb2dhdGUgcHJvcGVybHkgdG8gY2hpbGQgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogQW4gaWRlbnRpZmllciB1c2VkIHRvIGNsYXNzaWZ5IHRoZSB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgY29tcG9uZW50IG1hbmFnZXIgdXNlcyB0aGlzIGluZm9ybWF0aW9uIGluIG9yZGVyIHRvIHBlcnNpc3QgYW5kIG9yZ2FuaXplIGNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfENvbXBvbmVudFR5cGV9XG4gICAgICovXG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29tcG9uZW50LCBpZiBleGlzdHNcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgICAqL1xuICAgIHRoaXMuX3BhcmVudENvbnRhaW5lciA9IGNvbmZpZy5wYXJlbnRDb250YWluZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgY29udGFpbmVyIGZvciBhbGwgdGhlIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50W119XG4gICAgICovXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGF0ZSAoZGF0YSkgb2YgdGhlIGNvbXBvbmVudCB0byBiZSBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUgZm9yIHJlbmRlcmluZ1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGUoY29uZmlnLnN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRPRE8oYmlsbHkpIFRoaXMgc2hvdWxkIGJlICdzZXJ2aWNlcydcbiAgICAgKi9cbiAgICB0aGlzLmNvcmUgPSBzeXN0ZW1Db25maWcuY29yZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNvbXBvbmVudCBtYW5hZ2VyLCB3aGljaCBjb250YWlucyBhbGwgb2YgdGhlIGNvbXBvbmVudCBjbGFzc2VzXG4gICAgICogZWxpZ2libGUgdG8gYmUgY3JlYXRlZFxuICAgICAqIEB0eXBlIHtDb21wb25lbnRNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuY29tcG9uZW50TWFuYWdlciA9IHN5c3RlbUNvbmZpZy5jb21wb25lbnRNYW5hZ2VyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgYW5hbHl0aWNzIHJlcG9ydGVyLCB1c2VkIHRvIHJlcG9ydCBldmVudHMgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICogQHR5cGUge0FuYWx5dGljc1JlcG9ydGVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIgPSBzeXN0ZW1Db25maWcuYW5hbHl0aWNzUmVwb3J0ZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGFsbCBhbmFseXRpYyBldmVudHMgc2VudCBieSB0aGlzIGNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NPcHRpb25zID0gY29uZmlnLmFuYWx5dGljc09wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgRE9NIG5vZGUgdGhhdCB0aGUgY29tcG9uZW50IHdpbGwgYmUgYXBwZW5kZWQgdG8gd2hlbiBtb3VudGVkL3JlbmRlcmVkLlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBpZiAodGhpcy5fcGFyZW50Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5xdWVyeShjb25maWcuY29udGFpbmVyKSB8fCBudWxsO1xuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBjb250YWluZXIgRE9NIG5vZGU6ICcgKyBjb25maWcuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSBET00ucXVlcnkodGhpcy5fcGFyZW50Q29udGFpbmVyLCBjb25maWcuY29udGFpbmVyKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBhcmVudCwgYW5kIHRoZSBjb250YWluZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBET00sXG4gICAgICAvLyB3ZSBjb25zdHJ1Y3QgdGhlIGNvbnRhaW5lciBhbmQgYXBwZW5kIGl0IHRvIHRoZSBwYXJlbnRcbiAgICAgIGlmICh0aGlzLl9jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6IGNvbmZpZy5jb250YWluZXIuc3Vic3RyaW5nKDEsIGNvbmZpZy5jb250YWluZXIubGVuZ3RoKVxuICAgICAgICB9KTtcbiAgICAgICAgRE9NLmFwcGVuZCh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gY2xhc3MgdG8gYmUgYXBwbGllZCB0byB7dGhpcy5fY29udGFpbmVyfSBub2RlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9jbGFzc05hbWUgPSBjb25maWcuY2xhc3MgfHwgJ2NvbXBvbmVudCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBkZWZhdWx0IHJlbmRlcmVyXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3JlbmRlciA9IGNvbmZpZy5yZW5kZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHtSZW5kZXJlcn0gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBzeXN0ZW1Db25maWcucmVuZGVyZXIgfHwgUmVuZGVyZXJzLkhhbmRsZWJhcnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgc3RyaW5nIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnRcbiAgICAgKiBJZiB0aGlzIGlzIGxlZnQgZW1wdHksIHdlIGxvb2t1cCB0aGUgdGVtcGxhdGUgdGhlIGJhc2UgdGVtcGxhdGVzIHVzaW5nIHRoZSB0ZW1wbGF0ZU5hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlID0gY29uZmlnLnRlbXBsYXRlID8gdGhpcy5fcmVuZGVyZXIuY29tcGlsZShjb25maWcudGVtcGxhdGUpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZU5hbWUgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBUaGlzIGlzIG9ubHkgdXNlZCBpZiBfdGVtcGxhdGUgaXMgZW1wdHkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wbGF0ZU5hbWUgPSBjb25maWcudGVtcGxhdGVOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFRlbXBsYXRlTmFtZShjb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgc3RhdGUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrLCB0aGF0cyB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgaW50ZXJuYWwgZGF0YVxuICAgICAqIG1vZGVscyBvZiB0aGUgY29tcG9uZW50cywgYmVmb3JlIGl0IGdldHMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50IHN0YXRlLlxuICAgICAqIEJ5IGRlZmF1bHQsIG5vIHRyYW5zZm9ybWF0aW9uIGhhcHBlbnMuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtRGF0YSA9IGNvbmZpZy50cmFuc2Zvcm1EYXRhIHx8IHRoaXMudHJhbnNmb3JtRGF0YSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uQ3JlYXRlID0gY29uZmlnLm9uQ3JlYXRlT3ZlcnJpZGUgfHwgdGhpcy5vbkNyZWF0ZSB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICB0aGlzLm9uQ3JlYXRlID0gdGhpcy5vbkNyZWF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIE1vdW50ZWQuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VudCA9IGNvbmZpZy5vbk1vdW50T3ZlcnJpZGUgfHwgdGhpcy5vbk1vdW50IHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMub25Nb3VudCA9IHRoaXMub25Nb3VudC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgY29tcG9uZW50cyBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gY29uZmlnLm9uVXBkYXRlT3ZlcnJpZGUgfHwgdGhpcy5vblVwZGF0ZSB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgdGhpcy5vblVwZGF0ZSA9IHRoaXMub25VcGRhdGUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEEgdXNlciBwcm92aWRlZCBvbkNyZWF0ZSBjYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJPbkNyZWF0ZSA9IGNvbmZpZy5vbkNyZWF0ZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgdXNlciBwcm92aWRlZCBvbk1vdW50IGNhbGxiYWNrXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXNlck9uTW91bnQgPSBjb25maWcub25Nb3VudCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgdXNlciBwcm92aWRlZCBvblVwZGF0ZSBjYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJPblVwZGF0ZSA9IGNvbmZpZy5vblVwZGF0ZSB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAnZGVmYXVsdCc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnQ29tcG9uZW50JztcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGluaXQgKG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShvcHRzLmRhdGEgfHwgb3B0cy5zdGF0ZSB8fCB7fSk7XG4gICAgICB0aGlzLm9uQ3JlYXRlKCk7XG4gICAgICB0aGlzLnVzZXJPbkNyZWF0ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICdFcnJvciBpbml0aWFsaXppbmcgY29tcG9uZW50JyxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci50eXBlLFxuICAgICAgICBlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZS5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnVzZXJPblVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnVuTW91bnQoKTtcbiAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAgICdFcnJvciB1cGRhdGluZyBjb21wb25lbnQnLFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IudHlwZSxcbiAgICAgICAgICBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIERPTS5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NsYXNzTmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgeyBfY29uZmlnOiB0aGlzLl9jb25maWcgfSwgZGF0YSk7XG4gICAgdGhpcy5fc3RhdGUuc2V0KG5ld1N0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFN0YXRlIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldChwcm9wKTtcbiAgfVxuXG4gIGhhc1N0YXRlIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmhhcyhwcm9wKTtcbiAgfVxuXG4gIHRyYW5zZm9ybURhdGEgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGFkZENoaWxkIChkYXRhLCB0eXBlLCBvcHRzKSB7XG4gICAgbGV0IGNoaWxkQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZShcbiAgICAgIHR5cGUsXG4gICAgICBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSwgb3B0cyB8fCB7fSwge1xuICAgICAgICBfcGFyZW50T3B0czogdGhpcy5fY29uZmlnXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkQ29tcG9uZW50KTtcbiAgICByZXR1cm4gY2hpbGRDb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudCBhbmQgcmVtb3ZlIHRoaXMgY29tcG9uZW50IGFuZCBpdHMgY2hpbGRyZW4gZnJvbSB0aGUgbGlzdFxuICAgKiBvZiBhY3RpdmUgY29tcG9uZW50c1xuICAgKi9cbiAgcmVtb3ZlICgpIHtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGMgPT4gYy5yZW1vdmUoKSk7XG4gICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlbW92ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlbmRlciBtZXRob2QgdG8gYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVuZGVyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHNldFJlbmRlciAocmVuZGVyKSB7XG4gICAgdGhpcy5fcmVuZGVyID0gcmVuZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyZXIgZm9yIHRoZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtSZW5kZXJlclR5cGV9IHJlbmRlcmVyXG4gICAqL1xuICBzZXRSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IFJlbmRlcmVyc1tyZW5kZXJlcl07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGVtcGxhdGUgZm9yIHRoZSBjb21wb25lbnQgdG8gdXNlIHdoZW4gcmVuZGVyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0VGVtcGxhdGUgKHRlbXBsYXRlKSB7XG4gICAgdGhpcy5fdGVtcGxhdGUgPSB0aGlzLl9yZW5kZXJlci5jb21waWxlKHRlbXBsYXRlKTtcbiAgfVxuXG4gIHVuTW91bnQgKCkge1xuICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLnVuTW91bnQoKTtcbiAgICB9KTtcblxuICAgIERPTS5lbXB0eSh0aGlzLl9jb250YWluZXIpO1xuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goYyA9PiBjLnJlbW92ZSgpKTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMub25Vbk1vdW50KCk7XG4gIH1cblxuICBtb3VudCAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iZWZvcmVNb3VudCgpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgRE9NLmFwcGVuZCh0aGlzLl9jb250YWluZXIsIHRoaXMucmVuZGVyKHRoaXMuX3N0YXRlLmFzSlNPTigpKSk7XG5cbiAgICAvLyBQcm9jZXNzIHRoZSBET00gdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjcmVhdGVcbiAgICAvLyBpbi1tZW1vcnkgc3ViLWNvbXBvbmVudHMgZm9yIHJlbmRlcmluZ1xuICAgIGNvbnN0IGRvbUNvbXBvbmVudHMgPSBET00ucXVlcnlBbGwodGhpcy5fY29udGFpbmVyLCAnW2RhdGEtY29tcG9uZW50XTpub3QoW2RhdGEtaXMtY29tcG9uZW50LW1vdW50ZWRdKScpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnRyYW5zZm9ybURhdGEoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLl9zdGF0ZS5nZXQoKSkpKTtcbiAgICBkb21Db21wb25lbnRzLmZvckVhY2goYyA9PiB0aGlzLl9jcmVhdGVTdWJjb21wb25lbnQoYywgZGF0YSkpO1xuXG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgLy8gQXR0YWNoIGFuYWx5dGljcyBob29rcyBhcyBuZWNlc3NhcnlcbiAgICBpZiAodGhpcy5hbmFseXRpY3NSZXBvcnRlcikge1xuICAgICAgbGV0IGRvbUhvb2tzID0gRE9NLnF1ZXJ5QWxsKHRoaXMuX2NvbnRhaW5lciwgJ1tkYXRhLWV2ZW50dHlwZV06bm90KFtkYXRhLWlzLWFuYWx5dGljcy1hdHRhY2hlZF0pJyk7XG4gICAgICBkb21Ib29rcy5mb3JFYWNoKHRoaXMuX2NyZWF0ZUFuYWx5dGljc0hvb2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uTW91bnQodGhpcyk7XG4gICAgdGhpcy51c2VyT25Nb3VudCh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbmRlciB0aGUgdGVtcGxhdGUgdXNpbmcgdGhlIHtSZW5kZXJlcn0gd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGVtcGxhdGUgb2YgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgcmVuZGVyIChkYXRhID0gdGhpcy5fc3RhdGUuZ2V0KCkpIHtcbiAgICB0aGlzLmJlZm9yZVJlbmRlcigpO1xuICAgIC8vIFRlbXBvcmFyeSBmaXggZm9yIHBhc3NpbmcgaW1tdXRhYmxlIGRhdGEgdG8gdHJhbnNmb3JtRGF0YSgpLlxuICAgIGRhdGEgPSB0aGlzLnRyYW5zZm9ybURhdGEoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkpO1xuXG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICAvLyBVc2UgZWl0aGVyIHRoZSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIG9yIHRoZSBpbnRlcm5hbCByZW5kZXJlclxuICAgIC8vIGRlcGVuZGFudCBvbiB0aGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb25cbiAgICBpZiAodHlwZW9mIHRoaXMuX3JlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaHRtbCA9IHRoaXMuX3JlbmRlcihkYXRhKTtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXIgbWV0aG9kIG11c3QgcmV0dXJuIEhUTUwgYXMgdHlwZSB7c3RyaW5nfScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGV4aXN0aW5nIHRlbXBsYXRlcyBhcyBhIHN0cmluZ1xuICAgICAgaHRtbCA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlcih7XG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLl90ZW1wbGF0ZSxcbiAgICAgICAgdGVtcGxhdGVOYW1lOiB0aGlzLl90ZW1wbGF0ZU5hbWVcbiAgICAgIH0sIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIFdlIGNyZWF0ZSBhbiBIVE1MIERvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIHJlbmRlcmVkIHN0cmluZ1xuICAgIC8vIFNvIHRoYXQgd2UgY2FuIHF1ZXJ5IGl0IGZvciBwcm9jZXNzaW5nIG9mIHN1YiBjb21wb25lbnRzXG4gICAgbGV0IGVsID0gRE9NLmNyZWF0ZShodG1sKTtcblxuICAgIHRoaXMuYWZ0ZXJSZW5kZXIoKTtcbiAgICByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICB9XG5cbiAgX2NyZWF0ZVN1YmNvbXBvbmVudCAoZG9tQ29tcG9uZW50LCBkYXRhKSB7XG4gICAgZG9tQ29tcG9uZW50LmRhdGFzZXQuaXNDb21wb25lbnRNb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCBkYXRhc2V0ID0gZG9tQ29tcG9uZW50LmRhdGFzZXQ7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQuY29tcG9uZW50O1xuICAgIGNvbnN0IHByb3AgPSBkYXRhc2V0LnByb3A7XG4gICAgbGV0IG9wdHMgPSBkYXRhc2V0Lm9wdHMgPyBKU09OLnBhcnNlKGRhdGFzZXQub3B0cykgOiB7fTtcblxuICAgIGxldCBjaGlsZERhdGEgPSBkYXRhW3Byb3BdIHx8IHt9O1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBjb250YWluZXI6IGRvbUNvbXBvbmVudFxuICAgIH07XG5cbiAgICAvLyBUT0RPKGJpbGx5KSBSaWdodCBub3csIGlmIHdlIHByb3ZpZGUgYW4gYXJyYXkgYXMgdGhlIGRhdGEgcHJvcCxcbiAgICAvLyB0aGUgYmVoYXZpb3IgaXMgdG8gY3JlYXRlIG1hbnkgY29tcG9uZW50cyBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAvLyBUSEFUIGludGVyZmFjZSBTSE9VTEQgY2hhbmdlIHRvIHVzZSBhIGRpZmZlcmVudCBwcm9wZXJ0eSB0aGF0IGRlZmluZXNcbiAgICAvLyB3aGV0aGVyIHRvIGFycmF5IGRhdGEgc2hvdWxkIGJlIHVzZWQgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBvclxuICAgIC8vIHRvIGNyZWF0ZSBtYW55IGNvbXBvbmVudHMgZm9yIGVhY2ggaXRlbS5cbiAgICAvLyBPdmVybG9hZGluZyBhbmQgaGF2aW5nIHRoaXMgc2lkZSBlZmZlY3QgaXMgdW5pbnR1aXRpdmUgYW5kIFdST05HXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkRGF0YSkpIHtcbiAgICAgIC8vIFJlbmRlcmluZyBhIHN1YiBjb21wb25lbnQgc2hvdWxkIGJlIHdpdGhpbiB0aGUgY29udGV4dCxcbiAgICAgIC8vIG9mIHRoZSBub2RlIHRoYXQgd2UgcHJvY2Vzc2VkIGl0IGZyb21cbiAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGREYXRhLCB0eXBlLCBvcHRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaGlsZERhdGEucmV2ZXJzZSgpO1xuICAgIGNoaWxkRGF0YS5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgdGhpcy5hZGRDaGlsZChkYXRhLCB0eXBlLCBvcHRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVBbmFseXRpY3NIb29rIChkb21Db21wb25lbnQpIHtcbiAgICBkb21Db21wb25lbnQuZGF0YXNldC5pc0FuYWx5dGljc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICBjb25zdCBkYXRhc2V0ID0gZG9tQ29tcG9uZW50LmRhdGFzZXQ7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQuZXZlbnR0eXBlO1xuICAgIGNvbnN0IGxhYmVsID0gZGF0YXNldC5ldmVudGxhYmVsO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkYXRhc2V0LmV2ZW50b3B0aW9ucyA/IEpTT04ucGFyc2UoZGF0YXNldC5ldmVudG9wdGlvbnMpIDoge307XG5cbiAgICBET00ub24oZG9tQ29tcG9uZW50LCAnY2xpY2snLCBlID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KHR5cGUsIGxhYmVsKTtcbiAgICAgIGV2ZW50LmFkZE9wdGlvbnModGhpcy5fYW5hbHl0aWNzT3B0aW9ucyk7XG4gICAgICBldmVudC5hZGRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uQ3JlYXRlIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgY29uc3RydWN0ZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uQ3JlYXRlIChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25VcGRhdGUgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgY2hhbmdlc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25VcGRhdGUgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBiZWZvcmVSZW5kZXIgZXZlbnQgaXMgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBiZWZvcmVSZW5kZXIgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBhZnRlclJlbmRlciBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgYWZ0ZXJSZW5kZXIgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvbk1vdW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIERPTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25Nb3VudCAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIG9uVW5Nb3VudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvblVuTW91bnQgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBiZWZvcmVNb3VudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBiZWZvcmVNb3VudCAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIG9uRGVzdHJveSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25EZXN0cm95IChjYikge1xuXG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEVycm9yUmVwb3J0ZXIgKi9cblxuaW1wb3J0IHsgQW5zd2Vyc0Jhc2VFcnJvciwgQW5zd2Vyc0Jhc2ljRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBMSUJfVkVSU0lPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9lcnJvcnJlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEVycm9yUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogRXJyb3JSZXBvcnRlciBpcyB1c2VkIGZvciByZXBvcnRpbmcgZXJyb3JzIHRvIHRoZSBjb25zb2xlIGFuZCBBUElcbiAqXG4gKiBAaW1wbGVtZW50cyB7RXJyb3JSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yUmVwb3J0ZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnLCBnbG9iYWxTdG9yYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGFwaUtleSB0byB1c2UgZm9yIHJlcG9ydGluZ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGVyaWVuY2VLZXkgdG8gdXNlIHdoZW4gcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmV4cGVyaWVuY2VLZXkgPSBjb25maWcuZXhwZXJpZW5jZUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbnN3ZXJzIGNvbmZpZyB2ZXJzaW9uIHVzZWQgZm9yIGFwaSByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXhwZXJpZW5jZVZlcnNpb24gPSBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24gfHwgJ2NvbmZpZzEuMCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBwcmludCBlbnRpcmUgZXJyb3Igb2JqZWN0cyB0byB0aGUgY29uc29sZSBmb3IgaW5zcGVjdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucHJpbnRWZXJib3NlID0gY29uZmlnLnByaW50VmVyYm9zZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJlcG9ydCB0aGUgZXJyb3IgdGhlIHNlcnZlciBmb3IgbG9nZ2luZyBhbmQgbW9uaXRvcmluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VuZFRvU2VydmVyID0gY29uZmlnLnNlbmRUb1NlcnZlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgc3RvcmFnZSBpbnN0YW5jZSBvZiB0aGUgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtHbG9iYWxTdG9yYWdlfVxuICAgICAqL1xuICAgIGlmICh0aGlzLnNlbmRUb1NlcnZlciAmJiAhZ2xvYmFsU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKFxuICAgICAgICAnTXVzdCBpbmNsdWRlIGdsb2JhbFN0b3JhZ2UgdG8gc2VuZCBlcnJvcnMgdG8gc2VydmVyJyxcbiAgICAgICAgJ0Vycm9yUmVwb3J0ZXInKTtcbiAgICB9XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlID0gZ2xvYmFsU3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgQW5zd2VycyBleHBlcmllbmNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW52aXJvbm1lbnQgPSBjb25maWcuZW52aXJvbm1lbnQ7XG5cbiAgICAvLyBBdHRhY2ggcmVwb3J0aW5nIGxpc3RlbmVycyB0byB3aW5kb3dcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlID0+IHRoaXMucmVwb3J0KGUuZXJyb3IpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZSA9PiB0aGlzLnJlcG9ydChlLmVycm9yKSk7XG4gIH1cblxuICAvKipcbiAgICogcmVwb3J0IHByZXR0eSBwcmludHMgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvcHRpb25hbGx5XG4gICAqIHByaW50cyB0aGUgZW50aXJlIGVycm9yIGlmIGBwcmludFZlcmJvc2VgIGlzIHRydWUsIGFuZCBzZW5kcyB0aGVcbiAgICogZXJyb3IgdG8gdGhlIHNlcnZlciB0byBiZSBsb2dnZWQgaWYgYHNlbmRUb1NlcnZlcmAgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge0Fuc3dlcnNCYXNlRXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gYmUgcmVwb3J0ZWRcbiAgICogQHJldHVybnMge0Fuc3dlcnNCYXNlRXJyb3J9IFRoZSByZXBvcnRlZCBlcnJvclxuICAgKi9cbiAgcmVwb3J0IChlcnIpIHtcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBBbnN3ZXJzQmFzZUVycm9yKSB8fCBlcnIucmVwb3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnIucmVwb3J0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5wcmludEVycm9yKGVycik7XG5cbiAgICBpZiAodGhpcy5zZW5kVG9TZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB7XG4gICAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvZXJyb3JzJyxcbiAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgdmVyc2lvbjogMjAxOTAzMDEsXG4gICAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAnbGliVmVyc2lvbic6IExJQl9WRVJTSU9OLFxuICAgICAgICAgICdleHBlcmllbmNlVmVyc2lvbic6IHRoaXMuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLmV4cGVyaWVuY2VLZXksXG4gICAgICAgICAgJ2Vycm9yJzogZXJyLnRvSnNvbigpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5nbG9iYWxTdG9yYWdlKTtcblxuICAgICAgLy8gVE9ETyhhbXVsbGluZ3MpOiBXZSBzaG91bGQgcHJvYmFibHkgY2hhbmdlIHRoaXMgZW5kcG9pbnQgdG8gUE9TVCxcbiAgICAgIC8vIGlkZWFsbHkgdXNpbmcgdGhlIGJlYWNvbiBBUEkuIFN0YWNrIHRyYWNlcyB3aWxsIGxpa2VseSBlYXNpbHkgaGl0IFVSTFxuICAgICAgLy8gbGVuZ3RoIGxpbWl0cy5cbiAgICAgIHJlcXVlc3QuZ2V0KClcbiAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIHByaW50cyB0aGUgZ2l2ZW4gZXJyb3IgdG8gdGhlIGJyb3dzZXIgY29uc29sZVxuICAgKiBAcGFyYW0ge0Fuc3dlcnNCYXNlRXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gYmUgcHJpbnRlZFxuICAgKi9cbiAgcHJpbnRFcnJvciAoZXJyKSB7XG4gICAgaWYgKHRoaXMucHJpbnRWZXJib3NlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBlcnJvcjogJHtlcnIuZXJyb3JNZXNzYWdlfVxuY29kZTogJHtlcnIuZXJyb3JDb2RlfVxuYm91bmRhcnk6ICR7ZXJyLmJvdW5kYXJ5fVxuc3RhY2s6ICR7ZXJyLnN0YWNrfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVyci50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9lcnJvcnJlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEVycm9yUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQGltcGxlbWVudHMge0Vycm9yUmVwb3J0ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25zb2xlRXJyb3JSZXBvcnRlciB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG4iLCJpbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uL2RvbS9zZWFyY2hwYXJhbXMnO1xuaW1wb3J0IHsgQW5zd2Vyc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5cbi8qKiBAbW9kdWxlIFBlcnNpc3RlbnRTdG9yYWdlICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcnNpc3RlbnRTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcGFyYW1zIG1vZGVsXG4gICAgICogQHR5cGUge1NlYXJjaFBhcmFtc31cbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGhpc3RvcnkgZWRpdCB0aW1lciwgaWYgYW55XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9oaXN0b3J5VGltZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgbGlzdGVuZXJzIHRvIGV2ZXJ5IHN0b3JhZ2UgdXBkYXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uW119XG4gICAgICovXG4gICAgdGhpcy5fdXBkYXRlTGlzdGVuZXIgPSBjb25maWcudXBkYXRlTGlzdGVuZXIgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBsaXN0ZW5lcnMgdG8gc3RvcmFnZSByZXNldHNcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXNldExpc3RlbmVyID0gY29uZmlnLnJlc2V0TGlzdGVuZXIgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICB3aW5kb3cub25wb3BzdGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgdGhpcy5fY2FsbExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX2NhbGxMaXN0ZW5lcih0aGlzLl9yZXNldExpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgaW50byBzdG9yYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBpbnNlcnQgdGhlIGRhdGEgaW5cbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2UgaGlzdG9yeSBpbnN0ZWFkIG9mIHB1c2hpbmcgbmV3IHN0YXRlXG4gICAqL1xuICBzZXQgKGtleSwgZGF0YSwgcmVwbGFjZUhpc3RvcnkgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNTdG9yYWdlRXJyb3IoJ1N0b3JhZ2UgZGF0YSBrZXkgbXVzdCBiZSBhIHN0cmluZycsIGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgbGV0IG5ld0RhdGEgPSBkYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5ld0RhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyYW1zLnNldChrZXksIG5ld0RhdGEpO1xuICAgIHRoaXMuX3VwZGF0ZUhpc3RvcnkocmVwbGFjZUhpc3RvcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgZ2l2ZW4ga2V5IGZyb20gc3RvcmFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZGVsZXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSBoaXN0b3J5IGluc3RlYWQgb2YgcHVzaGluZyBuZXcgc3RhdGVcbiAgICovXG4gIGRlbGV0ZSAoa2V5LCByZXBsYWNlSGlzdG9yeSA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuX3VwZGF0ZUhpc3RvcnkocmVwbGFjZUhpc3RvcnkpO1xuICB9XG5cbiAgX3VwZGF0ZUhpc3RvcnkgKHJlcGxhY2VIaXN0b3J5ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5faGlzdG9yeVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlzdG9yeVRpbWVyKTtcbiAgICB9XG5cbiAgICAvLyBiYXRjaCB1cGRhdGUgY2FsbHMgYWNyb3NzIGNvbXBvbmVudHMgdG8gYXZvaWQgdXBkYXRpbmcgdGhlIHVybCB0b28gbXVjaFxuICAgIHRoaXMuX2hpc3RvcnlUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlUaW1lciA9IG51bGw7XG4gICAgICAgIGlmIChyZXBsYWNlSGlzdG9yeSkge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBgPyR7dGhpcy5fcGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIGA/JHt0aGlzLl9wYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIHRoZSBnaXZlbiBsaXN0IG9mIGNhbGxiYWNrcyB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2UgZGF0YVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uW119IGxpc3RlbmVycyBUaGUgY2FsbGJhY2tzIHRvIGludm9rZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbGxMaXN0ZW5lciAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcih0aGlzLmdldEFsbCgpLCB0aGlzLl9wYXJhbXMudG9TdHJpbmcoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUga2V5L3ZhbHVlIHBhaXJzIGluIHN0b3JhZ2VcbiAgICovXG4gIGdldEFsbCAoKSB7XG4gICAgY29uc3QgYWxsUGFyYW1zID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuX3BhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgIGFsbFBhcmFtc1trZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gYWxsUGFyYW1zO1xuICB9XG59XG4iLCJpbXBvcnQgeyBBbnN3ZXJzQ29uZmlnRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcblxuLyoqIEBtb2R1bGUgU2VhcmNoQ29uZmlnICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXggcmVzdWx0cyBwZXIgc2VhcmNoLlxuICAgICAqIEFsc28gZGVmaW5lcyB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgcGVyIHBhZ2UsIGlmIHBhZ2luYXRpb24gaXMgZW5hYmxlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5saW1pdCA9IGNvbmZpZy5saW1pdCB8fCAyMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0aWNhbCBrZXkgdG8gdXNlIGZvciBhbGwgc2VhcmNoZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgZGVmYXVsdCBzZWFyY2ggdG8gdXNlIG9uIGluaXRpYWxpemF0aW9uIGZvciB2ZXJ0aWNhbCBzZWFyY2hlcnMsIHdoZW4gdGhlIHVzZXIgaGFzJ3QgcHJvdmlkZWQgYSBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0SW5pdGlhbFNlYXJjaCA9IGNvbmZpZy5kZWZhdWx0SW5pdGlhbFNlYXJjaDtcblxuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5saW1pdCAhPT0gJ251bWJlcicgfHwgdGhpcy5saW1pdCA8IDEgfHwgdGhpcy5saW1pdCA+IDUwKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbmZpZ0Vycm9yKCdTZWFyY2ggTGltaXQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwJywgJ1NlYXJjaENvbmZpZycpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlRGF0YSAqL1xuXG5pbXBvcnQgSGlnaGxpZ2h0ZWRWYWx1ZSBmcm9tICcuL2hpZ2hsaWdodGVkdmFsdWUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVEYXRhIHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIHRoaXMuc2VjdGlvbnMgPSBkYXRhLnNlY3Rpb25zIHx8IFtdO1xuICAgIHRoaXMucXVlcnlJZCA9IGRhdGEucXVlcnlJZCB8fCAnJztcbiAgICB0aGlzLmlucHV0SW50ZW50cyA9IGRhdGEuaW5wdXRJbnRlbnRzIHx8IFtdO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBsZXQgc2VjdGlvbnM7XG4gICAgaWYgKHJlc3BvbnNlLnNlY3Rpb25zKSB7XG4gICAgICBzZWN0aW9ucyA9IHJlc3BvbnNlLnNlY3Rpb25zLm1hcChzID0+ICh7XG4gICAgICAgIGxhYmVsOiBzLmxhYmVsLFxuICAgICAgICByZXN1bHRzOiBzLnJlc3VsdHMubWFwKHIgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdChyKSlcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VjdGlvbnMgPSBbeyByZXN1bHRzOiByZXNwb25zZS5yZXN1bHRzLm1hcChyID0+IG5ldyBBdXRvQ29tcGxldGVSZXN1bHQocikpIH1dO1xuICAgIH1cbiAgICBsZXQgaW5wdXRJbnRlbnRzID0gcmVzcG9uc2UuaW5wdXQgPyByZXNwb25zZS5pbnB1dC5xdWVyeUludGVudHMgOiBbXTtcbiAgICByZXR1cm4gbmV3IEF1dG9Db21wbGV0ZURhdGEoe1xuICAgICAgc2VjdGlvbnMsXG4gICAgICBxdWVyeUlkOiByZXNwb25zZS5xdWVyeUlkLFxuICAgICAgaW5wdXRJbnRlbnRzIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRvQ29tcGxldGVSZXN1bHQge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5maWx0ZXIgPSBkYXRhLmZpbHRlciB8fCB7fTtcbiAgICB0aGlzLmhpZ2hsaWdodGVkVmFsdWUgPSBuZXcgSGlnaGxpZ2h0ZWRWYWx1ZShkYXRhKS5nZXRJbnZlcnRlZCgpO1xuICAgIHRoaXMua2V5ID0gZGF0YS5rZXkgfHwgJyc7XG4gICAgdGhpcy5tYXRjaGVkU3Vic3RyaW5ncyA9IGRhdGEubWF0Y2hlZFN1YnN0cmluZ3MgfHwgW107XG4gICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWUgfHwgJyc7XG4gICAgdGhpcy5zaG9ydFZhbHVlID0gZGF0YS5zaG9ydFZhbHVlIHx8IHRoaXMudmFsdWU7XG4gICAgdGhpcy5pbnRlbnRzID0gZGF0YS5xdWVyeUludGVudHMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyICovXG5cbmltcG9ydCBBdXRvQ29tcGxldGVEYXRhIGZyb20gJy4uL21vZGVscy9hdXRvY29tcGxldGVkYXRhJztcblxuLyoqXG4gKiBBIERhdGEgVHJhbnNmb3JtZXIgdGhhdCB0YWtlcyB0aGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gYSBBdXRvQ29tcGxldGUgcmVxdWVzdFxuICogQW5kIHRyYW5zZm9ybXMgaW4gdG8gYSBmcm9udC1lbmQgb3JpZW50ZWQgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBvdXJcbiAqIGNvbXBvbmVudCBsaWJyYXJ5IGFuZCBjb3JlIHN0b3JhZ2UgdW5kZXJzdGFuZC5cbiAqXG4gKiBUT0RPKGJpbGx5KSBDcmVhdGUgb3VyIG93biBmcm9udC1lbmQgZGF0YSBtb2RlbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIHtcbiAgc3RhdGljIGNsZWFuIChtb2R1bGVJZCwgZGF0YSkge1xuICAgIGlmIChkYXRhLnNlY3Rpb25zICYmIGRhdGEuc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgZGF0YS5zZWN0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zZWN0aW9ucyAmJiBkYXRhLnNlY3Rpb25zLmxlbmd0aCA9PT0gMSAmJiBkYXRhLnNlY3Rpb25zWzBdLnJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgZGF0YS5zZWN0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgW21vZHVsZUlkXTogZGF0YVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdW5pdmVyc2FsIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBdXRvQ29tcGxldGVEYXRhLmZyb20ocmVzcG9uc2UpO1xuICB9XG5cbiAgc3RhdGljIGZpbHRlciAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXV0b0NvbXBsZXRlRGF0YS5mcm9tKHJlc3BvbnNlKTtcbiAgfVxuXG4gIHN0YXRpYyB2ZXJ0aWNhbCAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXV0b0NvbXBsZXRlRGF0YS5mcm9tKHJlc3BvbnNlKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlQXBpICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIGZyb20gJy4vYXV0b2NvbXBsZXRlZGF0YXRyYW5zZm9ybWVyJztcbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yLCBBbnN3ZXJzRW5kcG9pbnRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuXG4vKipcbiAqIEF1dG9Db21wbGV0ZUFwaSBleHBvc2VzIGFuIGludGVyZmFjZSBmb3IgbmV0d29yayByZWxhdGVkIG1hdHRlcnNcbiAqIGZvciBhbGwgdGhlIGF1dG9jb21wbGV0ZSBlbmRwb2ludHMuXG4gKlxuICogQGltcGxlbWVudHMge0F1dG9Db21wbGV0ZVNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZUFwaSB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgZ2xvYmFsU3RvcmFnZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBBUEkgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0FwaSBLZXkgaXMgcmVxdWlyZWQnLCAnQXV0b0NvbXBsZXRlJyk7XG4gICAgfVxuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQW5zd2VycyBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5leHBlcmllbmNlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0Fuc3dlcnMgS2V5IGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9leHBlcmllbmNlS2V5ID0gY29uZmlnLmV4cGVyaWVuY2VLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgQVBJIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSBjb25maWcudmVyc2lvbiB8fCAyMDE5MDEwMSB8fCAyMDE5MDMwMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbnN3ZXJzIGNvbmZpZyB2ZXJzaW9uIHRvIHVzZSBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uID0gY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmxvY2FsZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdMb2NhbGUgaXMgcmVxdWlyZWQnLCAnQXV0b0NvbXBsZXRlJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIHN0b3JhZ2UgaW5zdGFuY2Ugb2YgdGhlIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7R2xvYmFsU3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghZ2xvYmFsU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdHbG9iYWwgc3RvcmFnZSBpcyByZXF1aXJlZCcsICdBdXRvQ29tcGxldGUnKTtcbiAgICB9XG4gICAgdGhpcy5fZ2xvYmFsU3RvcmFnZSA9IGdsb2JhbFN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIEFuc3dlcnMgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeUZpbHRlciAoaW5wdXQsIGNvbmZpZykge1xuICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB7XG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9hbnN3ZXJzL2ZpbHRlcnNlYXJjaCcsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBlbnZpcm9ubWVudDogdGhpcy5fZW52aXJvbm1lbnQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogaW5wdXQsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ3ZlcnRpY2FsS2V5JzogY29uZmlnLnZlcnRpY2FsS2V5LFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2VhcmNoX3BhcmFtZXRlcnMnOiBKU09OLnN0cmluZ2lmeShjb25maWcuc2VhcmNoUGFyYW1ldGVycylcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5fZ2xvYmFsU3RvcmFnZSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyLmZpbHRlcihyZXNwb25zZS5yZXNwb25zZSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0VuZHBvaW50RXJyb3IoJ0ZpbHRlciBzZWFyY2ggcmVxdWVzdCBmYWlsZWQnLCAnQXV0b0NvbXBsZXRlJywgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlWZXJ0aWNhbCAoaW5wdXQsIHZlcnRpY2FsS2V5KSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvdmVydGljYWwvYXV0b2NvbXBsZXRlJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBpbnB1dCxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAndmVydGljYWxLZXknOiB2ZXJ0aWNhbEtleSxcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLl9nbG9iYWxTdG9yYWdlKTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIudmVydGljYWwocmVzcG9uc2UucmVzcG9uc2UpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNFbmRwb2ludEVycm9yKCdWZXJ0aWNhbCBzZWFyY2ggcmVxdWVzdCBmYWlsZWQnLCAnQXV0b0NvbXBsZXRlJywgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlVbml2ZXJzYWwgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvYXV0b2NvbXBsZXRlJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBxdWVyeVN0cmluZyxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlXG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHJlcXVlc3RDb25maWcsIHRoaXMuX2dsb2JhbFN0b3JhZ2UpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QuZ2V0KHF1ZXJ5U3RyaW5nKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyLnVuaXZlcnNhbChyZXNwb25zZS5yZXNwb25zZSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0VuZHBvaW50RXJyb3IoJ1VuaXZlcnNhbCBzZWFyY2ggcmVxdWVzdCBmYWlsZWQnLCAnQXV0b0NvbXBsZXRlJywgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBBdXRvQ29tcGxldGVEYXRhLCB7IEF1dG9Db21wbGV0ZVJlc3VsdCB9IGZyb20gJy4uL21vZGVscy9hdXRvY29tcGxldGVkYXRhJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2F1dG9jb21wbGV0ZXNlcnZpY2UnKS5kZWZhdWx0fSBBdXRvQ29tcGxldGVTZXJ2aWNlICovXG5cbmNvbnN0IHVuaXZlcnNhbE9wdGlvbnMgPSBbXG4gICd3aGF0IGlzIHlleHQnLFxuICAnd2hvIGlzIHRoZSBjZW8gb2YgeWV4dCdcbl07XG5cbmNvbnN0IHZlcnRpY2FsT3B0aW9ucyA9IFtcbiAgJ25lYXIgbWUnLFxuICAnaW4gbmV3IHlvcmsnLFxuICAnYXZhaWxhYmxlIG5vdydcbl07XG5cbi8qKlxuICogTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2Ugc2VydmVzIGF1dG9jb21wbGV0ZSBxdWVyaWVzIHdpdGggbW9jayBkYXRhXG4gKlxuICogQGltcGxlbWVudHMge0F1dG9Db21wbGV0ZVNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5RmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgLy8gVE9ETyhhbXVsbGluZ3MpOiBTaW11bGF0ZSBmaWx0ZXIgc2VhcmNoLCB3aXRoIHNlY3Rpb25zXG4gICAgcmV0dXJuIGVtcHR5UmVzdWx0cygpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5VmVydGljYWwgKGlucHV0LCB2ZXJ0aWNhbEtleSkge1xuICAgIHJldHVybiBmaWx0ZXJPcHRpb25zKGlucHV0LCB2ZXJ0aWNhbE9wdGlvbnNcbiAgICAgIC5tYXAob3B0ID0+IGAke3ZlcnRpY2FsS2V5fSAke29wdH1gKVxuICAgICAgLmNvbmNhdCh1bml2ZXJzYWxPcHRpb25zKVxuICAgICk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlVbml2ZXJzYWwgKGlucHV0KSB7XG4gICAgcmV0dXJuIGZpbHRlck9wdGlvbnMoaW5wdXQsIHVuaXZlcnNhbE9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFF1ZXJ5IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9ucyBIYXJkY29kZWQgYXV0b2NvbXBsZXRlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEF1dG9Db21wbGV0ZURhdGE+fVxuICovXG5mdW5jdGlvbiBmaWx0ZXJPcHRpb25zIChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGVtcHR5UmVzdWx0cygpO1xuICB9XG5cbiAgY29uc3QgbG93ZXJjYXNlID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgcmVzdWx0cyA9IG9wdGlvbnNcbiAgICAuZmlsdGVyKG9wdCA9PiBvcHQuaW5jbHVkZXMobG93ZXJjYXNlKSlcbiAgICAubWFwKG9wdCA9PiBuZXcgQXV0b0NvbXBsZXRlUmVzdWx0KHtcbiAgICAgIHZhbHVlOiBvcHQsXG4gICAgICBtYXRjaGVkU3Vic3RyaW5nczogW3tcbiAgICAgICAgb2Zmc2V0OiBvcHQuaW5kZXhPZihsb3dlcmNhc2UpLFxuICAgICAgICBsZW5ndGg6IGxvd2VyY2FzZS5sZW5ndGhcbiAgICAgIH1dXG4gICAgfSkpO1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBdXRvQ29tcGxldGVEYXRhKHtcbiAgICBzZWN0aW9uczogW3sgcmVzdWx0cyB9XSxcbiAgICBxdWVyeUlkOiByYW5kb21TdHJpbmcoKVxuICB9KSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8QXV0b0NvbXBsZXRlRGF0YT59XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UmVzdWx0cyAoKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dG9Db21wbGV0ZURhdGEoe1xuICAgIHNlY3Rpb25zOiBbe31dLFxuICAgIHF1ZXJ5SWQ6IHJhbmRvbVN0cmluZygpXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByYW5kb21TdHJpbmcgKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xufVxuIiwiLyoqIEBtb2R1bGUgUXVlc3Rpb25BbnN3ZXJBcGkgKi9cblxuaW1wb3J0IEFwaVJlcXVlc3QgZnJvbSAnLi4vaHR0cC9hcGlyZXF1ZXN0JztcbmltcG9ydCB7IFBST0RVQ1RJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IsIEFuc3dlcnNFbmRwb2ludEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRLbm93bGVkZ2VBcGlVcmwgfSBmcm9tICcuLi91dGlscy91cmx1dGlscyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKipcbiAqIFF1ZXN0aW9uQW5zd2VyQXBpIHN1Ym1pdHMgcXVlc3Rpb25zIHZpYSB0aGUgUSZBIFJFU1QgQVBJXG4gKlxuICogQGltcGxlbWVudHMge1F1ZXN0aW9uQW5zd2VyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVlc3Rpb25BbnN3ZXJBcGkge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBcGkgS2V5IGlzIHJlcXVpcmVkJywgJ1F1ZXN0aW9uQW5zd2VyQXBpJyk7XG4gICAgfVxuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIHN0b3JhZ2UgaW5zdGFuY2Ugb2YgdGhlIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7R2xvYmFsU3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghZ2xvYmFsU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdHbG9iYWwgc3RvcmFnZSBpcyByZXF1aXJlZCcsICdRdWVzdGlvbkFuc3dlckFwaScpO1xuICAgIH1cbiAgICB0aGlzLl9nbG9iYWxTdG9yYWdlID0gZ2xvYmFsU3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgQW5zd2VycyBleHBlcmllbmNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Vudmlyb25tZW50ID0gY29uZmlnLmVudmlyb25tZW50IHx8IFBST0RVQ1RJT047XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGJhc2VVcmw6IGdldEtub3dsZWRnZUFwaVVybCh0aGlzLl9lbnZpcm9ubWVudCksXG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9xdWVzdGlvbnMnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2VudGl0eUlkJzogcXVlc3Rpb24uZW50aXR5SWQsXG4gICAgICAgICdzaXRlJzogcXVlc3Rpb24uc2l0ZSxcbiAgICAgICAgJ25hbWUnOiBxdWVzdGlvbi5uYW1lLFxuICAgICAgICAnZW1haWwnOiBxdWVzdGlvbi5lbWFpbCxcbiAgICAgICAgJ3F1ZXN0aW9uVGV4dCc6IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCxcbiAgICAgICAgJ3F1ZXN0aW9uRGVzY3JpcHRpb24nOiBxdWVzdGlvbi5xdWVzdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgICAncXVlc3Rpb25MYW5ndWFnZSc6IHF1ZXN0aW9uLnF1ZXN0aW9uTGFuZ3VhZ2VcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5fZ2xvYmFsU3RvcmFnZSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5wb3N0KHtcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0VuZHBvaW50RXJyb3IoXG4gICAgICAgICAgJ1F1ZXN0aW9uIHN1Ym1pdCBmYWlsZWQnLFxuICAgICAgICAgICdRdWVzdGlvbkFuc3dlckFwaScsXG4gICAgICAgICAgZXJyb3IpO1xuICAgICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtRdWVzdGlvbkFuc3dlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2Uge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgLy8gVE9ETyhhbXVsbGluZ3MpOiBNYWtlIGFjdHVhbCByZXNwb25zZSBvYmplY3Qgb25jZSB3ZSdyZSB1c2luZyBpdCBmb3JcbiAgICAvLyBzb21ldGhpbmdcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgfVxufVxuIiwiLyogZ2xvYmFsIGZldGNoICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9tb2RlbHMvc2VjdGlvbicpLmRlZmF1bHR9IFNlY3Rpb24gKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlc3VsdERhdGFcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZyB9IGh0bWxUaXRsZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFJlc3VsdHNNb2RpZmllclxuICogQHBhcmFtIHtSZXN1bHREYXRhW119IHJlc3VsdHNcbiAqIEByZXR1cm5zIHtSZXN1bHREYXRhW119XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTW9ja0RhdGFDb25zdW1lclxuICogQHBhcmFtIHtTZWN0aW9uW119IHNlY3Rpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5cbmNvbnN0IEFSQklUUkFSWV9CVVNJTkVTU19JRCA9IDkxOTg3MTtcblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7U2VhcmNoU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9ja1NlYXJjaFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dldE1vY2tEYXRhSnNvbiA9IGZldGNoKCdodHRwczovL2Fzc2V0cy5zaXRlc2Nkbi5uZXQvYW5zd2Vycy90ZXN0ZGF0YS9zZWFyY2gvbW9ja2RhdGFfdjEuanNvbicpXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AudGV4dCgpKVxuICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZlcnRpY2FsU2VhcmNoICh2ZXJ0aWNhbEtleSwgeyBpbnB1dCwgZmlsdGVyLCBmYWNldEZpbHRlciwgbGltaXQsIG9mZnNldCwgaWQsIGdlb2xvY2F0aW9uLCBpc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZCwgc2tpcFNwZWxsQ2hlY2ssIHF1ZXJ5VHJpZ2dlciB9KSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTW9ja0RhdGEoc2VjdGlvbnMgPT4ge1xuICAgICAgaWYgKGlucHV0ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKGNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2Uoe1xuICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgIGFwcGxpZWRRdWVyeUZpbHRlcnM6IFtdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIGZpbmQgYSBzZWN0aW9uIHdpdGggbWF0Y2hpbmcgSUQsIG9yIHBpY2sgb25lIGF0IHJhbmRvbVxuICAgICAgbGV0IHNlY3Rpb24gPSBzZWN0aW9ucy5maW5kKFxuICAgICAgICB2ZXJ0aWNhbE1vZHVsZSA9PiB2ZXJ0aWNhbEtleSA9PT0gdmVydGljYWxNb2R1bGVbJ3ZlcnRpY2FsQ29uZmlnSWQnXVxuICAgICAgKTtcbiAgICAgIGlmIChzZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNlY3Rpb25zLmxlbmd0aCldO1xuICAgICAgfVxuXG4gICAgICBtb2RpZnlSZXN1bHRzKHNlY3Rpb24sIGdldFJlc3VsdHNGaWx0ZXJlcihpbnB1dCkpO1xuICAgICAgaWYgKG9mZnNldCAhPSBudWxsICYmIGxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgbW9kaWZ5UmVzdWx0cyhzZWN0aW9uLCBmdW5jdGlvbiBsaW1pdCAocmVzdWx0cykge1xuICAgICAgICAgIHJldHVybiByZXN1bHRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcCA9IGNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2Uoc2VjdGlvbik7XG4gICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKHJlc3ApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHVuaXZlcnNhbFNlYXJjaCAocXVlcnlTdHJpbmcsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnVzZU1vY2tEYXRhKHNlY3Rpb25zID0+IHtcbiAgICAgIGlmIChxdWVyeVN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRSZXNwb25zZShjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZShbXSkpO1xuICAgICAgfVxuXG4gICAgICBzZWN0aW9ucy5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuICAgICAgICBtb2RpZnlSZXN1bHRzKHNlY3Rpb24sIGdldFJlc3VsdHNGaWx0ZXJlcihxdWVyeVN0cmluZykpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlY3Rpb25zID0gc2VjdGlvbnMuZmlsdGVyKHNlY3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5yZXN1bHRzLmxlbmd0aCA+IDA7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcCA9IGNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlKHNlY3Rpb25zKTtcbiAgICAgIHJldHVybiBkZWxheWVkUmVzcG9uc2UocmVzcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2NrRGF0YUNvbnN1bWVyfSBjb25zdW1lclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXNlTW9ja0RhdGEgKGNvbnN1bWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1vY2tEYXRhSnNvbi50aGVuKEpTT04ucGFyc2UpLnRoZW4oY29uc3VtZXIpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyaW5nXG4gKiBAcmV0dXJuIHtSZXN1bHRzTW9kaWZpZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VsdHNGaWx0ZXJlciAocXVlcnlTdHJpbmcpIHtcbiAgcmV0dXJuIHJlc3VsdHMgPT4gcmVzdWx0cy5maWx0ZXIocmVzdWx0ID0+IHtcbiAgICBpZiAocmVzdWx0Lmh0bWxUaXRsZSAmJiByZXN1bHQuaHRtbFRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnlTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHJlc3VsdC5kYXRhKSB7XG4gICAgICBjb25zdCB2YWwgPSByZXN1bHQuZGF0YVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWN0aW9ufSBzZWN0aW9uXG4gKiBAcGFyYW0ge1Jlc3VsdHNNb2RpZmllcn0gbW9kaWZ5Rm5cbiAqL1xuZnVuY3Rpb24gbW9kaWZ5UmVzdWx0cyAoc2VjdGlvbiwgbW9kaWZ5Rm4pIHtcbiAgc2VjdGlvbi5yZXN1bHRzID0gbW9kaWZ5Rm4oc2VjdGlvbi5yZXN1bHRzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb25bXX0gc2VjdGlvbnMgQSBsaXN0IG9mIG1vY2sgc2VjdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1vY2sgQW5zd2Vyc0FwaSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZSAoc2VjdGlvbnMpIHtcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBzcGVsbGNoZWNrLCBnZW8sIGZpbHRlcnNcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBGYWtlIGVuY29kZWRTdGF0ZSBvbmNlIHRoZSBTREsgdXNlcyBpdFxuICBzZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmaWxsU2VjdGlvbkZpZWxkcyk7XG4gIHJldHVybiB7XG4gICAgbWV0YToge1xuICAgICAgdXVpZDogdXVpZFY0KCksXG4gICAgICBlcnJvcnM6IFtdXG4gICAgfSxcbiAgICByZXNwb25zZToge1xuICAgICAgYnVzaW5lc3NJZDogQVJCSVRSQVJZX0JVU0lORVNTX0lELFxuICAgICAgbW9kdWxlczogc2VjdGlvbnMsXG4gICAgICBmYWlsZWRWZXJ0aWNhbHM6IFtdLFxuICAgICAgcXVlcnlJZDogdXVpZFY0KCksXG4gICAgICBzZWFyY2hJbnRlbnRzOiBbXVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb259IHNlY3Rpb24gQSBtb2NrIHNlY3Rpb24gZGF0YVxuICogQHJldHVybnMge09iamVjdH0gQSBtb2NrIEFuc3dlcnNBcGkgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0VmVydGljYWxSZXNwb25zZSAoc2VjdGlvbikge1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IHNwZWxsY2hlY2ssIGdlbywgZmlsdGVyc1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IEZha2UgZW5jb2RlZFN0YXRlIG9uY2UgdGhlIFNESyB1c2VzIGl0XG4gIHNlY3Rpb24gPSBmaWxsU2VjdGlvbkZpZWxkcyhzZWN0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBtZXRhOiB7XG4gICAgICB1dWlkOiB1dWlkVjQoKSxcbiAgICAgIGVycm9yczogW11cbiAgICB9LFxuICAgIHJlc3BvbnNlOiBPYmplY3QuYXNzaWduKHNlY3Rpb24sIHtcbiAgICAgIGJ1c2luZXNzSWQ6IEFSQklUUkFSWV9CVVNJTkVTU19JRCxcbiAgICAgIHF1ZXJ5SWQ6IHV1aWRWNCgpLFxuICAgICAgc2VhcmNoSW50ZW50czogW11cbiAgICB9KVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VjdGlvbn1cbiAqIEByZXR1cm5zIHtTZWN0aW9ufVxuICovXG5mdW5jdGlvbiBmaWxsU2VjdGlvbkZpZWxkcyAoc2VjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHNlY3Rpb24udmVydGljYWxDb25maWdJZCxcbiAgICByZXN1bHRzQ291bnQ6IHNlY3Rpb24ucmVzdWx0cy5sZW5ndGgsXG4gICAgZW5jb2RlZFN0YXRlOiAnJyxcbiAgICByZXN1bHRzOiBzZWN0aW9uLnJlc3VsdHMsXG4gICAgYXBwbGllZFF1ZXJ5RmlsdGVyczogc2VjdGlvbi5hcHBsaWVkUXVlcnlGaWx0ZXJzLFxuICAgIHF1ZXJ5RHVyYXRpb25NaWxsaXM6IHJhbmRvbUludCg1MCwgMTAwMCksXG4gICAgZmFjZXRzOiBzZWN0aW9uLmZhY2V0cyxcbiAgICBzb3VyY2U6IHNlY3Rpb24uc291cmNlXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cbmZ1bmN0aW9uIGRlbGF5ZWRSZXNwb25zZSAocmVzcCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHJlc3ApO1xuICAgIH0sIHJhbmRvbUludCgyNTAsIDEwMDApKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29kZS1nb2xmLXkgYnV0IGxlZ2l0IGJhc2ljIFVVSUQgdjQgaW1wbGVtZW50YXRpb24uIE5vdCBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUuXG4gKiBGcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgdjQtY29tcGxpYW50IFVVSURcbiAqL1xuZnVuY3Rpb24gdXVpZFY0ICgpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBiIChhKSB7IHJldHVybiBhID8gKGEgXiBNYXRoLnJhbmRvbSgpICogMTYgPj4gYSAvIDQpLnRvU3RyaW5nKDE2KSA6IChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBiKTsgfSkoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBleGNsdXNpdmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgaW4gdGhlIHNwZWNpZmllZCByYW5nZVxuICovXG5mdW5jdGlvbiByYW5kb21JbnQgKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XG59XG4iLCIvKiogQG1vZHVsZSBOYXZpZ2F0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG4vKipcbiAqIFRoZSBkZWJvdW5jZSBkdXJhdGlvbiBmb3IgcmVzaXplIGV2ZW50c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgUkVTSVpFX0RFQk9VTkNFID0gMTAwO1xuXG4vKipcbiAqIFRoZSBicmVha3BvaW50IGZvciBtb2JpbGVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1PQklMRV9CUkVBS1BPSU5UID0gNzY3O1xuXG4vKipcbiAqIEVudW0gb3B0aW9ucyBmb3IgbW9iaWxlIG92ZXJmbG93IGJlYWh2aW9yXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmNvbnN0IE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04gPSB7XG4gIENPTExBUFNFOiAnQ09MTEFQU0UnLFxuICBJTk5FUlNDUk9MTDogJ0lOTkVSU0NST0xMJ1xufTtcblxuLyoqXG4gKiBUaGUgVGFiIGlzIGEgbW9kZWwgdGhhdCBpcyB1c2VkIHRvIHBvd2VyIHRoZSBOYXZpZ2F0aW9uIHRhYnMgaW4gdGhlIHZpZXcuXG4gKiBJdCdzIGluaXRpYWxpemVkIHRocm91Z2ggdGhlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhYiB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGFiIHRoYXQgaXMgZXhwb3NlZCBmb3IgdGhlIGxpbmtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBjb25maWcubGFiZWw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcignbGFiZWwgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgdGFiLicsICdOYXZpZ2F0aW9uQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBsZXRlIFVSTCwgaW5jbHVkaW5nIHRoZSBwYXJhbXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcbiAgICBpZiAodHlwZW9mIHRoaXMudXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcigndXJsIGlzIGEgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBvcHRpb24gZm9yIHRhYi4nLCAnTmF2aWdhdGlvbkNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXJzaWRlIHZlcnRpY2FsIGNvbmZpZyBpZCB0aGF0IHRoaXMgaXMgcmVmZXJlbmNlZCB0by5cbiAgICAgKiBCeSBwcm92aWRpbmcgdGhpcywgZW5hYmxlcyBkeW5hbWljIHNvcnRpbmcgYmFzZWQgb24gcmVzdWx0cy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29uZmlnSWQgPSBjb25maWcuY29uZmlnSWQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIFVSTCB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgdGhlIFVSTCB3aXRoIHBhcmFtc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gY29uZmlnLnVybDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IHRoaXMgdGFiIGZpcnN0IGluIHRoZSBvcmRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNGaXJzdCA9IGNvbmZpZy5pc0ZpcnN0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBhcHBseSBhIHNwZWNpYWwgY2xhc3MgdG8gdGhlXG4gICAgICogbWFya3VwIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIGFjdGl2ZSB0YWJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQWN0aXZlID0gY29uZmlnLmlzQWN0aXZlIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIGZyb20gd2lsbCBjb25zdHJ1Y3QgYSBtYXAgb2YgY29uZmlnSWQgdG8ge1RhYn0gZnJvbVxuICAgKiBhIGNvbmZpZ3VyYXRpb24gZmlsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdGFic0NvbmZpZyB0aGUgY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBmcm9tICh0YWJzQ29uZmlnKSB7XG4gICAgbGV0IHRhYnMgPSB7fTtcbiAgICAvLyBQYXJzZSB0aGUgb3B0aW9ucyBhbmQgYnVpbGQgb3V0IG91ciB0YWJzIGFuZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFic0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRhYiA9IHRhYnNDb25maWdbaV07XG4gICAgICAvLyBGb3IgdGFicyB3aXRob3V0IGNvbmZpZyBpZHMsIG1hcCB0aGVpciBVUkwgdG8gdGhlIGNvbmZpZ0lEXG4gICAgICAvLyB0byBhdm9pZCBkdXBsaWNhdGlvbiBvZiByZW5kZXJzXG4gICAgICBpZiAodGFiLmNvbmZpZ0lkID09PSBudWxsICYmIHRhYnNbdGFiLmNvbmZpZ0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhYi5jb25maWdJZCA9IHRhYi51cmw7XG4gICAgICB9XG5cbiAgICAgIHRhYnNbdGFiLmNvbmZpZ0lkXSA9IG5ldyBUYWIodGFiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYnM7XG4gIH1cbn1cblxuLyoqXG4gKiBOYXZpZ2F0aW9uQ29tcG9uZW50IGV4cG9zZXMgYW4gaW50ZXJmYWNlIGZvciBidWlsZGluZyBhIGR5bmFtaWNcbiAqIG5hdmlnYXRpb24gdGhhdCBpcyBwb3dlcmVkIGJ5IHVuaXZlcnNhbCBzZWFyY2ggdXBkYXRlcy5cbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IG9uIHRoZSBkcm9wZG93biBtZW51IGJ1dHRvbiB3aGVuIG92ZXJmbG93XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93TGFiZWwgPSBjb25maWcub3ZlcmZsb3dMYWJlbCB8fCAnTW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgaWNvbiB0byBzaG93IG9uIHRoZSBkcm9wZG93biBtZW51IGJ1dHRvbiB3aGVuIG92ZXJmbG93XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93SWNvbiA9IGNvbmZpZy5vdmVyZmxvd0ljb24gfHwgJ2thYm9iJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2Uga2V5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuTkFWSUdBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRhYnMgY29uZmlnIGZyb20gZ2xvYmFsIG5hdmlnYXRpb24gY29uZmlnXG4gICAgICogQHR5cGUge0FycmF5LjxvYmplY3Q+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGFic0NvbmZpZyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLk5BVklHQVRJT05fQ09ORklHKS50YWJzQ29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogVW5vcmRlcmVkIG1hcCBvZiBlYWNoIHRhYiwga2V5ZWQgYnkgVlMgY29uZmlnSWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIE9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90YWJzID0gVGFiLmZyb20odGhpcy5fdGFic0NvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIHRhYnMsIHBhcnNlZCBmcm9tIGNvbmZpZ3VyYXRpb24gb3IgVVJMLlxuICAgICAqIFRoaXMgZ2V0cyB1cGRhdGVkIGJhc2VkIG9uIHRoZSBzZXJ2ZXIgcmVzdWx0c1xuICAgICAqIEB0eXBlIHtBcnJheS48U3RyaW5nPn0gVGhlIGxpc3Qgb2YgVlMgY29uZmlnSWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90YWJPcmRlciA9IHRoaXMuZ2V0RGVmYXVsdFRhYk9yZGVyKHRoaXMuX3RhYnNDb25maWcsIHRoaXMuZ2V0VXJsUGFyYW1zKCkpO1xuXG4gICAgLyoqXG4gICAgICogQnJlYWtwb2ludHMgYXQgd2hpY2ggbmF2aWdhdGlvbiBpdGVtcyBtb3ZlIHRvIHRoZSBcIm1vcmVcIiBkcm9wZG93blxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25hdkJyZWFrcG9pbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIG1vYmlsZSBvdmVyZmxvdyBiZWhhdmlvciBjb25maWdcbiAgICAgKiAgQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9tb2JpbGVPdmVyZmxvd0JlaGF2aW9yID0gY29uZmlnLm1vYmlsZU92ZXJmbG93QmVoYXZpb3IgfHwgTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTi5DT0xMQVBTRTtcblxuICAgIC8qKlxuICAgICAqICBUaGUgQVJJQSBsYWJlbFxuICAgICAqICBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2FyaWFMYWJlbCA9IGNvbmZpZy5hcmlhTGFiZWwgfHwgJ1NlYXJjaCBQYWdlIE5hdmlnYXRpb24nO1xuXG4gICAgdGhpcy5jaGVja091dHNpZGVDbGljayA9IHRoaXMuY2hlY2tPdXRzaWRlQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvciA9IHRoaXMuY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yLmJpbmQodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnTmF2aWdhdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ25hdmlnYXRpb24vbmF2aWdhdGlvbic7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgLy8gVE9ETzogUmUtcmVuZGVyaW5nIGFuZCByZS1tb3VudGluZyB0aGUgY29tcG9uZW50IGV2ZXJ5IHRpbSBlIHRoZSB3aW5kb3cgY2hhbmdlcyBzaXplXG4gICAgLy8gaXMgbm90IGdyZWF0LlxuICAgIERPTS5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLmNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvcik7XG4gIH1cblxuICBvbkRlc3Ryb3kgKCkge1xuICAgIERPTS5vZmYod2luZG93LCAncmVzaXplJywgdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IpO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkQ29sbGFwc2UoKSkge1xuICAgICAgdGhpcy5fbmF2QnJlYWtwb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuYmluZE92ZXJmbG93SGFuZGxlcnMoKTtcbiAgICAgIHRoaXMucmVmaXROYXYoKTtcbiAgICAgIERPTS5vbihET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9yZScpLCAnY2xpY2snLCB0aGlzLnRvZ2dsZU1vcmVEcm9wZG93bi5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICBvblVuTW91bnQgKCkge1xuICAgIHRoaXMudW5iaW5kT3ZlcmZsb3dIYW5kbGVycygpO1xuICB9XG5cbiAgYmluZE92ZXJmbG93SGFuZGxlcnMgKCkge1xuICAgIERPTS5vbih3aW5kb3csICdjbGljaycsIHRoaXMuY2hlY2tPdXRzaWRlQ2xpY2spO1xuICB9XG5cbiAgdW5iaW5kT3ZlcmZsb3dIYW5kbGVycyAoKSB7XG4gICAgRE9NLm9mZih3aW5kb3csICdjbGljaycsIHRoaXMuY2hlY2tPdXRzaWRlQ2xpY2spO1xuICB9XG5cbiAgcmVmaXROYXYgKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1jb250YWluZXInKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBjb25zdCBtYWluTGlua3MgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtZXhwYW5kZWQnKTtcbiAgICBjb25zdCBjb2xsYXBzZWRMaW5rcyA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuXG4gICAgY29uc3QgbmF2V2lkdGggPSBtb3JlQnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygneXh0LU5hdi1pdGVtLS1tb3JlJylcbiAgICAgID8gY29udGFpbmVyLm9mZnNldFdpZHRoXG4gICAgICA6IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAtIG1vcmVCdXR0b24ub2Zmc2V0V2lkdGg7XG4gICAgbGV0IG51bUJyZWFrcG9pbnRzID0gdGhpcy5fbmF2QnJlYWtwb2ludHMubGVuZ3RoO1xuXG4gICAgLy8gc3VtIGNoaWxkIHdpZHRocyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmVudCdzIHdpZHRoIHRvIGF2b2lkXG4gICAgLy8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXNcbiAgICBsZXQgbWFpbkxpbmtzV2lkdGggPSAwO1xuICAgIGZvciAobGV0IGVsIG9mIG1haW5MaW5rcy5jaGlsZHJlbikge1xuICAgICAgbWFpbkxpbmtzV2lkdGggKz0gZWwub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG1haW5MaW5rc1dpZHRoID4gbmF2V2lkdGgpIHtcbiAgICAgIHRoaXMuX25hdkJyZWFrcG9pbnRzLnB1c2gobWFpbkxpbmtzV2lkdGgpO1xuICAgICAgY29uc3QgbGFzdExpbmsgPSBtYWluTGlua3MuY2hpbGRyZW4uaXRlbShtYWluTGlua3MuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAobGFzdExpbmsgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29sbGFwc2VkTGlua3MucHJlcGVuZChsYXN0TGluayk7XG5cbiAgICAgIGlmIChtb3JlQnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygneXh0LU5hdi1pdGVtLS1tb3JlJykpIHtcbiAgICAgICAgbW9yZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtTmF2LWl0ZW0tLW1vcmUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG51bUJyZWFrcG9pbnRzICYmIG5hdldpZHRoID4gdGhpcy5fbmF2QnJlYWtwb2ludHNbbnVtQnJlYWtwb2ludHMgLSAxXSkge1xuICAgICAgICBjb25zdCBmaXJzdExpbmsgPSBjb2xsYXBzZWRMaW5rcy5jaGlsZHJlbi5pdGVtKDApO1xuICAgICAgICBpZiAoZmlyc3RMaW5rID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1haW5MaW5rcy5hcHBlbmQoZmlyc3RMaW5rKTtcbiAgICAgICAgdGhpcy5fbmF2QnJlYWtwb2ludHMucG9wKCk7XG4gICAgICAgIG51bUJyZWFrcG9pbnRzLS07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xsYXBzZWRMaW5rcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbW9yZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd5eHQtTmF2LWl0ZW0tLW1vcmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlTW9yZURyb3Bkb3duKCk7XG4gICAgaWYgKG1haW5MaW5rc1dpZHRoID4gbmF2V2lkdGggfHxcbiAgICAgIChudW1CcmVha3BvaW50cyA+IDAgJiYgbmF2V2lkdGggPiB0aGlzLl9uYXZCcmVha3BvaW50c1tudW1CcmVha3BvaW50cyAtIDFdKSkge1xuICAgICAgdGhpcy5yZWZpdE5hdigpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlTW9yZURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjb2xsYXBzZWQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcbiAgICBjb2xsYXBzZWQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgbW9yZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gIH1cblxuICBvcGVuTW9yZURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjb2xsYXBzZWQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcbiAgICBjb2xsYXBzZWQuY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgbW9yZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgfVxuXG4gIHRvZ2dsZU1vcmVEcm9wZG93biAoKSB7XG4gICAgY29uc3QgY29sbGFwc2VkID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vZGFsJyk7XG4gICAgY29sbGFwc2VkLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xuICAgIGNvbnN0IG1vcmVCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9yZScpO1xuICAgIG1vcmVCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgY29sbGFwc2VkLmNsYXNzTGlzdC5jb250YWlucygnaXMtYWN0aXZlJykpO1xuICB9XG5cbiAgY2hlY2tPdXRzaWRlQ2xpY2sgKGUpIHtcbiAgICBpZiAoZS50YXJnZXQuY2xvc2VzdCgnLnl4dC1OYXYtY29udGFpbmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlTW9yZURyb3Bkb3duKCk7XG4gIH1cblxuICBjaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IgKCkge1xuICAgIGlmICh0aGlzLl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lciA9IHNldFRpbWVvdXQodGhpcy5zZXRTdGF0ZS5iaW5kKHRoaXMpLCBSRVNJWkVfREVCT1VOQ0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbmNlIHRoZSBzZXJ2ZXIgZGF0YSBvbmx5IHByb3ZpZGVzIGEgbGlzdCBvZlxuICAgKiBWUyBjb25maWdJZHMsIHdlIG5lZWQgdG8gY29tcHV0ZSBhbmQgdHJhbnNmb3JtXG4gICAqIHRoZSBkYXRhIGludG8gdGhlIHByb3BlciBmb3JtYXQgZm9yIHJlbmRlcmluZy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSA9IHt9KSB7XG4gICAgaWYgKGRhdGEudGFiT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fdGFiT3JkZXIgPSB0aGlzLm1lcmdlVGFiT3JkZXIoZGF0YS50YWJPcmRlciwgdGhpcy5fdGFiT3JkZXIpO1xuICAgIH1cblxuICAgIC8vIFNpbmNlIHRoZSB0YWIgb3JkZXJpbmcgY2FuIGNoYW5nZSBiYXNlZCBvbiB0aGUgc2VydmVyIGRhdGFcbiAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSBlYWNoIHRhYnMgVVJMIHRvIGluY2x1ZGUgdGhlIG9yZGVyIGFzIHBhcnQgb2YgdGhlaXIgcGFyYW1zLlxuICAgIC8vIFRoaXMgaGVscHMgd2l0aCBwZXJzaXN0aW5nIHN0YXRlIGFjcm9zcyB2ZXJ0aWNhbHMuXG4gICAgbGV0IHRhYnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RhYk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGFiID0gdGhpcy5fdGFic1t0aGlzLl90YWJPcmRlcltpXV07XG4gICAgICBpZiAodGFiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFiLnVybCA9IHRoaXMuZ2VuZXJhdGVUYWJVcmwodGFiLmJhc2VVcmwsIHRoaXMuZ2V0VXJsUGFyYW1zKCkpO1xuICAgICAgICB0YWJzLnB1c2godGFiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgdGFiczogdGFicyxcbiAgICAgIG92ZXJmbG93TGFiZWw6IHRoaXMub3ZlcmZsb3dMYWJlbCxcbiAgICAgIG92ZXJmbG93SWNvbjogdGhpcy5vdmVyZmxvd0ljb24sXG4gICAgICBzaG93Q29sbGFwc2U6IHRoaXMuc2hvdWxkQ29sbGFwc2UoKSxcbiAgICAgIGFyaWFMYWJlbDogdGhpcy5fYXJpYUxhYmVsXG4gICAgfSk7XG4gIH1cblxuICBnZXRVcmxQYXJhbXMgKCkge1xuICAgIHJldHVybiBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgfVxuXG4gIHNob3VsZENvbGxhcHNlICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX21vYmlsZU92ZXJmbG93QmVoYXZpb3IpIHtcbiAgICAgIGNhc2UgTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTi5DT0xMQVBTRTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04uSU5ORVJTQ1JPTEw6XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1jb250YWluZXInKSB8fCB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG5hdldpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgICByZXR1cm4gbmF2V2lkdGggPiBNT0JJTEVfQlJFQUtQT0lOVDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0RGVmYXVsdFRhYk9yZGVyIHdpbGwgY29tcHV0ZSB0aGUgaW5pdGlhbCB0YWIgb3JkZXJpbmcgYmFzZWRcbiAgICogb24gYSBjb21iaW5hdGlvbiBvZiB0aGUgY29uZmlndXJhdGlvbiBwcm92aWRlZCBkaXJlY3RseSB0byB0aGUgY29tcG9uZW50XG4gICAqIGFuZCB0aGUgdXJsIHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gdGFic0NvbmZpZ1xuICAgKiBAcGFyYW0ge1NlYXJjaFBhcmFtc31cbiAgICovXG4gIGdldERlZmF1bHRUYWJPcmRlciAodGFic0NvbmZpZywgdXJsUGFyYW1zKSB7XG4gICAgbGV0IHRhYk9yZGVyID0gW107XG5cbiAgICAvLyBVc2UgdGhlIG9yZGVyaW5nIGZyb20gdGhlIFVSTCBhcyB0aGUgcHJpbWFyeSBjb25maWd1cmF0aW9uXG4gICAgLy8gQW5kIHRoZW4gbWVyZ2UgaXQgd2l0aCB0aGUgbG9jYWwgY29uZmlndXJhdGlvbiwgaWYgcHJvdmlkZWQuXG4gICAgaWYgKHVybFBhcmFtcyAmJiB1cmxQYXJhbXMuaGFzKCd0YWJPcmRlcicpKSB7XG4gICAgICB0YWJPcmRlciA9IHVybFBhcmFtcy5nZXQoJ3RhYk9yZGVyJykuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhYiA9IHRhYnNDb25maWdbaV07XG4gICAgICAvLyBTb21lIHRhYnMgZG9uJ3QgaGF2ZSBjb25maWdJZCwgc28gd2UgbWFwIGl0IGZyb20gVVJMXG4gICAgICBpZiAodGFiLmNvbmZpZ0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFiLmNvbmZpZ0lkID0gdGFiLnVybDtcbiAgICAgIH1cblxuICAgICAgLy8gQXZvaWQgZHVwbGljYXRlcyBpZiBjb25maWcgd2FzIHByb3ZpZGVkIGZyb20gVVJMXG4gICAgICBpZiAodGFiT3JkZXIuaW5jbHVkZXModGFiLmNvbmZpZ0lkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXNGaXJzdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBsaXN0XG4gICAgICBpZiAodGFiLmlzRmlyc3QpIHtcbiAgICAgICAgdGFiT3JkZXIudW5zaGlmdCh0YWIuY29uZmlnSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFiT3JkZXIucHVzaCh0YWIuY29uZmlnSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWJPcmRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBtZXJnZVRhYk9yZGVyIG1lcmdlcyB0d28gYXJyYXlzIGludG8gb25lXG4gICAqIGJ5IGFwcGVuZGluZyBhZGRpdGlvbmFsIHRhYnMgdG8gdGhlIGVuZCBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gdGFiT3JkZXIgVGFiIG9yZGVyIHByb3ZpZGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3RoZXJUYWJPcmRlciBUYWIgb3JkZXIgcHJvdmlkZWQgYnkgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAgICovXG4gIG1lcmdlVGFiT3JkZXIgKHRhYk9yZGVyLCBvdGhlclRhYk9yZGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlclRhYk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0YWJDb25maWcgPSBvdGhlclRhYk9yZGVyW2ldO1xuICAgICAgaWYgKHRhYk9yZGVyLmluY2x1ZGVzKHRhYkNvbmZpZykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlzRmlyc3Qgc2hvdWxkIGJlIGFuIG92ZXJyaWRlIHRvIGR5bmFtaWMgdGFiIG9yZGVyaW5nLlxuICAgICAgaWYgKHRoaXMuX3RhYnNbdGFiQ29uZmlnXSAmJiB0aGlzLl90YWJzW3RhYkNvbmZpZ10uaXNGaXJzdCkge1xuICAgICAgICB0YWJPcmRlci51bnNoaWZ0KHRhYkNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJPcmRlci5wdXNoKHRhYkNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYk9yZGVyO1xuICB9XG5cbiAgZ2VuZXJhdGVUYWJVcmwgKGJhc2VVcmwsIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSkge1xuICAgIC8vIFdlIHdhbnQgdG8gcGVyc2lzdCB0aGUgcGFyYW1zIGZyb20gdGhlIGV4aXN0aW5nIFVSTCB0byB0aGUgbmV3XG4gICAgLy8gVVJMUyB3ZSBjcmVhdGUuXG4gICAgcGFyYW1zLnNldCgndGFiT3JkZXInLCB0aGlzLl90YWJPcmRlcik7XG4gICAgcmV0dXJuIGJhc2VVcmwgKyAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5cbi8qKlxuICogU2VhcmNoQ29tcG9uZW50IGV4cG9zZXMgYW4gaW50ZXJmYWNlIGluIG9yZGVyIHRvIGNyZWF0ZVxuICogYSBVSSBTZWFyY2ggZXhwZXJpZW5jZSBmb3IgdmVydGljYWwgYW5kIHVuaXZlcnNhbCBzZWFyY2guXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgYXV0by1jb21wbGV0ZSBhbmQgc2VhcmNoIHdpbGwgYmUgYmFzZWQgb24gdW5pdmVyc2FsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUXVlcnkgc3VibWlzc2lvbiBpcyBiYXNlZCBvbiBhIGZvcm0gYXMgY29udGV4dC5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gbmF0aXZlIGZvcm0gbm9kZSB3aXRoaW4gY29udGFpbmVyXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1TZWxlY3RvciB8fCAnZm9ybSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgZWxlbWVudCB1c2VkIGZvciBzZWFyY2hpbmcgYW5kIHdpcmVzIHVwIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvblxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5faW5wdXRFbCA9IGNvbmZpZy5pbnB1dEVsIHx8ICcuanMteWV4dC1xdWVyeSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdXNlZCwgcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlIGFzIGEgZGF0YSBwb2ludFxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuIElmIG5vdCBwcm92aWRlZCwgbm8gdGl0bGUgd2lsbCBiZSBpbmNsdWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdGV4dCBpcyB1c2VkIGZvciBsYWJlbGluZyB0aGUgaW5wdXQgYm94LCBhbHNvIHByb3ZpZGVkIHRvIHRlbXBsYXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxUZXh0ID0gY29uZmlnLmxhYmVsVGV4dCB8fCAnQ29uZHVjdCBhIHNlYXJjaCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VibWl0IHRleHQgaXMgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIHN1Ym1pdCBidXR0b24sIGFsc28gcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0gY29uZmlnLnN1Ym1pdFRleHQgfHwgJ1N1Ym1pdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xlYXIgdGV4dCBpcyB1c2VkIGZvciBsYWJlbGluZyB0aGUgY2xlYXIgYnV0dG9uLCBhbHNvIHByb3ZpZGVkIHRvIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJUZXh0ID0gY29uZmlnLmNsZWFyVGV4dCB8fCAnQ2xlYXInO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1Ym1pdCBpY29uIGlzIGFuIGljb24gZm9yIHRoZSBzdWJtaXQgYnV0dG9uLCBpZiBwcm92aWRlZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhbmQgdGhlXG4gICAgICogc3VibWl0IHRleHQgd2lsbCBiZSB1c2VkIGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdWJtaXRJY29uID0gY29uZmlnLnN1Ym1pdEljb24gfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSB0ZXh0IHRvIHNob3cgYXMgdGhlIGZpcnN0IGl0ZW0gZm9yIGF1dG8gY29tcGxldGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9tcHRIZWFkZXIgPSBjb25maWcucHJvbXB0SGVhZGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBdXRvIGZvY3VzZXMgdGhlIGlucHV0IGJveCBpZiBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9Gb2N1cyA9IGNvbmZpZy5hdXRvRm9jdXMgPT09IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGFuIFwieFwiIHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGNsZWFyIHRoZSBjdXJyZW50XG4gICAgICogcXVlcnlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyQnV0dG9uID0gY29uZmlnLmNsZWFyQnV0dG9uID09PSB1bmRlZmluZWRcbiAgICAgID8gdHJ1ZVxuICAgICAgOiBjb25maWcuY2xlYXJCdXR0b247XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGF1dG9mb2N1c2luZyBvbiBsb2FkLCBvcHRpb25hbGx5IG9wZW4gdGhlIGF1dG9jb21wbGV0ZVxuICAgICAqIChwcmVzZXQgcHJvbXB0cylcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCA9IGNvbmZpZy5hdXRvY29tcGxldGVPbkxvYWQgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBzdWJtaXRVUkwgd2lsbCBmb3JjZSB0aGUgc2VhcmNoIHF1ZXJ5IHN1Ym1pc3Npb24gdG8gZ2V0XG4gICAgICogcmVkaXJlY3RlZCB0byB0aGUgVVJMIHByb3ZpZGVkLlxuICAgICAqIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBudWxsLlxuICAgICAqXG4gICAgICogSWYgbm8gcmVkaXJlY3RVcmwgcHJvdmlkZWQsIHdlIGtlZXAgdGhlIHBhZ2UgYXMgYSBzaW5nbGUgcGFnZSBhcHAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZGlyZWN0VXJsID0gY29uZmlnLnJlZGlyZWN0VXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZXJlIGlzIGFub3RoZXIgc2VhcmNoIGJhciBwcmVzZW50IG9uIHRoZSBwYWdlLlxuICAgICAqIFR3aW5zIG9ubHkgdXBkYXRlIHRoZSBxdWVyeSwgYW5kIGRvIG5vdCBzZWFyY2hcbiAgICAgKi9cbiAgICB0aGlzLl9pc1R3aW4gPSBjb25maWcuaXNUd2luO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHN0cmluZyB0byB1c2UgZm9yIHRoZSBpbnB1dCBib3gsIHByb3ZpZGVkIHRvIHRlbXBsYXRlIGZvciByZW5kZXJpbmcuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gY29uZmlnLnF1ZXJ5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuUVVFUlksIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICB0aGlzLmRlYm91bmNlZFNlYXJjaChxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHRpbWUgYWxsb3dlZCBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBzZWFyY2hlcyB0byBwcmV2ZW50XG4gICAgICogbWFueSBkdXBsaWNhdGUgc2VhcmNoZXMgYmFjay10by1iYWNrXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaENvb2xkb3duID0gY29uZmlnLnNlYXJjaENvb2xkb3duIHx8IDMwMDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSBhbmQgXCJuZWFyIG1lXCIgaW50ZW50IGlzIGV4cHJlc3NlZCwgcHJvbXB0IHRoZSB1c2VyIGZvciB0aGVpciBnZW9sb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJvbXB0Rm9yTG9jYXRpb24gPSBjb25maWcucHJvbXB0Rm9yTG9jYXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgPyB0cnVlXG4gICAgICA6IEJvb2xlYW4oY29uZmlnLnByb21wdEZvckxvY2F0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgc2VhcmNoIGNsZWFyIGJ1dHRvblxuICAgICAqL1xuICAgIHRoaXMuX3Nob3dDbGVhckJ1dHRvbiA9IHRoaXMuY2xlYXJCdXR0b24gJiYgdGhpcy5xdWVyeTtcblxuICAgIC8qKlxuICAgICAqIEZvciB2ZXJ0aWNhbCBzZWFyY2ggYmFycywgd2hldGhlciBvciBub3QgdG8gYWxsb3cgZW1wdHkgc2VhcmNoZXMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbGxvd0VtcHR5U2VhcmNoID0gISFjb25maWcuYWxsb3dFbXB0eVNlYXJjaDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCBBdXRvQ29tcGxldGUgY29tcG9uZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hdXRvQ29tcGxldGVOYW1lID0gYCR7dGhpcy5uYW1lfS5hdXRvY29tcGxldGVgO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1NlYXJjaEJhcic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9zZWFyY2gnO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5ICE9IG51bGwgJiYgIXRoaXMucmVkaXJlY3RVcmwpIHtcbiAgICAgIHRoaXMuY29yZS5zZXRRdWVyeSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBOT1RFKGFtdWxsaW5ncyk6IElmIGF1dG9jb21wbGV0ZU9uTG9hZCBpcyBmYWxzZSwgd2UgZm9jdXMgdGhlIGlucHV0XG4gICAgLy8gZWxlbWVudCBiZWZvcmUgbG9hZGluZyB0aGUgYXV0b2NvbXBsZXRlIGNvbXBvbmVudCBzbyB0aGF0IGl0cyBmb2N1c1xuICAgIC8vIGhhbmRsZXIgd29uJ3QgYmUgdHJpZ2dlcmVkXG4gICAgaWYgKHRoaXMuYXV0b0ZvY3VzID09PSB0cnVlICYmICF0aGlzLnF1ZXJ5ICYmICF0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCkge1xuICAgICAgdGhpcy5mb2N1c0lucHV0RWxlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIFdpcmUgdXAgb3VyIHNlYXJjaCBoYW5kbGluZyBhbmQgYXV0byBjb21wbGV0ZVxuICAgIHRoaXMuaW5pdFNlYXJjaCh0aGlzLl9mb3JtRWwpO1xuICAgIHRoaXMuaW5pdEF1dG9Db21wbGV0ZSh0aGlzLl9pbnB1dEVsKTtcblxuICAgIGlmICh0aGlzLmNsZWFyQnV0dG9uKSB7XG4gICAgICB0aGlzLmluaXRDbGVhckJ1dHRvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyA9PT0gdHJ1ZSAmJiAhdGhpcy5xdWVyeSAmJiB0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCkge1xuICAgICAgdGhpcy5mb2N1c0lucHV0RWxlbWVudCgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZSAoKSB7XG4gICAgdGhpcy5fYXV0b2NvbXBsZXRlLnJlbW92ZSgpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG5cbiAgaW5pdENsZWFyQnV0dG9uICgpIHtcbiAgICBjb25zdCBidXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1TZWFyY2hCYXItY2xlYXInKTtcbiAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSB0aGlzLl9zaG93Q2xlYXJCdXR0b24gfHwgdGhpcy5xdWVyeTtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZSgneXh0LVNlYXJjaEJhci0taGlkZGVuJywgIXRoaXMuX3Nob3dDbGVhckJ1dHRvbik7XG5cbiAgICBET00ub24oYnV0dG9uLCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gJyc7XG4gICAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSBmYWxzZTtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd5eHQtU2VhcmNoQmFyLS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWSwgdGhpcy5xdWVyeSk7XG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHRoaXMucXVlcnkpO1xuXG4gICAgICAvLyBGb2N1cyB0aGUgaW5wdXQgZWxlbWVudCBhZnRlciBjbGVhcmluZyB0aGUgcXVlcnksIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuICAgICAgLy8gb3Igbm90IHRoZSBhdXRvRm9jdXMgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAgICAvLyBOT1RFKGFtdWxsaW5ncyk6IFRoaXMgZGVwZW5kcyBoZWF2aWx5IG9uIHRoZSBmYWN0IHRoYXQgdGhlIHJlLXJlbmRlcnNcbiAgICAgIC8vIHRyaWdnZXJlZCBieSBzZXRTdGF0ZSBhbmQgY29yZS5zZXRRdWVyeSBoYXBwZW4gc3luY2hyb25vdXNseTsgaWYgdGhpc1xuICAgICAgLy8gc3RvcHMgYmVpbmcgdGhlIGNhc2UgYXQgc29tZSBwb2ludCwgd2UnbGwgbmVlZCBhbiBhbHRlcm5hdGl2ZSBzb2x1dGlvblxuICAgICAgdGhpcy5mb2N1c0lucHV0RWxlbWVudCgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCB0aGlzLl9pbnB1dEVsKTtcbiAgICBET00ub24oaW5wdXQsICdpbnB1dCcsIGUgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fc2hvd0NsZWFyQnV0dG9uICYmIGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaG93Q2xlYXJCdXR0b24gJiYgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Nob3dDbGVhckJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci0taGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIHVzZSBmb3Igd2lyaW5nIHVwIHNlYXJjaGluZyBvbiBmb3JtIHN1Ym1pc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1TZWxlY3RvciBDU1Mgc2VsZWN0b3IgdG8gYmluZCBvdXIgc3VibWl0IGhhbmRsaW5nIHRvXG4gICAqL1xuICBpbml0U2VhcmNoIChmb3JtU2VsZWN0b3IpIHtcbiAgICB0aGlzLl9mb3JtRWwgPSBmb3JtU2VsZWN0b3I7XG5cbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci13cmFwcGVyJyk7XG5cbiAgICBsZXQgZm9ybSA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIGZvcm1TZWxlY3Rvcik7XG4gICAgaWYgKCFmb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIFNlYXJjaEJhcjsgQ2FuIG5vdCBmaW5kIHtIVE1MRWxlbWVudH0gYCcsIHRoaXMuX2Zvcm1FbCwgJ2AuJyk7XG4gICAgfVxuXG4gICAgRE9NLm9uKGZvcm0sICdzdWJtaXQnLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBsZXQgaW5wdXRFbCA9IGZvcm0ucXVlcnlTZWxlY3Rvcih0aGlzLl9pbnB1dEVsKTtcblxuICAgICAgbGV0IHF1ZXJ5ID0gaW5wdXRFbC52YWx1ZTtcbiAgICAgIGxldCBwYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgIHBhcmFtcy5zZXQoJ3F1ZXJ5JywgcXVlcnkpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVkaXJlY3RVcmwsIHdlIHdhbnQgdGhlIGZvcm0gdG8gYmVcbiAgICAgIC8vIHNlcmlhbGl6ZWQgYW5kIHN1Ym1pdHRlZC5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWRpcmVjdFVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnJlZGlyZWN0VXJsICsgJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaW5wdXRFbC5ibHVyKCk7XG5cbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUlksIHF1ZXJ5KTtcbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuc2V0UXVlcnkocXVlcnkpO1xuICAgICAgdGhpcy5kZWJvdW5jZWRTZWFyY2gocXVlcnkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB3aXJlIHVwIG91ciBhdXRvIGNvbXBsZXRlIG9uIGFuIGlucHV0IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFNlbGVjdG9yIENTUyBzZWxlY3RvciB0byBiaW5kIG91ciBhdXRvIGNvbXBsZXRlIGNvbXBvbmVudCB0b1xuICAgKi9cbiAgaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIHRoaXMuX2lucHV0RWwgPSBpbnB1dFNlbGVjdG9yO1xuXG4gICAgaWYgKHRoaXMuX2F1dG9jb21wbGV0ZSkge1xuICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dG9jb21wbGV0ZSA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoJ0F1dG9Db21wbGV0ZScsIHtcbiAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgbmFtZTogdGhpcy5fYXV0b0NvbXBsZXRlTmFtZSxcbiAgICAgIGNvbnRhaW5lcjogJy55eHQtU2VhcmNoQmFyLWF1dG9jb21wbGV0ZScsXG4gICAgICBhdXRvRm9jdXM6IHRoaXMuYXV0b0ZvY3VzICYmICF0aGlzLmF1dG9jb21wbGV0ZU9uTG9hZCxcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5wcm9tcHRIZWFkZXIsXG4gICAgICBvcmlnaW5hbFF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgaW5wdXRFbDogaW5wdXRTZWxlY3RvcixcbiAgICAgIG9uU3VibWl0OiAoKSA9PiB7XG4gICAgICAgIERPTS50cmlnZ2VyKERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2Zvcm1FbCksICdzdWJtaXQnKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICBET00udHJpZ2dlcihET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBpbnB1dFNlbGVjdG9yKSwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBkZWJvdW5jZWQgcXVlcnkgdXNpbmcgdGhlIHByb3ZpZGVkIHN0cmluZyBpbnB1dC4gU3BlY2lmaWNhbGx5LCBhIG5ldyBzZWFyY2ggaXMgbm90XG4gICAqIHBlcmZvcm1lZCBpZiB3ZSByZWNlbnRseSBzZWFyY2hlZCwgaWYgdGhlcmUncyBubyBxdWVyeSBmb3IgdW5pdmVyc2FsIHNlYXJjaCwgb3IgaWYgdGhpc1xuICAgKiBpcyBhIHR3aW4gc2VhcmNoYmFyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHN0cmluZyB0byBxdWVyeSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBwZXJmb3JtIHRoZSBxdWVyeSBhbmQgdXBkYXRlIGdsb2JhbFN0b3JhZ2UgYWNjb3JkaW5nbHkuXG4gICAqL1xuICBkZWJvdW5jZWRTZWFyY2ggKHF1ZXJ5KSB7XG4gICAgaWYgKHRoaXMuX3Rocm90dGxlZCB8fFxuICAgICAgKCFxdWVyeSAmJiAhdGhpcy5fdmVydGljYWxLZXkpIHx8XG4gICAgICAoIXF1ZXJ5ICYmIHRoaXMuX3ZlcnRpY2FsS2V5ICYmICF0aGlzLl9hbGxvd0VtcHR5U2VhcmNoKSB8fFxuICAgICAgdGhpcy5faXNUd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdGhyb3R0bGVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fdGhyb3R0bGVkID0gZmFsc2U7IH0sIHRoaXMuX3NlYXJjaENvb2xkb3duKTtcblxuICAgIC8vIElmIF9wcm9tcHRGb3JMb2NhdGlvbiBpcyBlbmFibGVkLCB3ZSB3aWxsIGNvbXB1dGUgdGhlIHF1ZXJ5J3MgaW50ZW50IGFuZCwgZnJvbSB0aGVyZSxcbiAgICAvLyBkZXRlcm1pbmUgaWYgaXQncyBuZWNlc3NhcnkgdG8gcHJvbXB0IHRoZSB1c2VyIGZvciB0aGVpciBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gSXQgd2lsbFxuICAgIC8vIGJlIHVubmVjZXNzYXJ5IGlmIHRoZSBxdWVyeSBkb2VzIG5vdCBoYXZlIG5lYXIgbWUgaW50ZW50IG9yIHdlIGFscmVhZHkgaGF2ZSB0aGVpciBsb2NhdGlvblxuICAgIC8vIHN0b3JlZC5cbiAgICBpZiAodGhpcy5fcHJvbXB0Rm9yTG9jYXRpb24pIHtcbiAgICAgIHRoaXMuZmV0Y2hRdWVyeUludGVudHMocXVlcnkpXG4gICAgICAgIC50aGVuKHF1ZXJ5SW50ZW50cyA9PiBxdWVyeUludGVudHMuaW5jbHVkZXMoJ05FQVJfTUUnKSlcbiAgICAgICAgLnRoZW4ocXVlcnlIYXNOZWFyTWVJbnRlbnQgPT4ge1xuICAgICAgICAgIGlmIChxdWVyeUhhc05lYXJNZUludGVudCAmJiAhdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3lcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNlYXJjaChxdWVyeSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZSh0aGlzLnNlYXJjaChxdWVyeSkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHF1ZXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHF1ZXJ5IHVzaW5nIHRoZSBwcm92aWRlZCBzdHJpbmcgaW5wdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBUaGUgc3RyaW5nIHRvIHF1ZXJ5IGFnYWluc3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIHBlcmZvcm0gdGhlIHF1ZXJ5IGFuZCB1cGRhdGUgZ2xvYmFsU3RvcmFnZSBhY2NvcmRpbmdseS5cbiAgICovXG4gIHNlYXJjaCAocXVlcnkpIHtcbiAgICBpZiAodGhpcy5fdmVydGljYWxLZXkpIHtcbiAgICAgIGNvbnN0IGFsbEZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGlucHV0OiBxdWVyeSxcbiAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICAgIG9mZnNldDogdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5PVEUoYmlsbHkpIFRlbXBvcmFyeSBoYWNrIGZvciBERU1PXG4gICAgICAvLyBSZW1vdmUgbWUgYWZ0ZXIgdGhlIGRlbW9cbiAgICAgIGxldCBuYXYgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXJcbiAgICAgICAgLmdldEFjdGl2ZUNvbXBvbmVudCgnTmF2aWdhdGlvbicpO1xuXG4gICAgICBpZiAobmF2KSB7XG4gICAgICAgIGxldCB0YWJzID0gbmF2LmdldFN0YXRlKCd0YWJzJyk7XG4gICAgICAgIGxldCB1cmxzID0ge307XG5cbiAgICAgICAgaWYgKHRhYnMgJiYgQXJyYXkuaXNBcnJheSh0YWJzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXModGFic1tpXS51cmwuc3BsaXQoJz8nKVsxXSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgICAgICAgbGV0IHVybCA9IHRhYnNbaV0uYmFzZVVybDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudG9TdHJpbmcoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHVybCArPSAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHNbdGFic1tpXS5jb25maWdJZF0gPSB1cmw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcmUuc2VhcmNoKHF1ZXJ5LCB1cmxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBjb21wdXRlcyB0aGUgaW50ZW50cyBvZiB0aGUgcHJvdmlkZWQgcXVlcnkuIElmIHRoZSBxdWVyeSB3YXMgZW50ZXJlZFxuICAgKiBtYW51YWxseSBpbnRvIHRoZSBzZWFyY2ggYmFyIG9yIHNlbGVjdGVkIHZpYSBhdXRvY29tcGxldGUsIGl0cyBpbnRlbnRzIHdpbGwgaGF2ZSBiZWVuIHN0b3JlZFxuICAgKiBhbHJlYWR5IGluIGdsb2JhbFN0b3JhZ2UuIE90aGVyd2lzZSwgYSBuZXcgQVBJIGNhbGwgd2lsbCBoYXZlIHRvIGJlIGlzc3VlZCB0byBkZXRlcm1pbmVcbiAgICogaW50ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIGludGVudCBpcyBuZWVkZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgY29udGFpbmluZyB0aGUgaW50ZW50cyBvZiB0aGUgcXVlcnkuXG4gICAqL1xuICBmZXRjaFF1ZXJ5SW50ZW50cyAocXVlcnkpIHtcbiAgICBjb25zdCBhdXRvY29tcGxldGVEYXRhID1cbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHt0aGlzLl9hdXRvQ29tcGxldGVOYW1lfWApO1xuICAgIGlmICghYXV0b2NvbXBsZXRlRGF0YSkge1xuICAgICAgY29uc3QgYXV0b2NvbXBsZXRlUmVxdWVzdCA9IHRoaXMuX3ZlcnRpY2FsS2V5XG4gICAgICAgID8gdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVZlcnRpY2FsKFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHRoaXMuX2F1dG9Db21wbGV0ZU5hbWUsXG4gICAgICAgICAgdGhpcy5fdmVydGljYWxLZXkpXG4gICAgICAgIDogdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVVuaXZlcnNhbChxdWVyeSwgdGhpcy5fYXV0b0NvbXBsZXRlTmFtZSk7XG4gICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUmVxdWVzdC50aGVuKGRhdGEgPT4gZGF0YS5pbnB1dEludGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBhcmUgdHdvIGFsdGVybmF0aXZlcyB0byBjb25zaWRlciBoZXJlLiBUaGUgdXNlciBjb3VsZCBoYXZlIHNlbGVjdGVkIHRoZSBxdWVyeVxuICAgICAgLy8gYXMgYW4gYXV0b2NvbXBsZXRlIG9wdGlvbiBvciBtYW51YWxseSBpbnB1dCBpdCB0aGVtc2VsdmVzLiBJZiB0aGUgZm9ybWVyLCB1c2UgdGhlIGludGVudHNcbiAgICAgIC8vIG9mIHRoZSBjb3JyZXNwb25kaW5nIGF1dG9jb21wbGV0ZSBvcHRpb24uIElmIHRoZSBsYXR0ZXIsIHVzZSB0aGUgaW5wdXRJbnRlbnRzIG9mIHRoZVxuICAgICAgLy8gYXV0b2NvbXBsZXRlRGF0YS5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhdXRvY29tcGxldGVEYXRhLnNlY3Rpb25zLmZsYXRNYXAoc2VjdGlvbiA9PiBzZWN0aW9uLnJlc3VsdHMpO1xuICAgICAgY29uc3QgbWF0Y2hpbmdSZXN1bHQgPSByZXN1bHRzLmZpbmQocmVzdWx0ID0+IHJlc3VsdC52YWx1ZSA9PT0gcXVlcnkpO1xuICAgICAgY29uc3QgcXVlcnlJbnRlbnRzID0gbWF0Y2hpbmdSZXN1bHQgPyBtYXRjaGluZ1Jlc3VsdC5pbnRlbnRzIDogYXV0b2NvbXBsZXRlRGF0YS5pbnB1dEludGVudHM7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5SW50ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGNvbnN0cnVjdHMgdGhlIG1ldGEgaW5mb3JtYXRpb24gbmVlZGVkIGJ5IHRoZSBTRUFSQ0hfQ0xFQVJfQlVUVE9OXG4gICAqIGFuYWx5dGljcyBldmVudC5cbiAgICovXG4gIGV2ZW50T3B0aW9ucyAoKSB7XG4gICAgY29uc3QgcXVlcnlJZCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZX0lEKTtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgcXVlcnlJZCAmJiB7IHF1ZXJ5SWQgfSxcbiAgICAgIHRoaXMuX3ZlcnRpY2FsS2V5ICYmIHsgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5IH1cbiAgICApO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBsYWJlbFRleHQ6IHRoaXMubGFiZWxUZXh0LFxuICAgICAgc3VibWl0SWNvbjogdGhpcy5zdWJtaXRJY29uLFxuICAgICAgc3VibWl0VGV4dDogdGhpcy5zdWJtaXRUZXh0LFxuICAgICAgY2xlYXJUZXh0OiB0aGlzLmNsZWFyVGV4dCxcbiAgICAgIHNob3dDbGVhckJ1dHRvbjogdGhpcy5fc2hvd0NsZWFyQnV0dG9uLFxuICAgICAgcXVlcnk6IHRoaXMucXVlcnkgfHwgJycsXG4gICAgICBldmVudE9wdGlvbnM6IHRoaXMuZXZlbnRPcHRpb25zKClcbiAgICB9LCBkYXRhKSk7XG4gIH1cblxuICBmb2N1c0lucHV0RWxlbWVudCAoKSB7XG4gICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCkuZm9jdXMoKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoUGFyYW1zUGFyc2VyICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoUGFyYW1ldGVycyAoc2VhcmNoUGFyYW1ldGVyQ29uZmlncykge1xuICBsZXQgc2VhcmNoUGFyYW1ldGVycyA9IHtcbiAgICBzZWN0aW9uZWQ6IGZhbHNlLFxuICAgIGZpZWxkczogW11cbiAgfTtcbiAgaWYgKHNlYXJjaFBhcmFtZXRlckNvbmZpZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xuICB9XG4gIGlmIChzZWFyY2hQYXJhbWV0ZXJDb25maWdzLnNlY3Rpb25lZCkge1xuICAgIHNlYXJjaFBhcmFtZXRlcnMuc2VjdGlvbmVkID0gc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5zZWN0aW9uZWQ7XG4gIH1cbiAgc2VhcmNoUGFyYW1ldGVycy5maWVsZHMgPSBidWlsZEZpZWxkcyhzZWFyY2hQYXJhbWV0ZXJDb25maWdzLmZpZWxkcyk7XG4gIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xufVxuXG5mdW5jdGlvbiBidWlsZEZpZWxkcyAoZmllbGRDb25maWdzKSB7XG4gIGlmIChmaWVsZENvbmZpZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBmaWVsZENvbmZpZ3MubWFwKGZjID0+ICh7IGZldGNoRW50aXRpZXM6IGZhbHNlLCAuLi5mYyB9KSk7XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXJTZWFyY2hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcbmltcG9ydCBidWlsZFNlYXJjaFBhcmFtZXRlcnMgZnJvbSAnLi4vLi4vdG9vbHMvc2VhcmNocGFyYW1zcGFyc2VyJztcblxuLyoqXG4gKiBGaWx0ZXJTZWFyY2hDb21wb25lbnQgaXMgdXNlZCBmb3IgYXV0b2NvbXBsZXRlIHVzaW5nIHRoZSBGaWx0ZXJTZWFyY2ggYmFja2VuZC5cbiAqIEl0J2xsIGFsbG93IHlvdSB0byBwaWNrIHByZS1zZXQgZmlsdGVycyB0aGF0IGFyZSBzZXR1cCBvbiB0aGUgYmFja2VuZCB3aXRoaW5cbiAqIGEgdmVydGljYWwgc2VhcmNoIGNvbnRleHQuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlclNlYXJjaENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlIHRoZSBmaWx0ZXIgdmFsdWUgYnV0IGRvIG5vdCBzZWFyY2ggb24gY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBzdWJtaXNzaW9uIGlzIGJhc2VkIG9uIGEgZm9ybSBhcyBjb250ZXh0LlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0cyB0byBuYXRpdmUgZm9ybSBub2RlIHdpdGhpbiBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9mb3JtRWwgPSBjb25maWcuZm9ybVNlbGVjdG9yIHx8ICdmb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgZm9yIHNlYXJjaGluZyBhbmQgd2lyZXMgdXAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9uXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9pbnB1dEVsID0gY29uZmlnLmlucHV0RWwgfHwgJy5qcy15ZXh0LXF1ZXJ5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB1c2VkLCBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUgYXMgYSBkYXRhIHBvaW50XG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VhcmNoIHRleHQgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGlucHV0IGJveCwgYWxzbyBwcm92aWRlZCB0byB0ZW1wbGF0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaFRleHQgPSBjb25maWcuc2VhcmNoVGV4dCB8fCAnV2hhdCBhcmUgeW91IGludGVyZXN0ZWQgaW4/JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSB0ZXh0IHRvIHNob3cgYXMgdGhlIGZpcnN0IGl0ZW0gZm9yIGF1dG8gY29tcGxldGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9tcHRIZWFkZXIgPSBjb25maWcucHJvbXB0SGVhZGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBdXRvIGZvY3VzZXMgdGhlIGlucHV0IGJveCBpZiBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9Gb2N1cyA9IGNvbmZpZy5hdXRvRm9jdXMgPT09IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBzdWJtaXRVUkwgd2lsbCBmb3JjZSB0aGUgc2VhcmNoIHF1ZXJ5IHN1Ym1pc3Npb24gdG8gZ2V0XG4gICAgICogcmVkaXJlY3RlZCB0byB0aGUgVVJMIHByb3ZpZGVkLlxuICAgICAqIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBudWxsLlxuICAgICAqXG4gICAgICogSWYgbm8gcmVkaXJlY3RVcmwgcHJvdmlkZWQsIHdlIGtlZXAgdGhlIHBhZ2UgYXMgYSBzaW5nbGUgcGFnZSBhcHAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZGlyZWN0VXJsID0gY29uZmlnLnJlZGlyZWN0VXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gY29uZmlnLnF1ZXJ5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNlYXJjaCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpbHRlciBzdHJpbmcgdG8gdXNlIGZvciB0aGUgcHJvdmlkZWQgcXVlcnlcbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlciA9IGNvbmZpZy5maWx0ZXIgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBKU09OLnBhcnNlKHRoaXMuZmlsdGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hQYXJhbWV0ZXJzID0gYnVpbGRTZWFyY2hQYXJhbWV0ZXJzKGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKTtcblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIGYgPT4geyB0aGlzLmZpbHRlciA9IGY7IH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlclNlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9maWx0ZXJzZWFyY2gnO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5ICYmIHRoaXMuZmlsdGVyKSB7XG4gICAgICB0aGlzLnNlYXJjaCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIFdpcmUgdXAgb3VyIHNlYXJjaCBoYW5kbGluZyBhbmQgYXV0byBjb21wbGV0ZVxuICAgIHRoaXMuaW5pdEF1dG9Db21wbGV0ZSh0aGlzLl9pbnB1dEVsKTtcblxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyA9PT0gdHJ1ZSAmJiB0aGlzLnF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCkuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIHdpcmUgdXAgb3VyIGF1dG8gY29tcGxldGUgb24gYW4gaW5wdXQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIGF1dG8gY29tcGxldGUgY29tcG9uZW50IHRvXG4gICAqL1xuICBpbml0QXV0b0NvbXBsZXRlIChpbnB1dFNlbGVjdG9yKSB7XG4gICAgdGhpcy5faW5wdXRFbCA9IGlucHV0U2VsZWN0b3I7XG5cbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYCxcbiAgICAgIGlzRmlsdGVyU2VhcmNoOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiAnLnl4dC1TZWFyY2hCYXItYXV0b2NvbXBsZXRlJyxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5wcm9tcHRIZWFkZXIsXG4gICAgICBvcmlnaW5hbFF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgb3JpZ2luYWxGaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgaW5wdXRFbDogaW5wdXRTZWxlY3RvcixcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IHRoaXMuc2VhcmNoUGFyYW1ldGVycyxcbiAgICAgIG9uU3VibWl0OiAocXVlcnksIGZpbHRlcikgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgcGFyYW1zLnNldChgJHt0aGlzLm5hbWV9LnF1ZXJ5YCwgcXVlcnkpO1xuICAgICAgICBwYXJhbXMuc2V0KGAke3RoaXMubmFtZX0uZmlsdGVyYCwgZmlsdGVyKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVkaXJlY3RVcmwsIHdlIHdhbnQgdGhlIHBhcmFtcyB0byBiZVxuICAgICAgICAvLyBzZXJpYWxpemVkIGFuZCBzdWJtaXR0ZWQuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZWRpcmVjdFVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRoaXMucmVkaXJlY3RVcmwgKyAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIHRoZSBmaWx0ZXIgdG8gc3RvcmFnZSBmb3IgdGhlIG5leHQgc2VhcmNoXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBGaWx0ZXIuZnJvbVJlc3BvbnNlKGZpbHRlcik7XG4gICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHRoaXMucXVlcnkpO1xuICAgICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCwgdGhpcy5maWx0ZXIpO1xuICAgICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgdGhpcy5maWx0ZXIpO1xuICAgICAgICB0aGlzLnNlYXJjaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIHZlcnRpY2FsIHNlYXJjaCB3aXRoIGFsbCBzYXZlZCBmaWx0ZXJzIGFuZCBxdWVyeSxcbiAgICogb3B0aW9uYWxseSByZWRpcmVjdGluZyBiYXNlZCBvbiBjb25maWdcbiAgICovXG4gIHNlYXJjaCAoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlT25DaGFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgbGV0IHRvdGFsRmlsdGVyID0gZmlsdGVyc1swXTtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAxKSB7XG4gICAgICB0b3RhbEZpbHRlciA9IEZpbHRlci5hbmQoLi4uZmlsdGVycyk7XG4gICAgfVxuICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpIHx8ICcnO1xuICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUudmVydGljYWxTZWFyY2godGhpcy5fdmVydGljYWxLZXksIHtcbiAgICAgIGlucHV0OiBzZWFyY2hRdWVyeSxcbiAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKVxuICAgIH0pO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7XG4gICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgIHNlYXJjaFRleHQ6IHRoaXMuc2VhcmNoVGV4dCxcbiAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxuICAgIH0sIGRhdGEpKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXV0b0NvbXBsZXRlQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuY29uc3QgS2V5cyA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxMyxcbiAgU0hJRlQ6IDE2LFxuICBDVFJMOiAxNyxcbiAgQUxUOiAxOCxcbiAgRVNDQVBFOiAyNyxcblxuICBMRUZUOiAzNyxcbiAgUklHSFQ6IDM5LFxuICBVUDogMzgsXG5cbiAgREVMRVRFOiA0NixcbiAgRE9XTjogNDAsXG4gIExFRlRfT1NfS0VZOiA5MSxcbiAgUklHSFRfT1NfS0VZOiA5MixcbiAgU0VMRUNUX0tFWTogOTNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIHN5c3RlbU9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbU9wdHMpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhdXRvY29tcGxldGUgaXMgc2ltcGxlIG9yIGZpbHRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNGaWx0ZXJTZWFyY2ggPSBvcHRzLmlzRmlsdGVyU2VhcmNoIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGB2ZXJ0aWNhbEtleWAgb2YgdGhlIHZlcnRpY2FsIHNlYXJjaCB0byB1c2UgZm9yIGF1dG8tY29tcGxldGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gb3B0cy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsIHNlbGVjdG9yIGZvciBhdXRvIGNvbXBsZXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9pbnB1dEVsID0gb3B0cy5pbnB1dEVsIHx8ICcuanMteWV4dC1xdWVyeSc7XG5cbiAgICAvKipcbiAgICAgKiBBIHNlbGVjdG9yIGZvciB0aGUgYXV0b2NvbXBsZXRlIGVsZW1lbnRlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fYXV0b2NvbXBsZXRlRWxzID0gb3B0cy5hdXRvQ29tcGxldGVFbHMgfHwgJy5qcy15ZXh0LWF1dG9jb21wbGV0ZS1vcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIGZvciB0aGUgZGF0YS1zdG9yYWdlIHRvIGxpc3RlbiBmb3IgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7dGhpcy5uYW1lfWA7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGlucHV0IHZhbHVlIHdoZW4gdHlwaW5nLlxuICAgICAqIFdlIHVzZSB0aGlzIGZvciByZXNldHRpbmcgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIG90aGVyIGludGVyYWN0aW9ucyAoZS5nLiByZXN1bHQgbmF2aWdhdGlvbilcbiAgICAgKiBjaGFuZ2UgYmFzZWQgb24gaW50ZXJhY3Rpb25zLiBGb3IgaW5zdGFuY2UsIGhpdHRpbmcgZXNjYXBlIHNob3VsZCByZXNldCB0aGUgdmFsdWUgdG8gdGhlIG9yaWdpbmFsIHR5cGVkIHF1ZXJ5LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fb3JpZ2luYWxRdWVyeSA9IG9wdHMub3JpZ2luYWxRdWVyeSB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24gdGhyb3VnaCByZXN1bHRzLlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBzZWN0aW9uIHdlJ3JlIG5hdmlnYXRpbmcgaW4uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWN0aW9uSW5kZXggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbiB0aHJvdWdoIHJlc3VsdHMuXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlc3VsdCBpbmRleCB3ZSdyZSBuYXZpZ2F0aW5nIG9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVzdWx0SW5kZXggPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSB0ZXh0IHRvIHNob3cgYXMgdGhlIGZpcnN0IGl0ZW0gZm9yIGF1dG8gY29tcGxldGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9tcHRIZWFkZXIgPSBvcHRzLnByb21wdEhlYWRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgaW5wdXQgaXMgYXV0b2NvbWF0aWNhbGx5IGZvY3VzZWQgb3Igbm90XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fYXV0b0ZvY3VzID0gb3B0cy5hdXRvRm9jdXMgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIGBFbnRlcmAga2V5IGlzIHByZXNzZWQgb24gYXV0byBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICB0aGlzLl9vblN1Ym1pdCA9IG9wdHMub25TdWJtaXQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIHdoZW4ga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBhdXRvIGNvbXBsZXRlLiBOb3RlIHRoYXQgdGhpcyBpc1xuICAgICAqIG5vdCBjYWxsZWQgd2hlbiBlaXRoZXIgdGhlIGBFbnRlcmAga2V5IGlzIHByZXNzZWQgb3IgdGhlIG1vdXNlIGlzIHVzZWQgdG8gc2VsZWN0IGFuXG4gICAgICogYXV0b2NvbXBsZXRlIG9wdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLl9vbkNoYW5nZSA9IG9wdHMub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLl9zZWFyY2hQYXJhbWV0ZXJzID0gb3B0cy5zZWFyY2hQYXJhbWV0ZXJzIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFsaWFzZWQgdXNlZCBieSB0aGUgY29tcG9uZW50IG1hbmFnZXIgZm9yIGNyZWF0aW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0F1dG9Db21wbGV0ZSc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9hdXRvY29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldFN0YXRlIGlzIG92ZXJyaWRkZW4gc28gdGhhdCB3ZSBjYW4gcHJvdmlkZSBhZGRpdGlvbmFsIG1ldGEgZGF0YVxuICAgKiB0byB0aGUgdGVtcGxhdGUgKGUuZy4gdGhlIHNlY3Rpb25JbmRleCBhbmQgcmVzdWx0SW5kZXgpLCBzaW5jZVxuICAgKiB0aG9zZSBhcmUgY2xpZW50LWludGVyYWN0aW9uIHNwZWNpZmljIHZhbHVlcyBhbmQgYXJlbid0IHJldHVybmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICovXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmlzUXVlcnlJbnB1dEZvY3VzZWQoKSkge1xuICAgICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gMDtcbiAgICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gLTE7XG4gICAgICBkYXRhID0ge307XG4gICAgfVxuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIGhhc1Jlc3VsdHM6IHRoaXMuaGFzUmVzdWx0cyhkYXRhKSxcbiAgICAgIHNlY3Rpb25JbmRleDogdGhpcy5fc2VjdGlvbkluZGV4LFxuICAgICAgcmVzdWx0SW5kZXg6IHRoaXMuX3Jlc3VsdEluZGV4LFxuICAgICAgcHJvbXB0SGVhZGVyOiB0aGlzLl9vcmlnaW5hbFF1ZXJ5Lmxlbmd0aCA9PT0gMCA/IHRoaXMucHJvbXB0SGVhZGVyIDogbnVsbFxuICAgIH0pKTtcbiAgfVxuXG4gIGlzUXVlcnlJbnB1dEZvY3VzZWQgKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTmFtZS5pbmNsdWRlcyh0aGlzLl9pbnB1dEVsLnN1YnN0cmluZygxKSk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlU3RhdGUgaXMgYSBoZWxwZXIgdG8gYXBwbHkgdGhlIGN1cnJlbnQgc3RhdGUgd2l0aCBuZXcgY2xpZW50LXN0YXRlLlxuICAgKi9cbiAgdXBkYXRlU3RhdGUgKCkge1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fc3RhdGUuZ2V0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uQ3JlYXRlIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgZnJhbWV3b3JrLlxuICAgKiBPbmNlIHdlJ3JlIGluaXRhbGl6ZWQsIHdlIHdpcmUgdXAgYWxsIG9mIG91ciB1c2VyIGludGVyYWN0aW9uc1xuICAgKi9cbiAgb25DcmVhdGUgKCkge1xuICAgIC8vIFVzZSB0aGUgY29udGV4dCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBmaW5kIHRoZSBpbnB1dCBub2RlLlxuICAgIGxldCBxdWVyeUlucHV0ID0gRE9NLnF1ZXJ5KHRoaXMuX3BhcmVudENvbnRhaW5lciwgdGhpcy5faW5wdXRFbCk7XG4gICAgaWYgKCFxdWVyeUlucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIEF1dG9Db21wbGV0ZS4gQ2FuIG5vdCBmaW5kIHtIVE1MRWxlbWVudH0gYCcsIHRoaXMuX2lucHV0RWwsICdgLicpO1xuICAgIH1cblxuICAgIC8vIERpc2FibGUgdGhlIG5hdGl2ZSBhdXRvY29tcGxldGUsIGF1dG9jb3JyZWN0ICYgc3BlbGxjaGVja1xuICAgIERPTS5hdHRyaWJ1dGVzKHF1ZXJ5SW5wdXQsIHtcbiAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4gICAgICBzcGVsbGNoZWNrOiAnZmFsc2UnXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgdXNlciBleGl0cyB0aGUgaW5wdXQsIHNvIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHN0YXRlIGFuZCBjbG9zZVxuICAgIC8vIHRoZSBhdXRvIGNvbXBsZXRlXG4gICAgLy8gVE9ETyhqZGVsZXJtZSk6IENsb3NlIGxvZ2ljIHRvIGJlIG1vdmVkIHRvIHBhcmVudFxuICAgIERPTS5vbihkb2N1bWVudCwgJ2NsaWNrJywgZSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQubWF0Y2hlcygnLmpzLXl4dC1BdXRvQ29tcGxldGUtd3JhcHBlciAqJykgfHwgZS50YXJnZXQubWF0Y2hlcyh0aGlzLl9pbnB1dEVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIGEgdXNlciBmb2N1c2VzIHRoZSBpbnB1dCwgd2Ugc2hvdWxkIHBvcHVsYXRlIHRoZSBhdXRvY29tcGxldGUgYmFzZWRcbiAgICAvLyBvbiB0aGUgY3VycmVudCB2YWx1ZVxuICAgIERPTS5vbihxdWVyeUlucHV0LCAnZm9jdXMnLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLmF1dG9Db21wbGV0ZShxdWVyeUlucHV0LnZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5hdmlnYXRlIGJldHdlZW4gdGhlIHJlc3VsdHMgdXNpbmcgdGhlIGtleWJvYXJkXG4gICAgRE9NLm9uKHF1ZXJ5SW5wdXQsICdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlTmF2aWdhdGVSZXN1bHRzKGUua2V5Q29kZSwgZSk7XG4gICAgICB0aGlzLmhhbmRsZVN1Ym1pdFJlc3VsdChlLmtleUNvZGUsIHF1ZXJ5SW5wdXQudmFsdWUsIGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX2F1dG9Gb2N1cykge1xuICAgICAgRE9NLm9uY2UocXVlcnlJbnB1dCwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZShxdWVyeUlucHV0LnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIHNlbGVjdCBhIHJlc3VsdCB3aXRoIHRoZSBtb3VzZVxuICAgIERPTS5kZWxlZ2F0ZSh0aGlzLl9jb250YWluZXIsICcuanMteWV4dC1hdXRvY29tcGxldGUtb3B0aW9uJywgJ2NsaWNrJywgKGV2dCwgdGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IHRhcmdldC5kYXRhc2V0O1xuICAgICAgbGV0IHZhbCA9IGRhdGEuc2hvcnQ7XG5cbiAgICAgIHRoaXMudXBkYXRlUXVlcnkodmFsKTtcbiAgICAgIHRoaXMuX29uU3VibWl0KHZhbCwgZGF0YS5maWx0ZXIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gV2hlbiB0aGUgdXNlciBpcyB0eXBpbmcgaW4gdGhlIGlucHV0LCBwcm9jZXNzIHRoZSBhdXRvIGNvbXBsZXRlLlxuICAgIERPTS5vbihxdWVyeUlucHV0LCAna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVUeXBpbmcoZS5rZXlDb2RlLCBxdWVyeUlucHV0LnZhbHVlLCBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjbG9zZSB3aWxsIGhpZGUgdGhlIGF1dG8gY29tcGxldGUgcmVzdWx0cyBhbmQgcmVzZXQgdGhlIHN0YXRlLlxuICAgKi9cbiAgY2xvc2UgKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXNldHMgdGhlIGNsaWVudCBzdGF0ZSB0byB0aGVpciBvcmlnaW5hbCB2YWx1ZXMgYW5kIHRyaWdnZXJzXG4gICAqIGEgdGVtcGxhdGUtcmVyZW5kZXIgdmlhIHVwZGF0ZVN0YXRlXG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gMDtcbiAgICB0aGlzLl9yZXN1bHRJbmRleCA9IC0xO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0VmFsdWUgT3B0aW9uIHZhbHVlIHByb3ZpZGVkLlxuICAgKiBJZiBubyB2YWx1ZSBwcm92aWRlZCwgd2UnbGwgdHJ5IHRvIGZpbmQgaXQgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiBpbmRleGVzLlxuICAgKi9cbiAgdXBkYXRlUXVlcnkgKG9wdFZhbHVlKSB7XG4gICAgLy8gT25seSB3YW50IHRvIHVwZGF0ZSB0aGUgcXVlcnkgc3RyaW5nIGlmIHRoZXJlcyBhIHZhbHVlLlxuICAgIC8vIElmIG9uZSBpcyBwcm92aWRlZCwgZ3JlYXQuXG4gICAgLy8gT3RoZXJ3aXNlLCBsZXRzIHRyeSB0byBmaW5kIGl0IGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSByZXN1bHRzLlxuICAgIGlmIChvcHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLl9zdGF0ZS5nZXQoJ3NlY3Rpb25zJyk7XG5cbiAgICAgIGxldCByZXN1bHRzID0gc2VjdGlvbnNbdGhpcy5fc2VjdGlvbkluZGV4XS5yZXN1bHRzO1xuICAgICAgb3B0VmFsdWUgPSByZXN1bHRzW3RoaXMuX3Jlc3VsdEluZGV4XS5zaG9ydFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBxdWVyeUVsID0gRE9NLnF1ZXJ5KHRoaXMuX3BhcmVudENvbnRhaW5lciwgdGhpcy5faW5wdXRFbCk7XG4gICAgcXVlcnlFbC52YWx1ZSA9IG9wdFZhbHVlO1xuICB9XG5cbiAgaGFuZGxlVHlwaW5nIChrZXksIHZhbHVlLCBlKSB7XG4gICAgbGV0IGlnbm9yZWRLZXlzID0gW1xuICAgICAgS2V5cy5ET1dOLFxuICAgICAgS2V5cy5VUCxcbiAgICAgIEtleXMuQ1RSTCxcbiAgICAgIEtleXMuQUxULFxuICAgICAgS2V5cy5TSElGVCxcbiAgICAgIEtleXMuTEVGVCxcbiAgICAgIEtleXMuUklHSFQsXG4gICAgICBLZXlzLkxFRlRfT1NfS0VZLFxuICAgICAgS2V5cy5SSUdIVF9PU19LRVksXG4gICAgICBLZXlzLkVOVEVSLFxuICAgICAgS2V5cy5UQUIsXG4gICAgICBLZXlzLlNFTEVDVF9LRVlcbiAgICBdO1xuXG4gICAgaWYgKGlnbm9yZWRLZXlzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXNlciBlc2NhcGVzIG91dCBvZiBhdXRvIGNvbXBsZXRlLCBzbyB3ZSByZXNldCBpdCB0byB0aGUgb3JpZ2luYWwgaW5wdXRcbiAgICBpZiAoa2V5ID09PSBLZXlzLkVTQ0FQRSkge1xuICAgICAgdGhpcy51cGRhdGVRdWVyeSh0aGlzLl9vcmlnaW5hbFF1ZXJ5KTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIG9yaWdpbmFsIHZhbHVlIGJhc2VkIG9uIHRoZSB1c2VyIGlucHV0XG4gICAgdGhpcy5fb3JpZ2luYWxRdWVyeSA9IHZhbHVlO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuYXV0b0NvbXBsZXRlKHZhbHVlKTtcbiAgfVxuXG4gIGF1dG9Db21wbGV0ZSAoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5pc0ZpbHRlclNlYXJjaCkge1xuICAgICAgdGhpcy5jb3JlLmF1dG9Db21wbGV0ZUZpbHRlcihpbnB1dCwge1xuICAgICAgICBuYW1lc3BhY2U6IHRoaXMubmFtZSxcbiAgICAgICAgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5LFxuICAgICAgICBzZWFyY2hQYXJhbWV0ZXJzOiB0aGlzLl9zZWFyY2hQYXJhbWV0ZXJzXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZlcnRpY2FsS2V5KSB7XG4gICAgICB0aGlzLmNvcmUuYXV0b0NvbXBsZXRlVmVydGljYWwoaW5wdXQsIHRoaXMubmFtZSwgdGhpcy5fdmVydGljYWxLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvcmUuYXV0b0NvbXBsZXRlVW5pdmVyc2FsKGlucHV0LCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgaWYgd2UgaGF2ZSByZXN1bHRzIGluIGFueSBzZWN0aW9uXG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIGhhc1Jlc3VsdHMgKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHNlY3Rpb25zID0gZGF0YVsnc2VjdGlvbnMnXTtcbiAgICBpZiAoIXNlY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHNlY3Rpb25zW2ldO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0cyA9IGRhdGEucmVzdWx0cztcbiAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVOYXZpZ2F0ZVJlc3VsdHMgKGtleSwgZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuX3N0YXRlLmdldCgnc2VjdGlvbnMnKTtcbiAgICBpZiAoc2VjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWN0aW9ucy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRhYmJpbmcgb3V0IG9yIGVudGVyIHNob3VsZCBjbG9zZSB0aGUgYXV0byBjb21wbGV0ZS5cbiAgICBpZiAoa2V5ID09PSBLZXlzLlRBQikge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzID0gc2VjdGlvbnNbdGhpcy5fc2VjdGlvbkluZGV4XS5yZXN1bHRzO1xuICAgIGlmIChrZXkgPT09IEtleXMuVVApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLl9yZXN1bHRJbmRleCA8PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWN0aW9uSW5kZXggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fc2VjdGlvbkluZGV4LS07XG4gICAgICAgICAgdGhpcy5fcmVzdWx0SW5kZXggPSBzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHRoaXMuX29yaWdpbmFsUXVlcnkpO1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVzdWx0SW5kZXgtLTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgIHRoaXMudXBkYXRlUXVlcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSBLZXlzLkRPV04pIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLl9yZXN1bHRJbmRleCA+PSByZXN1bHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25JbmRleCA8IHNlY3Rpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aGlzLl9zZWN0aW9uSW5kZXgrKztcbiAgICAgICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVzdWx0SW5kZXgrKztcbiAgICAgIHRoaXMudXBkYXRlUXVlcnkoKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTdWJtaXRSZXN1bHQgKGtleSwgdmFsdWUsIGUpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLl9zdGF0ZS5nZXQoJ3NlY3Rpb25zJyk7XG4gICAgaWYgKHNlY3Rpb25zID09PSB1bmRlZmluZWQgfHwgc2VjdGlvbnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIGlmICh0aGlzLmlzRmlsdGVyU2VhcmNoKSB7XG4gICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdWJtaXQgdGhlIHNlYXJjaCBvbiBlbnRlclxuICAgIGlmIChrZXkgPT09IEtleXMuRU5URVIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNGaWx0ZXJTZWFyY2ggJiYgdGhpcy5fcmVzdWx0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGZpbHRlciA9ICcnO1xuICAgICAgaWYgKHRoaXMuX3NlY3Rpb25JbmRleCA+PSAwICYmIHRoaXMuX3Jlc3VsdEluZGV4ID49IDApIHtcbiAgICAgICAgZmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoc2VjdGlvbnNbdGhpcy5fc2VjdGlvbkluZGV4XS5yZXN1bHRzW3RoaXMuX3Jlc3VsdEluZGV4XS5maWx0ZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHZhbHVlKTtcbiAgICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX29uU3VibWl0KHZhbHVlLCBmaWx0ZXIpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3BlbGxDaGVja0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL2RvbS9zZWFyY2hwYXJhbXMnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbi8qKlxuICogU3BlbGxDaGVja0NvbXBvbmVudCB3aWxsIHN1cHBvcnQgZGlzcGxheWluZyBzdWdnZXN0aW9uLCBhdXRvY29ycmVjdCBhbmQgY29tYmluZWQobWF5YmUgaW4gdGhlIGZ1dHVyZSlcbiAqIHByb3ZpZGVkIGZyb20gc3BlbGxpbmcgY29ycmVjdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlbGxDaGVja0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0s7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU3BlbGxDaGVjayc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvc3BlbGxjaGVjayc7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZSgnc2tpcFNwZWxsQ2hlY2snLCB0cnVlKTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKCdxdWVyeVRyaWdnZXInLCB0cnVlKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgc2hvdWxkU2hvdzogZGF0YS5jb3JyZWN0ZWRRdWVyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgY29ycmVjdGVkUXVlcnlVcmw6IHRoaXMuX2J1aWxkUmVkaXJlY3RRdWVyeVVybChkYXRhLmNvcnJlY3RlZFF1ZXJ5LCBkYXRhLnR5cGUpLFxuICAgICAgaGVscFRleHQ6IHRoaXMuX2dldEhlbHBUZXh0KGRhdGEudHlwZSlcbiAgICB9LCB2YWwpKTtcbiAgfVxuXG4gIF9idWlsZFJlZGlyZWN0UXVlcnlVcmwgKHF1ZXJ5LCB0eXBlKSB7XG4gICAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgIHBhcmFtcy5zZXQoJ3F1ZXJ5JywgcXVlcnkudmFsdWUpO1xuICAgIHBhcmFtcy5zZXQoJ3NraXBTcGVsbENoZWNrJywgdHJ1ZSk7XG4gICAgcGFyYW1zLnNldCgncXVlcnlUcmlnZ2VyJywgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH1cblxuICBfZ2V0SGVscFRleHQgKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1NVR0dFU1QnOlxuICAgICAgICByZXR1cm4gJ0RpZCB5b3UgbWVhbjonO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG4vKipcbiAqIExvY2F0aW9uQmlhc0NvbXBvbmVudCB3aWxsIHNob3cgdGhlIHVzZXIgd2hlcmUgaXMgdXNlZCBmb3IgbG9jYXRpb24gYmlhcyBhbmQgYWxsb3cgdXNlciB0b1xuICogaW1wcm92ZSBhY2N1cmFjeSB3aXRoIEhUTUw1IGdlb2xvY2F0aW9uLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhdGlvbkJpYXNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjaWV2ZSB1cGRhdGVzIGZyb20gc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGluZGV4XG4gICAgICogQHR5cGUge1N0b3JhZ2VLZXl9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgd2hlbiBsb2NhdGlvbiB1cGRhdGVkLFxuICAgICAqIGEgdW5pdmVyc2FsIHNlYXJjaCB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIC8vIFRPRE86IFJlbW92ZSBjb25maWcudmVydGljYWxLZXlcbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHKS52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdXNlZCBmb3IgdXBkYXRpbmcgbG9jYXRpb25cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgICAqL1xuICAgIHRoaXMuX3VwZGF0ZUxvY2F0aW9uRWwgPSBjb25maWcudXBkYXRlTG9jYXRpb25FbCB8fCAnLmpzLWxvY2F0aW9uQmlhcy11cGRhdGUtbG9jYXRpb24nO1xuXG4gICAgdGhpcy5fbG9jYXRpb25EaXNwbGF5TmFtZSA9ICcnO1xuXG4gICAgdGhpcy5fYWNjdXJhY3kgPSAnJztcblxuICAgIHRoaXMuX2FsbG93VXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdMb2NhdGlvbkJpYXMnO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnc2VhcmNoL2xvY2F0aW9uYmlhcyc7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAoIXRoaXMuX2FsbG93VXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQoKTtcbiAgICBET00ub24odGhpcy5fdXBkYXRlTG9jYXRpb25FbCwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmICgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikge1xuICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiwge1xuICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgICAgICByYWRpdXM6IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2RvU2VhcmNoKCk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdGhyb3cgZXJyb3Igb3Igd2FybmluZyBoZXJlIGlmIG5vIGdlb2xvY2F0aW9uP1xuICAgIH0pO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIHRoaXMuX2xvY2F0aW9uRGlzcGxheU5hbWUgPSBkYXRhLmxvY2F0aW9uRGlzcGxheU5hbWU7XG4gICAgdGhpcy5fYWNjdXJhY3kgPSBkYXRhLmFjY3VyYWN5O1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBsb2NhdGlvbkRpc3BsYXlOYW1lOiB0aGlzLl9nZXRMb2NhdGlvbkRpc3BsYXlOYW1lKGRhdGEpLFxuICAgICAgYWNjdXJhY3lUZXh0OiB0aGlzLl9nZXRBY2N1cmFjeUhlbHBUZXh0KGRhdGEuYWNjdXJhY3kpLFxuICAgICAgaXNQcmVjaXNlTG9jYXRpb246IGRhdGEuYWNjdXJhY3kgPT09ICdERVZJQ0UnICYmIHRoaXMuX2FsbG93VXBkYXRlLFxuICAgICAgaXNVbmtub3duTG9jYXRpb246IGRhdGEuYWNjdXJhY3kgPT09ICdVTktOT1dOJyxcbiAgICAgIHNob3VsZFNob3c6IGRhdGEuYWNjdXJhY3kgIT09IHVuZGVmaW5lZCxcbiAgICAgIGFsbG93VXBkYXRlOiB0aGlzLl9hbGxvd1VwZGF0ZVxuICAgIH0sIHZhbCkpO1xuICB9XG5cbiAgX2dldExvY2F0aW9uRGlzcGxheU5hbWUgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5hY2N1cmFjeSA9PT0gJ1VOS05PV04nKSB7XG4gICAgICByZXR1cm4gJ1Vua25vd24gTG9jYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5sb2NhdGlvbkRpc3BsYXlOYW1lO1xuICB9XG5cbiAgX2dldEFjY3VyYWN5SGVscFRleHQgKGFjY3VyYWN5KSB7XG4gICAgc3dpdGNoIChhY2N1cmFjeSkge1xuICAgICAgY2FzZSAnSVAnOlxuICAgICAgICByZXR1cm4gJ2Jhc2VkIG9uIHlvdXIgaW50ZXJuZXQgYWRkcmVzcyc7XG4gICAgICBjYXNlICdERVZJQ0UnOlxuICAgICAgICByZXR1cm4gJ2Jhc2VkIG9uIHlvdXIgZGV2aWNlJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICBfZG9TZWFyY2ggKCkge1xuICAgIGxldCBxdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcbiAgICBpZiAodGhpcy5fdmVydGljYWxLZXkpIHtcbiAgICAgIGNvbnN0IGFsbEZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuICAgICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGlucHV0OiBxdWVyeSxcbiAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICAgIG9mZnNldDogdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMCxcbiAgICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29yZS5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIF9kaXNhYmxlTG9jYXRpb25VcGRhdGVJZkdlb2xvY2F0aW9uRGVuaWVkICgpIHtcbiAgICBpZiAoJ3Blcm1pc3Npb25zJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdnZW9sb2NhdGlvbicgfSlcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlTG9jYXRpb25VcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9kaXNhYmxlTG9jYXRpb25VcGRhdGUgKCkge1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTik7XG4gICAgdGhpcy5fYWxsb3dVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxvY2F0aW9uRGlzcGxheU5hbWU6IHRoaXMuX2xvY2F0aW9uRGlzcGxheU5hbWUsXG4gICAgICBhY2N1cmFjeTogdGhpcy5fYWNjdXJhY3lcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRmFjZXQgKi9cblxuLyoqXG4gKiBNb2RlbCByZXByZXNlbnRpbmcgYSBmYWNldCBmaWx0ZXIgd2l0aCB0aGUgZm9ybWF0IG9mXG4gKiB7XG4gKiAgIFwiZmllbGRfbmFtZVwiOiBbIEZpbHRlcnMuLi4gXSxcbiAqICAgLi4uXG4gKiB9XG4gKlxuICogQHNlZSB7QGxpbmsgRmlsdGVyfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWNldCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZmFjZXQgZmlsdGVyIGZyb20gYSBsaXN0IG9mIEZpbHRlcnNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIHVzZSBpbiB0aGlzIGZhY2V0XG4gICAqIEByZXR1cm5zIHtGYWNldH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRmlsdGVycyAoYXZhaWxhYmxlRmllbGRJZHMsIC4uLmZpbHRlcnMpIHtcbiAgICBjb25zdCBncm91cHMgPSB7fTtcbiAgICBhdmFpbGFibGVGaWVsZElkcy5mb3JFYWNoKGZpZWxkSWQgPT4ge1xuICAgICAgZ3JvdXBzW2ZpZWxkSWRdID0gW107XG4gICAgfSk7XG4gICAgY29uc3QgZmxhdEZpbHRlcnMgPSBmaWx0ZXJzLmZsYXRNYXAoZiA9PiBmLiRvciB8fCBmKTtcbiAgICBmbGF0RmlsdGVycy5mb3JFYWNoKGYgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMoZilbMF07XG4gICAgICBpZiAoIWdyb3Vwc1trZXldKSB7XG4gICAgICAgIGdyb3Vwc1trZXldID0gW107XG4gICAgICB9XG4gICAgICBncm91cHNba2V5XS5wdXNoKGYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBGYWNldChncm91cHMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXJCb3hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBGYWNldCBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9mYWNldCc7XG5cbmNsYXNzIEZpbHRlckJveENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBhYm92ZSB0aGUgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGUgfHwgJ0ZpbHRlcnMnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheSB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgbmV4dCB0byBlYWNoIGZhY2V0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93Q291bnQgPSBjb25maWcuc2hvd0NvdW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dDb3VudDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRyaWdnZXIgYSBzZWFyY2ggb24gZWFjaCBjaGFuZ2UgdG8gYSBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaE9uQ2hhbmdlID0gY29uZmlnLnNlYXJjaE9uQ2hhbmdlIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIGJ1dHRvbiB0byByZXNldCBmb3IgZWFjaCBmYWNldCBncm91cFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXIgPSBjb25maWcucmVzZXRGYWNldCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciB0aGUgcmVzZXQgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmlsdGVyTGFiZWwgPSBjb25maWcucmVzZXRGYWNldExhYmVsIHx8ICdyZXNldCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgXCJyZXNldCBhbGxcIiBidXR0b24gdG8gcmVzZXQgYWxsIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXJzID0gY29uZmlnLnJlc2V0RmFjZXRzID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnJlc2V0RmFjZXRzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSBcInJlc2V0IGFsbFwiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlcnNMYWJlbCA9IGNvbmZpZy5yZXNldEZhY2V0c0xhYmVsIHx8ICdyZXNldCBhbGwnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBudW1iZXIgb2YgZmFjZXRzIHRvIHNob3cgYmVmb3JlIGRpc3BsYXlpbmcgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGltaXQgPSBjb25maWcuc2hvd01vcmVMaW1pdCB8fCA1O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIGRpc3BsYXlpbmcgbW9yZSBmYWNldHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMYWJlbCA9IGNvbmZpZy5zaG93TW9yZUxhYmVsIHx8ICdzaG93IG1vcmUnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIGRpc3BsYXlpbmcgbGVzcyBmYWNldHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0xlc3NMYWJlbCA9IGNvbmZpZy5zaG93TGVzc0xhYmVsIHx8ICdzaG93IGxlc3MnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZW5hYmxlIGhpZGluZyBleGNlc3MgZmFjZXRzIGluIGVhY2ggZ3JvdXAgd2l0aCBhIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlID0gY29uZmlnLnNob3dNb3JlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dNb3JlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYWxsb3cgZXhwYW5kaW5nIGFuZCBjb2xsYXBzaW5nIGVhY2ggZ3JvdXAgb2YgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHBhbmQgPSBjb25maWcuZXhwYW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLmV4cGFuZDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYXBwbGllZCBmaWx0ZXJzIHdoZW4gY29sbGFwc2VkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TnVtYmVyQXBwbGllZCA9IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZDtcblxuICAgIC8qKlxuICAgICAqIFRleHQgdG8gZGlzcGxheSBvbiB0aGUgYXBwbHkgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5TGFiZWwgPSBjb25maWcuYXBwbHlMYWJlbCB8fCAnYXBwbHknO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdG9yIG9mIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlCdXR0b25TZWxlY3RvciA9IGNvbmZpZy5hcHBseUJ1dHRvblNlbGVjdG9yIHx8ICcuanMteWV4dC1maWx0ZXJib3gtYXBwbHknO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVycyB0byBkaXNwbGF5IGFuZCBjb250cm9sLCBpZ25vcmluZyBlbXB0eSBzZWN0aW9uc1xuICAgICAqIEB0eXBlIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlckNvbmZpZ3MgPSBjb25maWcuZmlsdGVycy5maWx0ZXIoZiA9PiBmLm9wdGlvbnMubGVuZ3RoICE9PSAwKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgZmlsdGVyYm94IGNvbnRhaW5zIGZhY2V0cy4gVGhpcyBhZmZlY3RzIHRoZVxuICAgICAqIHRoZSB3YXkgdGhlIGZpbHRlcnMgYXJlIHVzZWQgaW4gdGhlIHNlYXJjaFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNEeW5hbWljID0gY29uZmlnLmlzRHluYW1pYyB8fCBmYWxzZTtcblxuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBzZXQgb2YgZmlsdGVycywgYW5kIHNlYXJjaGVzIHdpdGggdGhlbSB3aGVuIGFwcGxpZWQuXG4gKiBNdWx0aXBsZSBGaWx0ZXJCb3ggY29tcG9uZW50cyB3aWxsIEFORCB0b2dldGhlciBidXQgd2lsbCBub3Qgc2hhcmUgc3RhdGUuXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyQm94Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIHRoaXMuY29uZmlnID0gbmV3IEZpbHRlckJveENvbmZpZyhjb25maWcpO1xuXG4gICAgaWYgKCFjb25maWcuZmlsdGVycyB8fCAhKGNvbmZpZy5maWx0ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRmlsdGVyQm94IHJlcXVpcmVzIGZpbHRlcnMgdG8gYmUgcHJvdmlkZWQgYXMgYW4gYXJyYXknLFxuICAgICAgICAnRmlsdGVyQm94Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudHMgY3JlYXRlZCBmb3IgZWFjaCBmaWx0ZXIgY29uZmlnXG4gICAgICogQHR5cGUge0NvbXBvbmVudFtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGZpbHRlciBjb21wb25lbnRzIGluIHRoZSBib3hcbiAgICAgKiBAdHlwZSB7RmlsdGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmlsdGVycyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zaG93Q291bnQpIHtcbiAgICAgIHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3MuZm9yRWFjaChjb25maWcgPT4ge1xuICAgICAgICBjb25maWcub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgb3B0aW9uLmNvdW50TGFiZWwgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdGaWx0ZXJCb3gnO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnZmlsdGVycy9maWx0ZXJib3gnO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB0aGlzLmNvbmZpZywge1xuICAgICAgc2hvd1Jlc2V0OiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlcnMsXG4gICAgICByZXNldExhYmVsOiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlcnNMYWJlbCxcbiAgICAgIHNob3dBcHBseUJ1dHRvbjogIXRoaXMuY29uZmlnLnNlYXJjaE9uQ2hhbmdlXG4gICAgfSkpO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlckNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLmZvckVhY2goYyA9PiBjLnJlbW92ZSgpKTtcbiAgICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMgPSBbXTtcbiAgICAgIHRoaXMuX2ZpbHRlcnMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGZpbHRlcnMgZnJvbSBjb25maWdzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5maWx0ZXJDb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZy5maWx0ZXJDb25maWdzW2ldO1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZShjb25maWcudHlwZSwgT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0aGlzLmNvbmZpZyxcbiAgICAgICAge1xuICAgICAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uZmlsdGVyJHtpfWAsXG4gICAgICAgICAgc3RvcmVPbkNoYW5nZTogZmFsc2UsXG4gICAgICAgICAgY29udGFpbmVyOiBgLmpzLXlleHQtZmlsdGVyYm94LWZpbHRlciR7aX1gLFxuICAgICAgICAgIHNob3dSZXNldDogdGhpcy5jb25maWcucmVzZXRGaWx0ZXIsXG4gICAgICAgICAgcmVzZXRMYWJlbDogdGhpcy5jb25maWcucmVzZXRGaWx0ZXJMYWJlbCxcbiAgICAgICAgICBzaG93RXhwYW5kOiB0aGlzLmNvbmZpZy5leHBhbmQsXG4gICAgICAgICAgb25DaGFuZ2U6IChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJDaGFuZ2UoaSwgZmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIGNvbXBvbmVudC5tb3VudCgpO1xuICAgICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICB0aGlzLl9maWx0ZXJzW2ldID0gY29tcG9uZW50LmdldEZpbHRlcigpO1xuICAgICAgdGhpcy5fc2F2ZUZpbHRlcnNUb1N0b3JhZ2UoKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGFwcGx5IGJ1dHRvblxuICAgIGlmICghdGhpcy5jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IpO1xuXG4gICAgICBpZiAoYnV0dG9uKSB7XG4gICAgICAgIERPTS5vbihidXR0b24sICdjbGljaycsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9zYXZlRmlsdGVyc1RvU3RvcmFnZSgpO1xuICAgICAgICAgIHRoaXMuX3NlYXJjaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHJlc2V0IGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbmZpZy5yZXNldEZpbHRlcnMpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtRmlsdGVyQm94LXJlc2V0JyksXG4gICAgICAgICdjbGljaycsXG4gICAgICAgIHRoaXMucmVzZXRGaWx0ZXJzLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0RmlsdGVycyAoKSB7XG4gICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cy5mb3JFYWNoKGZpbHRlciA9PiBmaWx0ZXIuY2xlYXJPcHRpb25zKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIHRvIGNoaWxkIGZpbHRlciBjb21wb25lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoYW5nZWQgZmlsdGVyXG4gICAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXIgVGhlIG5ldyBmaWx0ZXJcbiAgICovXG4gIG9uRmlsdGVyQ2hhbmdlIChpbmRleCwgZmlsdGVyKSB7XG4gICAgdGhpcy5fZmlsdGVyc1tpbmRleF0gPSBmaWx0ZXI7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNlYXJjaE9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLl9zYXZlRmlsdGVyc1RvU3RvcmFnZSgpO1xuICAgICAgdGhpcy5fc2VhcmNoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZmlsdGVyIGNvbXBvbmVudHMgYWxvbmcgd2l0aCB0aGlzIGNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlICgpIHtcbiAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLmZvckVhY2goYyA9PiBjLnJlbW92ZSgpKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGN1cnJlbnQgZmlsdGVycyB0byBzdG9yYWdlIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgc2VhcmNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUZpbHRlcnNUb1N0b3JhZ2UgKCkge1xuICAgIGNvbnN0IHZhbGlkRmlsdGVycyA9IHRoaXMuX2ZpbHRlcnMuZmlsdGVyKGYgPT5cbiAgICAgIGYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgZiAhPT0gbnVsbCAmJlxuICAgICAgT2JqZWN0LmtleXMoZikubGVuZ3RoID4gMCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuaXNEeW5hbWljKSB7XG4gICAgICBjb25zdCBhdmFpbGFibGVGaWVsZElkcyA9IHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3MubWFwKGNvbmZpZyA9PiBjb25maWcuZmllbGRJZCk7XG4gICAgICBjb25zdCBjb21iaW5lZEZpbHRlciA9IEZhY2V0LmZyb21GaWx0ZXJzKGF2YWlsYWJsZUZpZWxkSWRzLCAuLi52YWxpZEZpbHRlcnMpO1xuICAgICAgdGhpcy5jb3JlLnNldEZhY2V0RmlsdGVyKHRoaXMubmFtZSwgY29tYmluZWRGaWx0ZXIgfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21iaW5lZEZpbHRlciA9IHZhbGlkRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICAgID8gRmlsdGVyLmFuZCguLi52YWxpZEZpbHRlcnMpXG4gICAgICAgIDogdmFsaWRGaWx0ZXJzWzBdO1xuICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIGNvbWJpbmVkRmlsdGVyIHx8IHt9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHNlYXJjaCB3aXRoIGFsbCBmaWx0ZXJzIGluIHN0b3JhZ2VcbiAgICovXG4gIF9zZWFyY2ggKCkge1xuICAgIGNvbnN0IGFsbEZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICA6IGFsbEZpbHRlcnNbMF07XG5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcblxuICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUudmVydGljYWxTZWFyY2godGhpcy5fdmVydGljYWxLZXksIHtcbiAgICAgIGlucHV0OiBxdWVyeSxcbiAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXJPcHRpb25zQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgc3VwcG9ydGVkIGNvbnRyb2xzXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IFNVUFBPUlRFRF9DT05UUk9MUyA9IFtcbiAgJ3NpbmdsZW9wdGlvbicsXG4gICdtdWx0aW9wdGlvbidcbl07XG5cbmNsYXNzIEZpbHRlck9wdGlvbnNDb25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29udHJvbCB0byBkaXNwbGF5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRyb2wgPSBjb25maWcuY29udHJvbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGZpbHRlciBvcHRpb25zIHRvIGRpc3BsYXkgd2l0aCBjaGVja2VkIHN0YXR1c1xuICAgICAqIEB0eXBlIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBiZSB1c2VkIGluIHRoZSBsZWdlbmRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBjb25maWcubGFiZWwgfHwgJ0ZpbHRlcnMnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBjaGFuZ2VkXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgYnV0dG9uIHRvIHJlc2V0IHRoZSBjdXJyZW50IGZpbHRlciBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dSZXNldCA9IGNvbmZpZy5zaG93UmVzZXQgJiYgdGhpcy5vcHRpb25zLmxlbmd0aCA+IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldExhYmVsID0gY29uZmlnLnJlc2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGZhY2V0cyB0byBzaG93IGJlZm9yZSBkaXNwbGF5aW5nIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnc2hvdyBtb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3MgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnc2hvdyBsZXNzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGVuYWJsZSBoaWRpbmcgZXhjZXNzIGZhY2V0cyB3aXRoIGEgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmUgPSBjb25maWcuc2hvd01vcmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd01vcmU7XG4gICAgdGhpcy5zaG93TW9yZSA9IHRoaXMuc2hvd01vcmUgJiYgdGhpcy5vcHRpb25zLmxlbmd0aCA+IHRoaXMuc2hvd01vcmVMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFsbG93IGV4cGFuZGluZyBhbmQgY29sbGFwc2luZyB0aGUgZ3JvdXAgb2YgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93RXhwYW5kID0gY29uZmlnLnNob3dFeHBhbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0V4cGFuZDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYXBwbGllZCBmaWx0ZXJzIHdoZW4gY29sbGFwc2VkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TnVtYmVyQXBwbGllZCA9IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RvciB1c2VkIGZvciBvcHRpb25zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25TZWxlY3RvciA9IGNvbmZpZy5vcHRpb25TZWxlY3RvciB8fCAnLmpzLXlleHQtZmlsdGVyLW9wdGlvbic7XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5wcmV2aW91c09wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25maWcucHJldmlvdXNPcHRpb25zID0gSlNPTi5wYXJzZShjb25maWcucHJldmlvdXNPcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uZmlnLnByZXZpb3VzT3B0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRPcHRpb25zID0gY29uZmlnLnByZXZpb3VzT3B0aW9ucyB8fCBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNldERlZmF1bHRTZWxlY3RlZFZhbHVlcyh0aGlzLm9wdGlvbnMsIHNlbGVjdGVkT3B0aW9ucyk7XG4gIH1cblxuICBzZXREZWZhdWx0U2VsZWN0ZWRWYWx1ZXMgKG9wdGlvbnMsIHNlbGVjdGVkT3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLm1hcChvID0+ICh7XG4gICAgICAuLi5vLFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGhcbiAgICAgICAgPyBzZWxlY3RlZE9wdGlvbnMuaW5jbHVkZXMoby5sYWJlbClcbiAgICAgICAgOiBvLnNlbGVjdGVkXG4gICAgfSkpO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRDb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWR1Y2UoXG4gICAgICAobnVtU2VsZWN0ZWQsIG9wdGlvbikgPT4gb3B0aW9uLnNlbGVjdGVkID8gbnVtU2VsZWN0ZWQgKyAxIDogbnVtU2VsZWN0ZWQsXG4gICAgICAwKTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgICBpZiAoIXRoaXMuY29udHJvbCB8fCAhU1VQUE9SVEVEX0NPTlRST0xTLmluY2x1ZGVzKHRoaXMuY29udHJvbCkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICdGaWx0ZXJPcHRpb25zIHJlcXVpcmVzIGEgdmFsaWQgXCJjb250cm9sXCIgdG8gYmUgcHJvdmlkZWQnLFxuICAgICAgICAnRmlsdGVyT3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRmlsdGVyT3B0aW9ucyBjb21wb25lbnQgcmVxdWlyZXMgb3B0aW9ucyB0byBiZSBwcm92aWRlZCcsXG4gICAgICAgICdGaWx0ZXJPcHRpb25zJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHNldCBvZiBvcHRpb25zLCBlYWNoIG9uZSByZXByZXNlbnRpbmcgYSBmaWx0ZXIgaW4gYSBzZWFyY2guXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlck9wdGlvbnNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgbGV0IHByZXZpb3VzT3B0aW9ucyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKHRoaXMubmFtZSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKHRoaXMubmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IGNvbmZpZ1xuICAgICAqIEB0eXBlIHtGaWx0ZXJPcHRpb25zQ29uZmlnfVxuICAgICAqL1xuICAgIHRoaXMuY29uZmlnID0gbmV3IEZpbHRlck9wdGlvbnNDb25maWcoe1xuICAgICAgcHJldmlvdXNPcHRpb25zLFxuICAgICAgLi4uY29uZmlnXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgb3B0aW9uIGxpc3QgaXMgZXhwYW5kZWQgYW5kIHZpc2libGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGFuZGVkID0gdGhpcy5jb25maWcuc2hvd0V4cGFuZCA/IHNlbGVjdGVkQ291bnQgPiAwIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgYWxsIG9wdGlvbnMgYXJlIHNob3duLCBmYWxzZSBpZiBzb21lIGFyZSBoaWRkZW4gYmFzZWQgb24gY29uZmlnXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbGxTaG93biA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlck9wdGlvbnMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXIsIGJhc2VkIG9uIHRoZSBjb250cm9sXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiBgY29udHJvbHMvZmlsdGVyb3B0aW9uc2A7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucztcbiAgICBpZiAodGhpcy5jb25maWcuc2hvd01vcmUgJiYgIXRoaXMuYWxsU2hvd24pIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zLnNsaWNlKDAsIHRoaXMuY29uZmlnLnNob3dNb3JlTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICBzaG93UmVzZXQ6IHRoaXMuY29uZmlnLnNob3dSZXNldCAmJiBzZWxlY3RlZENvdW50ID4gMCxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgICAgYWxsU2hvd246IHRoaXMuYWxsU2hvd24sXG4gICAgICBzZWxlY3RlZENvdW50LFxuICAgICAgaXNTaW5nbGVPcHRpb246IHRoaXMuY29uZmlnLmNvbnRyb2wgPT09ICdzaW5nbGVvcHRpb24nLFxuICAgICAgb3B0aW9uc1xuICAgIH0pKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIERPTS5kZWxlZ2F0ZShcbiAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIGAueXh0LUZpbHRlck9wdGlvbnMtb3B0aW9uc2ApLFxuICAgICAgdGhpcy5jb25maWcub3B0aW9uU2VsZWN0b3IsXG4gICAgICAnY2xpY2snLFxuICAgICAgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVPcHRpb24ocGFyc2VJbnQoZXZlbnQudGFyZ2V0LmRhdGFzZXQuaW5kZXgpLCBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSB0aGlzLmNvbmZpZy5nZXRTZWxlY3RlZENvdW50KCk7XG5cbiAgICAvLyByZXNldCBidXR0b25cbiAgICBpZiAodGhpcy5jb25maWcuc2hvd1Jlc2V0ICYmIHNlbGVjdGVkQ291bnQgPiAwKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LUZpbHRlck9wdGlvbnMtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5jbGVhck9wdGlvbnMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gc2hvdyBtb3JlL2xlc3MgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dNb3JlKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LUZpbHRlck9wdGlvbnMtc2hvd1RvZ2dsZScpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hbGxTaG93biA9ICF0aGlzLmFsbFNob3duO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZXhwYW5kIGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zaG93RXhwYW5kKSB7XG4gICAgICBjb25zdCBsZWdlbmQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLWNsaWNrYWJsZUxlZ2VuZCcpO1xuICAgICAgRE9NLm9uKFxuICAgICAgICBsZWdlbmQsXG4gICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICBjbGljayA9PiB7XG4gICAgICAgICAgaWYgKGNsaWNrLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIERPTS5vbihcbiAgICAgICAgbGVnZW5kLFxuICAgICAgICAna2V5ZG93bicsXG4gICAgICAgIGtleSA9PiB7XG4gICAgICAgICAgaWYgKGtleS5rZXkgPT09ICcgJyB8fCBrZXkua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBrZXkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyT3B0aW9ucyAoKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnMubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlTGlzdGVuZXJzICgpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZy5vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgX3VwZGF0ZU9wdGlvbiAoaW5kZXgsIHNlbGVjdGVkKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbnRyb2wgPT09ICdzaW5nbGVvcHRpb24nKSB7XG4gICAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucy5tYXAobyA9PiBPYmplY3QuYXNzaWduKHt9LCBvLCB7IHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcub3B0aW9uc1tpbmRleF0gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZy5vcHRpb25zW2luZGV4XSwgeyBzZWxlY3RlZCB9KTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9wdGlvbnNcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IERPTS5xdWVyeUFsbCh0aGlzLl9jb250YWluZXIsIHRoaXMuY29uZmlnLm9wdGlvblNlbGVjdG9yKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGUgPT4gZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnZmFsc2UnKSk7XG4gICAgdGhpcy5fYXBwbHlGaWx0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbmQgcmV0dXJuIHRoZSBGaWx0ZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRGaWx0ZXIgKCkge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zXG4gICAgICAuZmlsdGVyKG8gPT4gby5zZWxlY3RlZClcbiAgICAgIC5tYXAobyA9PiBvLmZpbHRlclxuICAgICAgICA/IG8uZmlsdGVyXG4gICAgICAgIDogRmlsdGVyLmVxdWFsKG8uZmllbGQsIG8udmFsdWUpKTtcblxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQodGhpcy5uYW1lLCB0aGlzLmNvbmZpZy5vcHRpb25zLmZpbHRlcihvID0+IG8uc2VsZWN0ZWQpLm1hcChvID0+IG8ubGFiZWwpKTtcbiAgICByZXR1cm4gZmlsdGVycy5sZW5ndGggPiAwXG4gICAgICA/IEZpbHRlci5ncm91cCguLi5maWx0ZXJzKVxuICAgICAgOiB7fTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUmFuZ2VGaWx0ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIHRvIGZpbHRlciBvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZCA9IGNvbmZpZy5maWVsZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZpbHRlciB2YWx1ZSBjaGFuZ2VzXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc3RvcmVPbkNoYW5nZTtcblxuICAgIGxldCBtaW5WYWwgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHt0aGlzLm5hbWV9Lm1pbmApO1xuICAgIGlmICh0eXBlb2YgbWluVmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWluVmFsID0gTnVtYmVyLnBhcnNlSW50KG1pblZhbCk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICBsZXQgbWF4VmFsID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5tYXhgKTtcbiAgICBpZiAodHlwZW9mIG1pblZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1heFZhbCA9IE51bWJlci5wYXJzZUludChtYXhWYWwpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCByYW5nZSByZXByZXNlbnRlZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yYW5nZSA9IHtcbiAgICAgIG1pbjogbWluVmFsIHx8IGNvbmZpZy5pbml0aWFsTWluIHx8IDAsXG4gICAgICBtYXg6IG1heFZhbCB8fCBjb25maWcuaW5pdGlhbE1heCB8fCAxMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBmb3IgdGhlIHJhbmdlIGNvbnRyb2xcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gZGlzcGxheSBmb3IgdGhlIG1pbiBpbnB1dFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9taW5MYWJlbCA9IGNvbmZpZy5taW5MYWJlbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGxhYmVsIHRvIGRpc3BsYXkgZm9yIHRoZSBtYXggaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWF4TGFiZWwgPSBjb25maWcubWF4TGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGVOYW1lID0gYGNvbnRyb2xzL3JhbmdlYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdSYW5nZUZpbHRlcic7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHRpdGxlOiB0aGlzLl90aXRsZSxcbiAgICAgIG1pbkxhYmVsOiB0aGlzLl9taW5MYWJlbCxcbiAgICAgIG1heExhYmVsOiB0aGlzLl9tYXhMYWJlbCxcbiAgICAgIG1pblZhbHVlOiB0aGlzLl9yYW5nZS5taW4sXG4gICAgICBtYXhWYWx1ZTogdGhpcy5fcmFuZ2UubWF4XG4gICAgfSkpO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIERPTS5kZWxlZ2F0ZSh0aGlzLl9jb250YWluZXIsICcuanMteWV4dC1yYW5nZScsICdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVJhbmdlKGV2ZW50LnRhcmdldC5kYXRhc2V0LmtleSwgTnVtYmVyLnBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0TWluICh2YWx1ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtaW4nLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRNYXggKHZhbHVlKSB7XG4gICAgdGhpcy5fdXBkYXRlUmFuZ2UoJ21heCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHJhbmdlIHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJhbmdlIGtleSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBrZXlcbiAgICovXG4gIF91cGRhdGVSYW5nZSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3JhbmdlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcmFuZ2UsIHsgW2tleV06IHZhbHVlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcblxuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gICAgaWYgKHRoaXMuX3N0b3JlT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCBmaWx0ZXIpO1xuICAgIH1cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke3RoaXMubmFtZX0ubWluYCwgdGhpcy5fcmFuZ2UubWluKTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke3RoaXMubmFtZX0ubWF4YCwgdGhpcy5fcmFuZ2UubWF4KTtcblxuICAgIHRoaXMuX29uQ2hhbmdlKGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgdGhlIGZpbHRlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyICgpIHtcbiAgICByZXR1cm4gRmlsdGVyLmluY2x1c2l2ZVJhbmdlKHRoaXMuX2ZpZWxkLCB0aGlzLl9yYW5nZS5taW4sIHRoaXMuX3JhbmdlLm1heCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIERhdGVGaWx0ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBBIGZpbHRlciBmb3IgYSByYW5nZSBvZiBkYXRlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlUmFuZ2VGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFwaSBmaWVsZCB0aGlzIGZpbHRlciBjb250cm9sc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZCA9IGNvbmZpZy5maWVsZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGZvciB0aGUgZGF0ZSByYW5nZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90aXRsZSA9IGNvbmZpZy50aXRsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBsYWJlbCB0byBzaG93IGZvciB0aGUgbWluIGRhdGUgaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWluTGFiZWwgPSBjb25maWcubWluTGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBsYWJlbCB0byBzaG93IGZvciB0aGUgbWF4IGRhdGUgaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWF4TGFiZWwgPSBjb25maWcubWF4TGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayB1c2VkIHdoZW4gYSBkYXRlIGlzIGNoYW5nZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vbkNoYW5nZSA9IGNvbmZpZy5vbkNoYW5nZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlcyB0aGUgZmlsdGVyIHRvIHN0b3JhZ2Ugb24gZWFjaCBjaGFuZ2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlT25DaGFuZ2UgPSBjb25maWcuc3RvcmVPbkNoYW5nZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zdG9yZU9uQ2hhbmdlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBmaWx0ZXIgcmVwcmVzZW50cyBhbiBleGNsdXNpdmUgcmFuZ2UsIHJhdGhlciB0aGFuIGFuIGluY2x1c2l2ZSBvbmVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzRXhjbHVzaXZlID0gY29uZmlnLmlzRXhjbHVzaXZlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGVOYW1lID0gYGNvbnRyb2xzL2RhdGVgO1xuXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRvZGF5U3RyaW5nID0gYCR7dG9kYXkuZ2V0RnVsbFllYXIoKX0tJHtgJHt0b2RheS5nZXRNb250aCgpICsgMX1gLnBhZFN0YXJ0KDIsICcwJyl9LSR7YCR7dG9kYXkuZ2V0RGF0ZSgpfWAucGFkU3RhcnQoMiwgJzAnKX1gO1xuICAgIGNvbnN0IG1pbkRhdGUgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHt0aGlzLm5hbWV9Lm1pbmApO1xuICAgIGNvbnN0IG1heERhdGUgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHt0aGlzLm5hbWV9Lm1heGApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZGF0ZSByYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGF0ZSA9IHtcbiAgICAgIG1pbjogbWluRGF0ZSB8fCBjb25maWcuaW5pdGlhbE1pbiB8fCB0b2RheVN0cmluZyxcbiAgICAgIG1heDogbWF4RGF0ZSB8fCBjb25maWcuaW5pdGlhbE1heCB8fCB0b2RheVN0cmluZ1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRGF0ZVJhbmdlRmlsdGVyJztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgdGl0bGU6IHRoaXMuX3RpdGxlLFxuICAgICAgbWluTGFiZWw6IHRoaXMuX21pbkxhYmVsLFxuICAgICAgbWF4TGFiZWw6IHRoaXMuX21heExhYmVsLFxuICAgICAgZGF0ZU1pbjogdGhpcy5fZGF0ZS5taW4sXG4gICAgICBkYXRlTWF4OiB0aGlzLl9kYXRlLm1heFxuICAgIH0pKTtcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtZGF0ZScsICdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVJhbmdlKGV2ZW50LnRhcmdldC5kYXRhc2V0LmtleSwgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1pbiBkYXRlIHRvIHRoZSBvbmUgcHJvdmlkZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGUgRGF0ZSB0byBzZXQgaW4geXl5eS1tbS1kZCBzdHJpbmcgZm9ybWF0XG4gICAqL1xuICBzZXRNaW4gKGRhdGUpIHtcbiAgICB0aGlzLl91cGRhdGVSYW5nZSgnbWluJywgZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtYXggZGF0ZSB0byB0aGUgb25lIHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIERhdGUgdG8gc2V0IGluIHl5eXktbW0tZGQgc3RyaW5nIGZvcm1hdFxuICAgKi9cbiAgc2V0TWF4IChkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlUmFuZ2UoJ21heCcsIGRhdGUpO1xuICB9XG5cbiAgZ2V0RmlsdGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVpbGRGaWx0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBmb3IgdGhlIGRhdGUgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHJpbmcgZGF0ZSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVJhbmdlIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fZGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RhdGUsIHsgW2tleV06IHZhbHVlIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcblxuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gICAgaWYgKHRoaXMuX3N0b3JlT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCBmaWx0ZXIpO1xuICAgIH1cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke3RoaXMubmFtZX0ubWluYCwgdGhpcy5fZGF0ZS5taW4pO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7dGhpcy5uYW1lfS5tYXhgLCB0aGlzLl9kYXRlLm1heCk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBhcGkgZmlsdGVyIHdpdGggdGhlIGN1cnJlbnQgZGF0ZSBzdGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyICgpIHtcbiAgICBpZiAodGhpcy5fZGF0ZS5taW4gPT09ICcnIHx8IHRoaXMuX2RhdGUubWF4ID09PSAnJykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faXNFeGNsdXNpdmVcbiAgICAgID8gRmlsdGVyLmV4Y2x1c2l2ZVJhbmdlKHRoaXMuX2ZpZWxkLCB0aGlzLl9kYXRlLm1pbiwgdGhpcy5fZGF0ZS5tYXgpXG4gICAgICA6IEZpbHRlci5pbmNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fZGF0ZS5taW4sIHRoaXMuX2RhdGUubWF4KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRmFjZXRzQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG5jbGFzcyBGYWNldHNDb25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgYWJvdmUgdGhlIGNvbnRyb2xzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gY29uZmlnLnRpdGxlIHx8ICdGaWx0ZXJzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiByZXN1bHRzIG5leHQgdG8gZWFjaCBmYWNldFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0NvdW50ID0gY29uZmlnLnNob3dDb3VudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93Q291bnQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0cmlnZ2VyIGEgc2VhcmNoIG9uIGVhY2ggY2hhbmdlIHRvIGEgZmlsdGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hPbkNoYW5nZSA9IGNvbmZpZy5zZWFyY2hPbkNoYW5nZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBidXR0b24gdG8gcmVzZXQgZm9yIGVhY2ggZmFjZXQgZ3JvdXBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmFjZXQgPSBjb25maWcucmVzZXRGYWNldCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciB0aGUgcmVzZXQgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmFjZXRMYWJlbCA9IGNvbmZpZy5yZXNldEZhY2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBcInJlc2V0IGFsbFwiIGJ1dHRvbiB0byByZXNldCBhbGwgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0cyA9IGNvbmZpZy5yZXNldEZhY2V0cyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5yZXNldEZhY2V0cztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciB0aGUgXCJyZXNldCBhbGxcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGYWNldHNMYWJlbCA9IGNvbmZpZy5yZXNldEZhY2V0c0xhYmVsIHx8ICdyZXNldCBhbGwnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBudW1iZXIgb2YgZmFjZXRzIHRvIHNob3cgYmVmb3JlIGRpc3BsYXlpbmcgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGltaXQgPSBjb25maWcuc2hvd01vcmVMaW1pdCB8fCA1O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIGRpc3BsYXlpbmcgbW9yZSBmYWNldHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMYWJlbCA9IGNvbmZpZy5zaG93TW9yZUxhYmVsIHx8ICdzaG93IG1vcmUnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIGRpc3BsYXlpbmcgbGVzcyBmYWNldHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0xlc3NMYWJlbCA9IGNvbmZpZy5zaG93TGVzc0xhYmVsIHx8ICdzaG93IGxlc3MnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZW5hYmxlIGhpZGluZyBleGNlc3MgZmFjZXRzIGluIGVhY2ggZ3JvdXAgd2l0aCBhIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlID0gY29uZmlnLnNob3dNb3JlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dNb3JlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYWxsb3cgZXhwYW5kaW5nIGFuZCBjb2xsYXBzaW5nIGVhY2ggZ3JvdXAgb2YgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHBhbmQgPSBjb25maWcuZXhwYW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLmV4cGFuZDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYXBwbGllZCBmaWx0ZXJzIHdoZW4gY29sbGFwc2VkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TnVtYmVyQXBwbGllZCA9IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZDtcblxuICAgIC8qKlxuICAgICAqIFRleHQgdG8gZGlzcGxheSBvbiB0aGUgYXBwbHkgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5TGFiZWwgPSBjb25maWcuYXBwbHlMYWJlbCB8fCAnYXBwbHknO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2xzIHRvIHVzZSBmb3IgZWFjaCBmaWVsZC4gRWFjaCB0eXBlIG9mIGZpbHRlciBoYXMgYSBkZWZhdWx0XG4gICAgICogJGVxIDogbXVsdGlvcHRpb24gKGNoZWNrYm94KVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5maWVsZENvbnRyb2xzID0gY29uZmlnLmZpZWxkQ29udHJvbHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3Igb2YgdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5QnV0dG9uU2VsZWN0b3IgPSBjb25maWcuYXBwbHlCdXR0b25TZWxlY3RvciB8fCBudWxsO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICB9XG59XG5cbi8qKlxuICogRGlzcGxheXMgYSBzZXQgb2YgZHluYW1pYyBmaWx0ZXJzIHJldHVybmVkIGZyb20gdGhlIGJhY2tlbmRcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWNldHNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgdGhpcy5jb25maWcgPSBuZXcgRmFjZXRzQ29uZmlnKGNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB0aGUgc2VhcmNoXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5O1xuXG4gICAgLy8gY29uZmlnLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3Igb2YgdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hcHBseUJ1dHRvblNlbGVjdG9yID0gY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSBmb3IgdGhlIGRhdGEgc3RvcmFnZSB0byBsaXN0ZW4gZm9yIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpbHRlciBib3ggdGhhdCBkaXNwbGF5cyB0aGUgZHluYW1pYyBmaWx0ZXJzXG4gICAgICogQHR5cGUge0ZpbHRlckJveENvbXBvbmVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlcmJveCA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRmFjZXRzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnZmlsdGVycy9mYWNldHMnO1xuICB9XG5cbiAgcmVtb3ZlICgpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyYm94KSB7XG4gICAgICB0aGlzLl9maWx0ZXJib3gucmVtb3ZlKCk7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgdGhpcy5jb3JlLmVuYWJsZUR5bmFtaWNGaWx0ZXJzKCk7XG5cbiAgICBpZiAodGhpcy5fZmlsdGVyYm94KSB7XG4gICAgICB0aGlzLl9maWx0ZXJib3gucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgbGV0IHsgZmlsdGVycyB9ID0gdGhpcy5fc3RhdGUuZ2V0KCk7XG5cbiAgICBpZiAoIWZpbHRlcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaWx0ZXJzID0gZmlsdGVycy5tYXAoZiA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZiwge1xuICAgICAgICB0eXBlOiAnRmlsdGVyT3B0aW9ucycsXG4gICAgICAgIGNvbnRyb2w6IHRoaXMuY29uZmlnLmZpZWxkQ29udHJvbHNbZi5maWVsZElkXSB8fCAnbXVsdGlvcHRpb24nXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2ZpbHRlcmJveCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoXG4gICAgICAnRmlsdGVyQm94JyxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgICBuYW1lOiBgJHt0aGlzLm5hbWV9LmZpbHRlcmJveGAsXG4gICAgICAgIGNvbnRhaW5lcjogJy5qcy15eHQtRmFjZXRzJyxcbiAgICAgICAgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5LFxuICAgICAgICByZXNldEZpbHRlcjogdGhpcy5jb25maWcucmVzZXRGYWNldCxcbiAgICAgICAgcmVzZXRGaWx0ZXJzOiB0aGlzLmNvbmZpZy5yZXNldEZhY2V0cyxcbiAgICAgICAgcmVzZXRGaWx0ZXJMYWJlbDogdGhpcy5jb25maWcucmVzZXRGYWNldExhYmVsLFxuICAgICAgICByZXNldEZpbHRlcnNMYWJlbDogdGhpcy5jb25maWcucmVzZXRGYWNldHNMYWJlbCxcbiAgICAgICAgaXNEeW5hbWljOiB0cnVlLFxuICAgICAgICBmaWx0ZXJzXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLl9maWx0ZXJib3gubW91bnQoKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgR2VvTG9jYXRpb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IGJ1aWxkU2VhcmNoUGFyYW1ldGVycyBmcm9tICcuLi8uLi90b29scy9zZWFyY2hwYXJhbXNwYXJzZXInO1xuXG5jb25zdCBNRVRFUlNfUEVSX01JTEUgPSAxNjA5LjM0NDtcblxuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIC8qKlxuICAgKiBUaGUgcmFkaXVzLCBpbiBtaWxlcywgYXJvdW5kIHRoZSB1c2VyJ3MgbG9jYXRpb24gdG8gZmluZCByZXN1bHRzLlxuICAgKiBJZiBsb2NhdGlvbiBhY2N1cmFjeSBpcyBsb3csIGEgbGFyZ2VyIHJhZGl1cyBtYXkgYmUgdXNlZCBhdXRvbWF0aWNhbGx5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICByYWRpdXM6IDUwLFxuXG4gIC8qKlxuICAgKiBUaGUgdmVydGljYWwga2V5IHRvIHVzZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdmVydGljYWxLZXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHN1Ym1pdHMgYSBzZWFyY2ggd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNlYXJjaE9uQ2hhbmdlOiBmYWxzZSxcblxuICAvKipcbiAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRpdGxlOiAnTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgdG8gZGlzcGxheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbGFiZWw6ICdMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHVybCB0byBzaG93IGluIHRoZSBnZW8gYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZW9CdXR0b25JY29uOiAnJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyBpbiB0aGUgZ2VvIGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2VvQnV0dG9uVGV4dDogJ1VzZSBNeSBMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIHNob3cgd2hlbiBnZW9sb2NhdGlvbiBpcyBlbmFibGVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBlbmFibGVkVGV4dDogJ0N1cnJlbnQgTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBzaG93IHdoZW4gbG9hZGluZyB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBsb2FkaW5nVGV4dDogJ0ZpbmRpbmcgWW91ciBMb2NhdGlvbi4uLicsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIHNob3cgaWYgdGhlIHVzZXIncyBsb2NhdGlvbiBjYW5ub3QgYmUgZm91bmRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGVycm9yVGV4dDogJ0NvdWxkIE5vdCBGaW5kIFlvdXIgTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIHNlbGVjdG9yIG9mIHRoZSB0b2dnbGUgYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBidXR0b25TZWxlY3RvcjogJy5qcy15eHQtR2VvTG9jYXRpb25GaWx0ZXItYnV0dG9uJyxcblxuICAvKipcbiAgICogVGhlIENTUyBzZWxlY3RvciBvZiB0aGUgcXVlcnkgaW5wdXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGlucHV0U2VsZWN0b3I6ICcuanMteXh0LUdlb0xvY2F0aW9uRmlsdGVyLWlucHV0J1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgYnV0dG9uIHRoYXQgd2hlbiBjbGlja2VkIGFkZHMgYSBzdGF0aWMgZmlsdGVyIHJlcHJlc2VudGluZyB0aGUgdXNlcidzIGxvY2F0aW9uXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvTG9jYXRpb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoeyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH0sIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCkgfHwgJyc7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gLCBxID0+IHtcbiAgICAgIHRoaXMucXVlcnkgPSBxO1xuICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpbHRlciB0byB1c2UgZm9yIHRoZSBjdXJyZW50IHF1ZXJ5XG4gICAgICogQHR5cGUge0ZpbHRlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCkgfHwge307XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gSlNPTi5wYXJzZSh0aGlzLmZpbHRlcik7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIGYgPT4geyB0aGlzLmZpbHRlciA9IGY7IH0pO1xuXG4gICAgdGhpcy5zZWFyY2hQYXJhbWV0ZXJzID0gYnVpbGRTZWFyY2hQYXJhbWV0ZXJzKGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdHZW9Mb2NhdGlvbkZpbHRlcic7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdjb250cm9scy9nZW9sb2NhdGlvbic7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGxldCBwbGFjZWhvbGRlciA9ICcnO1xuICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHRoaXMuX2NvbmZpZy5lbmFibGVkVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEuZ2VvTG9hZGluZykge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLl9jb25maWcubG9hZGluZ1RleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLmdlb0Vycm9yKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHRoaXMuX2NvbmZpZy5lcnJvclRleHQ7XG4gICAgfVxuICAgIHN1cGVyLnNldFN0YXRlKHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICB0aXRsZTogdGhpcy5fY29uZmlnLnRpdGxlLFxuICAgICAgZ2VvRW5hYmxlZDogdGhpcy5fZW5hYmxlZCxcbiAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgbGFiZWxUZXh0OiB0aGlzLl9jb25maWcubGFiZWwsXG4gICAgICBlbmFibGVkVGV4dDogdGhpcy5fY29uZmlnLmVuYWJsZWRUZXh0LFxuICAgICAgbG9hZGluZ1RleHQ6IHRoaXMuX2NvbmZpZy5sb2FkaW5nVGV4dCxcbiAgICAgIGVycm9yVGV4dDogdGhpcy5fY29uZmlnLmVycm9yVGV4dCxcbiAgICAgIGdlb0J1dHRvbkljb246IHRoaXMuX2NvbmZpZy5nZW9CdXR0b25JY29uLFxuICAgICAgZ2VvVmFsdWU6IHRoaXMuX2VuYWJsZWQgfHwgZGF0YS5nZW9Mb2FkaW5nIHx8IGRhdGEuZ2VvRXJyb3IgPyAnJyA6IHRoaXMucXVlcnksXG4gICAgICBnZW9QbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICBnZW9CdXR0b25UZXh0OiB0aGlzLl9jb25maWcuZ2VvQnV0dG9uVGV4dFxuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9jb21wbGV0ZSkge1xuICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRBdXRvQ29tcGxldGUodGhpcy5fY29uZmlnLmlucHV0U2VsZWN0b3IpO1xuICAgIERPTS5vbih0aGlzLl9jb25maWcuYnV0dG9uU2VsZWN0b3IsICdjbGljaycsICgpID0+IHRoaXMuX3RvZ2dsZUdlb0ZpbHRlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdG8gd2lyZSB1cCBvdXIgYXV0byBjb21wbGV0ZSBvbiBhbiBpbnB1dCBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRTZWxlY3RvciBDU1Mgc2VsZWN0b3IgdG8gYmluZCBvdXIgYXV0byBjb21wbGV0ZSBjb21wb25lbnQgdG9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0QXV0b0NvbXBsZXRlIChpbnB1dFNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9jb21wbGV0ZSkge1xuICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2F1dG9jb21wbGV0ZSA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoJ0F1dG9Db21wbGV0ZScsIHtcbiAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgbmFtZTogYCR7dGhpcy5uYW1lfS5hdXRvY29tcGxldGVgLFxuICAgICAgaXNGaWx0ZXJTZWFyY2g6IHRydWUsXG4gICAgICBjb250YWluZXI6ICcuanMteXh0LUdlb0xvY2F0aW9uRmlsdGVyLWF1dG9jb21wbGV0ZScsXG4gICAgICBvcmlnaW5hbFF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgb3JpZ2luYWxGaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgaW5wdXRFbDogaW5wdXRTZWxlY3RvcixcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl9jb25maWcudmVydGljYWxLZXksXG4gICAgICBzZWFyY2hQYXJhbWV0ZXJzOiB0aGlzLnNlYXJjaFBhcmFtZXRlcnMsXG4gICAgICBvblN1Ym1pdDogKHF1ZXJ5LCBmaWx0ZXIpID0+IHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmZpbHRlciA9IEZpbHRlci5mcm9tUmVzcG9uc2UoZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fc2F2ZURhdGFUb1N0b3JhZ2UocXVlcnksIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHN0YXRpYyBmaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90b2dnbGVHZW9GaWx0ZXIgKCkge1xuICAgIGlmICghbmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZ2VvRXJyb3I6IHRydWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZ2VvTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgIHBvc2l0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcihwb3NpdGlvbik7XG4gICAgICAgICAgdGhpcy5fc2F2ZURhdGFUb1N0b3JhZ2UoJycsIGZpbHRlciwgcG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWApO1xuICAgICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGdlb0Vycm9yOiB0cnVlIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgcHJvdmlkZWQgZmlsdGVyIHVuZGVyIHRoaXMgY29tcG9uZW50J3MgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHRvIHNhdmVcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlciBUaGUgZmlsdGVyIHRvIHNhdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBzYXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZURhdGFUb1N0b3JhZ2UgKHF1ZXJ5LCBmaWx0ZXIsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCwgcXVlcnkpO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gLCBmaWx0ZXIpO1xuICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCBmaWx0ZXIpO1xuXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04sIHtcbiAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGxldCB0b3RhbEZpbHRlciA9IGZpbHRlcnNbMF07XG4gICAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRvdGFsRmlsdGVyID0gRmlsdGVyLmFuZCguLi5maWx0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpIHx8ICcnO1xuICAgICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcblxuICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl9jb25maWcudmVydGljYWxLZXksIHtcbiAgICAgICAgaW5wdXQ6IHNlYXJjaFF1ZXJ5LFxuICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgcG9zaXRpb24sIGNvbnN0cnVjdCBhIEZpbHRlciBvYmplY3RcbiAgICogQHBhcmFtIHtQb3N0aXRpb259IHBvc2l0aW9uIFRoZSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyIChwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3kgfSA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heChhY2N1cmFjeSwgdGhpcy5fY29uZmlnLnJhZGl1cyAqIE1FVEVSU19QRVJfTUlMRSk7XG4gICAgcmV0dXJuIEZpbHRlci5wb3NpdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlLCByYWRpdXMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTb3J0T3B0aW9uc0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQmFzaWNFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5cbi8qKlxuICogUmVuZGVycyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHNvcnRpbmcgVmVydGljYWwgUmVzdWx0cy5cbiAqIFRPRE86IGhvdyB0byBkZWFsIHdpdGggbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoaXMgY29tcG9uZW50IChhbmQgZmlsdGVycyBpbiBnZW5lcmFsKSxcbiAqIGlkZWFsbHkgXCJpZGVudGljYWxcIiBmaWx0ZXJzL3NvcnRzIHdvdWxkIGJlIHN5bmNlZCB1cC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29ydE9wdGlvbnNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoYXNzaWduRGVmYXVsdHMoY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgICB0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXggPSBwYXJzZUludCh0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSh0aGlzLm5hbWUpKSB8fCAwO1xuICAgIHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuaGlkZUV4Y2Vzc09wdGlvbnMgPSB0aGlzLl9jb25maWcuc2hvd01vcmUgJiYgdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4IDw9IHRoaXMuX2NvbmZpZy5zaG93TW9yZUxpbWl0O1xuICAgIHRoaXMuc2hvd1Jlc2V0ID0gdGhpcy5fY29uZmlnLnNob3dSZXNldCAmJiB0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXggIT09IDA7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLmhpZGVFeGNlc3NPcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNsaWNlKDAsIHRoaXMuX2NvbmZpZy5zaG93TW9yZUxpbWl0KTtcbiAgICB9XG4gICAgc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGhpZGVFeGNlc3NPcHRpb25zOiB0aGlzLmhpZGVFeGNlc3NPcHRpb25zLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc2hvd1Jlc2V0OiB0aGlzLnNob3dSZXNldFxuICAgIH0pKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIEhhbmRsZSByYWRpbyBidXR0b24gc2VsZWN0aW9uc1xuICAgIERPTS5vbihcbiAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LVNvcnRPcHRpb25zLWZpZWxkU2V0JyksXG4gICAgICAnY2hhbmdlJyxcbiAgICAgIGV2dCA9PiB0aGlzLmhhbmRsZU9wdGlvblNlbGVjdGlvbihwYXJzZUludChldnQudGFyZ2V0LnZhbHVlKSlcbiAgICApO1xuXG4gICAgLy8gUmVnaXN0ZXIgbW9yZS9sZXNzIGJ1dHRvblxuICAgIGlmICh0aGlzLl9jb25maWcuc2hvd01vcmUpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtU29ydE9wdGlvbnMtc2hvd1RvZ2dsZScpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaWRlRXhjZXNzT3B0aW9ucyA9ICF0aGlzLmhpZGVFeGNlc3NPcHRpb25zO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBzaG93IHJlc2V0IGJ1dHRvblxuICAgIGlmICh0aGlzLnNob3dSZXNldCkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1Tb3J0T3B0aW9ucy1yZXNldCcpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZU9wdGlvblNlbGVjdGlvbigwKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhcHBseSBidXR0b25cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1Tb3J0T3B0aW9ucy1hcHBseScpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICAoKSA9PiB0aGlzLl9zb3J0UmVzdWx0cygpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU9wdGlvblNlbGVjdGlvbiAob3B0aW9uSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVTZWxlY3RlZE9wdGlvbihvcHRpb25JbmRleCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgdGhpcy5fc29ydFJlc3VsdHMoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlU2VsZWN0ZWRPcHRpb24gKG9wdGlvbkluZGV4KSB7XG4gICAgdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRPcHRpb25JbmRleF0uaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9uc1tvcHRpb25JbmRleF0uaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4ID0gb3B0aW9uSW5kZXg7XG4gICAgdGhpcy5zaG93UmVzZXQgPSB0aGlzLl9jb25maWcuc2hvd1Jlc2V0ICYmIG9wdGlvbkluZGV4ICE9PSAwO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIF9zb3J0UmVzdWx0cyAoKSB7XG4gICAgY29uc3Qgb3B0aW9uSW5kZXggPSB0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXg7XG4gICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zW29wdGlvbkluZGV4XTtcblxuICAgIC8vIHNlYXJjaE9uQ2hhbmdlIHJlYWxseSBtZWFucyBzb3J0IG9uIGNoYW5nZSBoZXJlLCBqdXN0IHRoYXQgdGhlIHNvcnQgaXMgZG9uZSB0aHJvdWdoIGEgc2VhcmNoLFxuICAgIC8vIFRoaXMgd2FzIGRvbmUgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgb3B0aW9uIG5hbWUgYmV0d2VlbiBmaWx0ZXJzLlxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQodGhpcy5uYW1lLCBvcHRpb25JbmRleCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5zdG9yZU9uQ2hhbmdlICYmIG9wdGlvbkluZGV4ID09PSAwKSB7XG4gICAgICB0aGlzLmNvcmUuY2xlYXJTb3J0QnlzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jb25maWcuc3RvcmVPbkNoYW5nZSkge1xuICAgICAgdGhpcy5jb3JlLnNldFNvcnRCeXMob3B0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5fc2VhcmNoKCk7XG4gICAgdGhpcy5fY29uZmlnLm9uQ2hhbmdlKG9wdGlvbik7XG4gICAgdGhpcy5zZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzZWFyY2ggd2l0aCBhbGwgZmlsdGVycyBpbiBzdG9yYWdlXG4gICAqL1xuICBfc2VhcmNoICgpIHtcbiAgICBjb25zdCBhbGxGaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgY29uc3QgdG90YWxGaWx0ZXIgPSBhbGxGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgOiBhbGxGaWx0ZXJzWzBdO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpIHx8ICcnO1xuICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX2NvbmZpZy52ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQsXG4gICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdTb3J0T3B0aW9ucyc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdjb250cm9scy9zb3J0b3B0aW9ucyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMgKGNvbmZpZykge1xuICBjb25zdCB1cGRhdGVkQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcblxuICAvLyBPcHRpb25hbCwgVGhlIGxhYmVsIHVzZWQgZm9yIHRoZSDigJxkZWZhdWx04oCdIHNvcnQgKGFrYSB0aGUgc29ydCBzcGVjaWZpZWQgYnkgdGhlIGV4cGVyaWVuY2UgY29uZmlnXCIpLlxuICB1cGRhdGVkQ29uZmlnLmRlZmF1bHRTb3J0TGFiZWwgPSBjb25maWcuZGVmYXVsdFNvcnRMYWJlbCB8fCAnQmVzdCBNYXRjaCc7XG5cbiAgLy8gQXJyYXkgb2Ygc2VhcmNoIG9wdGlvbnMsIHdoZXJlIGFuIG9wdGlvbiBoYXMgdHlwZSwgbGFiZWwsIGFuZCBpZiBpcyB0eXBlIEZJRUxEIGFsc28gYSBsYWJlbCBhbmQgZGlyZWN0aW9uXG4gIGlmICghY29uZmlnLm9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ2NvbmZpZy5vcHRpb25zIGFyZSByZXF1aXJlZCcsICdTb3J0T3B0aW9ucycpO1xuICB9XG4gIGNvbnN0IE9QVElPTl9UWVBFUyA9IFsnRklFTEQnLCAnUkVMRVZBTkNFJywgJ0VOVElUWV9ESVNUQU5DRSddO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLm9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cycsICdTb3J0T3B0aW9ucycpO1xuICB9XG4gIHVwZGF0ZWRDb25maWcub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgIGlmICghb3B0aW9uLmxhYmVsIHx8ICFvcHRpb24udHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKGBvcHRpb24ubGFiZWwgYW5kIG9wdGlvbi50eXBlIGFyZSByZXF1aXJlZCBvcHRpb24gJHtvcHRpb259YCwgJ1NvcnRPcHRpb25zJyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld09wdGlvbiA9IHsgaXNTZWxlY3RlZDogZmFsc2UgfTtcbiAgICBuZXdPcHRpb24ubGFiZWwgPSBvcHRpb24ubGFiZWw7XG4gICAgbmV3T3B0aW9uLnR5cGUgPSBvcHRpb24udHlwZTtcbiAgICBjb25zdCBpc0ZpZWxkID0gT1BUSU9OX1RZUEVTLmluZGV4T2YobmV3T3B0aW9uLnR5cGUpID09PSAwO1xuICAgIGlmIChpc0ZpZWxkICYmIG9wdGlvbi5maWVsZCAmJiBvcHRpb24uZGlyZWN0aW9uKSB7XG4gICAgICBuZXdPcHRpb24uZmllbGQgPSBvcHRpb24uZmllbGQ7XG4gICAgICBuZXdPcHRpb24uZGlyZWN0aW9uID0gb3B0aW9uLmRpcmVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcihgb3B0aW9uLmZpZWxkIGFuZCBvcHRpb24uZGlyZWN0aW9uIGFyZSByZXF1aXJlZCBmb3Igb3B0aW9uOiAke29wdGlvbn1gLCAnU29ydE9wdGlvbnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbjtcbiAgfSk7XG4gIC8vIEFkZCBkZWZhdWx0IG9wdGlvbiB0byB0aGUgZnJvbnQgb2YgdGhlIG9wdGlvbnMgYXJyYXlcbiAgdXBkYXRlZENvbmZpZy5vcHRpb25zLnVuc2hpZnQoe1xuICAgIGxhYmVsOiB1cGRhdGVkQ29uZmlnLmRlZmF1bHRTb3J0TGFiZWwsXG4gICAgaXNTZWxlY3RlZDogZmFsc2VcbiAgfSk7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBzZWxlY3RvciB1c2VkIGZvciBvcHRpb25zIGluIHRoZSB0ZW1wbGF0ZVxuICB1cGRhdGVkQ29uZmlnLm9wdGlvblNlbGVjdG9yID0gY29uZmlnLm9wdGlvblNlbGVjdG9yIHx8ICd5eHQtU29ydE9wdGlvbnMtb3B0aW9uU2VsZWN0b3InO1xuXG4gIC8vIE9wdGlvbmFsLCBpZiB0cnVlLCB0cmlnZ2VycyBhIHNlYXJjaCBvbiBlYWNoIGNoYW5nZSB0byBhIGZpbHRlcixcbiAgLy8gaWYgZmFsc2UgdGhlIGNvbXBvbmVudCBhbHNvIHJlbmRlcnMgYW4gYXBwbHkgYnV0dG9uLCBkZWZhdWx0cyB0byBmYWxzZVxuICB1cGRhdGVkQ29uZmlnLnNlYXJjaE9uQ2hhbmdlID0gY29uZmlnLnNlYXJjaE9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNlYXJjaE9uQ2hhbmdlO1xuXG4gIC8vIE9wdGlvbmFsLCBzaG93IGEgcmVzZXQgYnV0dG9uLiBDbGlja2luZyBpdCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHVzZXIgdG8gdGhlIGRlZmF1bHQgc29ydGluZyBvcHRpb24uXG4gIHVwZGF0ZWRDb25maWcuc2hvd1Jlc2V0ID0gY29uZmlnLnNob3dSZXNldCB8fCBmYWxzZTtcblxuICAvLyBPcHRpb25hbCwgdGhlIGxhYmVsIHRvIHVzZSBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICB1cGRhdGVkQ29uZmlnLnJlc2V0TGFiZWwgPSBjb25maWcucmVzZXRMYWJlbCB8fCAncmVzZXQnO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgbWF4IG51bWJlciBvZiBmaWx0ZXIgb3B0aW9ucyB0byBzaG93IGJlZm9yZSBjb2xsYXBzaW5nIGV4dHJhc1xuICB1cGRhdGVkQ29uZmlnLnNob3dNb3JlTGltaXQgPSBjb25maWcuc2hvd01vcmVMaW1pdCB8fCA1O1xuXG4gIC8vIE9wdGlvbmFsLCBhbGxvdyBjb2xsYXBzaW5nIGV4Y2VzcyBzb3J0IG9wdGlvbnMgYWZ0ZXIgYSBsaW1pdFxuICB1cGRhdGVkQ29uZmlnLnNob3dNb3JlID0gY29uZmlnLnNob3dNb3JlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dNb3JlO1xuICB1cGRhdGVkQ29uZmlnLnNob3dNb3JlID0gdXBkYXRlZENvbmZpZy5zaG93TW9yZSAmJiAodXBkYXRlZENvbmZpZy5vcHRpb25zLmxlbmd0aCA+IHVwZGF0ZWRDb25maWcuc2hvd01vcmVMaW1pdCk7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgb3B0aW9uc1xuICB1cGRhdGVkQ29uZmlnLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnU2hvdyBtb3JlJztcblxuICAvLyBPcHRpb25hbCwgdGhlIGxhYmVsIHRvIHNob3cgZm9yIGRpc3BsYXlpbmcgbGVzcyBvcHRpb25zXG4gIHVwZGF0ZWRDb25maWcuc2hvd0xlc3NMYWJlbCA9IGNvbmZpZy5zaG93TGVzc0xhYmVsIHx8ICdTaG93IGxlc3MnO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGNoYW5nZWRcbiAgdXBkYXRlZENvbmZpZy5vbkNoYW5nZSA9IGNvbmZpZy5vbkNoYW5nZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAvLyBPcHRpb25hbCwgVG9wIHRpdGxlIGZvciB0aGUgc29ydGluZyBjb21wb25lbnRcbiAgdXBkYXRlZENvbmZpZy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCAnU29ydGluZyc7XG5cbiAgLy8gT3B0aW9uYWwsIHdoZW4gdHJ1ZSBjb21wb25lbnQgZG9lcyBub3QgdXBkYXRlIGdsb2JhbFN0b3JhZ2VcbiAgLy8gcG9zc2libHkgZGVsZWdhdGluZyB0aGF0IHRvIGEgaGlnaGVyLW9yZGVyL2NvbXBvc2l0ZSBjb21wb25lbnRcbiAgdXBkYXRlZENvbmZpZy5zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc3RvcmVPbkNoYW5nZTtcblxuICB1cGRhdGVkQ29uZmlnLmFwcGx5TGFiZWwgPSBjb25maWcuYXBwbHlMYWJlbCB8fCAnQXBwbHknO1xuXG4gIHVwZGF0ZWRDb25maWcudmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykudmVydGljYWxLZXk7XG4gIGlmICghdXBkYXRlZENvbmZpZy52ZXJ0aWNhbEtleSkge1xuICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcigndmVydGljYWwga2V5IGlzIHJlcXVpcmVkJywgJ1NvcnRPcHRpb25zJyk7XG4gIH1cblxuICAvLyBub3RlOiBzaG93RXhwYW5kIGFuZCBzaG93TnVtYmVyQXBwbGllZCBleHBsaWNpdGx5IG5vdCBpbmNsdWRlZCwgb24gdGhlIGdyb3VuZHMgdGhhdFxuICAvLyBzb3J0aW5nIHNob3VsZCBhbHdheXMgYmUgZXhwb3NlZCB0byB0aGUgdXNlciBpZiBhZGRlZC5cblxuICByZXR1cm4gdXBkYXRlZENvbmZpZztcbn1cbiIsIi8qKiBAbW9kdWxlIERpcmVjdEFuc3dlckNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi4vLi4vLi4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuXG4vKipcbiAqIEV2ZW50VHlwZXMgYXJlIGV4cGxpY2l0IHN0cmluZ3MgZGVmaW5lZFxuICogZm9yIHdoYXQgdGhlIHNlcnZlciBleHBlY3RzIGZvciBhbmFseXRpY3MuXG4gKlxuICogQGVudW1cbiAqL1xuY29uc3QgRXZlbnRUeXBlcyA9IHtcbiAgVEhVTUJTX1VQOiAnVEhVTUJTX1VQJyxcbiAgVEhVTUJTX0RPV046ICdUSFVNQlNfRE9XTidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdEFuc3dlckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWNpZXZlIHVwZGF0ZXMgZnJvbSBzdG9yYWdlIGJhc2VkIG9uIHRoaXMgaW5kZXhcbiAgICAgKiBAdHlwZSB7U3RvcmFnZUtleX1cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuRElSRUNUX0FOU1dFUjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtIHVzZWQgZm9yIHN1Ym1pdHRpbmcgdGhlIGZlZWRiYWNrXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9mb3JtRWwgPSBjb25maWcuZm9ybUVsIHx8ICcuanMtZGlyZWN0QW5zd2VyLWZlZWRiYWNrLWZvcm0nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGB0aHVtYnMgdXBgIGNzcyBzZWxlY3RvciB0byBiaW5kIHVpIGludGVyYWN0aW9uIHRvIGZvciByZXBvcnRpbmdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3RodW1ic1VwU2VsZWN0b3IgPSBjb25maWcudGh1bWJzVXBTZWxlY3RvciB8fCAnLmpzLWRpcmVjdEFuc3dlci10aHVtYlVwJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdGh1bWJzIGRvd25gIGNzcyBzZWxlY3RvciB0byBiaW5kIHVpIGludGVyYWN0aW9uIHRvIGZvciByZXBvcnRpbmdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3RodW1ic0Rvd25TZWxlY3RvciA9IGNvbmZpZy50aHVtYnNEb3duU2VsZWN0b3IgfHwgJy5qcy1kaXJlY3RBbnN3ZXItdGh1bWJEb3duJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXNwbGF5IHRleHQgZm9yIHRoZSBWaWV3IERldGFpbHMgY2xpY2sgdG8gYWN0aW9uIGxpbmtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3ZpZXdEZXRhaWxzVGV4dCA9IGNvbmZpZy52aWV3RGV0YWlsc1RleHQgfHwgJ1ZpZXcgRGV0YWlscyc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRGlyZWN0QW5zd2VyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9kaXJlY3RhbnN3ZXInO1xuICB9XG5cbiAgLyoqXG4gICAqIGJlZm9yZU1vdW50LCBvbmx5IGRpc3BsYXkgdGhlIGRpcmVjdCBhbnN3ZXIgY29tcG9uZW50IGlmIGl0IGhhcyBkYXRhXG4gICAqL1xuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1N0YXRlKCdhbnN3ZXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIERPTSBpcyBjb25zdHJ1Y3RlZCxcbiAgICogd2Ugd2FudCB0byB3aXJlIHVwIHRoZSBiZWhhdmlvciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgcXVhbGl0eSBmZWVkYmFjayByZXBvcnRpbmcgKHRodW1ic3VwL2Rvd24pXG4gICAqL1xuICBvbk1vdW50ICgpIHtcbiAgICAvLyBBdm9pZCBiaW5kaW5ncyBpZiB0aGUgZmVlZGJhY2sgaGFzIHByZXZpb3VzbHkgYmVlbiBzdWJtaXR0ZWRcbiAgICBpZiAodGhpcy5nZXRTdGF0ZSgnZmVlZGJhY2tTdWJtaXR0ZWQnKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRm9yIFdDQUcgY29tcGxpYW5jZSwgdGhlIGZlZWRiYWNrIHNob3VsZCBiZSBhIHN1Ym1pdHRhYmxlIGZvcm1cbiAgICBET00ub24odGhpcy5fZm9ybUVsLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGxldCBmb3JtRWwgPSBlLnRhcmdldDtcbiAgICAgIGxldCBjaGVja2VkVmFsdWUgPSBET00ucXVlcnkoZm9ybUVsLCAnaW5wdXQ6Y2hlY2tlZCcpLnZhbHVlID09PSAndHJ1ZSc7XG5cbiAgICAgIHRoaXMucmVwb3J0UXVhbGl0eShjaGVja2VkVmFsdWUpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgICdmZWVkYmFja1N1Ym1pdHRlZCc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSXMgdGhpcyBhY3R1YWxseSBuZWNlc3Nhcnk/IEkgZ3Vlc3MgaXQncyBvbmx5IG5lY2Vzc2FyeSBpZiB0aGVcbiAgICAvLyBzdWJtaXQgYnV0dG9uIGlzIGhpZGRlbi5cbiAgICBET00ub24odGhpcy5fdGh1bWJzVXBTZWxlY3RvciwgJ2NsaWNrJywgKCkgPT4geyBET00udHJpZ2dlcih0aGlzLl9mb3JtRWwsICdzdWJtaXQnKTsgfSk7XG4gICAgRE9NLm9uKHRoaXMuX3RodW1ic0Rvd25TZWxlY3RvciwgJ2NsaWNrJywgKCkgPT4geyBET00udHJpZ2dlcih0aGlzLl9mb3JtRWwsICdzdWJtaXQnKTsgfSk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlU3RhdGUgZW5hYmxlcyBmb3IgcGFydGlhbCB1cGRhdGVzICh0aGUgZGVsdGEgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcpXG4gICAqIEB0eXBlIHtvYmplY3R9IFRoZSBuZXcgc3RhdGUgdG8gYXBwbHkgdG8gdGhlIG9sZFxuICAgKi9cbiAgdXBkYXRlU3RhdGUgKHN0YXRlID0ge30pIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U3RhdGUoKSwgc3RhdGUpO1xuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucyhkYXRhKSxcbiAgICAgIHZpZXdEZXRhaWxzVGV4dDogdGhpcy5fdmlld0RldGFpbHNUZXh0XG4gICAgfSkpO1xuICB9XG5cbiAgZXZlbnRPcHRpb25zIChkYXRhKSB7XG4gICAgaWYgKCFkYXRhIHx8IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiBkYXRhLnJlbGF0ZWRJdGVtLnZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICBzZWFyY2hlcjogJ1VOSVZFUlNBTCcsXG4gICAgICBlbnRpdHlJZDogZGF0YS5yZWxhdGVkSXRlbS5kYXRhLmlkLFxuICAgICAgY3RhTGFiZWw6IHRoaXMuX3ZpZXdEZXRhaWxzVGV4dC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJyAnLCAnXycpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcmVwb3J0UXVhbGl0eSB3aWxsIHNlbmQgdGhlIHF1YWxpdHkgZmVlZGJhY2sgdG8gYW5hbHl0aWNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNHb29kIHRydWUgaWYgdGhlIGFuc3dlciBpcyB3aGF0IHlvdSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAqL1xuICByZXBvcnRRdWFsaXR5IChpc0dvb2QpIHtcbiAgICBjb25zdCBldmVudFR5cGUgPSBpc0dvb2QgPT09IHRydWUgPyBFdmVudFR5cGVzLlRIVU1CU19VUCA6IEV2ZW50VHlwZXMuVEhVTUJTX0RPV047XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQW5hbHl0aWNzRXZlbnQoZXZlbnRUeXBlKVxuICAgICAgLmFkZE9wdGlvbnMoe1xuICAgICAgICAnZGlyZWN0QW5zd2VyJzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdHNJdGVtQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdWx0c0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiB2ZXJ0aWNhbENvbmZpZ0lkIHVzZWQgZm9yIGFuYWx5dGljcyBhbmQgcGFzc2VkIHRvIGNoaWxkcmVuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQgPSBvcHRzLnZlcnRpY2FsQ29uZmlnSWQ7XG5cbiAgICAvKipcbiAgICAgKiBpc1VuaXZlcnNhbCBpcyB1c2VkIGZvciBhbmFseXRpY3MgYW5kIHBhc3NlZCB0byBjaGlsZHJlbiBhbmQgaXMgc2V0IHRvXG4gICAgICogdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhZGRlZCBieSB0aGUgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faXNVbml2ZXJzYWwgPSBvcHRzLmlzVW5pdmVyc2FsIHx8IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1Jlc3VsdHNJdGVtQ29tcG9uZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9yZXN1bHRzaXRlbSc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgdG8gY29uc3RydWN0IHRoZSBldmVudE9wdGlvbnMgb2JqZWN0IGZvciB0aGUgdGl0bGUgbGlua1xuICAgKiBAcGFyYW0gZW50aXR5SWQgVGhlIElEIG9mIHRoZSByZXN1bHQgaXRlbSwgaWYgcHJlc2VudFxuICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIHJlc3VsdCBpdGVtLCBpZiBwcmVzZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBldmVudE9wdGlvbnMgKGVudGl0eUlkLCB1cmwpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxDb25maWdJZCxcbiAgICAgIHNlYXJjaGVyOiB0aGlzLl9pc1VuaXZlcnNhbCA/ICdVTklWRVJTQUwnIDogJ1ZFUlRJQ0FMJ1xuICAgIH07XG5cbiAgICBpZiAoZW50aXR5SWQpIHtcbiAgICAgIG9wdGlvbnMuZW50aXR5SWQgPSBlbnRpdHlJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhc3NlcyBldmVudE9wdGlvbnMgdG8gdGhlIHZpZXdNb2RlbFxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdHNJdGVtQ29tcG9uZW50fVxuICAgKi9cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBldmVudE9wdGlvbnM6IHRoaXMuZXZlbnRPcHRpb25zKGRhdGEuaWQsIGRhdGEubGluaylcbiAgICB9KSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIExvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQgKi9cblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgUmVzdWx0c0l0ZW1Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbUNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvbG9jYXRpb25yZXN1bHRzaXRlbSc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBSZXN1bHRzSXRlbUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtQ29uZmlnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9ldmVudHJlc3VsdHNpdGVtJztcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgUmVzdWx0c0l0ZW1Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcGVvcGxlcmVzdWx0c2l0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1hcFByb3ZpZGVyICovXG5cbi8qKlxuICogQSBNYXBQcm92aWRlciBpcyBhbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoYXQgc2hvdWxkIGJlIGltcGxlbWVudGVkXG4gKiBpbiBvcmRlciB0byBpbnRlZ3JhdGUgd2l0aCBhIFRoaXJkIFBhcnR5IE1hcCBwcm92aWRlciBmb3JcbiAqIGludGVyYWN0aXZlIG1hcHMuIE1hcFByb3ZpZGVycyBhcmUgdXNlZCBieSB0aGUgTWFwQ29tcG9uZW50LlxuICpcbiAqIEltcGxlbWVudGF0aW9ucyBzaG91bGQgZXh0ZW5kIHRoaXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBBUEkgS2V5IHVzZWQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIG1hcCBwcm92aWRlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAsIGRlZmF1bHRzIHRvIDE0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl96b29tID0gY29uZmlnLnpvb20gfHwgMTQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb29yZGluYXRlcyB0byBkaXNwbGF5IGlmIHRoZXJlIGFyZSBubyByZXN1bHRzIHJldHVybmVkXG4gICAgICogT25seSB1c2VkIGlmIHNob3dFbXB0eU1hcCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fZGVmYXVsdFBvc2l0aW9uID0gY29uZmlnLmRlZmF1bHRQb3NpdGlvbiB8fCB7IGxhdDogMzcuMDkwMiwgbG5nOiAtOTUuNzEyOSB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbXB0eSBtYXAgc2hvdWxkIGJlIHNob3duIHdoZW4gdGhlcmUgYXJlIG5vIHJlc3VsdHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9zaG93RW1wdHlNYXAgPSBjb25maWcuc2hvd0VtcHR5TWFwIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgbWFwIGluc3RhbmNlLCBjcmVhdGVkIGJ5IHRoZSBleHRlcm5hbCBsaWIuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IGJvb2xlYW4gdHJhY2tpbmcgd2hldGhlciBvciBub3QgdGhlIGV4dGVybmFsIEpTIGxpYnJhcnkgaXMgbG9hZGVkIChzZWUgVE9ETyBiZWxvdylcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYSBwaW4gaXMgY2xpY2tlZC4gVGhlIGNsaWNrZWQgaXRlbShzKSBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9vblBpbkNsaWNrID0gY29uZmlnLm9uUGluQ2xpY2sgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSBvbmNlIHRoZSBKYXZhc2NyaXB0IGlzIGxvYWRlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9vbkxvYWRlZCA9IGNvbmZpZy5vbkxvYWRlZCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXN0b20gY29uZmlndXJhdGlvbiBvdmVycmlkZSB0byB1c2UgZm9yIHRoZSBtYXAgbWFya2Vyc1xuICAgICAqIEB0eXBlIHtPYmplY3R8RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fcGluQ29uZmlnID0gdHlwZW9mIGNvbmZpZy5waW4gPT09ICdmdW5jdGlvbicgPyBjb25maWcucGluIDogT2JqZWN0LmFzc2lnbihNYXBQcm92aWRlci5ERUZBVUxUX1BJTl9DT05GSUcsIGNvbmZpZy5waW4pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBjb2xsYXBzZSBwaW5zIGF0IHRoZSBzYW1lIGxhdC9sbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9jb2xsYXBzZVBpbnMgPSBjb25maWcuY29sbGFwc2VQaW5zIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gdG8gdXNlIGZvciB0aGUgbWFwIG1hcmtlcnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogVE9ETyhiaWxseSkgQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBtb2RlbFxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1BJTl9DT05GSUcgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiB7XG4gICAgICAgIGFuY2hvcjogbnVsbCwgLy8gZS5nLiB7IHg6IDEsIHk6IDEgfVxuICAgICAgICBzdmc6IG51bGwsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgc2NhbGVkU2l6ZTogbnVsbCAvLyBlLmcuIHsgdzogMjAsIGg6IDIwIH1cbiAgICAgIH0sXG4gICAgICBsYWJlbFR5cGU6ICdudW1lcmljJ1xuICAgIH07XG4gIH1cblxuICBvbkxvYWRlZCAoY2IpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fb25Mb2FkZWQgPSBjYjtcbiAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICB0aGlzLl9vbkxvYWRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGlzTG9hZGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gIH1cblxuICBsb2FkSlMgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBNZXRob2Q6IGxvYWRKUycpO1xuICB9XG5cbiAgaW5pdCAobWFwRGF0YSkge1xuICAgIC8vIFRPRE8oYmlsbHkpIFRoaXMgc2hvdWxkIGJlIGJhc2VkIG9mZiBhIHByb21pc2UgdGhhdCBnZXRzIGNyZWF0ZWQgZnJvbSBsb2FkSlNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgTWV0aG9kOiBpbml0Jyk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBsaXN0IG9mIG1hcmtlcnMsIGNvbWJpbmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGxhdC9sbmcgaW50byBhIHNpbmdsZSBtYXJrZXJcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gbWFya2VycyBUaGUgbWFya2VycyB0byBjb2xsYXBzZVxuICAgKi9cbiAgX2NvbGxhcHNlTWFya2VycyAobWFya2Vycykge1xuICAgIGNvbnN0IGxvY2F0aW9uVG9JdGVtID0ge307XG4gICAgbWFya2Vycy5mb3JFYWNoKG0gPT4ge1xuICAgICAgbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdXG4gICAgICAgID8gbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdLnB1c2gobSlcbiAgICAgICAgOiBsb2NhdGlvblRvSXRlbVtgJHttLmxhdGl0dWRlfSR7bS5sb25naXR1ZGV9YF0gPSBbbV07XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXJzID0gW107XG4gICAgZm9yIChsZXQgWywgbWFya2Vyc10gb2YgT2JqZWN0LmVudHJpZXMobG9jYXRpb25Ub0l0ZW0pKSB7XG4gICAgICBpZiAobWFya2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZE1hcmtlciA9IHtcbiAgICAgICAgICBpdGVtOiBtYXJrZXJzLm1hcChtID0+IG0uaXRlbSksXG4gICAgICAgICAgbGFiZWw6IG1hcmtlcnMubGVuZ3RoLFxuICAgICAgICAgIGxhdGl0dWRlOiBtYXJrZXJzWzBdLmxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogbWFya2Vyc1swXS5sb25naXR1ZGVcbiAgICAgICAgfTtcbiAgICAgICAgY29sbGFwc2VkTWFya2Vycy5wdXNoKGNvbGxhcHNlZE1hcmtlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsYXBzZWRNYXJrZXJzLnB1c2gobWFya2Vyc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxhcHNlZE1hcmtlcnM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdvb2dsZU1hcFByb3ZpZGVyICovXG5cbmltcG9ydCBNYXBQcm92aWRlciBmcm9tICcuL21hcHByb3ZpZGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vLi4vZG9tL2RvbSc7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cblxuLyoqXG4gKiBHb29nbGVNYXBQcm92aWRlciBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE1hcFByb3ZpZGVyXG4gKiB0aGF0IGhhbmRsZXMgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIHRoaXJkIHBhcnR5IEFQSSB0byBleHBvc2UgbWFwcy5cbiAqIEBleHRlbmRzIE1hcFByb3ZpZGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvb2dsZU1hcFByb3ZpZGVyIGV4dGVuZHMgTWFwUHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgLy8gbm9ybWFsaXplIGJlY2F1c2UgZ29vZ2xlJ3Mgem9vbSBpcyBlZmZlY3RpdmVseSAxIHVuaXQgb2YgZGlmZmVyZW5jZSBhd2F5IGZyb20gbWFwYm94IHpvb21cbiAgICB0aGlzLl96b29tT2Zmc2V0ID0gMTtcbiAgICB0aGlzLl96b29tICs9IHRoaXMuX3pvb21PZmZzZXQ7XG4gICAgdGhpcy5fY2xpZW50SWQgPSBvcHRzLmNsaWVudElkO1xuICAgIHRoaXMuX3NpZ25hdHVyZSA9IG9wdHMuc2lnbmF0dXJlO1xuXG4gICAgaWYgKCF0aGlzLmhhc1ZhbGlkQ2xpZW50Q3JlZGVudGlhbHMoKSAmJiAhdGhpcy5fYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZU1hcHNQcm92aWRlcjogTWlzc2luZyBgYXBpS2V5YCBvciB7YGNsaWVudElkYCwgYHNpZ25hdHVyZWB9Jyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZEpTIChvbkxvYWQpIHtcbiAgICBpZiAoRE9NLnF1ZXJ5KCcjeWV4dC1tYXAtanMnKSkge1xuICAgICAgdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Mb2FkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHNjcmlwdCA9IERPTS5jcmVhdGVFbCgnc2NyaXB0Jywge1xuICAgICAgaWQ6ICd5ZXh0LW1hcC1qcycsXG4gICAgICBvbmxvYWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vbkxvYWRlZCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgc3JjOiBgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzPyR7dGhpcy5nZW5lcmF0ZUNyZWRlbnRpYWxzKCl9YFxuICAgIH0pO1xuXG4gICAgRE9NLmFwcGVuZCgnYm9keScsIHNjcmlwdCk7XG4gIH1cblxuICBnZW5lcmF0ZUNyZWRlbnRpYWxzICgpIHtcbiAgICBpZiAodGhpcy5oYXNWYWxpZENsaWVudENyZWRlbnRpYWxzKCkpIHtcbiAgICAgIHJldHVybiBgY2xpZW50PSR7dGhpcy5fY2xpZW50SWR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBrZXk9JHt0aGlzLl9hcGlLZXl9YDtcbiAgICB9XG4gIH1cblxuICBoYXNWYWxpZENsaWVudENyZWRlbnRpYWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50SWQ7XG4gIH1cblxuICBpbml0IChlbCwgbWFwRGF0YSkge1xuICAgIGlmICgoIW1hcERhdGEgfHwgbWFwRGF0YS5tYXBNYXJrZXJzLmxlbmd0aCA8PSAwKSAmJiAhdGhpcy5fc2hvd0VtcHR5TWFwKSB7XG4gICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gTk9URShiaWxseSkgVGhpcyB0aW1lb3V0IGlzIGEgaGFjayBmb3IgZGVhbGluZyB3aXRoIGFzeW5jIG5hdHVyZS5cbiAgICAvLyBPbmx5IGhlcmUgZm9yIGRlbW8gcHVycG9zZXMsIHNvIHdlJ2xsIGZpeCBsYXRlci5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxldCBjb250YWluZXIgPSBET00ucXVlcnkoZWwpO1xuICAgICAgdGhpcy5tYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGNvbnRhaW5lciwge1xuICAgICAgICB6b29tOiB0aGlzLl96b29tLFxuICAgICAgICBjZW50ZXI6IHRoaXMuZ2V0Q2VudGVyTWFya2VyKG1hcERhdGEpXG4gICAgICB9KTtcblxuICAgICAgLy8gQXBwbHkgb3VyIHNlYXJjaCBkYXRhIHRvIG91ciBHb29nbGVNYXBcbiAgICAgIGlmIChtYXBEYXRhICYmIG1hcERhdGEubWFwTWFya2Vycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY29sbGFwc2VkTWFya2VycyA9IHRoaXMuX2NvbGxhcHNlUGluc1xuICAgICAgICAgID8gdGhpcy5fY29sbGFwc2VNYXJrZXJzKG1hcERhdGEubWFwTWFya2VycylcbiAgICAgICAgICA6IG1hcERhdGEubWFwTWFya2VycztcbiAgICAgICAgbGV0IGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MgPSBHb29nbGVNYXBNYXJrZXJDb25maWcuZnJvbShcbiAgICAgICAgICBjb2xsYXBzZWRNYXJrZXJzLFxuICAgICAgICAgIHRoaXMuX3BpbkNvbmZpZyxcbiAgICAgICAgICB0aGlzLm1hcCk7XG5cbiAgICAgICAgbGV0IGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnb29nbGVNYXBNYXJrZXJDb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoZ29vZ2xlTWFwTWFya2VyQ29uZmlnc1tpXSk7XG4gICAgICAgICAgaWYgKHRoaXMuX29uUGluQ2xpY2spIHtcbiAgICAgICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLl9vblBpbkNsaWNrKGNvbGxhcHNlZE1hcmtlcnNbaV0uaXRlbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHRoaXMubWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfVxuXG4gIGdldENlbnRlck1hcmtlciAobWFwRGF0YSkge1xuICAgIHJldHVybiBtYXBEYXRhICYmIG1hcERhdGEubWFwQ2VudGVyICYmIG1hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSAmJiBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZVxuICAgICAgPyB7IGxuZzogbWFwRGF0YS5tYXBDZW50ZXIubG9uZ2l0dWRlLCBsYXQ6IG1hcERhdGEubWFwQ2VudGVyLmxhdGl0dWRlIH1cbiAgICAgIDogeyBsbmc6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sbmcsIGxhdDogdGhpcy5fZGVmYXVsdFBvc2l0aW9uLmxhdCB9O1xuICB9XG59XG5cbi8vIFRPRE8oYmlsbHkpIE1vdmUgdG8gb3duIGNsYXNzXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFwTWFya2VyQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgZ29vZ2xlIG1hcCwgdGhhdCB0aGUgbWFya2VyIGlzIGFwcGVuZGVkIHRvXG4gICAgICogQHR5cGUge0dvb2dsZU1hcH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IG9wdHMubWFwIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgbWFya2VyIChsYXQvbG5nKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdHMucG9zaXRpb24gfHwge1xuICAgICAgbGF0OiB1bmRlZmluZWQsXG4gICAgICBsbmc6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcGVydGllcy9zZXR0aW5ncyBvZiB0aGUgaWNvbiB1c2VkIGZvciB0aGUgbWFya2VyXG4gICAgICogZS5nLiB7XG4gICAgICogICAgICAgIGFuY2hvcjogeyB4OiAwLCB5OiAwIH1cbiAgICAgKiAgICAgICAgdXJsOiAncGF0aC90by91cmwuanBnJ1xuICAgICAqICAgICAgICBzY2FsZWRTaXplOiB7IHc6IDAsIGg6IDAgfVxuICAgICAqICAgICAgIH1cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5pY29uID0gb3B0cy5pY29uIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCBvZiB0aGUgbWFya2VyIHRvIHVzZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IG9wdHMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYW4gYXJyYXkgb2YgbWFya2VyIGNvbmZpZ3NcbiAgICogQHBhcmFtIHtHb29nbGVNYXBNYXJrZXJDb25maWdbXX0gZ29vZ2xlTWFwTWFya2VyQ29uZmlnc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgc2VyaWFsaXplIChnb29nbGVNYXBNYXJrZXJDb25maWdzKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRNYXJrZXJzID0gW107XG4gICAgZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgIHNlcmlhbGl6ZWRNYXJrZXJzLnB1c2goYG1hcmtlcnM9bGFiZWw6JHttYXJrZXIubGFiZWx9fCR7bWFya2VyLnBvc2l0aW9uLmxhdH0sJHttYXJrZXIucG9zaXRpb24ubG5nfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWFya2Vycy5qb2luKCcmJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHN0b3JhZ2UgZGF0YSBtb2RlbCBvZiBtYXJrZXJzIGludG8gR29vZ2xlQVBJTWFya2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IG1hcmtlcnMgVGhlIGRhdGEgb2YgdGhlIG1hcmtlclxuICAgKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwaW5Db25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIG1hcmtlclxuICAgKiBAcGFyYW0ge0dvb2dsZU1hcH0gbWFwIHJlZmVyZW5jZSB0byB0aGUgZ29vZ2xlIG1hcCB0byBhcHBseSB0aGUgbWFya2VyIHRvXG4gICAqIEByZXR1cm5zIHtHb29nbGVNYXBNYXJrZXJDb25maWdbXX1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChtYXJrZXJzLCBwaW5Db25maWcsIG1hcCkge1xuICAgIGxldCBnb29nbGVNYXBNYXJrZXJDb25maWdzID0gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hcmtlcnMpKSB7XG4gICAgICBtYXJrZXJzID0gW21hcmtlcnNdO1xuICAgIH1cblxuICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAvLyBTdXBwb3J0IGNvbmZpZ3VyYXRpb24gYXMgYSBmdW5jdGlvblxuICAgICAgbGV0IHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZztcbiAgICAgIGlmICh0eXBlb2YgcGluQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZyhcbiAgICAgICAgICBtYXJrZXIuaXRlbSxcbiAgICAgICAgICBNYXBQcm92aWRlci5ERUZBVUxUX1BJTl9DT05GSUcsXG4gICAgICAgICAgbWFya2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJhbnNmb3JtIG91ciBDb25maWd1cmF0aW9uIE9iamVjdCBpbnRvIHRoZSBleHBlY3RlZFxuICAgICAgLy8gR29vZ2xlIEFQSSBmb3JtYXQuXG4gICAgICBsZXQgaWNvbiA9IHt9O1xuICAgICAgaWYgKHBpbkNvbmZpZ09iai5hbmNob3IpIHtcbiAgICAgICAgaWNvbi5hbmNob3IgPSBnb29nbGUubWFwcy5Qb2ludChwaW5Db25maWdPYmouYW5jaG9yLngsIHBpbkNvbmZpZ09iai5hbmNob3IueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5Db25maWdPYmouc2NhbGVkU2l6ZSkge1xuICAgICAgICBpY29uLnNjYWxlZFNpemUgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaW5Db25maWdPYmouc2NhbGVkU2l6ZS53LCBwaW5Db25maWdPYmouc2NhbGVkU2l6ZS5oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbkNvbmZpZ09iai51cmwpIHtcbiAgICAgICAgaWNvbi51cmwgPSBwaW5Db25maWdPYmoudXJsO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluQ29uZmlnT2JqLnN2Zykge1xuICAgICAgICBpY29uLnVybCA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwgJHtlbmNvZGVVUklDb21wb25lbnQocGluQ29uZmlnT2JqLnN2Zyl9YDtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhYmVsO1xuICAgICAgaWYgKHBpbkNvbmZpZ09iai5sYWJlbCkge1xuICAgICAgICBsYWJlbCA9IHBpbkNvbmZpZ09iai5sYWJlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsID0gbWFya2VyLmxhYmVsLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEUoYmlsbHkpIEdvb2dsZSBtYXBzIGRvZXNuJ3QgaGFuZGxlIGVtcHR5IGljb24gb2JqZWN0cyBuaWNlbHlcbiAgICAgIC8vIE1ha2UgZ29vZ2xlIG1hcHMgaGFwcHkgaWYgbm8gc2V0dGluZ3MgZm9yIGljb24gYXJlIHByb3ZpZGVkO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGljb24pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpY29uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBnb29nbGVNYXBNYXJrZXJDb25maWdzLnB1c2goXG4gICAgICAgIG5ldyBHb29nbGVNYXBNYXJrZXJDb25maWcoe1xuICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBsYXQ6IG1hcmtlci5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxuZzogbWFya2VyLmxvbmdpdHVkZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWNvbjogaWNvbixcbiAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ29vZ2xlTWFwTWFya2VyQ29uZmlncztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTWFwQm94TWFwUHJvdmlkZXIgKi9cblxuaW1wb3J0IE1hcFByb3ZpZGVyIGZyb20gJy4vbWFwcHJvdmlkZXInO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi8uLi9kb20vZG9tJztcblxuLyogZ2xvYmFsIG1hcGJveGdsICovXG5cbi8qKlxuICogTWFwQm94TWFwUHJvdmlkZXIgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYSBNYXBQcm92aWRlclxuICogdGhhdCBoYW5kbGVzIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSB0aGlyZCBwYXJ0eSBBUEkgdG8gZXhwb3NlIG1hcHMuXG4gKiBAZXh0ZW5kcyBNYXBQcm92aWRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBCb3hNYXBQcm92aWRlciBleHRlbmRzIE1hcFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIExvYWQgdGhlIGV4dGVybmFsIEpTIExpYnJhcnlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25Mb2FkIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIHRoZSBKUyBpcyBsb2FkZWQuXG4gICAqL1xuICBsb2FkSlMgKG9uTG9hZCkge1xuICAgIGxldCBzY3JpcHQgPSBET00uY3JlYXRlRWwoJ3NjcmlwdCcsIHtcbiAgICAgIGlkOiAneWV4dC1tYXAtanMnLFxuICAgICAgb25sb2FkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSB0aGlzLl9hcGlLZXk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fb25Mb2FkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl9vbkxvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmM6IHRydWUsXG4gICAgICBzcmM6ICdodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC1nbC1qcy92MC40NC4xL21hcGJveC1nbC5qcydcbiAgICB9KTtcblxuICAgIGxldCBjc3MgPSBET00uY3JlYXRlRWwoJ2xpbmsnLCB7XG4gICAgICBpZDogJ3lleHQtbWFwLWNzcycsXG4gICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgIGhyZWY6ICdodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC1nbC1qcy92MC40NC4xL21hcGJveC1nbC5jc3MnXG4gICAgfSk7XG5cbiAgICBET00uYXBwZW5kKCdib2R5JywgY3NzKTtcbiAgICBET00uYXBwZW5kKCdib2R5Jywgc2NyaXB0KTtcbiAgfVxuXG4gIGluaXQgKGVsLCBtYXBEYXRhKSB7XG4gICAgaWYgKCghbWFwRGF0YSB8fCBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoIDw9IDApICYmICF0aGlzLl9zaG93RW1wdHlNYXApIHtcbiAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgY29udGFpbmVyID0gRE9NLnF1ZXJ5KGVsKTtcbiAgICB0aGlzLl9tYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgem9vbTogdGhpcy5fem9vbSxcbiAgICAgIHN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL21hcGJveC9zdHJlZXRzLXY5JyxcbiAgICAgIGNlbnRlcjogdGhpcy5nZXRDZW50ZXJNYXJrZXIobWFwRGF0YSlcbiAgICB9KTtcblxuICAgIGlmIChtYXBEYXRhICYmIG1hcERhdGEubWFwTWFya2Vycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZE1hcmtlcnMgPSB0aGlzLl9jb2xsYXBzZVBpbnNcbiAgICAgICAgPyB0aGlzLl9jb2xsYXBzZU1hcmtlcnMobWFwRGF0YS5tYXBNYXJrZXJzKVxuICAgICAgICA6IG1hcERhdGEubWFwTWFya2VycztcbiAgICAgIGNvbnN0IG1hcGJveE1hcE1hcmtlckNvbmZpZ3MgPSBNYXBCb3hNYXJrZXJDb25maWcuZnJvbShcbiAgICAgICAgY29sbGFwc2VkTWFya2VycyxcbiAgICAgICAgdGhpcy5fcGluQ29uZmlnLFxuICAgICAgICB0aGlzLl9tYXApO1xuXG4gICAgICBjb25zdCBib3VuZHMgPSBuZXcgbWFwYm94Z2wuTG5nTGF0Qm91bmRzKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcGJveE1hcE1hcmtlckNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBtYXBib3hNYXBNYXJrZXJDb25maWdzW2ldLndyYXBwZXI7XG4gICAgICAgIGxldCBjb29yZHMgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KFxuICAgICAgICAgIG1hcGJveE1hcE1hcmtlckNvbmZpZ3NbaV0ucG9zaXRpb24ubG9uZ2l0dWRlLFxuICAgICAgICAgIG1hcGJveE1hcE1hcmtlckNvbmZpZ3NbaV0ucG9zaXRpb24ubGF0aXR1ZGUpO1xuICAgICAgICBsZXQgbWFya2VyID0gbmV3IG1hcGJveGdsLk1hcmtlcih3cmFwcGVyKS5zZXRMbmdMYXQoY29vcmRzKTtcbiAgICAgICAgYm91bmRzLmV4dGVuZChtYXJrZXIuZ2V0TG5nTGF0KCkpO1xuICAgICAgICBtYXJrZXIuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgaWYgKHRoaXMuX29uUGluQ2xpY2spIHtcbiAgICAgICAgICBtYXJrZXIuZ2V0RWxlbWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5fb25QaW5DbGljayhjb2xsYXBzZWRNYXJrZXJzW2ldLml0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcGJveE1hcE1hcmtlckNvbmZpZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhib3VuZHMsIHsgcGFkZGluZzogNTAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2VudGVyTWFya2VyIChtYXBEYXRhKSB7XG4gICAgcmV0dXJuIG1hcERhdGEgJiYgbWFwRGF0YS5tYXBDZW50ZXIgJiYgbWFwRGF0YS5tYXBDZW50ZXIubG9uZ2l0dWRlICYmIG1hcERhdGEubWFwQ2VudGVyLmxhdGl0dWRlXG4gICAgICA/IFttYXBEYXRhLm1hcENlbnRlci5sb25naXR1ZGUsIG1hcERhdGEubWFwQ2VudGVyLmxhdGl0dWRlXVxuICAgICAgOiB7IGxuZzogdGhpcy5fZGVmYXVsdFBvc2l0aW9uLmxuZywgbGF0OiB0aGlzLl9kZWZhdWx0UG9zaXRpb24ubGF0IH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcEJveE1hcmtlckNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIG1hcGJveCBtYXAsIHRoYXQgdGhlIG1hcmtlciBpcyBhcHBlbmRlZCB0b1xuICAgICAqIEB0eXBlIHtNYXBCb3h9XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBvcHRzLm1hcCB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1hcmtlciAobGF0L2xuZylcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBvcHRzLnBvc2l0aW9uIHx8IHtcbiAgICAgIGxhdGl0dWRlOiB1bmRlZmluZWQsXG4gICAgICBsb25naXR1ZGU6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaHRtbCBlbGVtZW50IHRvIGJlIHVzZWQgYXMgdGhlIG1hcCBtYXJrZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMud3JhcHBlciA9IG9wdHMud3JhcHBlciB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgb2YgdGhlIG1hcmtlciB0byB1c2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBvcHRzLmxhYmVsIHx8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgb2YgdGhlIHBpbiBmb3IgdGhlIHN0YXRpYyBtYXBcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGljTWFwUGluID0gb3B0cy5zdGF0aWNNYXBQaW4gfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYW4gYXJyYXkgb2YgbWFya2VyIGNvbmZpZ3NcbiAgICogQHBhcmFtIHtNYXBCb3hNYXJrZXJDb25maWdbXX0gbWFwYm94TWFwTWFya2VyQ29uZmlnc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgc2VyaWFsaXplIChtYXBib3hNYXBNYXJrZXJDb25maWdzKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRNYXJrZXJzID0gW107XG4gICAgbWFwYm94TWFwTWFya2VyQ29uZmlncy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgIGlmIChtYXJrZXIuc3RhdGljTWFwUGluKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRNYXJrZXJzLnB1c2goYHVybC0ke21hcmtlci5zdGF0aWNNYXBQaW59KCR7bWFya2VyLnBvc2l0aW9uLmxvbmdpdHVkZX0sJHttYXJrZXIucG9zaXRpb24ubGF0aXR1ZGV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZE1hcmtlcnMucHVzaChgcGluLXMtJHttYXJrZXIubGFiZWx9KCR7bWFya2VyLnBvc2l0aW9uLmxvbmdpdHVkZX0sJHttYXJrZXIucG9zaXRpb24ubGF0aXR1ZGV9KWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWFya2Vycy5qb2luKCcsJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHN0b3JhZ2UgZGF0YSBtb2RlbCBvZiBtYXJrZXJzIGludG8gTWFwQm94TWFya2VyQ29uZmlnXG4gICAqIEBwYXJhbSB7TWFwQm94fSBBIHJlZmVyZW5jZSB0byB0aGUgbWFwYm94IG1hcCB0byBhcHBseSB0aGUgbWFya2VyIHRvXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IG1hcmtlcnMgVGhlIGRhdGEgb2YgdGhlIG1hcmtlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGluQ29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSBtYXJrZXJcbiAgICogQHJldHVybnMge01hcEJveE1hcmtlckNvbmZpZ1tdfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKG1hcmtlcnMsIHBpbkNvbmZpZywgbWFwKSB7XG4gICAgbGV0IG1hcGJveE1hcE1hcmtlckNvbmZpZ3MgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWFya2VycykpIHtcbiAgICAgIG1hcmtlcnMgPSBbbWFya2Vyc107XG4gICAgfVxuXG4gICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgIC8vIFN1cHBvcnQgY29uZmlndXJhdGlvbiBhcyBhIGZ1bmN0aW9uXG4gICAgICBsZXQgcGluQ29uZmlnT2JqID0gcGluQ29uZmlnO1xuICAgICAgaWYgKHR5cGVvZiBwaW5Db25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGluQ29uZmlnT2JqID0gcGluQ29uZmlnKFxuICAgICAgICAgIG1hcmtlci5pdGVtLFxuICAgICAgICAgIE1hcFByb3ZpZGVyLkRFRkFVTFRfUElOX0NPTkZJRyxcbiAgICAgICAgICBtYXJrZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cmFwcGVyID0gcGluQ29uZmlnT2JqLndyYXBwZXIgPyBwaW5Db25maWdPYmoud3JhcHBlciA6IG51bGw7XG4gICAgICBjb25zdCBzdGF0aWNNYXBQaW4gPSBwaW5Db25maWdPYmouc3RhdGljTWFwUGluID8gcGluQ29uZmlnT2JqLnN0YXRpY01hcFBpbiA6IG51bGw7XG5cbiAgICAgIG1hcGJveE1hcE1hcmtlckNvbmZpZ3MucHVzaChcbiAgICAgICAgbmV3IE1hcEJveE1hcmtlckNvbmZpZyh7XG4gICAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiBtYXJrZXIubGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGU6IG1hcmtlci5sb25naXR1ZGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyYXBwZXI6IHdyYXBwZXIsXG4gICAgICAgICAgbGFiZWw6IG1hcmtlci5sYWJlbCxcbiAgICAgICAgICBzdGF0aWNNYXBQaW46IHN0YXRpY01hcFBpblxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXBib3hNYXBNYXJrZXJDb25maWdzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuXG5pbXBvcnQgR29vZ2xlTWFwUHJvdmlkZXIgZnJvbSAnLi9wcm92aWRlcnMvZ29vZ2xlbWFwcHJvdmlkZXInO1xuaW1wb3J0IE1hcEJveE1hcFByb3ZpZGVyIGZyb20gJy4vcHJvdmlkZXJzL21hcGJveG1hcHByb3ZpZGVyJztcblxuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmNvbnN0IFByb3ZpZGVyVHlwZXMgPSB7XG4gICdnb29nbGUnOiBHb29nbGVNYXBQcm92aWRlcixcbiAgJ21hcGJveCc6IE1hcEJveE1hcFByb3ZpZGVyXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcblxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhpcyBjb21wb25lbnQgdG8gbGlzdGVuIHRvIHRoZSBzdG9yYWdlIGJhc2VkIG9uIHRoaXMga2V5XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFM7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbGlhc2VkIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIG1hcCBwcm92aWRlciB0byB1c2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX21hcFByb3ZpZGVyID0gb3B0cy5tYXBQcm92aWRlcjtcbiAgICBpZiAoIXRoaXMuX21hcFByb3ZpZGVyIHx8ICEodGhpcy5fbWFwUHJvdmlkZXIudG9Mb3dlckNhc2UoKSBpbiBQcm92aWRlclR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXBDb21wb25lbnQ6IEludmFsaWQgTWFwIFByb3ZpZGVyOyBtdXN0IGJlIGBnb29nbGVgIG9yIGBtYXBCb3hgJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gYW4gaW5zdGFuY2Ugb2YgdGhlIHtNYXBQcm92aWRlcn0gdGhhdCdzIGNvbnN0cnVjdGVkXG4gICAgICogQHR5cGUge01hcFByb3ZpZGVyfVxuICAgICAqL1xuICAgIHRoaXMuX21hcCA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnTWFwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9tYXAnO1xuICB9XG5cbiAgLy8gVE9ETyhiaWxseSkgTWFrZSBQcm92aWRlclR5cGVzIGEgZmFjdG9yeSBjbGFzc1xuICBnZXRQcm92aWRlckluc3RhbmNlICh0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlclR5cGVzW3R5cGUudG9Mb3dlckNhc2UoKV0odGhpcy5fY29uZmlnKTtcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICB0aGlzLl9tYXAgPSB0aGlzLmdldFByb3ZpZGVySW5zdGFuY2UodGhpcy5fbWFwUHJvdmlkZXIpO1xuICAgIHRoaXMuX21hcC5sb2FkSlMoKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIHRoaXMuX21hcC5vbkxvYWRlZCgoKSA9PiB7XG4gICAgICB0aGlzLl9tYXAuaW5pdCh0aGlzLl9jb250YWluZXIsIHRoaXMuZ2V0U3RhdGUoJ21hcCcpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoZGF0YSwgdmFsKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUmVzdWx0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbmltcG9ydCBSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHNpdGVtY29tcG9uZW50JztcbmltcG9ydCBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vbG9jYXRpb25yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL2V2ZW50cmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IFBlb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcGVvcGxlcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IE1hcENvbXBvbmVudCBmcm9tICcuLi9tYXAvbWFwY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcblxuY29uc3QgUmVzdWx0VHlwZSA9IHtcbiAgRVZFTlQ6ICdldmVudCcsXG4gIExPQ0FUSU9OOiAnbG9jYXRpb24nLFxuICBQRU9QTEU6ICdwZW9wbGUnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIHZlcnRpY2FsQ29uZmlnSWQgdXNlZCBmb3IgYW5hbHl0aWNzIGFuZCBwYXNzZWQgdG8gY2hpbGRyZW5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxDb25maWdJZCA9IGNvbmZpZy52ZXJ0aWNhbENvbmZpZ0lkO1xuXG4gICAgLyoqXG4gICAgICogaXNVbml2ZXJzYWwgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQgYnkgdGhlIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzVW5pdmVyc2FsID0gY29uZmlnLmlzVW5pdmVyc2FsIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFM7XG4gICAgdGhpcy5faXRlbUNvbmZpZyA9IHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgIHRlbXBsYXRlOiBudWxsXG4gICAgICB9LFxuICAgICAgW0V2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQudHlwZV06IHtcbiAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICB0ZW1wbGF0ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIFtMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50LnR5cGVdOiB7XG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgdGVtcGxhdGU6IG51bGxcbiAgICAgIH0sXG4gICAgICBbUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQudHlwZV06IHtcbiAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICB0ZW1wbGF0ZTogbnVsbFxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnLnJlbmRlckl0ZW0gPT09IHVuZGVmaW5lZCAmJiBjb25maWcuX3BhcmVudE9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZmlnLnJlbmRlckl0ZW0gPSBjb25maWcuX3BhcmVudE9wdHMucmVuZGVySXRlbTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLml0ZW1UZW1wbGF0ZSA9PT0gdW5kZWZpbmVkICYmIGNvbmZpZy5fcGFyZW50T3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuaXRlbVRlbXBsYXRlID0gY29uZmlnLl9wYXJlbnRPcHRzLml0ZW1UZW1wbGF0ZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ3VyZUl0ZW0oe1xuICAgICAgcmVuZGVyOiBjb25maWcucmVuZGVySXRlbSxcbiAgICAgIHRlbXBsYXRlOiBjb25maWcuaXRlbVRlbXBsYXRlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIHRvIHRoZSB1bml2ZXJzYWwgcGFnZSBmb3IgdGhlIG5vIHJlc3VsdHMgcGFnZSB0byBsaW5rIGJhY2sgdG8gd2l0aCBjdXJyZW50IHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3VuaXZlcnNhbFVybCA9IGNvbmZpZy51bml2ZXJzYWxVcmw7XG4gIH1cblxuICBtb3VudCAoKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZ2V0U3RhdGUoKSkubGVuZ3RoID4gMCkge1xuICAgICAgc3VwZXIubW91bnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZHVwbGljYXRlc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBkYXRhLnJlc3VsdHMgfHwgW107XG4gICAgY29uc3Qgc2VhcmNoU3RhdGUgPSBkYXRhLnNlYXJjaFN0YXRlIHx8IFNlYXJjaFN0YXRlcy5QUkVfU0VBUkNIO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgcmVzdWx0czogW10gfSwgZGF0YSwge1xuICAgICAgaXNQcmVTZWFyY2g6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuUFJFX1NFQVJDSCxcbiAgICAgIGlzU2VhcmNoTG9hZGluZzogc2VhcmNoU3RhdGUgPT09IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORyxcbiAgICAgIGlzU2VhcmNoQ29tcGxldGU6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFLFxuICAgICAgaW5jbHVkZU1hcDogdGhpcy5fY29uZmlnLmluY2x1ZGVNYXAsXG4gICAgICBtYXBDb25maWc6IHRoaXMuX2NvbmZpZy5tYXBDb25maWcsXG4gICAgICBldmVudE9wdGlvbnM6IHRoaXMuZXZlbnRPcHRpb25zKCksXG4gICAgICB1bml2ZXJzYWxVcmw6IHRoaXMuX3VuaXZlcnNhbFVybCA/IHRoaXMuX3VuaXZlcnNhbFVybCArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggOiAnJyxcbiAgICAgIHNob3dOb1Jlc3VsdHM6IHJlc3VsdHMubGVuZ3RoID09PSAwLFxuICAgICAgcXVlcnk6IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKVxuICAgIH0pLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciB0byBjb25zdHJ1Y3QgdGhlIGV2ZW50T3B0aW9ucyBvYmplY3QgZm9yIHRoZSB2aWV3IGFsbCBsaW5rXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBldmVudE9wdGlvbnMgKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB0aGlzLl92ZXJ0aWNhbENvbmZpZ0lkXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnVmVydGljYWxSZXN1bHRzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9yZXN1bHRzJztcbiAgfVxuXG4gIGNvbmZpZ3VyZUl0ZW0gKGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5faXRlbUNvbmZpZy5nbG9iYWwucmVuZGVyID0gY29uZmlnLnJlbmRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZy5yZW5kZXIpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtUmVuZGVyKGtleSwgY29uZmlnLnJlbmRlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2l0ZW1Db25maWcuZ2xvYmFsLnRlbXBsYXRlID0gY29uZmlnLnRlbXBsYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnLnRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVRlbXBsYXRlKGtleSwgY29uZmlnLnRlbXBsYXRlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldEl0ZW1UZW1wbGF0ZSAodHlwZSwgdGVtcGxhdGUpIHtcbiAgICBsZXQgY2xhenogPSB0aGlzLmdldEl0ZW1Db21wb25lbnQodHlwZSk7XG4gICAgdGhpcy5faXRlbUNvbmZpZ1tjbGF6ei50eXBlXS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICB9XG5cbiAgc2V0SXRlbVJlbmRlciAodHlwZSwgcmVuZGVyKSB7XG4gICAgbGV0IGNsYXp6ID0gdGhpcy5nZXRJdGVtQ29tcG9uZW50KHR5cGUpO1xuICAgIHRoaXMuX2l0ZW1Db25maWdbY2xhenoudHlwZV0ucmVuZGVyID0gcmVuZGVyO1xuICB9XG5cbiAgZ2V0SXRlbUNvbXBvbmVudCAodHlwZSkge1xuICAgIGxldCBjb21wID0gUmVzdWx0c0l0ZW1Db21wb25lbnQ7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJlc3VsdFR5cGUuRVZFTlQ6XG4gICAgICAgIGNvbXAgPSBFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVzdWx0VHlwZS5MT0NBVElPTjpcbiAgICAgICAgY29tcCA9IExvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSZXN1bHRUeXBlLlBFT1BMRTpcbiAgICAgICAgY29tcCA9IFBlb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcDtcbiAgfVxuXG4gIGFkZENoaWxkIChkYXRhLCB0eXBlLCBvcHRzKSB7XG4gICAgLy8gVE9ETyhiaWxseSkgUmVmYWN0b3IgdGhlIHdheSBjb25maWd1cmF0aW9uIGFuZCBkYXRhIGZsb3dzXG4gICAgLy8gdGhyb3VnaCB0b3AgbGV2ZWwgY29tcG9uZW50cyB0byBjaGlsZCBjb21wb25lbnRzLlxuICAgIGlmICh0eXBlID09PSBSZXN1bHRzSXRlbUNvbXBvbmVudC50eXBlKSB7XG4gICAgICBsZXQgY2xhenogPSB0aGlzLmdldEl0ZW1Db21wb25lbnQoZGF0YS50eXBlKTtcbiAgICAgIGlmIChjbGF6eikge1xuICAgICAgICB0eXBlID0gY2xhenoudHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE1hcENvbXBvbmVudC50eXBlKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBtYXA6IGRhdGFcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXdPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fY29uZmlnLm1hcENvbmZpZywgb3B0cyk7XG4gICAgICByZXR1cm4gc3VwZXIuYWRkQ2hpbGQoZGF0YSwgdHlwZSwgbmV3T3B0cyk7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdGhlIHByb3BlciBpdGVtIHJlbmRlcnMgdG8gdGhlIHRoZSBjb21wb25lbnRzXG4gICAgLy8gaGF2ZSBqdXN0IGJlZW4gY29uc3RydWN0ZWQuIFByaW9yaXRpemUgZ2xvYmFsIG92ZXIgaW5kaXZpZHVhbCBpdGVtcy5cbiAgICBsZXQgY29tcCA9IHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIE9iamVjdC5hc3NpZ24ob3B0cywge1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxDb25maWdJZCxcbiAgICAgIGlzVW5pdmVyc2FsOiB0aGlzLl9pc1VuaXZlcnNhbFxuICAgIH0pKTtcbiAgICBsZXQgZ2xvYmFsQ29uZmlnID0gdGhpcy5faXRlbUNvbmZpZy5nbG9iYWw7XG4gICAgbGV0IGl0ZW1Db25maWcgPSB0aGlzLl9pdGVtQ29uZmlnW2NvbXAudHlwZV07XG4gICAgbGV0IGhhc0dsb2JhbFJlbmRlciA9IHR5cGVvZiBnbG9iYWxDb25maWcucmVuZGVyID09PSAnZnVuY3Rpb24nO1xuICAgIGxldCBoYXNHbG9iYWxUZW1wbGF0ZSA9IHR5cGVvZiBnbG9iYWxDb25maWcudGVtcGxhdGUgPT09ICdzdHJpbmcnO1xuXG4gICAgaWYgKGhhc0dsb2JhbFJlbmRlcikge1xuICAgICAgY29tcC5zZXRSZW5kZXIoZ2xvYmFsQ29uZmlnLnJlbmRlcik7XG4gICAgfVxuXG4gICAgaWYgKGhhc0dsb2JhbFRlbXBsYXRlKSB7XG4gICAgICBjb21wLnNldFRlbXBsYXRlKGdsb2JhbENvbmZpZy50ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtQ29uZmlnKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9XG5cbiAgICBpZiAoIWhhc0dsb2JhbFJlbmRlciAmJiBpdGVtQ29uZmlnLnJlbmRlcikge1xuICAgICAgY29tcC5zZXRSZW5kZXIoaXRlbUNvbmZpZy5yZW5kZXIpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRlbXBsYXRlIHNwZWNpZmljIHNpdHVhdGlvblxuICAgIGlmICghaGFzR2xvYmFsVGVtcGxhdGUgJiYgaXRlbUNvbmZpZy50ZW1wbGF0ZSkge1xuICAgICAgY29tcC5zZXRUZW1wbGF0ZShpdGVtQ29uZmlnLnRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFjY29yZGlvblJlc3VsdHNDb21wb25lbnQgKi9cbmltcG9ydCBSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBleHRlbmRzIFJlc3VsdHNDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogYmFzZSBzZWxlY3RvciB0byB1c2Ugd2hlbiBmaW5kaW5nIERPTSB0YXJnZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9zZWxlY3RvckJhc2UgPSBjb25maWcuc2VsZWN0b3JCYXNlIHx8ICcuanMteXh0LUFjY29yZGlvblJlc3VsdCc7XG5cbiAgICAvKipcbiAgICAgKiBjb2xsYXBzZWQgc3RhdGUgY2xhc3NcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2VkQ2xhc3MgPSBjb25maWcuY29sbGFwc2VkQ2xhc3MgfHwgJ2lzLWNvbGxhcHNlZCc7XG5cbiAgICAvKipcbiAgICAgKiB2ZXJ0aWNhbCBjb25maWcgaWQgaXMgcmVxdWlyZWQgZm9yIGFuYWx5dGljc1xuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2FsQ29uZmlnSWQgPSBjb25maWcudmVydGljYWxDb25maWdJZCB8fCBjb25maWcuX3BhcmVudE9wdHMudmVydGljYWxDb25maWdJZCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoZSBjb21wb25lbnQgdHlwZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdBY2NvcmRpb25SZXN1bHRzJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAncmVzdWx0cy9yZXN1bHRzYWNjb3JkaW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBvdmVycmlkZXMgb25Nb3VudCB0byBhZGQgYmluZGluZ3MgdG8gY2hhbmdlIHRoZSBoZWlnaHQgb24gY2xpY2tcbiAgICogQHJldHVybnMge0FjY29yZGlvblJlc3VsdHNDb21wb25lbnR9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb25Nb3VudCAoKSB7XG4gICAgc3VwZXIub25Nb3VudCgpO1xuXG4gICAgLy8gTk9URShhbXVsbGluZ3MpOiBUaGlzIGlzIGEgaGFjaywgc2luY2UgY3VycmVudGx5IGNvbXBvbmVudHMgd2l0aCBzaWJsaW5nc1xuICAgIC8vIGhhdmUgbm8gd2F5IG9mIHJlZmVycmluZyB0byB0aGVpciBvd24gZWxlbWVudC4gV2UgaGF2ZSB0byBncmFiIHRoZSBmaXJzdFxuICAgIC8vIGVsZW1lbnQgc2luY2Ugc2VjdGlvbnMgZ2V0IGFkZGVkIGluIHJldmVyc2UuXG4gICAgY29uc3Qgc2VsZkVsID0gdGhpcy5fY29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgY29uc3QgYWNjb3JkaW9uRWxzID0gRE9NLnF1ZXJ5QWxsKHNlbGZFbCwgdGhpcy5fc2VsZWN0b3JCYXNlKTtcbiAgICBhY2NvcmRpb25FbHMuZm9yRWFjaCgoYWNjb3JkaW9uRWwpID0+IHtcbiAgICAgIGNvbnN0IHRvZ2dsZUVsID0gRE9NLnF1ZXJ5KGFjY29yZGlvbkVsLCB0aGlzLnRvZ2dsZVNlbGVjdG9yKCkpO1xuICAgICAgY29uc3QgY29udGVudEVsID0gRE9NLnF1ZXJ5KGFjY29yZGlvbkVsLCB0aGlzLmJvZHlTZWxlY3RvcigpKTtcbiAgICAgIHRoaXMuY2hhbmdlSGVpZ2h0KGNvbnRlbnRFbCwgYWNjb3JkaW9uRWwpO1xuICAgICAgdG9nZ2xlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soYWNjb3JkaW9uRWwsIHRvZ2dsZUVsLCBjb250ZW50RWwpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG1vZGlmaWVyOiB0aGlzLnZlcnRpY2FsQ29uZmlnSWRcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogY2xpY2sgaGFuZGxlciBmb3IgdGhlIGFjY29yZGlvbiB0b2dnbGUgYnV0dG9uXG4gICAqIEBwYXJhbSB3cmFwcGVyRWwge0hUTUxFbGVtZW50fSB0aGUgdG9nZ2xlIGNvbnRhaW5lclxuICAgKiBAcGFyYW0gdG9nZ2xlRWwge0hUTUxFbGVtZW50fSB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSBjb250ZW50RWwge0hUTUxFbGVtZW50fSB0aGUgdG9nZ2xlIHRhcmdldFxuICAgKi9cbiAgaGFuZGxlQ2xpY2sgKHdyYXBwZXJFbCwgdG9nZ2xlRWwsIGNvbnRlbnRFbCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KHRoaXMuaXNDb2xsYXBzZWQod3JhcHBlckVsKSA/ICdST1dfRVhQQU5EJyA6ICdST1dfQ09MTEFQU0UnKVxuICAgICAgLmFkZE9wdGlvbnMoe1xuICAgICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB0aGlzLnZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICAgIGVudGl0eUlkOiB0b2dnbGVFbC5kYXRhc2V0LmVudGl0eUlkXG4gICAgICB9KTtcbiAgICB3cmFwcGVyRWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmNvbGxhcHNlZENsYXNzKTtcbiAgICB0aGlzLmNoYW5nZUhlaWdodChjb250ZW50RWwsIHdyYXBwZXJFbCk7XG4gICAgdG9nZ2xlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdGhpcy5pc0NvbGxhcHNlZCh3cmFwcGVyRWwpID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgY29sbGFwc2VkXG4gICAqIEBwYXJhbSB3cmFwcGVyRWwge0hUTUxFbGVtZW50fSB0aGUgdG9nZ2xlIGNvbnRhaW5lclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29sbGFwc2VkICh3cmFwcGVyRWwpIHtcbiAgICBpZiAoIXdyYXBwZXJFbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVyRWwuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29sbGFwc2VkQ2xhc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRvZ2dsZXMgdGhlIGhlaWdodCBiZXR3ZWVuIDAgYW5kIHRoZSBjb250ZW50IGhlaWdodCBmb3Igc21vb3RoIGFuaW1hdGlvblxuICAgKiBAcGFyYW0gdGFyZ2V0RWwge0hUTUxFbGVtZW50fVxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGNoYW5nZUhlaWdodCAodGFyZ2V0RWwsIHdyYXBwZXJFbCkge1xuICAgIHRhcmdldEVsLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaXNDb2xsYXBzZWQod3JhcHBlckVsKSA/IDAgOiB0YXJnZXRFbC5zY3JvbGxIZWlnaHR9cHhgO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciBmb3IgY29tcG9zaW5nIGNoaWxkIGVsZW1lbnQgc2VsZWN0b3JzXG4gICAqIEBwYXJhbSBjaGlsZCB7c3RyaW5nfVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgYnVpbGRTZWxlY3RvciAoY2hpbGQpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fc2VsZWN0b3JCYXNlfSR7Y2hpbGR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIHRoZSB0b2dnbGUgYnV0dG9uIHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b2dnbGVTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRTZWxlY3RvcignLXRvZ2dsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciBmb3IgdGhlIGNvbnRlbnQgZWxlbWVudCBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgYm9keVNlbGVjdG9yICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZFNlbGVjdG9yKCctYm9keScpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcbmltcG9ydCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vYWNjb3JkaW9ucmVzdWx0c2NvbXBvbmVudC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcblxuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUUztcbiAgICB0aGlzLl9saW1pdCA9IG9wdHMubGltaXQgfHwgMTA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnVW5pdmVyc2FsUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvdW5pdmVyc2FscmVzdWx0cyc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGluaXQgKG9wdHMpIHtcbiAgICBzdXBlci5pbml0KG9wdHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gZGF0YS5zZWN0aW9ucyB8fCBbXTtcbiAgICBjb25zdCBzZWFyY2hTdGF0ZSA9IGRhdGEuc2VhcmNoU3RhdGUgfHwgU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0g7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oeyBzZWN0aW9uczogW10gfSwgZGF0YSwge1xuICAgICAgaXNQcmVTZWFyY2g6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuUFJFX1NFQVJDSCxcbiAgICAgIGlzU2VhcmNoTG9hZGluZzogc2VhcmNoU3RhdGUgPT09IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORyxcbiAgICAgIGlzU2VhcmNoQ29tcGxldGU6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFLFxuICAgICAgc2hvd05vUmVzdWx0czogc2VjdGlvbnMubGVuZ3RoID09PSAwLFxuICAgICAgcXVlcnk6IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKVxuICAgIH0pLCB2YWwpO1xuICB9XG5cbiAgYWRkQ2hpbGQgKGRhdGEgPSB7fSwgdHlwZSwgb3B0cykge1xuICAgIGNvbnN0IGNoaWxkT3B0cyA9IHsgLi4ub3B0cywgLi4udGhpcy5nZXRDaGlsZENvbmZpZyhbZGF0YVsndmVydGljYWxDb25maWdJZCddXSkgfTtcbiAgICBpZiAoY2hpbGRPcHRzLnVzZUFjY29yZGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIEFjY29yZGlvblJlc3VsdHNDb21wb25lbnQudHlwZSwgY2hpbGRPcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIGNoaWxkT3B0cyk7XG4gIH1cblxuICBnZXRDaGlsZENvbmZpZyAoY29uZmlnSWQpIHtcbiAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgdmVydGljYWxDb25maWdJZDogY29uZmlnSWQsXG4gICAgICBpc1VuaXZlcnNhbDogdHJ1ZVxuICAgIH07XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZy5jb25maWc7XG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdENvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdENvbmZpZywgdGhpcy5fY29uZmlnWydjb25maWcnXVtjb25maWdJZF0gfHwgdGhpcy5fY29uZmlnWydjb25maWcnXSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFBhZ2luYXRpb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2luYXRpb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2UgZm9yIHNlYXJjaGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykudmVydGljYWxLZXk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl92ZXJ0aWNhbEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICd2ZXJ0aWNhbEtleSBub3QgcHJvdmlkZWQsIGJ1dCBuZWNlc3NhcnkgZm9yIHBhZ2luYXRpb24nLFxuICAgICAgICAnUGFnaW5hdGlvbkNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXlzIHRoZSBmaXJzdCBwYWdlIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCA9IGNvbmZpZy5zaG93Rmlyc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0ZpcnN0O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheXMgdGhlIGxhc3QgcGFnZSBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCA9IGNvbmZpZy5zaG93TGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TGFzdDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGFsbCBhbmFseXRpYyBldmVudHMgc2VudCBieSB0aGlzIGNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NPcHRpb25zID0ge1xuICAgICAgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5XG4gICAgfTtcblxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDA7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIE51bWJlcihvZmZzZXQpKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgb2Zmc2V0ID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgTnVtYmVyKG9mZnNldCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIHJlc3VsdHMgPT4ge1xuICAgICAgaWYgKHJlc3VsdHMuc2VhcmNoU3RhdGUgPT09IFNlYXJjaFN0YXRlcy5TRUFSQ0hfQ09NUExFVEUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1BhZ2luYXRpb24nO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAncmVzdWx0cy9wYWdpbmF0aW9uJztcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTKSB8fCB7fTtcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLmxpbWl0O1xuICAgIGNvbnN0IHNob3dDb250cm9scyA9IHJlc3VsdHMuc2VhcmNoU3RhdGUgPT09ICdzZWFyY2gtY29tcGxldGUnICYmIHJlc3VsdHMucmVzdWx0c0NvdW50ID4gbGltaXQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMDtcbiAgICBpZiAoIXNob3dDb250cm9scykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZpb3VzUGFnZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LVBhZ2luYXRpb24tcHJldmlvdXMnKTtcbiAgICBjb25zdCBuZXh0UGFnZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LVBhZ2luYXRpb24tbmV4dCcpO1xuICAgIGNvbnN0IG1heFBhZ2UgPSBNYXRoLnRydW5jKChyZXN1bHRzLnJlc3VsdHNDb3VudCAtIDEpIC8gbGltaXQpO1xuXG4gICAgRE9NLm9uKHByZXZpb3VzUGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKG9mZnNldCAtIGxpbWl0KSk7XG4gICAgRE9NLm9uKG5leHRQYWdlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZVBhZ2Uob2Zmc2V0ICsgbGltaXQpKTtcblxuICAgIGlmICh0aGlzLl9maXJzdFBhZ2VCdXR0b25FbmFibGVkKSB7XG4gICAgICBjb25zdCBmaXJzdFBhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLWZpcnN0Jyk7XG4gICAgICBET00ub24oZmlyc3RQYWdlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZVBhZ2UoMCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGxhc3RQYWdlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtUGFnaW5hdGlvbi1sYXN0Jyk7XG4gICAgICBET00ub24obGFzdFBhZ2VCdXR0b24sICdjbGljaycsICgpID0+IHRoaXMudXBkYXRlUGFnZShtYXhQYWdlICogbGltaXQpKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVQYWdlIChvZmZzZXQpIHtcbiAgICB0aGlzLnNjcm9sbFRvVG9wKCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIG9mZnNldCk7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBvZmZzZXQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFBhZ2UodGhpcy5fdmVydGljYWxLZXksIG9mZnNldCk7XG4gIH1cblxuICBzY3JvbGxUb1RvcCAoKSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgLy8gU2FmYXJpXG4gICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSAwO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUykgfHwge307XG4gICAgbGV0IG9mZnNldCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDA7XG4gICAgY29uc3QgbGltaXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHKS5saW1pdDtcbiAgICBjb25zdCBwYWdlTnVtYmVyID0gb2Zmc2V0IC8gbGltaXQ7XG4gICAgY29uc3Qgc2hvd0NvbnRyb2xzID0gcmVzdWx0cy5zZWFyY2hTdGF0ZSA9PT0gJ3NlYXJjaC1jb21wbGV0ZScgJiYgcmVzdWx0cy5yZXN1bHRzQ291bnQgPiBsaW1pdDtcbiAgICBjb25zdCBpc01vcmVSZXN1bHRzID0gcmVzdWx0cy5yZXN1bHRzQ291bnQgPiBvZmZzZXQgKyBsaW1pdDtcbiAgICBjb25zdCBtYXhQYWdlID0gTWF0aC50cnVuYygocmVzdWx0cy5yZXN1bHRzQ291bnQgLSAxKSAvIGxpbWl0KTtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoe1xuICAgICAgc2hvd0NvbnRyb2xzOiBzaG93Q29udHJvbHMsXG4gICAgICBmaXJzdFBhZ2VCdXR0b25FbmFibGVkOiB0aGlzLl9maXJzdFBhZ2VCdXR0b25FbmFibGVkLFxuICAgICAgbGFzdFBhZ2VCdXR0b25FbmFibGVkOiB0aGlzLl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQsXG4gICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyICsgMSxcbiAgICAgIHNob3dGaXJzdFBhZ2VCdXR0b246IHBhZ2VOdW1iZXIgPiAxLFxuICAgICAgc2hvd1ByZXZpb3VzUGFnZUJ1dHRvbjogcGFnZU51bWJlciA+IDAsXG4gICAgICBzaG93TmV4dFBhZ2VCdXR0b246IGlzTW9yZVJlc3VsdHMsXG4gICAgICBzaG93TGFzdFBhZ2VCdXR0b246IHBhZ2VOdW1iZXIgPCBtYXhQYWdlIC0gMSxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBRdWVzdGlvblN1Ym1pc3Npb24gZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvcXVlc3Rpb25zdWJtaXNzaW9uJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi4vLi4vLi4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcblxuLyoqXG4gKiBDb25maWd1cmFibGUgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIC8qKlxuICAgKiBUaGUgZW50aXR5IGlkZW50aWZpZXIgdGhhdCB0aGUgcXVlc3Rpb24gaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKiBUaGlzIGlzIHR5cGljYWxseSBhbiBvcmdhbml6YXRpb24gb2JqZWN0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICAnZW50aXR5SWQnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBDU1Mgc2VsZWN0b3IgdXNlZCB0byByZWZlcmVuY2UgdGhlIGZvcm0gZm9yIHRoZSBjb21wb25lbnQuXG4gICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgKi9cbiAgJ2Zvcm1TZWxlY3Rvcic6ICdmb3JtJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgZS1tYWlsIGFkZHJlc3MgaW5wdXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdlbWFpbExhYmVsJzogJ0VtYWlsJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgbmFtZSBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ25hbWVMYWJlbCc6ICdOYW1lJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgcXVlc3Rpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdxdWVzdGlvbkxhYmVsJzogJ1F1ZXN0aW9uJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgUHJpdmFjeSBQb2xpY3lcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdwcml2YWN5UG9saWN5VGV4dCc6ICdCeSBzdWJtaXR0aW5nIG15IGVtYWlsIGFkZHJlc3MsIEkgY29uc2VudCB0byBiZWluZyBjb250YWN0ZWQgdmlhIGVtYWlsIGF0IHRoZSBhZGRyZXNzIHByb3ZpZGVkLicsXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSBTdWJtaXQgYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnYnV0dG9uTGFiZWwnOiAnU3VibWl0JyxcblxuICAvKipcbiAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgaW4gdGhlIHRpdGxlIGJhclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3NlY3Rpb25UaXRsZSc6ICdBc2sgYSBRdWVzdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiB0byBkaXNwbGF5IGluIHRoZSB0aXRsZSBiYXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd0ZWFzZXInOiAnQ2Fu4oCZdCBmaW5kIHdoYXQgeW91XFwncmUgbG9va2luZyBmb3I/IEFzayBhIHF1ZXN0aW9uIGJlbG93LicsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpY29uIHRvIHVzZSBpbiB0aGUgdGl0bGUgYmFyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnc2VjdGlvblRpdGxlSWNvbk5hbWUnOiAnc3VwcG9ydCcsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIGZlZWRiYWNrIGZvcm0gYWhlYWQgb2YgdGhlIFF1ZXN0aW9uIGlucHV0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnZGVzY3JpcHRpb24nOiAnRW50ZXIgeW91ciBxdWVzdGlvbiBhbmQgY29udGFjdCBpbmZvcm1hdGlvbiwgYW5kIHdlXFwnbGwgZ2V0IGJhY2sgdG8geW91IHdpdGggYSByZXNwb25zZSBzaG9ydGx5LicsXG5cbiAgLyoqXG4gICAqIFRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciByZXF1aXJlZCBpbnB1dHNcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdyZXF1aXJlZElucHV0UGxhY2Vob2xkZXInOiAnKHJlcXVpcmVkKScsXG5cbiAgLyoqXG4gICAqIFRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgcXVlc3Rpb24gdGV4dCBhcmVhXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncXVlc3Rpb25JbnB1dFBsYWNlaG9sZGVyJzogJ0VudGVyIHlvdXIgcXVlc3Rpb24gaGVyZScsXG5cbiAgLyoqXG4gICAqIFRoZSBjb25maXJtYXRpb24gdGV4dCB0byBkaXNwbGF5IGFmdGVyIHN1Y2Nlc3NmdWxseSBzdWJtaXR0aW5nIGZlZWRiYWNrXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncXVlc3Rpb25TdWJtaXNzaW9uQ29uZmlybWF0aW9uVGV4dCc6ICdUaGFuayB5b3UgZm9yIHlvdXIgcXVlc3Rpb24hJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcHJpdmFjeSBwb2xpY3kgdXJsIGxhYmVsXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICovXG4gICdwcml2YWN5UG9saWN5VXJsTGFiZWwnOiAnTGVhcm4gbW9yZSBoZXJlLicsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaXZhY3kgcG9saWN5IHVybFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lVcmwnOiAnJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcHJpdmFjeSBwb2xpY3kgZXJyb3IgdGV4dCwgc2hvd24gd2hlbiB0aGUgdXNlciBkb2VzIG5vdCBhZ3JlZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lFcnJvclRleHQnOiAnKiBZb3UgbXVzdCBhZ3JlZSB0byB0aGUgcHJpdmFjeSBwb2xpY3kgdG8gc3VibWl0IGEgcXVlc3Rpb24uJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZW1haWwgZm9ybWF0IGVycm9yIHRleHQsIHNob3duIHdoZW4gdGhlIHVzZXIgc3VibWl0cyBhbiBpbnZhbGlkIGVtYWlsXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnZW1haWxGb3JtYXRFcnJvclRleHQnOiAnKiBQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IGlzIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgJ2V4cGFuZGVkJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQgaXMgYSBjb21wb25lbnQgdGhhdCBjcmVhdGVzIGEgZm9ybVxuICogdGhhdHMgZGlzcGxheWVkIHdoZW5ldmVyIGEgcXVlcnkgaXMgcnVuLiBJdCBlbmFibGVzIHRoZSB1c2VyXG4gKiB0byBzdWJtaXQgcXVlc3Rpb25zIHRoYXQgdGhleSBjYW50IGZpbmQgdGhlIGFuc3dlciBmb3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgc3RvcmFnZSBtb2RlbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT047XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxvY2FsZSBhcyBzZXQgaW4gdGhlIGdsb2JhbCBjb25maWdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuTE9DQUxFKTtcblxuICAgIC8qKlxuICAgICAqIE5PVEUoYmlsbHkpIGlmIHRoaXMgaXMgYSBwYXR0ZXJuIHdlIHdhbnQgdG8gZm9sbG93IGZvciBjb25maWd1cmF0aW9uXG4gICAgICogd2Ugc2hvdWxkIGJha2UgaXQgaW50byB0aGUgY29yZSBjbGFzcy5cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUXVlc3Rpb25TdWJtaXNzaW9uIGNvbXBvbmVudCBzaG91bGQgYmUgcmVuZGVyZWQgb25seSBvbmNlIGEgc2VhcmNoIGhhcyBjb21wbGV0ZWQuIElmIHRoZVxuICAgICAqIHNlYXJjaCByZXN1bHRzIGFyZSBzdGlsbCBsb2FkaW5nLCB0aGUgY29tcG9uZW50IHNob3VsZCBub3QgYmUgZGlzcGxheWVkLlxuICAgICAqL1xuICAgIGNvbnN0IG9uUmVzdWx0c1VwZGF0ZSA9IHJlc3VsdHMgPT4ge1xuICAgICAgaWYgKHJlc3VsdHMuc2VhcmNoU3RhdGUgIT09IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORykge1xuICAgICAgICBjb25zdCBxdWVzdGlvblRleHQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3IFF1ZXN0aW9uU3VibWlzc2lvbih7XG4gICAgICAgICAgcXVlc3Rpb25UZXh0OiBxdWVzdGlvblRleHQsXG4gICAgICAgICAgZXhwYW5kZWQ6IHRoaXMuX2NvbmZpZy5leHBhbmRlZFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuTW91bnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIG9uUmVzdWx0c1VwZGF0ZSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlVOSVZFUlNBTF9SRVNVTFRTLCBvblJlc3VsdHNVcGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdxdWVzdGlvbnMvcXVlc3Rpb25zdWJtaXNzaW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGludGVyZmFjZSBhbGlhcyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdRQVN1Ym1pc3Npb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIHZhbGlkYXRpb25Db25maWcgY29udGFpbnMgYSBidW5jaCBvZiBydWxlc1xuICAgKiB0aGF0IGFyZSB1c2VkIHRvIHZhbGlkYXRlIGFnaW5zdCBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAqL1xuICB2YWxpZGF0ZUNvbmZpZyAoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5lbnRpdHlJZCA9PT0gbnVsbCB8fCB0aGlzLl9jb25maWcuZW50aXR5SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ2BlbnRpdHlJZGAgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgUXVlc3Rpb24gU3VibWlzc2lvbicsXG4gICAgICAgICdRdWVzdGlvblN1Ym1pc3Npb24nKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgLy8gQXZvaWQgbW91bnRpbmcgdGhlIGNvbXBvbmVudCBpZiB0aGVyZXMgbm8gZGF0YVxuICAgIC8vIE5vdGUsIDEgYmVjYXVzZSBgY29uZmlnYCBpcyBhbHdheXMgcGFydCBvZiB0aGUgc3RhdGUuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0U3RhdGUoKSkubGVuZ3RoID4gMTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGxldCB0cmlnZ2VyRWwgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLWNvbnRlbnQtdmlzaWJpbGl0eS10b2dnbGUnKTtcbiAgICBpZiAodHJpZ2dlckVsICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmJpbmRGb3JtVG9nZ2xlKHRyaWdnZXJFbCk7XG4gICAgfVxuXG4gICAgbGV0IGZvcm1FbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbmZpZy5mb3JtU2VsZWN0b3IpO1xuICAgIGlmIChmb3JtRWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRGb3JtRm9jdXMoZm9ybUVsKTtcbiAgICB0aGlzLmJpbmRGb3JtU3VibWl0KGZvcm1FbCk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1Gb2N1cyB3aWxsIHdpcmUgdXAgdGhlIERPTSBmb2N1cyBldmVudCB0byBzZXJ2ZXJzaWRlIHJlcG9ydGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICovXG4gIGJpbmRGb3JtRm9jdXMgKGZvcm1FbCkge1xuICAgIGlmICh0aGlzLmFuYWx5dGljc1JlcG9ydGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcXVlc3Rpb25UZXh0ID0gRE9NLnF1ZXJ5KGZvcm1FbCwgJy5qcy1xdWVzdGlvbi10ZXh0Jyk7XG4gICAgRE9NLm9uKHF1ZXN0aW9uVGV4dCwgJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQodGhpcy5nZXRBbmFseXRpY3NFdmVudCgnUVVFU1RJT05fRk9DVVMnKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1TdWJtaXQgaGFuZGxlcyBzdWJtaXR0aW5nIHRoZSBxdWVzdGlvbiB0byB0aGUgc2VydmVyLFxuICAgKiBhbmQgc3VibWl0cyBhbiBldmVudCB0byBzZXJ2ZXJzaWRlIHJlcG9ydGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICovXG4gIGJpbmRGb3JtU3VibWl0IChmb3JtRWwpIHtcbiAgICBET00ub24oZm9ybUVsLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KHRoaXMuZ2V0QW5hbHl0aWNzRXZlbnQoJ1FVRVNUSU9OX1NVQk1JVCcpKTtcblxuICAgICAgLy8gVE9ETyhiaWxseSkgd2UgcHJvYmFibHkgd2FudCB0byBkaXNhYmxlIHRoZSBmb3JtIGZyb20gYmVpbmcgc3VibWl0dGVkIHR3aWNlXG4gICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnZhbGlkYXRlKGZvcm1FbCk7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IHRoaXMucGFyc2UoZm9ybUVsKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShuZXcgUXVlc3Rpb25TdWJtaXNzaW9uKGZvcm1EYXRhLCBlcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlLnN1Ym1pdFF1ZXN0aW9uKHtcbiAgICAgICAgJ2VudGl0eUlkJzogdGhpcy5fY29uZmlnLmVudGl0eUlkLFxuICAgICAgICAncXVlc3Rpb25MYW5ndWFnZSc6IHRoaXMubG9jYWxlLFxuICAgICAgICAnc2l0ZSc6ICdGSVJTVFBBUlRZJyxcbiAgICAgICAgJ25hbWUnOiBmb3JtRGF0YS5uYW1lLFxuICAgICAgICAnZW1haWwnOiBmb3JtRGF0YS5lbWFpbCxcbiAgICAgICAgJ3F1ZXN0aW9uVGV4dCc6IGZvcm1EYXRhLnF1ZXN0aW9uVGV4dCxcbiAgICAgICAgJ3F1ZXN0aW9uRGVzY3JpcHRpb24nOiBmb3JtRGF0YS5xdWVzdGlvbkRlc2NyaXB0aW9uXG4gICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBuZXcgUXVlc3Rpb25TdWJtaXNzaW9uKGZvcm1EYXRhLCB7XG4gICAgICAgICAgICAgICduZXR3b3JrJzogJ1dlXFwncmUgc29ycnksIGFuIGVycm9yIG9jY3VycmVkLidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogYmluZEZvcm1Ub2dnbGUgaGFuZGxlcyBleHBhbmRpbmcgYW5kIG1pbWltaXppbmcgdGhlIGNvbXBvbmVudCdzIGZvcm0uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRyaWdnZXJFbFxuICAgKi9cbiAgYmluZEZvcm1Ub2dnbGUgKHRyaWdnZXJFbCkge1xuICAgIERPTS5vbih0cmlnZ2VyRWwsICdjbGljaycsIChlKSA9PiB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgIG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oe1xuICAgICAgICAgIC4uLmZvcm1EYXRhLFxuICAgICAgICAgICdleHBhbmRlZCc6ICFmb3JtRGF0YS5xdWVzdGlvbkV4cGFuZGVkLFxuICAgICAgICAgICdzdWJtaXR0ZWQnOiBmb3JtRGF0YS5xdWVzdGlvblN1Ym1pdHRlZCB9LFxuICAgICAgICBmb3JtRGF0YS5lcnJvcnMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZm9ybSwgYW5kIGJ1aWxkcyBhIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGlucHV0IG5hbWVzXG4gICAqIGFuZCB0ZXh0IGZpZWxkcy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZm9ybUVsXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBwYXJzZSAoZm9ybUVsKSB7XG4gICAgY29uc3QgaW5wdXRGaWVsZHMgPSBET00ucXVlcnlBbGwoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLWZpZWxkJyk7XG4gICAgaWYgKCFpbnB1dEZpZWxkcyB8fCBpbnB1dEZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBsZXQgb2JqID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHZhbCA9IGlucHV0RmllbGRzW2ldLnZhbHVlO1xuICAgICAgaWYgKGlucHV0RmllbGRzW2ldLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgdmFsID0gaW5wdXRGaWVsZHNbaV0uY2hlY2tlZDtcbiAgICAgIH1cbiAgICAgIG9ialtpbnB1dEZpZWxkc1tpXS5uYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgZmllbGRzIGZvciBjb3JyZWN0IGZvcm1hdHRpbmdcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZm9ybUVsXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGVycm9ycyBvYmplY3QgaWYgYW55IGVycm9ycyBmb3VuZFxuICAgKi9cbiAgdmFsaWRhdGUgKGZvcm1FbCkge1xuICAgIGxldCBlcnJvcnMgPSB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBET00ucXVlcnlBbGwoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLWZpZWxkJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZmllbGRzW2ldLmNoZWNrVmFsaWRpdHkoKSkge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIC8vIHNldCBmb2N1cyBzdGF0ZSBvbiBmaXJzdCBlcnJvclxuICAgICAgICAgIGZpZWxkc1tpXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmllbGRzW2ldLm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdlbWFpbCc6XG4gICAgICAgICAgICBlcnJvcnNbJ2VtYWlsRXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc1tpXS52YWxpZGl0eS52YWx1ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgZXJyb3JzWydlbWFpbEVycm9yVGV4dCddID0gdGhpcy5fY29uZmlnLmVtYWlsRm9ybWF0RXJyb3JUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICBlcnJvcnNbJ25hbWVFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ByaXZhY3lQb2xpY3knOlxuICAgICAgICAgICAgZXJyb3JzWydwcml2YWN5UG9saWN5RXJyb3JUZXh0J10gPSB0aGlzLl9jb25maWcucHJpdmFjeVBvbGljeUVycm9yVGV4dDtcbiAgICAgICAgICAgIGVycm9yc1sncHJpdmFjeVBvbGljeUVycm9yJ10gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncXVlc3Rpb25UZXh0JzpcbiAgICAgICAgICAgIGVycm9yc1sncXVlc3Rpb25UZXh0RXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3B0aW9ucyBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29udGV4dCBvZiBhIHJlcG9ydGFibGUgZXZlbnRcbiAgICovXG4gIGdldEFuYWx5dGljc0V2ZW50IChldmVudFR5cGUpIHtcbiAgICBjb25zdCBhbmFseXRpY3NFdmVudCA9IG5ldyBBbmFseXRpY3NFdmVudChldmVudFR5cGUpO1xuICAgIGFuYWx5dGljc0V2ZW50LmFkZE9wdGlvbnMoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBzZWFyY2hlcjogdGhpcy5fdmVydGljYWxLZXkgPyAnVkVSVElDQUwnIDogJ1VOSVZFUlNBTCdcbiAgICB9KTtcbiAgICByZXR1cm4gYW5hbHl0aWNzRXZlbnQ7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNWR0ljb24ge1xuICAvKipcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcGFyYW0gY29uZmlnLm5hbWVcbiAgICogQHBhcmFtIGNvbmZpZy5wYXRoXG4gICAqIEBwYXJhbSBjb25maWcuY29tcGxleENvbnRlbnRzXG4gICAqIEBwYXJhbSBjb25maWcudmlld0JveFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgaWNvblxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIC8qKlxuICAgICAqIGFuIHN2ZyBwYXRoIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnBhdGggPSBjb25maWcucGF0aDtcbiAgICAvKipcbiAgICAgKiBpZiBub3QgdXNpbmcgYSBwYXRoLCBhIHRoZSBtYXJrdXAgZm9yIGEgY29tcGxleCBTVkdcbiAgICAgKi9cbiAgICB0aGlzLmNvbXBsZXhDb250ZW50cyA9IGNvbmZpZy5jb21wbGV4Q29udGVudHM7XG4gICAgLyoqXG4gICAgICogdGhlIHZpZXcgYm94IGRlZmluaXRpb24sIGRlZmF1bHRzIHRvIDI0eDI0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdCb3ggPSBjb25maWcudmlld0JveCB8fCAnMCAwIDI0IDI0JztcbiAgICAvKipcbiAgICAgKiBhY3R1YWwgY29udGVudHMgdXNlZFxuICAgICAqL1xuICAgIHRoaXMuY29udGVudHMgPSB0aGlzLnBhdGhEZWZpbml0aW9uKCk7XG4gIH1cblxuICBwYXRoRGVmaW5pdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY29tcGxleENvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV4Q29udGVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGA8cGF0aCBkPVwiJHt0aGlzLnBhdGh9XCI+PC9wYXRoPmA7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgc3ZnIG1hcmt1cFxuICAgKi9cbiAgbWFya3VwICgpIHtcbiAgICByZXR1cm4gYDxzdmcgdmlld0JveD1cIiR7dGhpcy52aWV3Qm94fVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4ke3RoaXMuY29udGVudHN9PC9zdmc+YDtcbiAgfVxufVxuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3RodW1iJyxcbiAgdmlld0JveDogJzAgMCAyNCAyMicsXG4gIHBhdGg6ICdNMTUuMjczIDFINS40NTVjLS45MDYgMC0xLjY4LjU1LTIuMDA4IDEuMzQyTC4xNTMgMTAuMDk3QTIuMTkgMi4xOSAwIDAwMCAxMC45djIuMmMwIDEuMjEuOTgyIDIuMiAyLjE4MiAyLjJoNi44ODNMOC4wMyAyMC4zMjdsLS4wMzMuMzUyYzAgLjQ1MS4xODYuODY5LjQ4IDEuMTY2TDkuNjMzIDIzbDcuMTc4LTcuMjQ5YTIuMTYgMi4xNiAwIDAwLjY0NC0xLjU1MXYtMTFjMC0xLjIxLS45ODItMi4yLTIuMTgyLTIuMnptMCAxMy4ybC00LjczNSA0Ljc3NEwxMS43NSAxMy4xSDIuMTgydi0yLjJsMy4yNzMtNy43aDkuODE4djExek0xOS42MzYgMUgyNHYxMy4yaC00LjM2NFYxeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3JlY2VpcHQnLFxuICBwYXRoOiAnTTE0LjYwNiA5LjVjLS42NzEtLjUxNS0xLjU5MS0uODMzLTIuNjA2LS44MzMgMS4wMTUgMCAxLjkzNS4zMTggMi42MDYuODMzem0tNy45ODUgMEgxLjY1NUExLjY2IDEuNjYgMCAwMTAgNy44MzNWMy42NjdDMCAyLjc0Ny43NDEgMiAxLjY1NSAyaDIwLjY5QTEuNjYgMS42NiAwIDAxMjQgMy42Njd2NC4xNjZBMS42NiAxLjY2IDAgMDEyMi4zNDUgOS41aC00Ljk2NlYyMkg2LjYyMVY5LjVoMi43NzNINi42MnptMTAuNzU4LTEuNjY3aDQuOTY2VjMuNjY3SDEuNjU1djQuMTY2aDQuOTY2di0yLjVoMTAuNzU4djIuNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwYW50aGVvbicsXG4gIHBhdGg6ICdNOS45NDcgMTYuNTk4aC4yNTJWOS40MTJoLS4yNTJhLjQzMi40MzIgMCAwMS0uMjMtLjA2NWMtLjA3LS4wNDMtLjEwNi0uMDkzLS4xMDYtLjE1TDkuMTUgNy44MnYtLjE1YzAtLjA0NC4wMjgtLjA4LjA4NC0uMTA5YS42OTEuNjkxIDAgMDEuMTA1LS4wODYuMjU0LjI1NCAwIDAxLjE0Ni0uMDQzSDEzLjZjLjA1NiAwIC4xMDQuMDE1LjE0Ni4wNDMuMDQyLjAzLjA5MS4wNTguMTQ3LjA4NmEuMjcxLjI3MSAwIDAxLjA2My4xMDhjLjAxNC4wNDMuMDA3LjA5My0uMDIuMTVsLS40MiAxLjM3OGEuMzc0LjM3NCAwIDAxLS4xNDcuMTUuMzcuMzcgMCAwMS0uMTkuMDY1aC0uMjUxdjcuMTg2aC4yNTJhLjM3LjM3IDAgMDEuMTg5LjA2NWMuMDcuMDQzLjExOS4wOTMuMTQ3LjE1bC40MiAxLjM3OGMuMDI3LjAyOC4wMzQuMDcxLjAyLjEyOWEuMjc1LjI3NSAwIDAxLS4wNjMuMTI5IDEuMzY0IDEuMzY0IDAgMDAtLjE0Ny4wODYuMjU0LjI1NCAwIDAxLS4xNDYuMDQzSDkuNDg1YS4yNTQuMjU0IDAgMDEtLjE0Ni0uMDQzLjY5MS42OTEgMCAwMS0uMTA1LS4wODZjLS4wNTYtLjAyOS0uMDg0LS4wNzItLjA4NC0uMTN2LS4xMjhsLjQ2MS0xLjM3N2MwLS4wNTguMDM1LS4xMDguMTA1LS4xNTFhLjQzMi40MzIgMCAwMS4yMzEtLjA2NXptNS43OTIgMGguMjUyVjkuNDEyaC0uMjUyYS40MzIuNDMyIDAgMDEtLjIzLS4wNjUuMzc0LjM3NCAwIDAxLS4xNDgtLjE1bC0uNDItMS4zNzdjLS4wMjctLjAyOS0uMDM0LS4wNzItLjAyLS4xM2EuMjc1LjI3NSAwIDAxLjA2My0uMTI5Yy4wNTYtLjAyOC4xMDUtLjA1Ny4xNDYtLjA4NmEuMjU0LjI1NCAwIDAxLjE0Ny0uMDQzaDQuMTE0Yy4wNTUgMCAuMTA0LjAxNS4xNDYuMDQzYS42OTEuNjkxIDAgMDEuMTA1LjA4NmMuMDU2LjAzLjA4NC4wNzIuMDg0LjEzdi4xMjlsLS40MiAxLjM3N2EuMzc0LjM3NCAwIDAxLS4xNDYuMTUuNDMyLjQzMiAwIDAxLS4yMzEuMDY1aC0uMjF2Ny4xODZoLjIxYS40My40MyAwIDAxLjIzLjA2NWMuMDcuMDQzLjEyLjA5My4xNDguMTVsLjQyIDEuMzc4di4xNWMwIC4wNDMtLjAyOS4wOC0uMDg1LjEwOGEuNjkxLjY5MSAwIDAxLS4xMDUuMDg2LjI1NC4yNTQgMCAwMS0uMTQ2LjA0M2gtNC4xMTRhLjI1NC4yNTQgMCAwMS0uMTQ3LS4wNDMgMS4zNjQgMS4zNjQgMCAwMC0uMTQ2LS4wODYuMjcxLjI3MSAwIDAxLS4wNjMtLjEwOGMtLjAxNC0uMDQzLS4wMDctLjA5My4wMi0uMTVsLjQyLTEuMzc3YS4zNzQuMzc0IDAgMDEuMTQ3LS4xNTEuNDMyLjQzMiAwIDAxLjIzMS0uMDY1em0tMTEuNzk0LS4wODZoLjI1MlY5LjQ5OGgtLjI1MmEuMzM0LjMzNCAwIDAxLS4yMS0uMDY1LjM4Ni4zODYgMCAwMS0uMTI2LS4xOTNsLS40Mi0xLjM3N2EuMjQ4LjI0OCAwIDAxLS4wMi0uMTcyLjg1NC44NTQgMCAwMS4wNjMtLjE3M2MuMDI4LS4wNTcuMDctLjEuMTI2LS4xMjlhLjM2NS4zNjUgMCAwMS4xNjgtLjA0M2g0LjA3Yy4wNTcgMCAuMTEzLjAxNS4xNjkuMDQzYS4yNzguMjc4IDAgMDEuMTI2LjEzLjg1NC44NTQgMCAwMS4wNjIuMTcyLjI0OC4yNDggMCAwMS0uMDIuMTcybC0uNDIgMS4zNzdhLjM4Ni4zODYgMCAwMS0uMTI2LjE5My4zMzQuMzM0IDAgMDEtLjIxLjA2NWgtLjIxdjcuMDE0aC4yMWMuMDg0IDAgLjE1NC4wMjkuMjEuMDg2YS42NzMuNjczIDAgMDEuMTI2LjE3MmwuNDIgMS4zNzhhLjI0OC4yNDggMCAwMS4wMi4xNzIuODU0Ljg1NCAwIDAxLS4wNjIuMTcyLjI3OC4yNzggMCAwMS0uMTI2LjEyOS4zNjUuMzY1IDAgMDEtLjE2OC4wNDNIMy41MjZhLjM2NS4zNjUgMCAwMS0uMTY4LS4wNDMuMjc4LjI3OCAwIDAxLS4xMjYtLjEzLjg1NC44NTQgMCAwMS0uMDYzLS4xNzEuMjQ4LjI0OCAwIDAxLjAyLS4xNzJsLjQyLTEuMzc4YS42NzMuNjczIDAgMDEuMTI2LS4xNzIuMjgxLjI4MSAwIDAxLjIxLS4wODZ6TTEuNzYzIDYuNjU4YS43MTcuNzE3IDAgMDEtLjUwNC0uMTk0LjY0NC42NDQgMCAwMS0uMjEtLjQ5NXYtLjQzYS43My43MyAwIDAxLjEwNS0uMzg3LjY4LjY4IDAgMDEuMjczLS4yNTlDNC4zMDkgMy40MDIgNi41NCAyLjI3NiA4LjEyMSAxLjUxNSA5LjcwMi43NTUgMTAuNDkzLjM2MSAxMC40OTMuMzMyYy41MzEtLjI1OC45NzItLjM2NiAxLjMyMi0uMzIzLjM1LjA0My43MzQuMTY1IDEuMTU0LjM2Nmw4LjMxIDQuNTE4Yy4xNC4wNTguMjQ1LjE0NC4zMTUuMjU5YS43My43MyAwIDAxLjEwNS4zODd2LjQzYzAgLjIwMS0uMDcuMzY2LS4yMS40OTVhLjcxNy43MTcgMCAwMS0uNTA0LjE5NEgxLjc2M3ptLS43MTQgMTMuMzRhLjU0LjU0IDAgMDEuMTY4LS4zODcuNTE2LjUxNiAwIDAxLjM3OC0uMTcyaDE5LjY0MmMuMTY4IDAgLjMwOC4wNTcuNDIuMTcyYS41NDEuNTQxIDAgMDEuMTY4LjM4N3YuODE4YS41MjIuNTIyIDAgMDEtLjE2OC40MDguNjA1LjYwNSAwIDAxLS40Mi4xNTFIMS41OTVhLjU1MS41NTEgMCAwMS0uMzc4LS4xNS41MjIuNTIyIDAgMDEtLjE2OC0uNDF2LS44MTd6bTIxLjQwNSAyLjAyMmMuMTQgMCAuMjY2LjA1OC4zNzguMTczYS41OTIuNTkyIDAgMDEuMTY4LjQzdi44MThhLjU0MS41NDEgMCAwMS0uMTY4LjM4Ny41MTYuNTE2IDAgMDEtLjM3OC4xNzJMLjU0NiAyMy45NTdhLjUxNi41MTYgMCAwMS0uMzc4LS4xNzIuNTQxLjU0MSAwIDAxLS4xNjgtLjM4N3YtLjgxOGEuNTkuNTkgMCAwMS4xNjgtLjQzLjUxNi41MTYgMCAwMS4zNzgtLjE3M2wyMS45MDguMDQzeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ21pYycsXG4gIHBhdGg6ICdNMTIgMTVjMS42NiAwIDIuOTktMS4zNCAyLjk5LTNMMTUgNmMwLTEuNjYtMS4zNC0zLTMtM1M5IDQuMzQgOSA2djZjMCAxLjY2IDEuMzQgMyAzIDN6bTUuMy0zYzAgMy0yLjU0IDUuMS01LjMgNS4xUzYuNyAxNSA2LjcgMTJINWMwIDMuNDEgMi43MiA2LjIzIDYgNi43MlYyMmgydi0zLjI4YzMuMjgtLjQ4IDYtMy4zIDYtNi43MmgtMS43eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2RpcmVjdGlvbnMnLFxuICBwYXRoOiAnTTIzLjY0OSAxMS4xNTRMMTIuODQ2LjM1YTEuMTk1IDEuMTk1IDAgMDAtMS42OTIgMEwuMzUgMTEuMTU0YTEuMTk1IDEuMTk1IDAgMDAwIDEuNjkyTDExLjE1NCAyMy42NWExLjE5NSAxLjE5NSAwIDAwMS42OTIgMEwyMy42NSAxMi44NDZjLjQ2OC0uNDU2LjQ2OC0xLjIxMiAwLTEuNjkyem0tOS4yNTQgMy44NTN2LTMuMDAxSDkuNTkzdjMuNmgtMi40di00LjhjMC0uNjYuNTQtMS4yIDEuMi0xLjJoNi4wMDJWNi42MDRsNC4yIDQuMi00LjIgNC4yMDJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnY2FsZW5kYXInLFxuICBwYXRoOiAnTTE4LjExMSAxMy4ySDEydjZoNi4xMTF2LTZ6TTE2Ljg5IDB2Mi40SDcuMTFWMEg0LjY2N3YyLjRIMy40NDRjLTEuMzU2IDAtMi40MzIgMS4wOC0yLjQzMiAyLjRMMSAyMS42QzEgMjIuOTIgMi4wODggMjQgMy40NDQgMjRoMTcuMTEyQzIxLjkgMjQgMjMgMjIuOTIgMjMgMjEuNlY0LjhjMC0xLjMyLTEuMS0yLjQtMi40NDQtMi40aC0xLjIyM1YwSDE2Ljg5em0zLjY2NyAyMS42SDMuNDQ0VjguNGgxNy4xMTJ2MTMuMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjYWxsb3V0JyxcbiAgcGF0aDogJ00yMS45OSA0YzAtMS4xLS44OS0yLTEuOTktMkg0Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDE0bDQgNC0uMDEtMTh6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnaW5mbycsXG4gIHBhdGg6ICdNMTIgOC40QTEuMiAxLjIgMCAxMDEyIDZhMS4yIDEuMiAwIDAwMCAyLjR6TTEyIDBjNi42MjQgMCAxMiA1LjM3NiAxMiAxMnMtNS4zNzYgMTItMTIgMTJTMCAxOC42MjQgMCAxMiA1LjM3NiAwIDEyIDB6bTAgMThjLjY2IDAgMS4yLS41NCAxLjItMS4yVjEyYzAtLjY2LS41NC0xLjItMS4yLTEuMi0uNjYgMC0xLjIuNTQtMS4yIDEuMnY0LjhjMCAuNjYuNTQgMS4yIDEuMiAxLjJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnYnJpZWZjYXNlJyxcbiAgcGF0aDogJ00yMCA3aC00VjVjMC0xLjExLS44OS0yLTItMmgtNGMtMS4xMSAwLTIgLjg5LTIgMnYySDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDIwYzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjljMC0xLjExLS44OS0yLTItMnptLTYgMGgtNFY1aDR2MnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdrYWJvYicsXG4gIHZpZXdCb3g6ICcwIDAgMyAxMScsXG4gIGNvbXBsZXhDb250ZW50czogYDxjaXJjbGUgY3g9XCIxLjVcIiBjeT1cIjEuNVwiIHI9XCIxLjVcIi8+PGNpcmNsZSBjeD1cIjEuNVwiIGN5PVwiNS41XCIgcj1cIjEuNVwiLz48Y2lyY2xlIGN4PVwiMS41XCIgY3k9XCI5LjVcIiByPVwiMS41XCIvPmBcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3BlcnNvbicsXG4gIHZpZXdCb3g6ICcwIDAgMTggMTgnLFxuICBwYXRoOiAnTTkgOWMyLjQ4NiAwIDQuNS0yLjAxNCA0LjUtNC41UzExLjQ4NiAwIDkgMGE0LjQ5OSA0LjQ5OSAwIDAwLTQuNSA0LjVDNC41IDYuOTg2IDYuNTE0IDkgOSA5em0wIDIuMjVjLTMuMDA0IDAtOSAxLjUwOC05IDQuNXYxLjEyNUMwIDE3LjQ5NC41MDYgMTggMS4xMjUgMThoMTUuNzVjLjYxOSAwIDEuMTI1LS41MDYgMS4xMjUtMS4xMjVWMTUuNzVjMC0yLjk5Mi01Ljk5Ni00LjUtOS00LjV6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbWFnbmlmeWluZ19nbGFzcycsXG4gIHBhdGg6ICdNMTYuMTI0IDEzLjA1MWE1LjE1NCA1LjE1NCAwIDExMC0xMC4zMDggNS4xNTQgNS4xNTQgMCAwMTAgMTAuMzA4TTE2LjExNCAwYTcuODg2IDcuODg2IDAgMDAtNi40NiAxMi40MDdMMCAyMi4wNiAxLjk0IDI0bDkuNjUzLTkuNjUzQTcuODg2IDcuODg2IDAgMTAxNi4xMTMgMCdcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ29mZmljZScsXG4gIHBhdGg6ICdNMTIgN1YzSDJ2MThoMjBWN0gxMnpNNiAxOUg0di0yaDJ2MnptMC00SDR2LTJoMnYyem0wLTRINFY5aDJ2MnptMC00SDRWNWgydjJ6bTQgMTJIOHYtMmgydjJ6bTAtNEg4di0yaDJ2MnptMC00SDhWOWgydjJ6bTAtNEg4VjVoMnYyem0xMCAxMmgtOHYtMmgydi0yaC0ydi0yaDJ2LTJoLTJWOWg4djEwem0tMi04aC0ydjJoMnYtMnptMCA0aC0ydjJoMnYtMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdsaW5rJyxcbiAgcGF0aDogJ00yLjI4IDEyQTMuNzIzIDMuNzIzIDAgMDE2IDguMjhoNC44VjZINmMtMy4zMTIgMC02IDIuNjg4LTYgNnMyLjY4OCA2IDYgNmg0Ljh2LTIuMjhINkEzLjcyMyAzLjcyMyAwIDAxMi4yOCAxMnptNC45MiAxLjJoOS42di0yLjRINy4ydjIuNHpNMTggNmgtNC44djIuMjhIMThBMy43MjMgMy43MjMgMCAwMTIxLjcyIDEyIDMuNzIzIDMuNzIzIDAgMDExOCAxNS43MmgtNC44VjE4SDE4YzMuMzEyIDAgNi0yLjY4OCA2LTZzLTIuNjg4LTYtNi02eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3dpbmRvdycsXG4gIHBhdGg6ICdNMyAxM2g4VjNIM3YxMHptMCA4aDh2LTZIM3Y2em0xMCAwaDhWMTFoLTh2MTB6bTAtMTh2Nmg4VjNoLTh6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncGhvbmUnLFxuICBwYXRoOiAnTTQuODI3IDEwLjM4N2EyMC4xOTggMjAuMTk4IDAgMDA4Ljc4NiA4Ljc4NmwyLjkzNC0yLjkzM2MuMzYtLjM2Ljg5My0uNDggMS4zNi0uMzJhMTUuMjEgMTUuMjEgMCAwMDQuNzYuNzZjLjczMyAwIDEuMzMzLjYgMS4zMzMgMS4zMzN2NC42NTRDMjQgMjMuNCAyMy40IDI0IDIyLjY2NyAyNCAxMC4xNDcgMjQgMCAxMy44NTMgMCAxLjMzMyAwIC42LjYgMCAxLjMzMyAwSDZjLjczMyAwIDEuMzMzLjYgMS4zMzMgMS4zMzMgMCAxLjY2Ny4yNjcgMy4yNjcuNzYgNC43Ni4xNDcuNDY3LjA0Ljk4Ny0uMzMzIDEuMzZsLTIuOTMzIDIuOTM0eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3RhZycsXG4gIHZpZXdCb3g6ICcwIDAgMTggMTgnLFxuICBwYXRoOiAnTTE3LjQ2OSA4LjYyMmwtOC4xLTguMUExLjc4OSAxLjc4OSAwIDAwOC4xIDBIMS44Qy44MSAwIDAgLjgxIDAgMS44djYuM2MwIC40OTUuMTk4Ljk0NS41MzEgMS4yNzhsOC4xIDguMWMuMzI0LjMyNC43NzQuNTIyIDEuMjY5LjUyMmExLjc2IDEuNzYgMCAwMDEuMjY5LS41MzFsNi4zLTYuM0ExLjc2IDEuNzYgMCAwMDE4IDkuOWMwLS40OTUtLjIwNy0uOTU0LS41MzEtMS4yNzh6TTMuMTUgNC41Yy0uNzQ3IDAtMS4zNS0uNjAzLTEuMzUtMS4zNSAwLS43NDcuNjAzLTEuMzUgMS4zNS0xLjM1Ljc0NyAwIDEuMzUuNjAzIDEuMzUgMS4zNSAwIC43NDctLjYwMyAxLjM1LTEuMzUgMS4zNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdkb2N1bWVudCcsXG4gIHBhdGg6ICdNNCA2SDJ2MTRjMCAxLjEuOSAyIDIgMmgxNHYtMkg0VjZ6bTE2LTRIOGMtMS4xIDAtMiAuOS0yIDJ2MTJjMCAxLjEuOSAyIDIgMmgxMmMxLjEgMCAyLS45IDItMlY0YzAtMS4xLS45LTItMi0yem0tMSA5SDlWOWgxMHYyem0tNCA0SDl2LTJoNnYyem00LThIOVY1aDEwdjJ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnY2hldnJvbicsXG4gIHZpZXdCb3g6ICcwIDAgNyA5JyxcbiAgY29tcGxleENvbnRlbnRzOiBgPGcgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMSAtOClcIj48cGF0aCBkPVwibTIuNjQxNzAwNCA4LTEuMTQxNzAwNCAxLjA1NzUgMy43MDg1MDIwMiAzLjQ0MjUtMy43MDg1MDIwMiAzLjQ0MjUgMS4xNDE3MDA0IDEuMDU3NSA0Ljg1ODI5OTYtNC41elwiLz48L2c+YFxufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnc3VwcG9ydCcsXG4gIHBhdGg6ICdNMTIsMCBDNS4zNzYsMCAwLDUuMzc2IDAsMTIgQzAsMTguNjI0IDUuMzc2LDI0IDEyLDI0IEMxOC42MjQsMjQgMjQsMTguNjI0IDI0LDEyIEMyNCw1LjM3NiAxOC42MjQsMCAxMiwwIFogTTEzLDE5IEwxMSwxOSBMMTEsMTcgTDEzLDE3IEwxMywxOSBaIE0xNS4wNywxMS4yNSBMMTQuMTcsMTIuMTcgQzEzLjQ1LDEyLjkgMTMsMTMuNSAxMywxNSBMMTEsMTUgTDExLDE0LjUgQzExLDEzLjQgMTEuNDUsMTIuNCAxMi4xNywxMS42NyBMMTMuNDEsMTAuNDEgQzEzLjc4LDEwLjA1IDE0LDkuNTUgMTQsOSBDMTQsNy45IDEzLjEsNyAxMiw3IEMxMC45LDcgMTAsNy45IDEwLDkgTDgsOSBDOCw2Ljc5IDkuNzksNSAxMiw1IEMxNC4yMSw1IDE2LDYuNzkgMTYsOSBDMTYsOS44OCAxNS42NCwxMC42OCAxNS4wNywxMS4yNSBaJ1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAneWV4dCcsXG4gIHZpZXdCb3g6ICcwIDAgMzAgMzAnLFxuICBwYXRoOiAnTTI1LjUxNyAyOC4xNDJ2LjA5NWgtLjIwNHYuOTA1aC0uMDY2di0uOTA1aC0uMTk3di0uMDk1aC40Njd6bS42NjcgMGguMDY2djFoLS4wNjZ2LS44MjVsLS4yNC41OTVoLS4wMTNsLS4yNC0uNTk1di44MjVoLS4wNjZ2LTFoLjA2NmwuMjQ3LjYxLjI0Ni0uNjF6TTE1IDI4LjhjNy42MjIgMCAxMy44LTYuMTc4IDEzLjgtMTMuOCAwLTcuNjIyLTYuMTc4LTEzLjgtMTMuOC0xMy44QzcuMzc4IDEuMiAxLjIgNy4zNzggMS4yIDE1YzAgNy42MjIgNi4xNzggMTMuOCAxMy44IDEzLjh6TTE1IDBjOC4yODQgMCAxNSA2LjcxNiAxNSAxNSAwIDguMjg0LTYuNzE2IDE1LTE1IDE1LTguMjg0IDAtMTUtNi43MTYtMTUtMTVDMCA2LjcxNiA2LjcxNiAwIDE1IDB6bS40NSAxNi42NXYtMS4yaDYuNnYxLjJoLTIuN3Y1LjRoLTEuMnYtNS40aC0yLjd6bS0xLjU5OS0xLjM1bC44NDkuODQ5LTIuNjAxIDIuNjAxIDIuNjAxIDIuNjAxLS44NDkuODQ5LTIuNjAxLTIuNjAxTDguNjQ5IDIyLjJsLS44NDktLjg0OSAyLjYwMS0yLjYwMUw3LjggMTYuMTQ5bC44NDktLjg0OSAyLjYwMSAyLjYwMSAyLjYwMS0yLjYwMXpNMTguNjc1IDlhMi4xNzUgMi4xNzUgMCAwMC0xLjg0NyAzLjMyM2wyLjk5NS0yLjk5NUEyLjE2MyAyLjE2MyAwIDAwMTguNjc1IDl6bTAgNS41NWEzLjM3NSAzLjM3NSAwIDExMi44MzMtNS4yMDlsLTMuNzg5IDMuNzg4YTIuMTc1IDIuMTc1IDAgMDAzLjEzLTEuOTU0aDEuMjAxYTMuMzc1IDMuMzc1IDAgMDEtMy4zNzUgMy4zNzV6bS03LjQyNS0zLjczNEwxMy43OCA3LjhsLjkyLjc3MS0yLjg1IDMuMzk3djIuNTgyaC0xLjJ2LTIuNTgyTDcuOCA4LjU3bC45Mi0uNzcxIDIuNTMgMy4wMTZ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncGluJyxcbiAgdmlld0JveDogJzAgMCAxMyAxOCcsXG4gIHBhdGg6ICdtOS4zNzUgMGMtMy41MjQ0NjQyOSAwLTYuMzc1IDIuODE3LTYuMzc1IDYuMyAwIDQuNzI1IDYuMzc1IDExLjcgNi4zNzUgMTEuN3M2LjM3NS02Ljk3NSA2LjM3NS0xMS43YzAtMy40ODMtMi44NTA1MzU3LTYuMy02LjM3NS02LjN6bS4wMDAwMDAxOCA4LjU1MDAwMDA3Yy0xLjI1Njc4NTc2IDAtMi4yNzY3ODU3OS0xLjAwOC0yLjI3Njc4NTc5LTIuMjVzMS4wMjAwMDAwMy0yLjI1IDIuMjc2Nzg1NzktMi4yNWMxLjI1Njc4NTcyIDAgMi4yNzY3ODU4MiAxLjAwOCAyLjI3Njc4NTgyIDIuMjVzLTEuMDIwMDAwMSAyLjI1LTIuMjc2Nzg1ODIgMi4yNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdnZWFyJyxcbiAgcGF0aDogJ00xMiAxMGMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTctN0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGEyIDIgMCAwMDItMlY1YTIgMiAwIDAwLTItMnptLTEuNzUgOWMwIC4yMy0uMDIuNDYtLjA1LjY4bDEuNDggMS4xNmMuMTMuMTEuMTcuMy4wOC40NWwtMS40IDIuNDJjLS4wOS4xNS0uMjcuMjEtLjQzLjE1bC0xLjc0LS43Yy0uMzYuMjgtLjc2LjUxLTEuMTguNjlsLS4yNiAxLjg1Yy0uMDMuMTctLjE4LjMtLjM1LjNoLTIuOGMtLjE3IDAtLjMyLS4xMy0uMzUtLjI5bC0uMjYtMS44NWMtLjQzLS4xOC0uODItLjQxLTEuMTgtLjY5bC0xLjc0LjdjLS4xNi4wNi0uMzQgMC0uNDMtLjE1bC0xLjQtMi40MmEuMzUzLjM1MyAwIDAxLjA4LS40NWwxLjQ4LTEuMTZjLS4wMy0uMjMtLjA1LS40Ni0uMDUtLjY5IDAtLjIzLjAyLS40Ni4wNS0uNjhsLTEuNDgtMS4xNmEuMzUzLjM1MyAwIDAxLS4wOC0uNDVsMS40LTIuNDJjLjA5LS4xNS4yNy0uMjEuNDMtLjE1bDEuNzQuN2MuMzYtLjI4Ljc2LS41MSAxLjE4LS42OWwuMjYtMS44NWMuMDMtLjE3LjE4LS4zLjM1LS4zaDIuOGMuMTcgMCAuMzIuMTMuMzUuMjlsLjI2IDEuODVjLjQzLjE4LjgyLjQxIDEuMTguNjlsMS43NC0uN2MuMTYtLjA2LjM0IDAgLjQzLjE1bDEuNCAyLjQyYy4wOS4xNS4wNS4zNC0uMDguNDVsLTEuNDggMS4xNmMuMDMuMjMuMDUuNDYuMDUuNjl6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbGlnaHRfYnVsYicsXG4gIHZpZXdCb3g6ICcwIDAgMzIgMzUnLFxuICBwYXRoOiAnTTExLjU4NSAzMS4wNTZsOC4zOC0uNDkzdi0uOTg2bC04LjM4LjQ5M3pNMTEuNTg1IDMzLjAyOEwxNS43NzUgMzVsNC4xOS0xLjk3MlYzMS41NWwtOC4zOC40OTN2Ljk4NnptNi45MjYtLjQwN2wtMi43MzYgMS4yOS0yLjEzLTEuMDA0IDQuODY2LS4yODZ6TTE1Ljc3NSA3LjM5NGMtNC42MyAwLTguMzggMy4yMDUtOC4zOCA4LjM4IDAgNS4xNzcgNC4xOSA2LjkwMiA0LjE5IDEyLjgxOHYuNDkzbDguMzgtLjQ5M2MwLTUuOTE2IDQuMTktOC4xODggNC4xOS0xMi44MTdhOC4zOCA4LjM4IDAgMDAtOC4zOC04LjM4em01LjYxNyAxMy40OGMtMS4wMjUgMS44MzctMi4xNzQgMy44OTItMi4zODEgNi43ODZsLTYuNDQuMzhjLS4xMjktMy4wMS0xLjI5LTUuMDIxLTIuMzItNi44MDgtLjQ5My0uOC0uOTI4LTEuNjM2LTEuMjk5LTIuNWgxMy41NTZjLS4zMjUuNzA4LS43MDQgMS40MDMtMS4xMTYgMi4xNDJ6bTEuNDc5LTMuMTI4SDguNjI3YTcuNzkzIDcuNzkzIDAgMDEtLjI0Ny0xLjk3MWMwLTQuMzUzIDMuMDQyLTcuMzk1IDcuMzk1LTcuMzk1YTcuMzk0IDcuMzk0IDAgMDE3LjM5NCA3LjM5NSA2LjczOSA2LjczOSAwIDAxLS4zIDEuOTcxaC4wMDJ6TTI2LjYyIDE1LjI4Mmg0LjkzdjFoLTQuOTN6TTIzLjA5NCA3Ljc1NmwyLjA5MS0yLjA5MS42OTguNjk3LTIuMDkyIDIuMDkyek0xNS4yODIgMGgxdjQuOTNoLTF6TTUuNjY2IDYuMzYybC42OTctLjY5NyAyLjA5MSAyLjA5MS0uNjk3LjY5N3pNMCAxNS4yODJoNC45M3YxSDB6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncmVjZWlwdCcsXG4gIHZpZXdCb3g6ICcwIDAgMTggMTgnLFxuICBwYXRoOiAnTTguOTkxIDBDNC4wMjMgMCAwIDQuMDMyIDAgOXM0LjAyMyA5IDguOTkxIDlDMTMuOTY4IDE4IDE4IDEzLjk2OCAxOCA5cy00LjAzMi05LTkuMDA5LTl6bTMuODE2IDE0LjRMOSAxMi4xMDUgNS4xOTMgMTQuNGwxLjAwOC00LjMyOS0zLjM1Ny0yLjkwNyA0LjQyOC0uMzc4TDkgMi43bDEuNzI4IDQuMDc3IDQuNDI4LjM3OC0zLjM1NyAyLjkwN3onXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjbG9zZScsXG4gIGNvbXBsZXhDb250ZW50czogYFxuICAgIDxwYXRoIGQ9XCJNNyA4bDkuNzE2IDkuNzE2bTAtOS43MTZMNyAxNy43MTZcIiBcbiAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBcbiAgICAgICAgICBzdHJva2Utd2lkdGg9XCIyXCIvPlxuICBgXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdlbGVtZW50cycsXG4gIHBhdGg6ICdNMTMsMTUgTDEzLDE3IEwyMSwxNyBMMjEsMTkgTDEzLDE5IEwxMywyMSBMMTEsMjEgTDExLDE1IEwxMywxNSBaIE05LDE3IEw5LDE5IEwzLDE5IEwzLDE3IEw5LDE3IFogTTksMTUgTDcsMTUgTDcsMTMgTDMsMTMgTDMsMTEgTDcsMTEgTDcsOSBMOSw5IEw5LDE1IFogTTIxLDExIEwyMSwxMyBMMTEsMTMgTDExLDExIEwyMSwxMSBaIE0xNywzIEwxNyw1IEwyMSw1IEwyMSw3IEwxNyw3IEwxNyw5IEwxNSw5IEwxNSwzIEwxNywzIFogTTEzLDUgTDEzLDcgTDMsNyBMMyw1IEwxMyw1IFonXG59KTtcbiIsImltcG9ydCB0aHVtYkljb24gZnJvbSAnLi90aHVtYi5qcyc7XG5pbXBvcnQgcmVjZWlwdEljb24gZnJvbSAnLi9yZWNlaXB0LmpzJztcbmltcG9ydCBwYW50aGVvbkljb24gZnJvbSAnLi9wYW50aGVvbi5qcyc7XG5pbXBvcnQgbWljSWNvbiBmcm9tICcuL21pYy5qcyc7XG5pbXBvcnQgZGlyZWN0aW9uc0ljb24gZnJvbSAnLi9kaXJlY3Rpb25zLmpzJztcbmltcG9ydCBjYWxlbmRhckljb24gZnJvbSAnLi9jYWxlbmRhci5qcyc7XG5pbXBvcnQgY2FsbG91dEljb24gZnJvbSAnLi9jYWxsb3V0LmpzJztcbmltcG9ydCBpbmZvSWNvbiBmcm9tICcuL2luZm8uanMnO1xuaW1wb3J0IGJyaWVmY2FzZUljb24gZnJvbSAnLi9icmllZmNhc2UuanMnO1xuaW1wb3J0IGthYm9iSWNvbiBmcm9tICcuL2thYm9iLmpzJztcbmltcG9ydCBwZXJzb25JY29uIGZyb20gJy4vcGVyc29uLmpzJztcbmltcG9ydCBtYWduaWZ5aW5nR2xhc3NJY29uIGZyb20gJy4vbWFnbmlmeWluZ19nbGFzcy5qcyc7XG5pbXBvcnQgb2ZmaWNlSWNvbiBmcm9tICcuL29mZmljZS5qcyc7XG5pbXBvcnQgbGlua0ljb24gZnJvbSAnLi9saW5rLmpzJztcbmltcG9ydCB3aW5kb3dJY29uIGZyb20gJy4vd2luZG93LmpzJztcbmltcG9ydCBwaG9uZUljb24gZnJvbSAnLi9waG9uZS5qcyc7XG5pbXBvcnQgdGFnSWNvbiBmcm9tICcuL3RhZy5qcyc7XG5pbXBvcnQgZG9jdW1lbnRJY29uIGZyb20gJy4vZG9jdW1lbnQuanMnO1xuaW1wb3J0IGNoZXZyb25JY29uIGZyb20gJy4vY2hldnJvbi5qcyc7XG5pbXBvcnQgc3VwcG9ydEljb24gZnJvbSAnLi9zdXBwb3J0LmpzJztcbmltcG9ydCB5ZXh0SWNvbiBmcm9tICcuL3lleHQuanMnO1xuaW1wb3J0IHBpbkljb24gZnJvbSAnLi9waW4uanMnO1xuaW1wb3J0IGdlYXJJY29uIGZyb20gJy4vZ2Vhci5qcyc7XG5pbXBvcnQgbGlnaHRCdWxiSWNvbiBmcm9tICcuL2xpZ2h0X2J1bGIuanMnO1xuaW1wb3J0IHN0YXJJY29uIGZyb20gJy4vc3Rhci5qcyc7XG5pbXBvcnQgY2xvc2UgZnJvbSAnLi9jbG9zZS5qcyc7XG5pbXBvcnQgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cyc7XG5cbmNvbnN0IGljb25zQXJyYXkgPSBbXG4gIHRodW1iSWNvbixcbiAgcmVjZWlwdEljb24sXG4gIHBhbnRoZW9uSWNvbixcbiAgbWljSWNvbixcbiAgZGlyZWN0aW9uc0ljb24sXG4gIGNhbGVuZGFySWNvbixcbiAgY2FsbG91dEljb24sXG4gIGluZm9JY29uLFxuICBicmllZmNhc2VJY29uLFxuICBrYWJvYkljb24sXG4gIHBlcnNvbkljb24sXG4gIG1hZ25pZnlpbmdHbGFzc0ljb24sXG4gIG9mZmljZUljb24sXG4gIGxpbmtJY29uLFxuICB3aW5kb3dJY29uLFxuICBwaG9uZUljb24sXG4gIHRhZ0ljb24sXG4gIGRvY3VtZW50SWNvbixcbiAgY2hldnJvbkljb24sXG4gIHN1cHBvcnRJY29uLFxuICB5ZXh0SWNvbixcbiAgcGluSWNvbixcbiAgZ2Vhckljb24sXG4gIGxpZ2h0QnVsYkljb24sXG4gIGVsZW1lbnRzLFxuICBjbG9zZVxuXTtcblxuY29uc3QgSWNvbnMgPSB7fTtcblxuaWNvbnNBcnJheS5mb3JFYWNoKGljb24gPT4ge1xuICBJY29uc1tpY29uLm5hbWVdID0gaWNvbi5tYXJrdXAoKTtcbn0pO1xuXG5JY29ucy5kZWZhdWx0ID0gc3Rhckljb24ubWFya3VwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25zO1xuIiwiLyoqIEBtb2R1bGUgSWNvbkNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgSWNvbnMgZnJvbSAnLi4vLi4vaWNvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEljb25Db21wb25lbnRcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHBhcmFtIG9wdHMuaWNvbk5hbWUge3N0cmluZ31cbiAgICogQHBhcmFtIG9wdHMuY3VzdG9tSWNvbiB7c3RyaW5nfVxuICAgKiBAcGFyYW0gb3B0cy5pY29uVXJsIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcblxuICAgIC8qKlxuICAgICAqIG5hbWUgb2YgYW4gaWNvbiBmcm9tIHRoZSBkZWZhdWx0IGljb24gc2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmljb25OYW1lID0gb3B0cy5pY29uTmFtZSB8fCAnZGVmYXVsdCc7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgbWFya3VwIGZvciBhIGZ1bGx5IGN1c3RvbSBpY29uXG4gICAgICogQHR5cGUgeyp8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmN1c3RvbUljb24gPSBvcHRzLmN1c3RvbUljb24gfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiB0aGUgdXJsIHRvIGEgY3VzdG9tIGltYWdlIGljb25cbiAgICAgKiBAdHlwZSB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmljb25VcmwgPSBvcHRzLmljb25VcmwgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXR0ZXIgZm9yIHRoZSBpbWFnZSBwYXN0ZWQgdG8gaGFuZGxlYmFyc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGltYWdlICgpIHtcbiAgICBpZiAodGhpcy5jdXN0b21JY29uKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXN0b21JY29uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmljb25VcmwpIHtcbiAgICAgIHJldHVybiBgPGltZyBzcmM9XCIke3RoaXMuaWNvblVybH1cIiBhbHQ9XCJcIiBjbGFzcz1cIkljb24taW1hZ2VcIj5gO1xuICAgIH1cblxuICAgIGlmIChJY29uc1t0aGlzLmljb25OYW1lXSkge1xuICAgICAgcmV0dXJuIEljb25zW3RoaXMuaWNvbk5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gSWNvbnMuZGVmYXVsdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdJY29uQ29tcG9uZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAnaWNvbnMvaWNvbic7XG4gIH1cblxuICAvKipcbiAgICogYWxsb3dpbmcgZHVwbGljYXRlc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvdmVycmlkZXMgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IHRvIHByb3ZpZGUgbmFtZSBhbmQgbWFya3VwXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtJY29uQ29tcG9uZW50fVxuICAgKi9cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBpbWFnZTogdGhpcy5pbWFnZSxcbiAgICAgIG5hbWU6IHRoaXMuaWNvbk5hbWUgPyB0aGlzLmljb25OYW1lIDogJ2N1c3RvbSdcbiAgICB9KSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5pbXBvcnQgTmF2aWdhdGlvbkNvbXBvbmVudCBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBTZWFyY2hDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvc2VhcmNoY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXJTZWFyY2hDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvZmlsdGVyc2VhcmNoY29tcG9uZW50JztcbmltcG9ydCBBdXRvQ29tcGxldGVDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvYXV0b2NvbXBsZXRlY29tcG9uZW50JztcbmltcG9ydCBTcGVsbENoZWNrQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL3NwZWxsY2hlY2tjb21wb25lbnQnO1xuaW1wb3J0IExvY2F0aW9uQmlhc0NvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9sb2NhdGlvbmJpYXNjb21wb25lbnQnO1xuXG5pbXBvcnQgRmlsdGVyQm94Q29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9maWx0ZXJib3hjb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlck9wdGlvbnNDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2ZpbHRlcm9wdGlvbnNjb21wb25lbnQnO1xuaW1wb3J0IFJhbmdlRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9yYW5nZWZpbHRlcmNvbXBvbmVudCc7XG5pbXBvcnQgRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9kYXRlcmFuZ2VmaWx0ZXJjb21wb25lbnQnO1xuaW1wb3J0IEZhY2V0c0NvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZmFjZXRzY29tcG9uZW50JztcbmltcG9ydCBHZW9Mb2NhdGlvbkNvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZ2VvbG9jYXRpb25jb21wb25lbnQnO1xuaW1wb3J0IFNvcnRPcHRpb25zQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9zb3J0b3B0aW9uc2NvbXBvbmVudCc7XG5cbmltcG9ydCBEaXJlY3RBbnN3ZXJDb21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL2RpcmVjdGFuc3dlcmNvbXBvbmVudCc7XG5pbXBvcnQgUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvcmVzdWx0c2NvbXBvbmVudCc7XG5pbXBvcnQgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvYWNjb3JkaW9ucmVzdWx0c2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvdW5pdmVyc2FscmVzdWx0c2NvbXBvbmVudCc7XG5pbXBvcnQgUGFnaW5hdGlvbkNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvcGFnaW5hdGlvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IExvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL2xvY2F0aW9ucmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL2V2ZW50cmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5pbXBvcnQgUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzL3Blb3BsZXJlc3VsdHNpdGVtY29tcG9uZW50JztcblxuaW1wb3J0IE1hcENvbXBvbmVudCBmcm9tICcuL21hcC9tYXBjb21wb25lbnQnO1xuaW1wb3J0IFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCBmcm9tICcuL3F1ZXN0aW9ucy9xdWVzdGlvbnN1Ym1pc3Npb25jb21wb25lbnQnO1xuXG5pbXBvcnQgSWNvbkNvbXBvbmVudCBmcm9tICcuL2ljb25zL2ljb25jb21wb25lbnQuanMnO1xuXG5jb25zdCBDT01QT05FTlRfQ0xBU1NfTElTVCA9IFtcbiAgLy8gQ29yZSBDb21wb25lbnRcbiAgQ29tcG9uZW50LFxuXG4gIC8vIE5hdmlnYXRpb24gQ29tcG9uZW50c1xuICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuXG4gIC8vIFNlYXJjaCBDb21wb25lbnRzXG4gIFNlYXJjaENvbXBvbmVudCxcbiAgRmlsdGVyU2VhcmNoQ29tcG9uZW50LFxuICBBdXRvQ29tcGxldGVDb21wb25lbnQsXG4gIFNwZWxsQ2hlY2tDb21wb25lbnQsXG4gIExvY2F0aW9uQmlhc0NvbXBvbmVudCxcblxuICAvLyBGaWx0ZXIgQ29tcG9uZW50c1xuICBGaWx0ZXJCb3hDb21wb25lbnQsXG4gIEZpbHRlck9wdGlvbnNDb21wb25lbnQsXG4gIFJhbmdlRmlsdGVyQ29tcG9uZW50LFxuICBEYXRlUmFuZ2VGaWx0ZXJDb21wb25lbnQsXG4gIEZhY2V0c0NvbXBvbmVudCxcbiAgR2VvTG9jYXRpb25Db21wb25lbnQsXG4gIFNvcnRPcHRpb25zQ29tcG9uZW50LFxuXG4gIC8vIFJlc3VsdHMgQ29tcG9uZW50c1xuICBEaXJlY3RBbnN3ZXJDb21wb25lbnQsXG4gIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnQsXG4gIFJlc3VsdHNDb21wb25lbnQsXG4gIFBhZ2luYXRpb25Db21wb25lbnQsXG4gIFJlc3VsdHNJdGVtQ29tcG9uZW50LFxuICBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50LFxuICBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50LFxuICBFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50LFxuICBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCxcbiAgTWFwQ29tcG9uZW50LFxuXG4gIC8vIFF1ZXN0aW9ucyBDb21wb25lbnRzXG4gIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCxcblxuICAvLyBIZWxwZXIgQ29tcG9uZW50c1xuICBJY29uQ29tcG9uZW50XG5dO1xuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgcmVnaXN0cnkgaXMgYSBtYXAgdGhhdCBjb250YWluc1xuICogYWxsIGF2YWlsYWJsZSBjb21wb25lbnQgY2xhc3NlcyB1c2VkIGZvciBjcmVhdGlvbiBvciBleHRlbnNpb24uXG4gKiBFYWNoIGNvbXBvbmVudCBjbGFzcyBoYXMgYSB1bmlxdWUgdHlwZSwgd2hpY2ggaXMgdXNlZCBhcyB0aGUga2V5IGZvciB0aGUgcmVnaXN0cnlcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ29tcG9uZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IENPTVBPTkVOVF9SRUdJU1RSWSA9IENPTVBPTkVOVF9DTEFTU19MSVNULnJlZHVjZSgocmVnaXN0cnksIGNsYXp6KSA9PiB7XG4gIHJlZ2lzdHJ5W2NsYXp6LnR5cGVdID0gY2xheno7XG4gIHJldHVybiByZWdpc3RyeTtcbn0sIHt9KTtcbiIsIi8qKiBAbW9kdWxlIENvbXBvbmVudE1hbmFnZXIgKi9cblxuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBET00gZnJvbSAnLi4vZG9tL2RvbSc7XG5pbXBvcnQgeyBDT01QT05FTlRfUkVHSVNUUlkgfSBmcm9tICcuL3JlZ2lzdHJ5JztcblxuLyoqXG4gKiBDb21wb25lbnRNYW5hZ2VyIGlzIGEgU2luZ2xldG9uZSB0aGF0IGNvbnRhaW5zIGJvdGggYW4gaW50ZXJuYWwgcmVnaXN0cnkgb2ZcbiAqIGVsaWdpYmxlIGNvbXBvbmVudHMgdG8gYmUgY3JlYXRlZCwgYXMgd2VsbCBhcyBrZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudFxuICogaW5zdGFudGlhdGVkIGFuZCBhY3RpdmUgY29tcG9uZW50cy5cbiAqXG4gKiBBTEwgY29tcG9uZW50cyBzaG91bGQgYmUgY29uc3RydWN0ZWQgdXNpbmcgdGhlIHtDb21wb25lbnRNYW5hZ2VyfSB2aWEgaXRzIGBjcmVhdGVgIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYWN0aXZlIGNvbXBvbmVudHMgaXMgYW4gaW50ZXJuYWwgY29udGFpbmVyIHRvIGtlZXAgdHJhY2tcbiAgICAgKiBvZiBhbGwgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY29yZSBsaWJyYXJ5IGRlcGVuZGVuY3lcbiAgICAgKlxuICAgICAqIFRoZSBDb3JlIGNvbnRhaW5zIGJvdGggdGhlIHN0b3JhZ2UgQU5EIHNlcnZpY2VzIHRoYXQgYXJlIG5lZWRlZCBmb3IgcGVyZm9ybWluZyBvcGVyYXRpb25zXG4gICAgICogbGlrZSBzZWFyY2ggYW5kIGF1dG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBUaGUgc3RvcmFnZSBpcyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgc3RhdGUgb2YgQUxMIGNvbXBvbmVudHMuXG4gICAgICogV2hlbmV2ZXIgdGhlIHN0b3JhZ2UgaXMgdXBkYXRlZCwgdGhlIHN0YXRlIGdldHMgcHVzaGVkIGRvd24gdG8gdGhlIG5lY2Vzc2FyeSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtDb3JlfVxuICAgICAqL1xuICAgIHRoaXMuX2NvcmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgcmVuZGVyZXIgdG8gdXNlIGZvciBhbGwgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtIYW5kbGViYXJzUmVuZGVyZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGFuYWx5dGljcyByZXBvcnRlciBkZXBlbmRlbmN5XG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXIgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlICgpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50TWFuYWdlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgc2V0UmVuZGVyZXIgKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvcmUgKGNvcmUpIHtcbiAgICB0aGlzLl9jb3JlID0gY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEFuYWx5dGljc1JlcG9ydGVyIChyZXBvcnRlcikge1xuICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyID0gcmVwb3J0ZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogcmVnaXN0ZXJzIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBjcmVhdGlvbiBhbmQgb3ZlcnJpZGUuXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBUaGUgQ29tcG9uZW50IENsYXNzIHRvIHJlZ2lzdGVyXG4gICAqL1xuICByZWdpc3RlciAoY29tcG9uZW50Q2xhenopIHtcbiAgICBDT01QT05FTlRfUkVHSVNUUllbY29tcG9uZW50Q2xhenoudHlwZV0gPSBjb21wb25lbnRDbGF6ejtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBjb25zdHJ1Y3RpbmcgYW55IGFuZCBhbGwgY29tcG9uZW50cy5cbiAgICogSXQgd2lsbCBpbnN0YW50aWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50LCBhbmQgYm90aCBhcHBseVxuICAgKiBpbml0aWFsIHN0YXRlIGZyb20gdGhlIHN0b3JhZ2UgYW5kIGJpbmQgaXQgdG8gdGhlIHN0b3JhZ2UgZm9yIHVwZGF0ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRUeXBlIFRoZSBjb21wb25lbnQgdHlwZSB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGlwZSB0byB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIGNyZWF0ZSAoY29tcG9uZW50VHlwZSwgb3B0cykge1xuICAgIC8vIEV2ZXJ5IGNvbXBvbmVudCBuZWVkcyBsb2NhbCBhY2Nlc3MgdG8gdGhlIGNvbXBvbmVudCBtYW5hZ2VyXG4gICAgLy8gYmVjYXVzZSBzb21ldGltZXMgY29tcG9uZW50cyBoYXZlIHN1YmNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGJlXG4gICAgLy8gY29uc3RydWN0ZWQgZHVyaW5nIGNyZWF0aW9uXG4gICAgbGV0IHN5c3RlbU9wdHMgPSB7XG4gICAgICBjb3JlOiB0aGlzLl9jb3JlLFxuICAgICAgcmVuZGVyZXI6IHRoaXMuX3JlbmRlcmVyLFxuICAgICAgYW5hbHl0aWNzUmVwb3J0ZXI6IHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyLFxuICAgICAgY29tcG9uZW50TWFuYWdlcjogdGhpc1xuICAgIH07XG5cbiAgICBsZXQgY29tcG9uZW50Q2xhc3MgPSBDT01QT05FTlRfUkVHSVNUUllbY29tcG9uZW50VHlwZV07XG5cbiAgICBpZiAoXG4gICAgICAhY29tcG9uZW50Q2xhc3MuYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkKCkgJiZcbiAgICAgIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuc29tZShjID0+IGMubmFtZSA9PT0gb3B0cy5uYW1lKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgYEFub3RoZXIgY29tcG9uZW50IHdpdGggbmFtZSAke29wdHMubmFtZX0gYWxyZWFkeSBleGlzdHNgLFxuICAgICAgICBjb21wb25lbnRUeXBlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBpc1R3aW46IHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuc29tZShjb21wb25lbnQgPT4gY29tcG9uZW50LmNvbnN0cnVjdG9yLnR5cGUgPT09IGNvbXBvbmVudFR5cGUpLFxuICAgICAgLi4ub3B0c1xuICAgIH07XG5cbiAgICAvLyBJbnN0YW50aWF0ZSBvdXIgbmV3IGNvbXBvbmVudCBhbmQga2VlcCB0cmFjayBvZiBpdFxuICAgIGxldCBjb21wb25lbnQgPVxuICAgICAgbmV3IENPTVBPTkVOVF9SRUdJU1RSWVtjb21wb25lbnRUeXBlXShjb25maWcsIHN5c3RlbU9wdHMpXG4gICAgICAgIC5pbml0KGNvbmZpZyk7XG5cbiAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgZ2xvYmFsIHN0b3JhZ2UgdG8gcG93ZXIgc3RhdGUsIGFwcGx5IHRoZSBzdGF0ZVxuICAgIC8vIGZyb20gdGhlIHN0b3JhZ2UgdG8gdGhlIGNvbXBvbmVudCwgYW5kIHRoZW4gYmluZCB0aGUgY29tcG9uZW50XG4gICAgLy8gc3RhdGUgdG8gdGhlIHN0b3JhZ2UgdmlhIGl0cyB1cGRhdGVzXG4gICAgaWYgKHRoaXMuX2NvcmUgJiYgdGhpcy5fY29yZS5nbG9iYWxTdG9yYWdlICE9PSBudWxsKSB7XG4gICAgICBpZiAoY29tcG9uZW50Lm1vZHVsZUlkID09PSB1bmRlZmluZWQgfHwgY29tcG9uZW50Lm1vZHVsZUlkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvcmUuZ2xvYmFsU3RvcmFnZVxuICAgICAgICAub24oJ3VwZGF0ZScsIGNvbXBvbmVudC5tb2R1bGVJZCwgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb21wb25lbnQuc2V0U3RhdGUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBwcm92aWRlZCBjb21wb25lbnQgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgY29tcG9uZW50cyBhbmQgcmVtb3ZlXG4gICAqIHRoZSBhc3NvY2lhdGVkIHN0b3JhZ2UgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlIChjb21wb25lbnQpIHtcbiAgICB0aGlzLl9jb3JlLmdsb2JhbFN0b3JhZ2Uub2ZmKCd1cGRhdGUnLCBjb21wb25lbnQubW9kdWxlSWQpO1xuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9hY3RpdmVDb21wb25lbnRzLmZpbmRJbmRleChjID0+IGMubmFtZSA9PT0gY29tcG9uZW50Lm5hbWUpO1xuICAgIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb21wbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUJ5TmFtZSAobmFtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuZmluZChjID0+IGMubmFtZSA9PT0gbmFtZSk7XG4gICAgY29tcG9uZW50LnJlbW92ZSgpO1xuICAgIERPTS5lbXB0eShjb21wb25lbnQuX2NvbnRhaW5lcik7XG4gIH1cblxuICBnZXRBY3RpdmVDb21wb25lbnQgKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5maW5kKGMgPT4gYy5jb25zdHJ1Y3Rvci50eXBlID09PSB0eXBlKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTmF2aWdhdGlvbkNvbmZpZyAqL1xuXG5leHBvcnQgY2xhc3MgVGFiQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHRhYiB0aGF0IGlzIGV4cG9zZWQgZm9yIHRoZSBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gY29uZmlnLmxhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcGxldGUgVVJMLCBpbmNsdWRpbmcgdGhlIHBhcmFtc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy51cmwgPSBjb25maWcudXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyc2lkZSB2ZXJ0aWNhbCBjb25maWcgaWQgdGhhdCB0aGlzIGlzIHJlZmVyZW5jZWQgdG8uXG4gICAgICogQnkgcHJvdmlkaW5nIHRoaXMsIGVuYWJsZXMgZHluYW1pYyBzb3J0aW5nIGJhc2VkIG9uIHJlc3VsdHMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ0lkID0gY29uZmlnLmNvbmZpZ0lkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gc2hvdyB0aGlzIHRhYiBmaXJzdCBpbiB0aGUgb3JkZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRmlyc3QgPSBjb25maWcuaXNGaXJzdCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gYXBwbHkgYSBzcGVjaWFsIGNsYXNzIHRvIHRoZVxuICAgICAqIG1hcmt1cCB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBhY3RpdmUgdGFiXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGNvbmZpZy5pc0FjdGl2ZSB8fCBmYWxzZTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tICh0YWJzKSB7XG4gICAgbGV0IHRhYkNvbmZpZ3MgPSBbXTtcbiAgICBpZiAodGFicyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGFiQ29uZmlncztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGFiID0gdGFic1tpXTtcbiAgICAgIHRhYkNvbmZpZ3MucHVzaChuZXcgVGFiQ29uZmlnKHRhYikpO1xuICAgIH1cbiAgICByZXR1cm4gdGFiQ29uZmlncztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy50YWJzQ29uZmlnID0gVGFiQ29uZmlnLmZyb20oY29uZmlnLnRhYnMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5pbXBvcnQgQ29yZSBmcm9tICcuL2NvcmUvY29yZSc7XG5cbmltcG9ydCB7XG4gIFRlbXBsYXRlTG9hZGVyLFxuICBSZW5kZXJlcnMsXG4gIERPTVxufSBmcm9tICcuL3VpL2luZGV4JztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi91aS9jb21wb25lbnRzL2NvbXBvbmVudCc7XG5cbmltcG9ydCBFcnJvclJlcG9ydGVyIGZyb20gJy4vY29yZS9lcnJvcnMvZXJyb3JyZXBvcnRlcic7XG5pbXBvcnQgQ29uc29sZUVycm9yUmVwb3J0ZXIgZnJvbSAnLi9jb3JlL2Vycm9ycy9jb25zb2xlZXJyb3JyZXBvcnRlcic7XG5pbXBvcnQgeyBBbmFseXRpY3NSZXBvcnRlciwgTm9vcEFuYWx5dGljc1JlcG9ydGVyIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCBQZXJzaXN0ZW50U3RvcmFnZSBmcm9tICcuL3VpL3N0b3JhZ2UvcGVyc2lzdGVudHN0b3JhZ2UnO1xuaW1wb3J0IEdsb2JhbFN0b3JhZ2UgZnJvbSAnLi9jb3JlL3N0b3JhZ2UvZ2xvYmFsc3RvcmFnZSc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaENvbmZpZyBmcm9tICcuL2NvcmUvbW9kZWxzL3NlYXJjaGNvbmZpZyc7XG5pbXBvcnQgQXV0b0NvbXBsZXRlQXBpIGZyb20gJy4vY29yZS9zZWFyY2gvYXV0b2NvbXBsZXRlYXBpJztcbmltcG9ydCBNb2NrQXV0b0NvbXBsZXRlU2VydmljZSBmcm9tICcuL2NvcmUvc2VhcmNoL21vY2thdXRvY29tcGxldGVzZXJ2aWNlJztcbmltcG9ydCBRdWVzdGlvbkFuc3dlckFwaSBmcm9tICcuL2NvcmUvc2VhcmNoL3F1ZXN0aW9uYW5zd2VyYXBpJztcbmltcG9ydCBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlIGZyb20gJy4vY29yZS9zZWFyY2gvbW9ja3F1ZXN0aW9uYW5zd2Vyc2VydmljZSc7XG5pbXBvcnQgU2VhcmNoQXBpIGZyb20gJy4vY29yZS9zZWFyY2gvc2VhcmNoYXBpJztcbmltcG9ydCBNb2NrU2VhcmNoU2VydmljZSBmcm9tICcuL2NvcmUvc2VhcmNoL21vY2tzZWFyY2hzZXJ2aWNlJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4vdWkvY29tcG9uZW50cy9jb21wb25lbnRtYW5hZ2VyJztcbmltcG9ydCBOYXZpZ2F0aW9uQ29uZmlnIGZyb20gJy4vY29yZS9tb2RlbHMvbmF2aWdhdGlvbmNvbmZpZyc7XG5pbXBvcnQgeyBTQU5EQk9YLCBQUk9EVUNUSU9OIH0gZnJvbSAnLi9jb3JlL2NvbnN0YW50cyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvc2VhcmNoc2VydmljZScpLmRlZmF1bHR9IFNlYXJjaFNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvYXV0b2NvbXBsZXRlc2VydmljZScpLmRlZmF1bHR9IEF1dG9Db21wbGV0ZVNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJykuZGVmYXVsdH0gUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvYW5hbHl0aWNzcmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gQW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQHR5cGVkZWYgU2VydmljZXNcbiAqIEBwcm9wZXJ0eSB7U2VhcmNoU2VydmljZX0gc2VhcmNoU2VydmljZVxuICogQHByb3BlcnR5IHtBdXRvQ29tcGxldGVTZXJ2aWNlfSBhdXRvQ29tcGxldGVTZXJ2aWNlXG4gKiBAcHJvcGVydHkge1F1ZXN0aW9uQW5zd2VyU2VydmljZX0gcXVlc3Rpb25BbnN3ZXJTZXJ2aWNlXG4gKiBAcHJvcGVydHkge0Vycm9yUmVwb3J0ZXJTZXJ2aWNlfSBlcnJvclJlcG9ydGVyU2VydmljZVxuICovXG5cbmNvbnN0IERFRkFVTFRTID0ge1xuICBsb2NhbGU6ICdlbidcbn07XG5cbi8qKlxuICogVGhlIG1haW4gQW5zd2VycyBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgQW5zd2VycyB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoIUFuc3dlcnMuc2V0SW5zdGFuY2UodGhpcykpIHtcbiAgICAgIHJldHVybiBBbnN3ZXJzLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIENvbXBvbmVudCBiYXNlIGNsYXNzIGZvciBjdXN0b21cbiAgICAgKiBjb21wb25lbnRzIHRvIGV4dGVuZFxuICAgICAqL1xuICAgIHRoaXMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIEFuYWx5dGljc0V2ZW50IGJhc2UgY2xhc3MgZm9yIHJlcG9ydGluZ1xuICAgICAqIGN1c3RvbSBhbmFseXRpY3NcbiAgICAgKi9cbiAgICB0aGlzLkFuYWx5dGljc0V2ZW50ID0gQW5hbHl0aWNzRXZlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSBvZiB0aGUgcmVuZGVyZXIgdG8gdXNlIGZvciB0aGUgY29tcG9uZW50c1xuICAgICAqIFRoaXMgaXMgcHJvdmlkZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEB0eXBlIHtSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVycy5IYW5kbGViYXJzKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50IG1hbmFnZXJcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50TWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbXBvbmVudHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY29yZSBhcGlcbiAgICAgKiBAdHlwZSB7Q29yZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvcmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2Ugb25jZSB0aGUgbGlicmFyeSBpcyByZWFkeS5cbiAgICAgKiBUeXBpY2FsbHkgZmlyZWQgYWZ0ZXIgdGVtcGxhdGVzIGFyZSBmZXRjaGVkIGZyb20gc2VydmVyIGZvciByZW5kZXJpbmcuXG4gICAgICovXG4gICAgdGhpcy5fb25SZWFkeSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbGlnaWJsZUZvckFuYWx5dGljcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NlcnZpY2VzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2VydmljZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FuYWx5dGljc1JlcG9ydGVyU2VydmljZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyU2VydmljZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgc2V0SW5zdGFuY2UgKGluc3RhbmNlKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIGluaXQgKGNvbmZpZykge1xuICAgIGNvbnN0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKHBhcnNlZENvbmZpZyk7XG5cbiAgICBwYXJzZWRDb25maWcuc2VhcmNoID0gbmV3IFNlYXJjaENvbmZpZyhwYXJzZWRDb25maWcuc2VhcmNoKTtcbiAgICBwYXJzZWRDb25maWcubmF2aWdhdGlvbiA9IG5ldyBOYXZpZ2F0aW9uQ29uZmlnKHBhcnNlZENvbmZpZy5uYXZpZ2F0aW9uKTtcblxuICAgIGNvbnN0IGdsb2JhbFN0b3JhZ2UgPSBuZXcgR2xvYmFsU3RvcmFnZSgpO1xuICAgIGNvbnN0IHBlcnNpc3RlbnRTdG9yYWdlID0gbmV3IFBlcnNpc3RlbnRTdG9yYWdlKHtcbiAgICAgIHVwZGF0ZUxpc3RlbmVyOiBwYXJzZWRDb25maWcub25TdGF0ZUNoYW5nZSxcbiAgICAgIHJlc2V0TGlzdGVuZXI6IGRhdGEgPT4gZ2xvYmFsU3RvcmFnZS5zZXRBbGwoZGF0YSlcbiAgICB9KTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldEFsbChwZXJzaXN0ZW50U3RvcmFnZS5nZXRBbGwoKSk7XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRywgcGFyc2VkQ29uZmlnLnNlYXJjaCk7XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTkFWSUdBVElPTl9DT05GSUcsIHBhcnNlZENvbmZpZy5uYXZpZ2F0aW9uKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBTEUsIHBhcnNlZENvbmZpZy5sb2NhbGUpO1xuICAgIGdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTiwgcGFyc2VkQ29uZmlnLnNlc3Npb25UcmFja2luZ0VuYWJsZWQpO1xuXG4gICAgdGhpcy5fc2VydmljZXMgPSBwYXJzZWRDb25maWcubW9ja1xuICAgICAgPyBnZXRNb2NrU2VydmljZXMoKVxuICAgICAgOiBnZXRTZXJ2aWNlcyhwYXJzZWRDb25maWcsIGdsb2JhbFN0b3JhZ2UpO1xuXG4gICAgdGhpcy5jb3JlID0gbmV3IENvcmUoe1xuICAgICAgYXBpS2V5OiBwYXJzZWRDb25maWcuYXBpS2V5LFxuICAgICAgZ2xvYmFsU3RvcmFnZTogZ2xvYmFsU3RvcmFnZSxcbiAgICAgIHBlcnNpc3RlbnRTdG9yYWdlOiBwZXJzaXN0ZW50U3RvcmFnZSxcbiAgICAgIGV4cGVyaWVuY2VLZXk6IHBhcnNlZENvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgZmllbGRGb3JtYXR0ZXJzOiBwYXJzZWRDb25maWcuZmllbGRGb3JtYXR0ZXJzLFxuICAgICAgZXhwZXJpZW5jZVZlcnNpb246IHBhcnNlZENvbmZpZy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgIGxvY2FsZTogcGFyc2VkQ29uZmlnLmxvY2FsZSxcbiAgICAgIHNlYXJjaFNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLnNlYXJjaFNlcnZpY2UsXG4gICAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlcy5hdXRvQ29tcGxldGVTZXJ2aWNlLFxuICAgICAgcXVlc3Rpb25BbnN3ZXJTZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlcy5xdWVzdGlvbkFuc3dlclNlcnZpY2VcbiAgICB9KTtcblxuICAgIGlmIChwYXJzZWRDb25maWcub25TdGF0ZUNoYW5nZSAmJiB0eXBlb2YgcGFyc2VkQ29uZmlnLm9uU3RhdGVDaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcnNlZENvbmZpZy5vblN0YXRlQ2hhbmdlKHBlcnNpc3RlbnRTdG9yYWdlLmdldEFsbCgpLCB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzXG4gICAgICAuc2V0Q29yZSh0aGlzLmNvcmUpXG4gICAgICAuc2V0UmVuZGVyZXIodGhpcy5yZW5kZXJlcik7XG5cbiAgICB0aGlzLl9lbGlnaWJsZUZvckFuYWx5dGljcyA9IHBhcnNlZENvbmZpZy5idXNpbmVzc0lkICE9IG51bGw7XG4gICAgaWYgKHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzKSB7XG4gICAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IEluaXRpYWxpemUgd2l0aCBvdGhlciBzZXJ2aWNlc1xuICAgICAgY29uc3QgcmVwb3J0ZXIgPSBwYXJzZWRDb25maWcubW9ja1xuICAgICAgICA/IG5ldyBOb29wQW5hbHl0aWNzUmVwb3J0ZXIoKVxuICAgICAgICA6IG5ldyBBbmFseXRpY3NSZXBvcnRlcihcbiAgICAgICAgICB0aGlzLmNvcmUsXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5idXNpbmVzc0lkLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5hbmFseXRpY3NPcHRpb25zLFxuICAgICAgICAgIHBhcnNlZENvbmZpZy5lbnZpcm9ubWVudCk7XG5cbiAgICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyU2VydmljZSA9IHJlcG9ydGVyO1xuXG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0QW5hbHl0aWNzUmVwb3J0ZXIocmVwb3J0ZXIpO1xuICAgICAgaW5pdFNjcm9sbExpc3RlbmVyKHJlcG9ydGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXREZWZhdWx0SW5pdGlhbFNlYXJjaChwYXJzZWRDb25maWcuc2VhcmNoKTtcblxuICAgIHRoaXMuX29uUmVhZHkgPSBwYXJzZWRDb25maWcub25SZWFkeSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGlmIChwYXJzZWRDb25maWcudXNlVGVtcGxhdGVzID09PSBmYWxzZSB8fCBwYXJzZWRDb25maWcudGVtcGxhdGVCdW5kbGUpIHtcbiAgICAgIGlmIChwYXJzZWRDb25maWcudGVtcGxhdGVCdW5kbGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5pbml0KHBhcnNlZENvbmZpZy50ZW1wbGF0ZUJ1bmRsZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uUmVhZHkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRlbXBsYXRlcyBhcmUgY3VycmVudGx5IGRvd25sb2FkZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBDT1JFIGFuZCBVSSBidW5kbGUuXG4gICAgLy8gRnV0dXJlIGVuaGFuY2VtZW50IGlzIHRvIHNoaXAgdGhlIGNvbXBvbmVudHMgd2l0aCB0ZW1wbGF0ZXMgaW4gYSBzZXBhcmF0ZSBidW5kbGUuXG4gICAgdGhpcy50ZW1wbGF0ZXMgPSBuZXcgVGVtcGxhdGVMb2FkZXIoe1xuICAgICAgdGVtcGxhdGVVcmw6IHBhcnNlZENvbmZpZy50ZW1wbGF0ZVVybFxuICAgIH0pLm9uTG9hZGVkKCh0ZW1wbGF0ZXMpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5pdCh0ZW1wbGF0ZXMpO1xuXG4gICAgICB0aGlzLl9vblJlYWR5KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRvbVJlYWR5IChjYikge1xuICAgIERPTS5vblJlYWR5KGNiKTtcbiAgfVxuXG4gIG9uUmVhZHkgKGNiKSB7XG4gICAgdGhpcy5fb25SZWFkeSA9IGNiO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgY29uZmlnIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLiBJbiB0aGUgcGFyc2VkIGNvbmZpZywgYW55IG9wdGlvbnMgbm90IHN1cHBsaWVkIGJ5IHRoZVxuICAgKiB1c2VyIGFyZSBnaXZlbiBkZWZhdWx0IHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgdXNlciBzdXBwbGllZCBjb25maWcuXG4gICAqL1xuICBwYXJzZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgY29uc3QgcGFyc2VkQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFMsIGNvbmZpZyk7XG4gICAgbGV0IHNlc3Npb25UcmFja2luZ0VuYWJsZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnNlc3Npb25UcmFja2luZ0VuYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9IGNvbmZpZy5zZXNzaW9uVHJhY2tpbmdFbmFibGVkO1xuICAgIH1cbiAgICBwYXJzZWRDb25maWcuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9IHNlc3Npb25UcmFja2luZ0VuYWJsZWQ7XG5cbiAgICBjb25zdCBzYW5kYm94UHJlZml4ID0gYCR7U0FOREJPWH0tYDtcbiAgICBwYXJzZWRDb25maWcuYXBpS2V5LmluY2x1ZGVzKHNhbmRib3hQcmVmaXgpXG4gICAgICA/IHBhcnNlZENvbmZpZy5lbnZpcm9ubWVudCA9IFNBTkRCT1hcbiAgICAgIDogcGFyc2VkQ29uZmlnLmVudmlyb25tZW50ID0gUFJPRFVDVElPTjtcbiAgICBwYXJzZWRDb25maWcuYXBpS2V5ID0gcGFyc2VkQ29uZmlnLmFwaUtleS5yZXBsYWNlKHNhbmRib3hQcmVmaXgsICcnKTtcblxuICAgIHJldHVybiBwYXJzZWRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBBbnN3ZXJzIGNvbmZpZyBvYmplY3QgdG8gZW5zdXJlIHRoaW5ncyBsaWtlIGFwaSBrZXkgYW5kIGV4cGVyaWVuY2Uga2V5IGFyZVxuICAgKiBwcm9wZXJseSBzZXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIEFuc3dlcnMgY29uZmlnLlxuICAgKi9cbiAgdmFsaWRhdGVDb25maWcgKGNvbmZpZykge1xuICAgIC8vIFRPRE8gKHRtZXllcik6IEV4dHJhY3QgdGhpcyBtZXRob2QgaW50byBpdCdzIG93biBjbGFzcy4gSW52ZXN0aWdhdGUgdGhlIHVzZSBvZiBKU09OIHNjaGVtYVxuICAgIC8vIHRvIHZhbGlkYXRlIHRoZXNlIGNvbmZpZ3MuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuYXBpS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGBhcGlLZXlgLiBUeXBlIG11c3QgYmUge3N0cmluZ30nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5leHBlcmllbmNlS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGBleHBlcmllbmNlS2V5YC4gVHlwZSBtdXN0IGJlIHtzdHJpbmd9Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY3VzdG9tIGNvbXBvbmVudCB0eXBlIHNvIGl0IGNhbiBiZSBjcmVhdGVkIHZpYVxuICAgKiBhZGRDb21wb25lbnQgYW5kIHVzZWQgYXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudENsYXNzXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudFR5cGUgKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGhpcy5jb21wb25lbnRzLnJlZ2lzdGVyKGNvbXBvbmVudENsYXNzKTtcbiAgfVxuXG4gIGFkZENvbXBvbmVudCAodHlwZSwgb3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogb3B0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21wb25lbnRzLmNyZWF0ZSh0eXBlLCBvcHRzKS5tb3VudCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoJ0ZhaWxlZCB0byBhZGQgY29tcG9uZW50JywgdHlwZSwgZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29tcG9uZW50IC0gYW5kIGFsbCBvZiBpdHMgY2hpbGRyZW4gLSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVDb21wb25lbnQgKG5hbWUpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMucmVtb3ZlQnlOYW1lKG5hbWUpO1xuICB9XG5cbiAgY3JlYXRlQ29tcG9uZW50IChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5jcmVhdGUoJ0NvbXBvbmVudCcsIG9wdHMpLm1vdW50KCk7XG4gIH1cblxuICByZWdpc3RlckhlbHBlciAobmFtZSwgY2IpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlZ2lzdGVySGVscGVyKG5hbWUsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHQgaW4gb3Igb3V0IG9mIGNvbnZlcnRpb24gdHJhY2tpbmcgYW5hbHl0aWNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0SW5cbiAgICovXG4gIHNldENvbnZlcnNpb25zT3B0SW4gKG9wdEluKSB7XG4gICAgaWYgKHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzKSB7XG4gICAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlclNlcnZpY2Uuc2V0Q29udmVyc2lvblRyYWNraW5nRW5hYmxlZChvcHRJbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wdCBpbiBvciBvdXQgb2Ygc2Vzc2lvbiBjb29raWVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0SW5cbiAgICovXG4gIHNldFNlc3Npb25zT3B0SW4gKG9wdEluKSB7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTiwgb3B0SW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzZWFyY2ggcXVlcnkgb24gaW5pdGlhbGl6YXRpb24gZm9yIHZlcnRpY2FsIHNlYXJjaGVycyB0aGF0IGhhdmUgYVxuICAgKiBkZWZhdWx0SW5pdGlhbFNlYXJjaCBwcm92aWRlZCwgaWYgdGhlIHVzZXIgaGFzbid0IGFscmVhZHkgcHJvdmlkZWQgdGhlaXJcbiAgICogb3duIHZpYSBVUkwgcGFyYW0uXG4gICAqIEBwYXJhbSB7U2VhcmNoQ29uZmlnfSBzZWFyY2hDb25maWdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXREZWZhdWx0SW5pdGlhbFNlYXJjaCAoc2VhcmNoQ29uZmlnKSB7XG4gICAgaWYgKHNlYXJjaENvbmZpZy5kZWZhdWx0SW5pdGlhbFNlYXJjaCA9PSBudWxsIHx8ICFzZWFyY2hDb25maWcudmVydGljYWxLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJlcG9wdWxhdGVkUXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgaWYgKHByZXBvcHVsYXRlZFF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KCdxdWVyeVRyaWdnZXInLCAnaW5pdGlhbGl6ZScpO1xuICAgIHRoaXMuY29yZS5zZXRRdWVyeShzZWFyY2hDb25maWcuZGVmYXVsdEluaXRpYWxTZWFyY2gpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtHbG9iYWxTdG9yYWdlfSBnbG9iYWxTdG9yYWdlXG4gKiBAcmV0dXJucyB7U2VydmljZXN9XG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZpY2VzIChjb25maWcsIGdsb2JhbFN0b3JhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWFyY2hTZXJ2aWNlOiBuZXcgU2VhcmNoQXBpKHtcbiAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgIGV4cGVyaWVuY2VLZXk6IGNvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgZXhwZXJpZW5jZVZlcnNpb246IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgIGxvY2FsZTogY29uZmlnLmxvY2FsZSxcbiAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICB9KSxcbiAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiBuZXcgQXV0b0NvbXBsZXRlQXBpKFxuICAgICAge1xuICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICAgIGV4cGVyaWVuY2VLZXk6IGNvbmZpZy5leHBlcmllbmNlS2V5LFxuICAgICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICBsb2NhbGU6IGNvbmZpZy5sb2NhbGUsXG4gICAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgIH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBRdWVzdGlvbkFuc3dlckFwaShcbiAgICAgIHsgYXBpS2V5OiBjb25maWcuYXBpS2V5LCBlbnZpcm9ubWVudDogY29uZmlnLmVudmlyb25tZW50IH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKSxcbiAgICBlcnJvclJlcG9ydGVyU2VydmljZTogbmV3IEVycm9yUmVwb3J0ZXIoXG4gICAgICB7XG4gICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICAgIGV4cGVyaWVuY2VWZXJzaW9uOiBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgIHByaW50VmVyYm9zZTogY29uZmlnLmRlYnVnLFxuICAgICAgICBzZW5kVG9TZXJ2ZXI6ICFjb25maWcuc3VwcHJlc3NFcnJvclJlcG9ydHMsXG4gICAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgIH0sXG4gICAgICBnbG9iYWxTdG9yYWdlKVxuICB9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtTZXJ2aWNlc31cbiAqL1xuZnVuY3Rpb24gZ2V0TW9ja1NlcnZpY2VzICgpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWFyY2hTZXJ2aWNlOiBuZXcgTW9ja1NlYXJjaFNlcnZpY2UoKSxcbiAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiBuZXcgTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2UoKSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlKCksXG4gICAgZXJyb3JSZXBvcnRlclNlcnZpY2U6IG5ldyBDb25zb2xlRXJyb3JSZXBvcnRlcigpXG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRvIHNlbmQgYW5hbHl0aWNzIGV2ZW50c1xuICogd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBib3R0b20uIERlYm91bmNlcyBzY3JvbGwgZXZlbnRzIHNvXG4gKiB0aGV5IGFyZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHVzZXIgc3RvcHMgc2Nyb2xsaW5nXG4gKi9cbmZ1bmN0aW9uIGluaXRTY3JvbGxMaXN0ZW5lciAocmVwb3J0ZXIpIHtcbiAgY29uc3QgREVCT1VOQ0VfVElNRSA9IDEwMDtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuXG4gIGNvbnN0IHNlbmRFdmVudCA9ICgpID0+IHtcbiAgICBpZiAoKHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5wYWdlWU9mZnNldCkgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KCdTQ1JPTExfVE9fQk9UVE9NX09GX1BBR0UnKTtcbiAgICAgIHJlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEV2ZW50LCBERUJPVU5DRV9USU1FKTtcbiAgfSk7XG59XG5cbmNvbnN0IEFOU1dFUlMgPSBuZXcgQW5zd2VycygpO1xuZXhwb3J0IGRlZmF1bHQgQU5TV0VSUztcbiJdLCJuYW1lcyI6WyJQUkVfU0VBUkNIIiwiU0VBUkNIX0xPQURJTkciLCJTRUFSQ0hfQ09NUExFVEUiLCJSZXN1bHQiLCJkYXRhIiwiX3JhdyIsInJhdyIsIl9mb3JtYXR0ZWQiLCJmb3JtYXR0ZWQiLCJfaGlnaGxpZ2h0ZWQiLCJoaWdobGlnaHRlZCIsIm9yZGluYWwiLCJ0aXRsZSIsImRldGFpbHMiLCJsaW5rIiwiaWQiLCJzdWJ0aXRsZSIsIm1vZGlmaWVyIiwiYmlnRGF0ZSIsImltYWdlIiwiY2FsbHNUb0FjdGlvbiIsImNvbGxhcHNlZCIsInVuZGVmaW5lZCIsIkhpZ2hsaWdodGVkVmFsdWUiLCJ2YWx1ZSIsInNob3J0VmFsdWUiLCJtYXRjaGVkU3Vic3RyaW5ncyIsIl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MiLCJidWlsZEhpZ2hsaWdodGVkVmFsdWUiLCJpbnZlcnRlZFN1YnN0cmluZ3MiLCJfZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzIiwibGVuZ3RoIiwidmFsIiwiaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzIiwiaGlnaGxpZ2h0ZWRWYWx1ZSIsIm5leHRTdGFydCIsImoiLCJzdGFydCIsIk51bWJlciIsIm9mZnNldCIsImVuZCIsInNsaWNlIiwiam9pbiIsInNvcnQiLCJhIiwiYiIsInZhbHVlTGVuZ3RoIiwiaSIsInN1YnN0cmluZyIsIm5leHRPZmZzZXQiLCJwdXNoIiwiQW5zd2Vyc0Jhc2VFcnJvciIsImVycm9yQ29kZSIsIm1lc3NhZ2UiLCJib3VuZGFyeSIsImNhdXNlZEJ5IiwiZXJyb3JNZXNzYWdlIiwicmVwb3J0ZWQiLCJmcm9tIiwic3RhY2siLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyaW5nIiwidG9TdHJpbmciLCJidWlsdGluRXJyb3IiLCJlcnJvciIsIkFuc3dlcnNCYXNpY0Vycm9yIiwiRXJyb3IiLCJBbnN3ZXJzQ29uZmlnRXJyb3IiLCJBbnN3ZXJzQ29tcG9uZW50RXJyb3IiLCJjb21wb25lbnQiLCJBbnN3ZXJzRW5kcG9pbnRFcnJvciIsIkFuc3dlcnNDb3JlRXJyb3IiLCJBbnN3ZXJzU3RvcmFnZUVycm9yIiwic3RvcmFnZUtleSIsIkFuc3dlcnNBbmFseXRpY3NFcnJvciIsImV2ZW50IiwiUmVzdWx0RmFjdG9yeSIsInJlc3VsdHNEYXRhIiwiZm9ybWF0dGVycyIsInZlcnRpY2FsSWQiLCJzb3VyY2UiLCJyZXN1bHRzIiwiZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSIsImZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lIiwiZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUiLCJmcm9tQWxnb2xpYVNlYXJjaEVuZ2luZSIsImhpZ2hsaWdodGVkRmllbGRzIiwiZnJvbUtub3dsZWRnZU1hbmFnZXIiLCJmcm9tR2VuZXJpYyIsImVudGl0eVByb2ZpbGVEYXRhIiwiaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSIsIk9iamVjdCIsImtleXMiLCJmb3JtYXR0ZWREYXRhIiwiZW50cmllcyIsImZvckVhY2giLCJmaWVsZE5hbWUiLCJmaWVsZFZhbCIsImhpZ2hsaWdodGVkRmllbGRWYWwiLCJlbnRpdHlGaWVsZFZhbHVlIiwiaGlnaGxpZ2h0ZWRFbnRpdHlGaWVsZFZhbHVlIiwiaXNEaXJlY3RBbnN3ZXIiLCJoaWdobGlnaHRlZERhdGEiLCJoaWdobGlnaHRlZEZpZWxkTmFtZSIsImhpZ2hsaWdodGVkRmllbGQiLCJjb21wdXRlSGlnaGxpZ2h0ZWREYXRhIiwiaGlnaGxpZ2h0ZWREYXRhVmFsdWUiLCJpbmRleCIsIm5hbWUiLCJ0cnVuY2F0ZSIsImRlc2NyaXB0aW9uIiwid2Vic2l0ZSIsImZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhIiwiY29tcHV0ZUZvcm1hdHRlZERhdGEiLCJyZXN1bHREZXRhaWxzIiwiaHRtbFRpdGxlIiwicmVwbGFjZSIsImh0bWxTbmlwcGV0Iiwic25pcHBldCIsInVybCIsImh0bWxfdXJsIiwib2JqZWN0SUQiLCJzdHIiLCJsaW1pdCIsInRyYWlsaW5nIiwic2VwIiwid29yZHMiLCJzcGxpdCIsIm1heCIsInRydW5jYXRlZCIsIndvcmQiLCJTZWN0aW9uIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZXMiLCJ2ZXJ0aWNhbENvbmZpZ0lkIiwicmVzdWx0c0NvdW50IiwiZW5jb2RlZFN0YXRlIiwiYXBwbGllZFF1ZXJ5RmlsdGVycyIsIkFwcGxpZWRRdWVyeUZpbHRlciIsImZhY2V0cyIsIm1hcCIsInBhcnNlTWFwIiwidmVydGljYWxVUkwiLCJtYXBNYXJrZXJzIiwiY2VudGVyQ29vcmRpbmF0ZXMiLCJyZXN1bHQiLCJ5ZXh0RGlzcGxheUNvb3JkaW5hdGUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsIml0ZW0iLCJsYWJlbCIsIm1vZHVsZXMiLCJ1cmxzIiwic2VjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhcHBsaWVkUXVlcnlGaWx0ZXIiLCJrZXkiLCJkaXNwbGF5S2V5IiwiZGlzcGxheVZhbHVlIiwiZmlsdGVycyIsIlVuaXZlcnNhbFJlc3VsdHMiLCJxdWVyeUlkIiwicmVzcG9uc2UiLCJEaXJlY3RBbnN3ZXIiLCJkaXJlY3RBbnN3ZXIiLCJhc3NpZ24iLCJmcmVlemUiLCJhbnN3ZXIiLCJyZWxhdGVkSXRlbSIsImZpZWxkQXBpTmFtZSIsImZpZWxkVmFsdWVzIiwiTmF2aWdhdGlvbiIsInRhYk9yZGVyIiwibmF2IiwiVmVydGljYWxSZXN1bHRzIiwibWVyZ2VkIiwiY29uY2F0IiwiU3BlbGxDaGVjayIsInF1ZXJ5IiwiY29ycmVjdGVkUXVlcnkiLCJjb3JyZWN0ZWRRdWVyeURpc3BsYXkiLCJ0eXBlIiwic2hvdWxkU2hvdyIsIm9yaWdpbmFsUXVlcnkiLCJnZXQiLCJOQVZJR0FUSU9OIiwiVU5JVkVSU0FMX1JFU1VMVFMiLCJWRVJUSUNBTF9SRVNVTFRTIiwiQVVUT0NPTVBMRVRFIiwiRElSRUNUX0FOU1dFUiIsIkZJTFRFUiIsIlFVRVJZIiwiUVVFUllfSUQiLCJGQUNFVF9GSUxURVIiLCJEWU5BTUlDX0ZJTFRFUlMiLCJQQVJBTVMiLCJHRU9MT0NBVElPTiIsIklOVEVOVFMiLCJRVUVTVElPTl9TVUJNSVNTSU9OIiwiU0VBUkNIX0NPTkZJRyIsIlNFQVJDSF9PRkZTRVQiLCJTUEVMTF9DSEVDSyIsIkxPQ0FUSU9OX0JJQVMiLCJTRVNTSU9OU19PUFRfSU4iLCJOQVZJR0FUSU9OX0NPTkZJRyIsIkxPQ0FMRSIsIlNPUlRfQllTIiwiRHluYW1pY0ZpbHRlcnMiLCJkeW5hbWljRmlsdGVycyIsImYiLCJmaWVsZElkIiwib3B0aW9ucyIsIm8iLCJjb3VudExhYmVsIiwic2VsZWN0ZWQiLCJmaWx0ZXIiLCJTZWFyY2hJbnRlbnRzIiwiaW50ZW50cyIsIm5lYXJNZSIsImluY2x1ZGVzIiwiTG9jYXRpb25CaWFzIiwiYWNjdXJhY3kiLCJsb2NhdGlvbkRpc3BsYXlOYW1lIiwiU2VhcmNoRGF0YVRyYW5zZm9ybWVyIiwiU3RvcmFnZUtleXMiLCJzZWFyY2hJbnRlbnRzIiwic3BlbGxDaGVjayIsImxvY2F0aW9uQmlhcyIsIlF1ZXN0aW9uU3VibWlzc2lvbiIsInF1ZXN0aW9uIiwiZXJyb3JzIiwiZW1haWwiLCJwcml2YWN5UG9saWN5IiwicXVlc3Rpb25UZXh0IiwicXVlc3Rpb25EZXNjcmlwdGlvbiIsInF1ZXN0aW9uRXhwYW5kZWQiLCJleHBhbmRlZCIsInF1ZXN0aW9uU3VibWl0dGVkIiwic3VibWl0dGVkIiwiRmlsdGVyIiwicmVzcG9uc2VGaWx0ZXIiLCJwYXJzZSIsImdyb3VwcyIsImdyb3VwRmlsdGVycyIsImZpZWxkIiwib3IiLCJhbmQiLCJfZnJvbU1hdGNoZXIiLCJtaW4iLCJsYXQiLCJsbmciLCJyYWRpdXMiLCJtYXRjaGVyIiwiQ29yZSIsImNvbmZpZyIsIl9hcGlLZXkiLCJhcGlLZXkiLCJfZXhwZXJpZW5jZUtleSIsImV4cGVyaWVuY2VLZXkiLCJfZXhwZXJpZW5jZVZlcnNpb24iLCJleHBlcmllbmNlVmVyc2lvbiIsIl9sb2NhbGUiLCJsb2NhbGUiLCJfZmllbGRGb3JtYXR0ZXJzIiwiZmllbGRGb3JtYXR0ZXJzIiwiZ2xvYmFsU3RvcmFnZSIsInBlcnNpc3RlbnRTdG9yYWdlIiwiX3NlYXJjaGVyIiwic2VhcmNoU2VydmljZSIsIl9hdXRvQ29tcGxldGUiLCJhdXRvQ29tcGxldGVTZXJ2aWNlIiwiX3F1ZXN0aW9uQW5zd2VyIiwicXVlc3Rpb25BbnN3ZXJTZXJ2aWNlIiwidmVydGljYWxLZXkiLCJhcHBlbmQiLCJzZXQiLCJzZWFyY2hMb2FkaW5nIiwidmVydGljYWxTZWFyY2giLCJnZXRTdGF0ZSIsImdlb2xvY2F0aW9uIiwiaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJfaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJza2lwU3BlbGxDaGVjayIsInF1ZXJ5VHJpZ2dlciIsInNlc3Npb25UcmFja2luZ0VuYWJsZWQiLCJzb3J0QnlzIiwidGhlbiIsInRyYW5zZm9ybVZlcnRpY2FsIiwibWVyZ2VkUmVzdWx0cyIsImFsbEZpbHRlcnMiLCJnZXRBbGwiLCJ0b3RhbEZpbHRlciIsImZhY2V0RmlsdGVyIiwiaW5wdXQiLCJxdWVyeVN0cmluZyIsInVuaXZlcnNhbFNlYXJjaCIsInRyYW5zZm9ybSIsIm5hbWVzcGFjZSIsInF1ZXJ5VW5pdmVyc2FsIiwicXVlcnlWZXJ0aWNhbCIsInF1ZXJ5RmlsdGVyIiwic3VibWl0UXVlc3Rpb24iLCJzb3J0QnlPcHRpb25zIiwib3B0aW9uIiwiZGlyZWN0aW9uIiwiZXZ0IiwibW9kdWxlSWQiLCJjYiIsIm9uIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJET00iLCJkIiwicCIsImh0bWwiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiZnJhZyIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiYXBwZW5kQ2hpbGQiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwicGFyZW50Iiwic2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIldpbmRvdyIsIkhUTUxEb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVhZHlTdGF0ZSIsImVsIiwib3B0c19kYXRhIiwibm9kZSIsInByb3BzIiwiYWRkQ2xhc3MiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJjbGFzc05hbWUiLCJjbGFzc2VzIiwibGVuIiwiY2xhc3NMaXN0IiwiYWRkIiwiaW5uZXJIVE1MIiwic3R5bGVzIiwicHJvcCIsInN0eWxlIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsImF0dHJzIiwic2V0dGluZ3MiLCJlIiwiRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiaGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImN0eHQiLCJ0YXJnZXQiLCJpc0VxdWFsTm9kZSIsIm1hdGNoZXMiLCJwYXJlbnROb2RlIiwiU2VhcmNoUGFyYW1zIiwiX3BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsInNlYXJjaCIsImluZGV4T2YiLCJlbmNvZGVkUGFyYW1zIiwia2V5VmFsIiwiZGVjb2RlIiwiU3RyaW5nIiwiZW5jb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJSZW5kZXJlciIsInRlbXBsYXRlIiwiSGFuZGxlYmFyc1JlbmRlcmVyIiwidGVtcGxhdGVzIiwiX2hhbmRsZWJhcnMiLCJfaGIiLCJfdGVtcGxhdGVzIiwiX3JlZ2lzdGVyQ3VzdG9tSGVscGVycyIsInJlZ2lzdGVySGVscGVyIiwiY29tcGlsZSIsInRlbXBsYXRlTmFtZSIsImFyZzEiLCJhcmcyIiwiZm4iLCJpbnZlcnNlIiwicGhvbmVOdW1iZXJTdHJpbmciLCJjbGVhbmVkIiwiaW50bENvZGUiLCJhcmdzIiwiYXJndW1lbnRzIiwicm9vdCIsInYiLCJSZW5kZXJlcnMiLCJTT1kiLCJIYW5kbGViYXJzIiwiTElCX1ZFUlNJT04iLCJQUk9EVUNUSU9OIiwiU0FOREJPWCIsIkNPTVBJTEVEX1RFTVBMQVRFU19VUkwiLCJUZW1wbGF0ZUxvYWRlciIsInNldEluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJfdGVtcGxhdGVVcmwiLCJ0ZW1wbGF0ZVVybCIsIl9vbkxvYWRlZCIsIl9pbml0IiwiZmV0Y2hUZW1wbGF0ZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNjcmlwdCIsImNyZWF0ZUVsIiwib25sb2FkIiwib25lcnJvciIsImFzeW5jIiwic3JjIiwiY29uc29sZSIsImxvZyIsImluc3RhbmNlIiwiRXZlbnRFbWl0dGVyIiwiX2xpc3RlbmVycyIsImxpc3RlbmVycyIsImtlZXAiLCJTdGF0ZSIsIl9zdGF0ZSIsIm9wdFZhbCIsIl9zZXQiLCJlbWl0Iiwib3B0UHJvcCIsIk1ldGhvZHMiLCJHRVQiLCJQT1NUIiwiUFVUIiwiREVMRVRFIiwiSHR0cFJlcXVlc3RlciIsIm9wdHMiLCJyZXF1ZXN0IiwiZW5jb2RlUGFyYW1zIiwidXJsUGFyYW1zIiwianNvbkJvZHkiLCJyZXF1ZXN0Q29uZmlnIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJyZXFBcmdzIiwiZmV0Y2giLCJuYXZpZ2F0b3IiLCJzZW5kQmVhY29uIiwiaGFzUGFyYW0iLCJzZWFyY2hRdWVyeSIsImdldExpdmVBcGlVcmwiLCJlbnYiLCJnZXRLbm93bGVkZ2VBcGlVcmwiLCJnZXRBbmFseXRpY3NVcmwiLCJjb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwiQXBpUmVxdWVzdCIsIl9yZXF1ZXN0ZXIiLCJfZW52aXJvbm1lbnQiLCJlbnZpcm9ubWVudCIsIl9iYXNlVXJsIiwiYmFzZVVybCIsIl9lbmRwb2ludCIsImVuZHBvaW50IiwiX3ZlcnNpb24iLCJ2ZXJzaW9uIiwiX2dsb2JhbFN0b3JhZ2UiLCJiYXNlUGFyYW1zIiwic2FuaXRpemVQYXJhbXMiLCJwb3N0IiwibG9jYXRpb24iLCJoYXMiLCJTZWFyY2hBcGkiLCJqc29uIiwiQW5hbHl0aWNzRXZlbnQiLCJldmVudFR5cGUiLCJ0b1VwcGVyQ2FzZSIsIkFuYWx5dGljc1JlcG9ydGVyIiwiY29yZSIsImJ1c2luZXNzSWQiLCJnbG9iYWxPcHRpb25zIiwiX2J1c2luZXNzSWQiLCJfZ2xvYmFsT3B0aW9ucyIsIl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwic2V0UXVlcnlJZCIsImNvb2tpZURhdGEiLCJ5dGFnIiwiYWRkT3B0aW9ucyIsImJlYWNvbiIsInRvQXBpRXZlbnQiLCJpc0VuYWJsZWQiLCJOb29wQW5hbHl0aWNzUmVwb3J0ZXIiLCJNb2R1bGVEYXRhIiwiX2lkIiwiX2hpc3RvcnkiLCJfZGF0YSIsImNhcHR1cmVQcmV2aW91cyIsInNoaWZ0IiwicHJldmlvdXMiLCJfcHJldmlvdXMiLCJwb3AiLCJHbG9iYWxTdG9yYWdlIiwiX21vZHVsZURhdGFDb250YWluZXIiLCJfZnV0dXJlTGlzdGVuZXJzIiwiX2luaXREYXRhQ29udGFpbmVyIiwiX2FwcGx5RnV0dXJlTGlzdGVuZXJzIiwiZGF0YUtleSIsInN0YXJ0c1dpdGgiLCJtb2R1bGVEYXRhIiwib2ZmIiwiZnV0dXJlcyIsImZ1dHVyZSIsIkNvbXBvbmVudCIsInN5c3RlbUNvbmZpZyIsImNvbnN0cnVjdG9yIiwiX2NvbmZpZyIsIl90eXBlIiwiX3BhcmVudENvbnRhaW5lciIsInBhcmVudENvbnRhaW5lciIsIl9jaGlsZHJlbiIsInN0YXRlIiwiY29tcG9uZW50TWFuYWdlciIsImFuYWx5dGljc1JlcG9ydGVyIiwiX2FuYWx5dGljc09wdGlvbnMiLCJhbmFseXRpY3NPcHRpb25zIiwiX2NvbnRhaW5lciIsIl9jbGFzc05hbWUiLCJfcmVuZGVyIiwicmVuZGVyIiwiX3JlbmRlcmVyIiwicmVuZGVyZXIiLCJfdGVtcGxhdGUiLCJfdGVtcGxhdGVOYW1lIiwiZGVmYXVsdFRlbXBsYXRlTmFtZSIsIl9pc01vdW50ZWQiLCJ0cmFuc2Zvcm1EYXRhIiwib25DcmVhdGUiLCJvbkNyZWF0ZU92ZXJyaWRlIiwiYmluZCIsIm9uTW91bnQiLCJvbk1vdW50T3ZlcnJpZGUiLCJvblVwZGF0ZSIsIm9uVXBkYXRlT3ZlcnJpZGUiLCJ1c2VyT25DcmVhdGUiLCJ1c2VyT25Nb3VudCIsInVzZXJPblVwZGF0ZSIsInNldFN0YXRlIiwidW5Nb3VudCIsIm1vdW50IiwibmV3U3RhdGUiLCJjaGlsZENvbXBvbmVudCIsImNyZWF0ZSIsIl9wYXJlbnRPcHRzIiwiYyIsInJlbW92ZSIsImNoaWxkIiwiZW1wdHkiLCJvblVuTW91bnQiLCJiZWZvcmVNb3VudCIsImFzSlNPTiIsImRvbUNvbXBvbmVudHMiLCJxdWVyeUFsbCIsIl9jcmVhdGVTdWJjb21wb25lbnQiLCJkb21Ib29rcyIsIl9jcmVhdGVBbmFseXRpY3NIb29rIiwiYmVmb3JlUmVuZGVyIiwiYWZ0ZXJSZW5kZXIiLCJkb21Db21wb25lbnQiLCJkYXRhc2V0IiwiaXNDb21wb25lbnRNb3VudGVkIiwiY2hpbGREYXRhIiwiYWRkQ2hpbGQiLCJyZXZlcnNlIiwiaXNBbmFseXRpY3NBdHRhY2hlZCIsImV2ZW50dHlwZSIsImV2ZW50bGFiZWwiLCJldmVudG9wdGlvbnMiLCJyZXBvcnQiLCJFcnJvclJlcG9ydGVyIiwicHJpbnRWZXJib3NlIiwic2VuZFRvU2VydmVyIiwiZXJyIiwicHJpbnRFcnJvciIsInRvSnNvbiIsIkNvbnNvbGVFcnJvclJlcG9ydGVyIiwiUGVyc2lzdGVudFN0b3JhZ2UiLCJfaGlzdG9yeVRpbWVyIiwiX3VwZGF0ZUxpc3RlbmVyIiwidXBkYXRlTGlzdGVuZXIiLCJfcmVzZXRMaXN0ZW5lciIsInJlc2V0TGlzdGVuZXIiLCJvbnBvcHN0YXRlIiwiX2NhbGxMaXN0ZW5lciIsInJlcGxhY2VIaXN0b3J5IiwibmV3RGF0YSIsIl91cGRhdGVIaXN0b3J5IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJwdXNoU3RhdGUiLCJsaXN0ZW5lciIsImFsbFBhcmFtcyIsIlNlYXJjaENvbmZpZyIsImRlZmF1bHRJbml0aWFsU2VhcmNoIiwidmFsaWRhdGUiLCJBdXRvQ29tcGxldGVEYXRhIiwiaW5wdXRJbnRlbnRzIiwicyIsInIiLCJBdXRvQ29tcGxldGVSZXN1bHQiLCJxdWVyeUludGVudHMiLCJnZXRJbnZlcnRlZCIsIkF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lciIsIkF1dG9Db21wbGV0ZUFwaSIsInNlYXJjaFBhcmFtZXRlcnMiLCJ2ZXJ0aWNhbCIsInVuaXZlcnNhbCIsInVuaXZlcnNhbE9wdGlvbnMiLCJ2ZXJ0aWNhbE9wdGlvbnMiLCJNb2NrQXV0b0NvbXBsZXRlU2VydmljZSIsImVtcHR5UmVzdWx0cyIsImZpbHRlck9wdGlvbnMiLCJvcHQiLCJsb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsInJhbmRvbVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJRdWVzdGlvbkFuc3dlckFwaSIsImVudGl0eUlkIiwic2l0ZSIsInF1ZXN0aW9uTGFuZ3VhZ2UiLCJtb2RlIiwiaGVhZGVycyIsIk1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UiLCJBUkJJVFJBUllfQlVTSU5FU1NfSUQiLCJNb2NrU2VhcmNoU2VydmljZSIsIl9nZXRNb2NrRGF0YUpzb24iLCJyZXNwIiwidGV4dCIsInVzZU1vY2tEYXRhIiwiZGVsYXllZFJlc3BvbnNlIiwiY29uc3RydWN0VmVydGljYWxSZXNwb25zZSIsInNlY3Rpb24iLCJmaW5kIiwidmVydGljYWxNb2R1bGUiLCJmbG9vciIsIm1vZGlmeVJlc3VsdHMiLCJnZXRSZXN1bHRzRmlsdGVyZXIiLCJjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZSIsImNvbnN1bWVyIiwibW9kaWZ5Rm4iLCJmaWxsU2VjdGlvbkZpZWxkcyIsIm1ldGEiLCJ1dWlkIiwidXVpZFY0IiwiZmFpbGVkVmVydGljYWxzIiwicXVlcnlEdXJhdGlvbk1pbGxpcyIsInJhbmRvbUludCIsIlJFU0laRV9ERUJPVU5DRSIsIk1PQklMRV9CUkVBS1BPSU5UIiwiTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTiIsIkNPTExBUFNFIiwiSU5ORVJTQ1JPTEwiLCJUYWIiLCJjb25maWdJZCIsImlzRmlyc3QiLCJpc0FjdGl2ZSIsInRhYnNDb25maWciLCJ0YWJzIiwidGFiIiwiTmF2aWdhdGlvbkNvbXBvbmVudCIsIm92ZXJmbG93TGFiZWwiLCJvdmVyZmxvd0ljb24iLCJfdGFic0NvbmZpZyIsIl90YWJzIiwiX3RhYk9yZGVyIiwiZ2V0RGVmYXVsdFRhYk9yZGVyIiwiZ2V0VXJsUGFyYW1zIiwiX25hdkJyZWFrcG9pbnRzIiwiX21vYmlsZU92ZXJmbG93QmVoYXZpb3IiLCJtb2JpbGVPdmVyZmxvd0JlaGF2aW9yIiwiX2FyaWFMYWJlbCIsImFyaWFMYWJlbCIsImNoZWNrT3V0c2lkZUNsaWNrIiwiY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yIiwic2hvdWxkQ29sbGFwc2UiLCJiaW5kT3ZlcmZsb3dIYW5kbGVycyIsInJlZml0TmF2IiwidG9nZ2xlTW9yZURyb3Bkb3duIiwidW5iaW5kT3ZlcmZsb3dIYW5kbGVycyIsIm1vcmVCdXR0b24iLCJtYWluTGlua3MiLCJjb2xsYXBzZWRMaW5rcyIsIm5hdldpZHRoIiwiY29udGFpbnMiLCJvZmZzZXRXaWR0aCIsIm51bUJyZWFrcG9pbnRzIiwibWFpbkxpbmtzV2lkdGgiLCJjaGlsZHJlbiIsImxhc3RMaW5rIiwicHJlcGVuZCIsImZpcnN0TGluayIsImNsb3NlTW9yZURyb3Bkb3duIiwidG9nZ2xlIiwiY2xvc2VzdCIsIl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lciIsIm1lcmdlVGFiT3JkZXIiLCJnZW5lcmF0ZVRhYlVybCIsInNob3dDb2xsYXBzZSIsInVuc2hpZnQiLCJvdGhlclRhYk9yZGVyIiwidGFiQ29uZmlnIiwiU2VhcmNoQ29tcG9uZW50IiwiX3ZlcnRpY2FsS2V5IiwiX2Zvcm1FbCIsImZvcm1TZWxlY3RvciIsIl9pbnB1dEVsIiwiaW5wdXRFbCIsImxhYmVsVGV4dCIsInN1Ym1pdFRleHQiLCJjbGVhclRleHQiLCJzdWJtaXRJY29uIiwicHJvbXB0SGVhZGVyIiwiYXV0b0ZvY3VzIiwiY2xlYXJCdXR0b24iLCJhdXRvY29tcGxldGVPbkxvYWQiLCJyZWRpcmVjdFVybCIsIl9pc1R3aW4iLCJpc1R3aW4iLCJxIiwiZGVib3VuY2VkU2VhcmNoIiwiX3NlYXJjaENvb2xkb3duIiwic2VhcmNoQ29vbGRvd24iLCJfcHJvbXB0Rm9yTG9jYXRpb24iLCJwcm9tcHRGb3JMb2NhdGlvbiIsIkJvb2xlYW4iLCJfc2hvd0NsZWFyQnV0dG9uIiwiX2FsbG93RW1wdHlTZWFyY2giLCJhbGxvd0VtcHR5U2VhcmNoIiwiX2F1dG9Db21wbGV0ZU5hbWUiLCJzZXRRdWVyeSIsImZvY3VzSW5wdXRFbGVtZW50IiwiaW5pdFNlYXJjaCIsImluaXRBdXRvQ29tcGxldGUiLCJpbml0Q2xlYXJCdXR0b24iLCJfYXV0b2NvbXBsZXRlIiwiYnV0dG9uIiwiZm9ybSIsInByZXZlbnREZWZhdWx0IiwiaHJlZiIsImJsdXIiLCJpbnB1dFNlbGVjdG9yIiwib25TdWJtaXQiLCJ0cmlnZ2VyIiwib25DaGFuZ2UiLCJfdGhyb3R0bGVkIiwiZmV0Y2hRdWVyeUludGVudHMiLCJxdWVyeUhhc05lYXJNZUludGVudCIsImdldEN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwiY29vcmRzIiwiZ2V0QWN0aXZlQ29tcG9uZW50IiwiYXV0b2NvbXBsZXRlRGF0YSIsImF1dG9jb21wbGV0ZVJlcXVlc3QiLCJhdXRvQ29tcGxldGVWZXJ0aWNhbCIsImF1dG9Db21wbGV0ZVVuaXZlcnNhbCIsImZsYXRNYXAiLCJtYXRjaGluZ1Jlc3VsdCIsInNob3dDbGVhckJ1dHRvbiIsImV2ZW50T3B0aW9ucyIsImZvY3VzIiwiYnVpbGRTZWFyY2hQYXJhbWV0ZXJzIiwic2VhcmNoUGFyYW1ldGVyQ29uZmlncyIsInNlY3Rpb25lZCIsImZpZWxkcyIsImJ1aWxkRmllbGRzIiwiZmllbGRDb25maWdzIiwiZmMiLCJmZXRjaEVudGl0aWVzIiwiRmlsdGVyU2VhcmNoQ29tcG9uZW50IiwiX3N0b3JlT25DaGFuZ2UiLCJzdG9yZU9uQ2hhbmdlIiwic2VhcmNoVGV4dCIsImlzRmlsdGVyU2VhcmNoIiwib3JpZ2luYWxGaWx0ZXIiLCJmcm9tUmVzcG9uc2UiLCJzZXRGaWx0ZXIiLCJLZXlzIiwiQkFDS1NQQUNFIiwiVEFCIiwiRU5URVIiLCJTSElGVCIsIkNUUkwiLCJBTFQiLCJFU0NBUEUiLCJMRUZUIiwiUklHSFQiLCJVUCIsIkRPV04iLCJMRUZUX09TX0tFWSIsIlJJR0hUX09TX0tFWSIsIlNFTEVDVF9LRVkiLCJBdXRvQ29tcGxldGVDb21wb25lbnQiLCJzeXN0ZW1PcHRzIiwiX2F1dG9jb21wbGV0ZUVscyIsImF1dG9Db21wbGV0ZUVscyIsIl9vcmlnaW5hbFF1ZXJ5IiwiX3NlY3Rpb25JbmRleCIsIl9yZXN1bHRJbmRleCIsIl9hdXRvRm9jdXMiLCJfb25TdWJtaXQiLCJfb25DaGFuZ2UiLCJfc2VhcmNoUGFyYW1ldGVycyIsImlzUXVlcnlJbnB1dEZvY3VzZWQiLCJoYXNSZXN1bHRzIiwic2VjdGlvbkluZGV4IiwicmVzdWx0SW5kZXgiLCJhY3RpdmVFbGVtZW50IiwicXVlcnlJbnB1dCIsImF0dHJpYnV0ZXMiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsInNwZWxsY2hlY2siLCJjbG9zZSIsInJlc2V0IiwiYXV0b0NvbXBsZXRlIiwiaGFuZGxlTmF2aWdhdGVSZXN1bHRzIiwia2V5Q29kZSIsImhhbmRsZVN1Ym1pdFJlc3VsdCIsImRlbGVnYXRlIiwidXBkYXRlUXVlcnkiLCJoYW5kbGVUeXBpbmciLCJ1cGRhdGVTdGF0ZSIsIm9wdFZhbHVlIiwicXVlcnlFbCIsImlnbm9yZWRLZXlzIiwiYXV0b0NvbXBsZXRlRmlsdGVyIiwiU3BlbGxDaGVja0NvbXBvbmVudCIsImNvcnJlY3RlZFF1ZXJ5VXJsIiwiX2J1aWxkUmVkaXJlY3RRdWVyeVVybCIsImhlbHBUZXh0IiwiX2dldEhlbHBUZXh0IiwiTG9jYXRpb25CaWFzQ29tcG9uZW50IiwiX3VwZGF0ZUxvY2F0aW9uRWwiLCJ1cGRhdGVMb2NhdGlvbkVsIiwiX2xvY2F0aW9uRGlzcGxheU5hbWUiLCJfYWNjdXJhY3kiLCJfYWxsb3dVcGRhdGUiLCJfZGlzYWJsZUxvY2F0aW9uVXBkYXRlSWZHZW9sb2NhdGlvbkRlbmllZCIsIl9kb1NlYXJjaCIsImNvZGUiLCJfZGlzYWJsZUxvY2F0aW9uVXBkYXRlIiwiX2dldExvY2F0aW9uRGlzcGxheU5hbWUiLCJhY2N1cmFjeVRleHQiLCJfZ2V0QWNjdXJhY3lIZWxwVGV4dCIsImlzUHJlY2lzZUxvY2F0aW9uIiwiaXNVbmtub3duTG9jYXRpb24iLCJhbGxvd1VwZGF0ZSIsInBlcm1pc3Npb25zIiwiRmFjZXQiLCJhdmFpbGFibGVGaWVsZElkcyIsImZsYXRGaWx0ZXJzIiwiJG9yIiwiRmlsdGVyQm94Q29uZmlnIiwic2hvd0NvdW50Iiwic2VhcmNoT25DaGFuZ2UiLCJyZXNldEZpbHRlciIsInJlc2V0RmFjZXQiLCJyZXNldEZpbHRlckxhYmVsIiwicmVzZXRGYWNldExhYmVsIiwicmVzZXRGaWx0ZXJzIiwicmVzZXRGYWNldHMiLCJyZXNldEZpbHRlcnNMYWJlbCIsInJlc2V0RmFjZXRzTGFiZWwiLCJzaG93TW9yZUxpbWl0Iiwic2hvd01vcmVMYWJlbCIsInNob3dMZXNzTGFiZWwiLCJzaG93TW9yZSIsImV4cGFuZCIsInNob3dOdW1iZXJBcHBsaWVkIiwiYXBwbHlMYWJlbCIsImFwcGx5QnV0dG9uU2VsZWN0b3IiLCJmaWx0ZXJDb25maWdzIiwiaXNEeW5hbWljIiwiRmlsdGVyQm94Q29tcG9uZW50IiwiX2ZpbHRlckNvbXBvbmVudHMiLCJfZmlsdGVycyIsInNob3dSZXNldCIsInJlc2V0TGFiZWwiLCJzaG93QXBwbHlCdXR0b24iLCJzaG93RXhwYW5kIiwib25GaWx0ZXJDaGFuZ2UiLCJnZXRGaWx0ZXIiLCJfc2F2ZUZpbHRlcnNUb1N0b3JhZ2UiLCJfc2VhcmNoIiwiY2xlYXJPcHRpb25zIiwidmFsaWRGaWx0ZXJzIiwiY29tYmluZWRGaWx0ZXIiLCJmcm9tRmlsdGVycyIsInNldEZhY2V0RmlsdGVyIiwiU1VQUE9SVEVEX0NPTlRST0xTIiwiRmlsdGVyT3B0aW9uc0NvbmZpZyIsImNvbnRyb2wiLCJvcHRpb25TZWxlY3RvciIsInByZXZpb3VzT3B0aW9ucyIsInNlbGVjdGVkT3B0aW9ucyIsInNldERlZmF1bHRTZWxlY3RlZFZhbHVlcyIsInJlZHVjZSIsIm51bVNlbGVjdGVkIiwiRmlsdGVyT3B0aW9uc0NvbXBvbmVudCIsInNlbGVjdGVkQ291bnQiLCJnZXRTZWxlY3RlZENvdW50IiwiYWxsU2hvd24iLCJpc1NpbmdsZU9wdGlvbiIsIl91cGRhdGVPcHRpb24iLCJwYXJzZUludCIsImNoZWNrZWQiLCJsZWdlbmQiLCJjbGljayIsInVwZGF0ZUxpc3RlbmVycyIsIl9idWlsZEZpbHRlciIsImVsZW1lbnRzIiwiX2FwcGx5RmlsdGVyIiwiZXF1YWwiLCJncm91cCIsIlJhbmdlRmlsdGVyQ29tcG9uZW50IiwiX2ZpZWxkIiwibWluVmFsIiwibWF4VmFsIiwiX3JhbmdlIiwiaW5pdGlhbE1pbiIsImluaXRpYWxNYXgiLCJfdGl0bGUiLCJfbWluTGFiZWwiLCJtaW5MYWJlbCIsIl9tYXhMYWJlbCIsIm1heExhYmVsIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIl91cGRhdGVSYW5nZSIsImluY2x1c2l2ZVJhbmdlIiwiRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IiwiX2lzRXhjbHVzaXZlIiwiaXNFeGNsdXNpdmUiLCJ0b2RheSIsIkRhdGUiLCJ0b2RheVN0cmluZyIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImdldERhdGUiLCJtaW5EYXRlIiwibWF4RGF0ZSIsIl9kYXRlIiwiZGF0ZU1pbiIsImRhdGVNYXgiLCJkYXRlIiwiZXhjbHVzaXZlUmFuZ2UiLCJGYWNldHNDb25maWciLCJmaWVsZENvbnRyb2xzIiwiRmFjZXRzQ29tcG9uZW50IiwiX2FwcGx5QnV0dG9uU2VsZWN0b3IiLCJfZmlsdGVyYm94IiwiZW5hYmxlRHluYW1pY0ZpbHRlcnMiLCJNRVRFUlNfUEVSX01JTEUiLCJERUZBVUxUX0NPTkZJRyIsImdlb0J1dHRvbkljb24iLCJnZW9CdXR0b25UZXh0IiwiZW5hYmxlZFRleHQiLCJsb2FkaW5nVGV4dCIsImVycm9yVGV4dCIsImJ1dHRvblNlbGVjdG9yIiwiR2VvTG9jYXRpb25Db21wb25lbnQiLCJwbGFjZWhvbGRlciIsIl9lbmFibGVkIiwiZ2VvTG9hZGluZyIsImdlb0Vycm9yIiwiZ2VvRW5hYmxlZCIsImdlb1ZhbHVlIiwiZ2VvUGxhY2Vob2xkZXIiLCJfaW5pdEF1dG9Db21wbGV0ZSIsIl90b2dnbGVHZW9GaWx0ZXIiLCJfc2F2ZURhdGFUb1N0b3JhZ2UiLCJTb3J0T3B0aW9uc0NvbXBvbmVudCIsImFzc2lnbkRlZmF1bHRzIiwic2VsZWN0ZWRPcHRpb25JbmRleCIsImlzU2VsZWN0ZWQiLCJoaWRlRXhjZXNzT3B0aW9ucyIsImhhbmRsZU9wdGlvblNlbGVjdGlvbiIsIl9zb3J0UmVzdWx0cyIsIm9wdGlvbkluZGV4IiwiX3VwZGF0ZVNlbGVjdGVkT3B0aW9uIiwiY2xlYXJTb3J0QnlzIiwic2V0U29ydEJ5cyIsInVwZGF0ZWRDb25maWciLCJkZWZhdWx0U29ydExhYmVsIiwiT1BUSU9OX1RZUEVTIiwibmV3T3B0aW9uIiwiaXNGaWVsZCIsIkV2ZW50VHlwZXMiLCJUSFVNQlNfVVAiLCJUSFVNQlNfRE9XTiIsIkRpcmVjdEFuc3dlckNvbXBvbmVudCIsImZvcm1FbCIsIl90aHVtYnNVcFNlbGVjdG9yIiwidGh1bWJzVXBTZWxlY3RvciIsIl90aHVtYnNEb3duU2VsZWN0b3IiLCJ0aHVtYnNEb3duU2VsZWN0b3IiLCJfdmlld0RldGFpbHNUZXh0Iiwidmlld0RldGFpbHNUZXh0IiwiaGFzU3RhdGUiLCJjaGVja2VkVmFsdWUiLCJyZXBvcnRRdWFsaXR5Iiwic2VhcmNoZXIiLCJjdGFMYWJlbCIsImlzR29vZCIsIlJlc3VsdHNJdGVtQ29tcG9uZW50IiwiX3ZlcnRpY2FsQ29uZmlnSWQiLCJfaXNVbml2ZXJzYWwiLCJpc1VuaXZlcnNhbCIsIkxvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQiLCJFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50IiwiUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQiLCJNYXBQcm92aWRlciIsIl96b29tIiwiem9vbSIsIl9kZWZhdWx0UG9zaXRpb24iLCJkZWZhdWx0UG9zaXRpb24iLCJfc2hvd0VtcHR5TWFwIiwic2hvd0VtcHR5TWFwIiwiX21hcCIsIl9pc0xvYWRlZCIsIl9vblBpbkNsaWNrIiwib25QaW5DbGljayIsIm9uTG9hZGVkIiwiX3BpbkNvbmZpZyIsInBpbiIsIkRFRkFVTFRfUElOX0NPTkZJRyIsIl9jb2xsYXBzZVBpbnMiLCJjb2xsYXBzZVBpbnMiLCJpc0xvYWRlZCIsIm1hcERhdGEiLCJtYXJrZXJzIiwibG9jYXRpb25Ub0l0ZW0iLCJtIiwiY29sbGFwc2VkTWFya2VycyIsImNvbGxhcHNlZE1hcmtlciIsImljb24iLCJhbmNob3IiLCJzdmciLCJzY2FsZWRTaXplIiwibGFiZWxUeXBlIiwiR29vZ2xlTWFwUHJvdmlkZXIiLCJfem9vbU9mZnNldCIsIl9jbGllbnRJZCIsImNsaWVudElkIiwiX3NpZ25hdHVyZSIsInNpZ25hdHVyZSIsImhhc1ZhbGlkQ2xpZW50Q3JlZGVudGlhbHMiLCJvbkxvYWQiLCJnZW5lcmF0ZUNyZWRlbnRpYWxzIiwiZ29vZ2xlIiwibWFwcyIsIk1hcCIsImNlbnRlciIsImdldENlbnRlck1hcmtlciIsIl9jb2xsYXBzZU1hcmtlcnMiLCJnb29nbGVNYXBNYXJrZXJDb25maWdzIiwiR29vZ2xlTWFwTWFya2VyQ29uZmlnIiwiYm91bmRzIiwiTGF0TG5nQm91bmRzIiwibWFya2VyIiwiTWFya2VyIiwiYWRkTGlzdGVuZXIiLCJleHRlbmQiLCJmaXRCb3VuZHMiLCJtYXBDZW50ZXIiLCJzZXJpYWxpemVkTWFya2VycyIsInBpbkNvbmZpZyIsInBpbkNvbmZpZ09iaiIsIlBvaW50IiwieCIsInkiLCJTaXplIiwidyIsImgiLCJNYXBCb3hNYXBQcm92aWRlciIsIm1hcGJveGdsIiwiYWNjZXNzVG9rZW4iLCJjc3MiLCJyZWwiLCJtYXBib3hNYXBNYXJrZXJDb25maWdzIiwiTWFwQm94TWFya2VyQ29uZmlnIiwiTG5nTGF0Qm91bmRzIiwid3JhcHBlciIsIkxuZ0xhdCIsInNldExuZ0xhdCIsImdldExuZ0xhdCIsImFkZFRvIiwiZ2V0RWxlbWVudCIsInBhZGRpbmciLCJzdGF0aWNNYXBQaW4iLCJQcm92aWRlclR5cGVzIiwiTWFwQ29tcG9uZW50IiwiX21hcFByb3ZpZGVyIiwibWFwUHJvdmlkZXIiLCJnZXRQcm92aWRlckluc3RhbmNlIiwibG9hZEpTIiwiaW5pdCIsIlJlc3VsdFR5cGUiLCJFVkVOVCIsIkxPQ0FUSU9OIiwiUEVPUExFIiwiUmVzdWx0c0NvbXBvbmVudCIsIl9pdGVtQ29uZmlnIiwiZ2xvYmFsIiwicmVuZGVySXRlbSIsIml0ZW1UZW1wbGF0ZSIsImNvbmZpZ3VyZUl0ZW0iLCJfdW5pdmVyc2FsVXJsIiwidW5pdmVyc2FsVXJsIiwiaXNQcmVTZWFyY2giLCJpc1NlYXJjaExvYWRpbmciLCJpc1NlYXJjaENvbXBsZXRlIiwiaW5jbHVkZU1hcCIsIm1hcENvbmZpZyIsInNob3dOb1Jlc3VsdHMiLCJzZXRJdGVtUmVuZGVyIiwic2V0SXRlbVRlbXBsYXRlIiwiY2xhenoiLCJnZXRJdGVtQ29tcG9uZW50IiwiY29tcCIsIm5ld09wdHMiLCJnbG9iYWxDb25maWciLCJpdGVtQ29uZmlnIiwiaGFzR2xvYmFsUmVuZGVyIiwiaGFzR2xvYmFsVGVtcGxhdGUiLCJzZXRSZW5kZXIiLCJzZXRUZW1wbGF0ZSIsIkFjY29yZGlvblJlc3VsdHNDb21wb25lbnQiLCJfc2VsZWN0b3JCYXNlIiwic2VsZWN0b3JCYXNlIiwiY29sbGFwc2VkQ2xhc3MiLCJzZWxmRWwiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImFjY29yZGlvbkVscyIsImFjY29yZGlvbkVsIiwidG9nZ2xlRWwiLCJ0b2dnbGVTZWxlY3RvciIsImNvbnRlbnRFbCIsImJvZHlTZWxlY3RvciIsImNoYW5nZUhlaWdodCIsImhhbmRsZUNsaWNrIiwid3JhcHBlckVsIiwiaXNDb2xsYXBzZWQiLCJ0YXJnZXRFbCIsImhlaWdodCIsInNjcm9sbEhlaWdodCIsImJ1aWxkU2VsZWN0b3IiLCJVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IiwiX2xpbWl0IiwiY2hpbGRPcHRzIiwiZ2V0Q2hpbGRDb25maWciLCJ1c2VBY2NvcmRpb24iLCJkZWZhdWx0Q29uZmlnIiwiUGFnaW5hdGlvbkNvbXBvbmVudCIsIl9maXJzdFBhZ2VCdXR0b25FbmFibGVkIiwic2hvd0ZpcnN0IiwiX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCIsInNob3dMYXN0Iiwic2hvd0NvbnRyb2xzIiwicHJldmlvdXNQYWdlQnV0dG9uIiwibmV4dFBhZ2VCdXR0b24iLCJtYXhQYWdlIiwidHJ1bmMiLCJ1cGRhdGVQYWdlIiwiZmlyc3RQYWdlQnV0dG9uIiwibGFzdFBhZ2VCdXR0b24iLCJzY3JvbGxUb1RvcCIsInZlcnRpY2FsUGFnZSIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbFRvcCIsInBhZ2VOdW1iZXIiLCJpc01vcmVSZXN1bHRzIiwiZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCIsImxhc3RQYWdlQnV0dG9uRW5hYmxlZCIsInNob3dGaXJzdFBhZ2VCdXR0b24iLCJzaG93UHJldmlvdXNQYWdlQnV0dG9uIiwic2hvd05leHRQYWdlQnV0dG9uIiwic2hvd0xhc3RQYWdlQnV0dG9uIiwiUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50IiwidmFsaWRhdGVDb25maWciLCJvblJlc3VsdHNVcGRhdGUiLCJ0cmlnZ2VyRWwiLCJiaW5kRm9ybVRvZ2dsZSIsImJpbmRGb3JtRm9jdXMiLCJiaW5kRm9ybVN1Ym1pdCIsImdldEFuYWx5dGljc0V2ZW50IiwiZm9ybURhdGEiLCJpbnB1dEZpZWxkcyIsIm9iaiIsImNoZWNrVmFsaWRpdHkiLCJ2YWxpZGl0eSIsInZhbHVlTWlzc2luZyIsImVtYWlsRm9ybWF0RXJyb3JUZXh0IiwicHJpdmFjeVBvbGljeUVycm9yVGV4dCIsImFuYWx5dGljc0V2ZW50IiwiU1ZHSWNvbiIsInBhdGgiLCJjb21wbGV4Q29udGVudHMiLCJ2aWV3Qm94IiwiY29udGVudHMiLCJwYXRoRGVmaW5pdGlvbiIsImljb25zQXJyYXkiLCJ0aHVtYkljb24iLCJyZWNlaXB0SWNvbiIsInBhbnRoZW9uSWNvbiIsIm1pY0ljb24iLCJkaXJlY3Rpb25zSWNvbiIsImNhbGVuZGFySWNvbiIsImNhbGxvdXRJY29uIiwiaW5mb0ljb24iLCJicmllZmNhc2VJY29uIiwia2Fib2JJY29uIiwicGVyc29uSWNvbiIsIm1hZ25pZnlpbmdHbGFzc0ljb24iLCJvZmZpY2VJY29uIiwibGlua0ljb24iLCJ3aW5kb3dJY29uIiwicGhvbmVJY29uIiwidGFnSWNvbiIsImRvY3VtZW50SWNvbiIsImNoZXZyb25JY29uIiwic3VwcG9ydEljb24iLCJ5ZXh0SWNvbiIsInBpbkljb24iLCJnZWFySWNvbiIsImxpZ2h0QnVsYkljb24iLCJJY29ucyIsIm1hcmt1cCIsInN0YXJJY29uIiwiSWNvbkNvbXBvbmVudCIsImljb25OYW1lIiwiY3VzdG9tSWNvbiIsImljb25VcmwiLCJDT01QT05FTlRfQ0xBU1NfTElTVCIsIkNPTVBPTkVOVF9SRUdJU1RSWSIsInJlZ2lzdHJ5IiwiQ29tcG9uZW50TWFuYWdlciIsIl9hY3RpdmVDb21wb25lbnRzIiwiX2NvcmUiLCJfYW5hbHl0aWNzUmVwb3J0ZXIiLCJyZXBvcnRlciIsImNvbXBvbmVudENsYXp6IiwiY29tcG9uZW50VHlwZSIsImNvbXBvbmVudENsYXNzIiwiYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkIiwic29tZSIsImZpbmRJbmRleCIsInNwbGljZSIsIlRhYkNvbmZpZyIsInRhYkNvbmZpZ3MiLCJOYXZpZ2F0aW9uQ29uZmlnIiwiREVGQVVMVFMiLCJBbnN3ZXJzIiwiY29tcG9uZW50cyIsIl9vblJlYWR5IiwiX2VsaWdpYmxlRm9yQW5hbHl0aWNzIiwiX3NlcnZpY2VzIiwiX2FuYWx5dGljc1JlcG9ydGVyU2VydmljZSIsInBhcnNlZENvbmZpZyIsInBhcnNlQ29uZmlnIiwibmF2aWdhdGlvbiIsIm9uU3RhdGVDaGFuZ2UiLCJzZXRBbGwiLCJtb2NrIiwiZ2V0TW9ja1NlcnZpY2VzIiwiZ2V0U2VydmljZXMiLCJzdWJzdHIiLCJzZXRDb3JlIiwic2V0UmVuZGVyZXIiLCJzZXRBbmFseXRpY3NSZXBvcnRlciIsImluaXRTY3JvbGxMaXN0ZW5lciIsIl9zZXREZWZhdWx0SW5pdGlhbFNlYXJjaCIsIm9uUmVhZHkiLCJ1c2VUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZUJ1bmRsZSIsInNhbmRib3hQcmVmaXgiLCJyZWdpc3RlciIsInJlbW92ZUJ5TmFtZSIsIm9wdEluIiwic2V0Q29udmVyc2lvblRyYWNraW5nRW5hYmxlZCIsInNlYXJjaENvbmZpZyIsInByZXBvcHVsYXRlZFF1ZXJ5IiwiZXJyb3JSZXBvcnRlclNlcnZpY2UiLCJkZWJ1ZyIsInN1cHByZXNzRXJyb3JSZXBvcnRzIiwiREVCT1VOQ0VfVElNRSIsInRpbWVvdXQiLCJzZW5kRXZlbnQiLCJpbm5lckhlaWdodCIsInBhZ2VZT2Zmc2V0IiwiQU5TV0VSUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUE7O0VBRUE7Ozs7O0FBS0EscUJBQWU7RUFDYkEsRUFBQUEsVUFBVSxFQUFFLFlBREM7RUFFYkMsRUFBQUEsY0FBYyxFQUFFLGdCQUZIO0VBR2JDLEVBQUFBLGVBQWUsRUFBRTtFQUhKLENBQWY7O0VDUEE7TUFFcUJDLFNBQ25CLGtCQUF3QjtFQUFBLE1BQVhDLElBQVcsdUVBQUosRUFBSTs7RUFBQTs7RUFDdEI7Ozs7O0VBS0EsT0FBS0MsSUFBTCxHQUFZRCxJQUFJLENBQUNFLEdBQUwsSUFBWSxJQUF4QjtFQUVBOzs7Ozs7RUFLQSxPQUFLQyxVQUFMLEdBQWtCSCxJQUFJLENBQUNJLFNBQXZCO0VBRUE7Ozs7OztFQUtBLE9BQUtDLFlBQUwsR0FBb0JMLElBQUksQ0FBQ00sV0FBekI7RUFFQTs7Ozs7RUFJQSxPQUFLQyxPQUFMLEdBQWVQLElBQUksQ0FBQ08sT0FBTCxJQUFnQixJQUEvQjtFQUVBOzs7OztFQUlBLE9BQUtDLEtBQUwsR0FBYVIsSUFBSSxDQUFDUSxLQUFMLElBQWMsSUFBM0I7RUFFQTs7Ozs7RUFJQSxPQUFLQyxPQUFMLEdBQWVULElBQUksQ0FBQ1MsT0FBTCxJQUFnQixJQUEvQjtFQUVBOzs7OztFQUlBLE9BQUtDLElBQUwsR0FBWVYsSUFBSSxDQUFDVSxJQUFMLElBQWEsSUFBekI7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