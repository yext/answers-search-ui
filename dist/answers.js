var ANSWERS = (function (noConflict, _objectSpread2, _inheritsLoose, _wrapNativeSuper, _createClass, _assertThisInitialized) {
  'use strict';

  _objectSpread2 = _objectSpread2 && _objectSpread2.hasOwnProperty('default') ? _objectSpread2['default'] : _objectSpread2;
  _inheritsLoose = _inheritsLoose && _inheritsLoose.hasOwnProperty('default') ? _inheritsLoose['default'] : _inheritsLoose;
  _wrapNativeSuper = _wrapNativeSuper && _wrapNativeSuper.hasOwnProperty('default') ? _wrapNativeSuper['default'] : _wrapNativeSuper;
  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;
  _assertThisInitialized = _assertThisInitialized && _assertThisInitialized.hasOwnProperty('default') ? _assertThisInitialized['default'] : _assertThisInitialized;

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  var DOMException = self.DOMException;
  try {
    new DOMException();
  } catch (err) {
    DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
  }

  function fetch$1(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch$1.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch$1;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  /** @module SearchStates */

  /**
   * SearchStates is an ENUM for the various stages of searching,
   * used to show different templates
   * @enum {string}
   */
  var SearchStates = {
    PRE_SEARCH: 'pre-search',
    SEARCH_LOADING: 'search-loading',
    SEARCH_COMPLETE: 'search-complete'
  };

  /** @module Result */
  var Result = function Result(data) {
    if (data === void 0) {
      data = {};
    }

    /**
     * The raw profile data
     * @type {Object}
     * @private
     */
    this._raw = data.raw || null;
    /**
     * The formatted profile data
     * @type {Object}
     * @private
     */

    this._formatted = data.formatted;
    /**
     * The highlighted profile data with highlights applied to applicable fields
     * @type {Object}
     * @private
     */

    this._highlighted = data.highlighted;
    /**
     * The index number of the result
     * @type {Number}
     */

    this.ordinal = data.ordinal || null;
    /**
     * The title of the result card
     * @type {string|null}
     */

    this.title = data.title || null;
    /**
     * The body of the details section of the result card, can contain HTML
     * @type {string| null}
     */

    this.details = data.details || null;
    /**
     * The destination link for the title of the result card
     * @type {string|null}
     */

    this.link = data.link || null;
    /**
     * The Entity ID, or other unique identifier, used for to power interactivity
     * @type {string|null}
     */

    this.id = data.id || null;
    /**
     * The subtitle on the result card
     * @type {string|null}
     */

    this.subtitle = data.subtitle || null;
    /**
     * The class modifier, usually derived from the vertical configuration ID
     * Used to apply different styling to different result card types
     * @type {string|null}
     */

    this.modifier = data.modifier || null;
    /**
     * A large date, of the format { month: 'Jan', day: '01' }
     * @type {Object|null}
     */

    this.bigDate = data.bigDate || null;
    /**
     * An image profile object, expected to have a url property
     * @type {Object|null}
     */

    this.image = data.image || null;
    /**
     * An array of calls to action, of the format:
     * { icon: '', url: '', text: '', eventType: '', eventOptions: {}}
     * @type {Array}
     */

    this.callsToAction = data.callsToAction || [];
    /**
     * Determines if an accordian result should be collapsed by default
     * @type {boolean}
     */

    this.collapsed = data.collapsed === undefined ? true : data.collapsed;
  };

  /** @module HighlightedValue */

  /**
   * Model representing a highlighted value.
   */
  var HighlightedValue =
  /*#__PURE__*/
  function () {
    function HighlightedValue(data) {
      if (data === void 0) {
        data = {};
      }

      this.value = data.value || data.shortValue || '';
      this.matchedSubstrings = data.matchedSubstrings || [];
    }
    /**
     * get highlighted value string
     * @returns {string}
     */


    var _proto = HighlightedValue.prototype;

    _proto.get = function get() {
      this._sortMatchedSubstrings();

      return this.buildHighlightedValue(this.value, this.matchedSubstrings);
    }
    /**
     * get inverted highlighted value string
     * @returns {string}
     */
    ;

    _proto.getInverted = function getInverted() {
      this._sortMatchedSubstrings();

      var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

      return this.buildHighlightedValue(this.value, invertedSubstrings);
    }
    /**
     * introduces highlighting to input data according to highlighting specifiers
     *
     * @param {Object} val input object to apply highlighting to
     *
     *  example object :
     *  {
     *    name: 'ATM',
     *    featuredMessage: {
     *      description: 'Save time & bank on your terms at over 1,800 ATMs'
     *    }
     *  }
     *
     * @param {Object} highlightedSubstrings highlighting specifiers to apply to input object
     *
     *  example object :
     *  {
     *    name: {
     *      matchedSubstrings: [{
     *        length: 3,
     *        offset: 0
     *      }],
     *      value: 'ATM'
     *    },
     *    featuredMessage: {
     *      description: {
     *        matchedSubstrings: [{
     *          length: 4,
     *          offset: 45
     *        }],
     *        value: 'Save time & bank on your terms at over 1,800 ATMs'
     *      }
     *    }
     *  }
     *
     * @returns {string} copy of input value with highlighting applied
     *
     *  example object :
     *  {
     *    name: '<strong>ATM</strong>',
     *    featuredMessage: {
     *      description: 'Save time & bank on your terms at over 1,800 <strong>ATMs</strong>'
     *    }
     *  }
     *
     */
    ;

    _proto.buildHighlightedValue = function buildHighlightedValue(val, highlightedSubstrings) {
      var highlightedValue = '';
      var nextStart = 0;

      if (highlightedSubstrings.length === 0) {
        return val;
      }

      for (var j = 0; j < highlightedSubstrings.length; j++) {
        var start = Number(highlightedSubstrings[j].offset);
        var end = start + highlightedSubstrings[j].length;
        highlightedValue += [val.slice(nextStart, start), '<strong>', val.slice(start, end), '</strong>'].join('');

        if (j === highlightedSubstrings.length - 1 && end < val.length) {
          highlightedValue += val.slice(end);
        }

        nextStart = end;
      }

      return highlightedValue;
    };

    _proto._sortMatchedSubstrings = function _sortMatchedSubstrings() {
      this.matchedSubstrings.sort(function (a, b) {
        if (a.offset < b.offset) {
          return -1;
        }

        if (a.offset > b.offset) {
          return 1;
        }

        return 0;
      });
    };

    _proto._getInvertedSubstrings = function _getInvertedSubstrings(matchedSubstrings, valueLength) {
      var invertedSubstrings = [];

      for (var i = 0; i < matchedSubstrings.length; i++) {
        var substring = matchedSubstrings[i];
        var nextOffset = substring.offset + substring.length;

        if (i === 0 && substring.offset !== 0) {
          invertedSubstrings.push({
            offset: 0,
            length: substring.offset
          });
        }

        if (valueLength > nextOffset) {
          invertedSubstrings.push({
            offset: nextOffset,
            length: i < matchedSubstrings.length - 1 ? matchedSubstrings[i + 1].offset - nextOffset : valueLength - nextOffset
          });
        }
      }

      return invertedSubstrings;
    };

    return HighlightedValue;
  }();

  /** @module Errors */

  /**
   * AnswersBaseError is an extension of the base Error object.
   * This is the object that is used to when reporting to the server.
   * @extends Error
   *
   * Error codes fall into one of four categories:
   * 1XX errors: Basic errors
   * 2XX errors: UI errors
   * 3XX errors: Endpoint errors
   * 4XX errors: Core errors
   */
  var AnswersBaseError =
  /*#__PURE__*/
  function (_Error) {
    _inheritsLoose(AnswersBaseError, _Error);

    function AnswersBaseError(errorCode, message, boundary, causedBy) {
      var _this;

      if (boundary === void 0) {
        boundary = 'unknown';
      }

      _this = _Error.call(this, message) || this;
      _this.errorCode = errorCode;
      _this.errorMessage = message;
      _this.boundary = boundary;
      _this.reported = false;

      if (causedBy) {
        _this.causedBy = causedBy instanceof AnswersBaseError ? causedBy : AnswersBaseError.from(causedBy);
        _this.stack = _this.stack + "\nCaused By: " + _this.causedBy.stack;
      }

      return _this;
    }

    var _proto = AnswersBaseError.prototype;

    _proto.toJson = function toJson() {
      return JSON.stringify(this);
    };

    _proto.toString = function toString() {
      var string = this.errorMessage + " (" + this.boundary + ")";

      if (this.causedBy) {
        string += "\n  Caused By: " + this.causedBy.toString();
      }

      return string;
    };

    AnswersBaseError.from = function from(builtinError, boundary) {
      var error = new AnswersBasicError(builtinError.message, boundary);
      error.stack = builtinError.stack;
      return error;
    };

    return AnswersBaseError;
  }(_wrapNativeSuper(Error));
  /**
   * AnswersBasicError is a wrapper around all the built-in errors
   * e.g. undefined variables, incorrect syntax, types, missing methods, etc.
   * @extends AnswersBaseError
   */

  var AnswersBasicError =
  /*#__PURE__*/
  function (_AnswersBaseError) {
    _inheritsLoose(AnswersBasicError, _AnswersBaseError);

    function AnswersBasicError(message, boundary, causedBy) {
      return _AnswersBaseError.call(this, 100, message, boundary, causedBy) || this;
    }

    return AnswersBasicError;
  }(AnswersBaseError);
  /**
   * AnswersUiError used for things like DOM errors.
   * @extends AnswersBaseError
   */

  var AnswersConfigError =
  /*#__PURE__*/
  function (_AnswersBaseError2) {
    _inheritsLoose(AnswersConfigError, _AnswersBaseError2);

    function AnswersConfigError(message, boundary, causedBy) {
      return _AnswersBaseError2.call(this, 101, message, boundary, causedBy) || this;
    }

    return AnswersConfigError;
  }(AnswersBaseError);
  /**
   * AnswersComponentError is used for Component oriented errors
   * e.g. failure to render, or catching unknowns.
   * @extends AnswersBaseError
   */

  var AnswersComponentError =
  /*#__PURE__*/
  function (_AnswersBaseError4) {
    _inheritsLoose(AnswersComponentError, _AnswersBaseError4);

    function AnswersComponentError(message, component, causedBy) {
      return _AnswersBaseError4.call(this, 201, message, component, causedBy) || this;
    }

    return AnswersComponentError;
  }(AnswersBaseError);
  /**
   * AnswersEndpointError represents all network related errors.
   * @extends AnswersBaseError
   */

  var AnswersEndpointError =
  /*#__PURE__*/
  function (_AnswersBaseError5) {
    _inheritsLoose(AnswersEndpointError, _AnswersBaseError5);

    function AnswersEndpointError(message, boundary, causedBy) {
      return _AnswersBaseError5.call(this, 300, message, boundary, causedBy) || this;
    }

    return AnswersEndpointError;
  }(AnswersBaseError);
  /**
   * AnswersCoreError represents errors for precondition failures in the core library
   * @extends AnswersBaseError
   */

  var AnswersCoreError =
  /*#__PURE__*/
  function (_AnswersBaseError6) {
    _inheritsLoose(AnswersCoreError, _AnswersBaseError6);

    function AnswersCoreError(message, boundary, causedBy) {
      return _AnswersBaseError6.call(this, 400, message, boundary, causedBy) || this;
    }

    return AnswersCoreError;
  }(AnswersBaseError);
  /**
   * AnswersStorageError represents storage related errors
   * @extends AnswersBaseError
   */

  var AnswersStorageError =
  /*#__PURE__*/
  function (_AnswersBaseError7) {
    _inheritsLoose(AnswersStorageError, _AnswersBaseError7);

    function AnswersStorageError(message, storageKey, data, causedBy) {
      var _this2;

      _this2 = _AnswersBaseError7.call(this, 401, message, 'Storage', causedBy) || this;
      _this2.storageKey = storageKey;
      _this2.data = data;
      return _this2;
    }

    return AnswersStorageError;
  }(AnswersBaseError);
  /**
   * AnswersAnalyticsError is used for errors when reporting analytics
   * @extends AnswersBaseError
   */

  var AnswersAnalyticsError =
  /*#__PURE__*/
  function (_AnswersBaseError8) {
    _inheritsLoose(AnswersAnalyticsError, _AnswersBaseError8);

    function AnswersAnalyticsError(message, event, causedBy) {
      var _this3;

      _this3 = _AnswersBaseError8.call(this, 402, message, 'Analytics', causedBy) || this;
      _this3.event = event;
      return _this3;
    }

    return AnswersAnalyticsError;
  }(AnswersBaseError);

  /** @module ResultFactory */

  var ResultFactory =
  /*#__PURE__*/
  function () {
    function ResultFactory() {}

    /**
     * Converts an API result object into a Result view model.
     * Includes default mappings of GoogleCustomSearchEngine results to
     * the fields exposed by the template.
     * @param resultsData  {Array} expected format: { data: { ... }, highlightedFields: { ... }}
     * @param {Object.<string, function>} formatters The formatters to apply to the result
     * @param {string} verticalId The vertical of these results
     * @param {string} source Backend source of these results
     * @returns {Result[]}
     */
    ResultFactory.from = function from(resultsData, formatters, verticalId, source) {
      var results = [];

      for (var i = 0; i < resultsData.length; i++) {
        var data = resultsData[i].data || resultsData[i];

        switch (source) {
          case 'GOOGLE_CSE':
            results.push(ResultFactory.fromGoogleCustomSearchEngine(data));
            break;

          case 'BING_CSE':
            results.push(ResultFactory.fromBingCustomSearchEngine(data));
            break;

          case 'ZENDESK':
            results.push(ResultFactory.fromZendeskSearchEngine(data));
            break;

          case 'ALGOLIA':
            results.push(ResultFactory.fromAlgoliaSearchEngine(data));
            break;

          case 'KNOWLEDGE_MANAGER':
            var highlightedFields = resultsData[i].highlightedFields || {};
            results.push(ResultFactory.fromKnowledgeManager(data, formatters, verticalId, highlightedFields, i));
            break;

          default:
            results.push(ResultFactory.fromGeneric(data, i));
        }
      }

      return results;
    }
    /**
     * Applies field formatters to Knowledge Manager Entity Profile Data
     *
     * @param {Object} entityProfileData Entity Profile Data
     * @param {Object} formatters Developer specified Field Formatters
     * @param {string} verticalId Identifier for Vertical
     * @param {Object} highlightedEntityProfileData Subset of Entity Profile Data with highlighting applied
     * @returns {Object} Subset of Entity Profile Data Fields with field formatters applied
     */
    ;

    ResultFactory.computeFormattedData = function computeFormattedData(entityProfileData, formatters, verticalId, highlightedEntityProfileData) {
      // if no field formatters specified, nothing to format
      if (Object.keys(formatters).length === 0) {
        return {};
      }

      var formattedData = {};
      Object.entries(entityProfileData).forEach(function (_ref) {
        var fieldName = _ref[0],
            fieldVal = _ref[1];

        // check if a field formatter exists for the current entity profile field
        if (formatters[fieldName] === undefined) {
          return;
        } // verify the field formatter provided is a formatter function as expected


        if (typeof formatters[fieldName] !== 'function') {
          throw new AnswersCoreError('Field formatter is not of expected type function', 'ResultFactory');
        } // if highlighted version of field value is available, make it available to field formatter


        var highlightedFieldVal = null;

        if (highlightedEntityProfileData && highlightedEntityProfileData[fieldName]) {
          highlightedFieldVal = highlightedEntityProfileData[fieldName];
        } // call formatter function associated with the field name
        // the input object defines the interface that field formatter functions work with


        formattedData[fieldName] = formatters[fieldName]({
          entityProfileData: entityProfileData,
          entityFieldValue: fieldVal,
          highlightedEntityFieldValue: highlightedFieldVal,
          verticalId: verticalId,
          isDirectAnswer: false
        });
      });
      return formattedData;
    }
    /**
     * Applies highlighting to substrings within Knowledge Manager Entity Field Values
     * according to highlighting specifiers returned from the Knowledge Manager Search Backend
     *
     * @param {Object} entityProfileData Entity Profile Data
     * @param {Object} highlightedFields KM specified highlighting instructions to highlight certain Fields
     * @returns {Object} Subset of Entity Profile Data Fields with highlighting applied
     */
    ;

    ResultFactory.computeHighlightedData = function computeHighlightedData(entityProfileData, highlightedFields) {
      // if no highlighted fields specified, nothing to highlight
      if (Object.keys(highlightedFields).length === 0) {
        return {};
      }

      var highlightedData = {}; // iterate through entity fields that have highlighting instructions

      Object.entries(highlightedFields).forEach(function (_ref2) {
        var highlightedFieldName = _ref2[0];

        // verify that the highlighted field name corresponds to an existing entity profile field
        if (entityProfileData[highlightedFieldName] === undefined) {
          throw new AnswersCoreError('Highlighted Field Name does not exist in Entity Profile', 'ResultFactory');
        }

        var highlightedField = highlightedFields[highlightedFieldName]; // check for nested fields

        if (typeof highlightedField === 'object' && Object.keys(highlightedField).length > 0 && highlightedField['matchedSubstrings'] === undefined) {
          // recurse to children fields
          highlightedData[highlightedFieldName] = ResultFactory.computeHighlightedData(entityProfileData[highlightedFieldName], highlightedFields[highlightedFieldName]);
        } else {
          var highlightedDataValue = new HighlightedValue(entityProfileData).buildHighlightedValue(highlightedField.value, highlightedField.matchedSubstrings);
          highlightedData[highlightedFieldName] = highlightedDataValue;
        }
      });
      return highlightedData;
    }
    /**
     * Converts an API result object into a generic result view model.
     * @param {Object} data
     * @param {number} index
     * @returns {Result}
     */
    ;

    ResultFactory.fromGeneric = function fromGeneric(data, index) {
      return new Result({
        raw: data,
        title: data.name,
        details: this.truncate(data.description),
        link: data.website,
        id: data.id,
        ordinal: index + 1
      });
    }
    /**
     * Converts an API result object into a Knowledge Manager result view model.
     * @param {Object} data
     * @param {Object} formatters
     * @param {string} verticalId
     * @param {Object} highlightedFields
     * @param {number} index
     * @returns {Result}
     */
    ;

    ResultFactory.fromKnowledgeManager = function fromKnowledgeManager(data, formatters, verticalId, highlightedFields, index) {
      // compute highlighted entity profile data
      var highlightedEntityProfileData = ResultFactory.computeHighlightedData(data, highlightedFields); // compute formatted entity profile data

      var formattedEntityProfileData = ResultFactory.computeFormattedData(data, formatters, verticalId, highlightedEntityProfileData); // set result details checking the following in order of priority : formatted, highlighted, raw

      var resultDetails = null;

      if (formattedEntityProfileData.description !== undefined) {
        resultDetails = formattedEntityProfileData.description;
      } else if (highlightedEntityProfileData.description !== undefined) {
        resultDetails = this.truncate(highlightedEntityProfileData.description);
      } else {
        resultDetails = this.truncate(data.description);
      }

      return new Result({
        raw: data,
        formatted: formattedEntityProfileData,
        highlighted: highlightedEntityProfileData,
        title: formattedEntityProfileData.name || data.name,
        details: resultDetails,
        link: data.website,
        id: data.id,
        ordinal: index + 1
      });
    }
    /**
     * Converts an API result object into a result view model.
     * Maps view model fields based on the API data for a Google Custom Search Engine object.
     * @param {Object} data
     * @returns {Result}
     */
    ;

    ResultFactory.fromGoogleCustomSearchEngine = function fromGoogleCustomSearchEngine(data) {
      return new Result({
        raw: data,
        title: data.htmlTitle.replace(/(<([^>]+)>)/ig, ''),
        details: data.htmlSnippet,
        link: data.link
      });
    }
    /**
     * Converts an API result object into a result view model.
     * Maps view model fields based on the API data for a Bing Custom Search Engine object.
     * @param {Object} data
     * @returns {Result}
     */
    ;

    ResultFactory.fromBingCustomSearchEngine = function fromBingCustomSearchEngine(data) {
      return new Result({
        raw: data,
        title: data.name,
        details: data.snippet,
        link: data.url
      });
    }
    /**
     * Converts an API result object into a result view model.
     * Maps view model fields based on the API data for a Zendesk Search Engine object.
     * @param {Object} data
     * @returns {Result}
     */
    ;

    ResultFactory.fromZendeskSearchEngine = function fromZendeskSearchEngine(data) {
      return new Result({
        raw: data,
        title: data.title,
        details: data.snippet,
        link: data.html_url
      });
    }
    /**
     * Converts an API result object into a result view model.
     * Maps view model fields based on the API data for a Algolia Search Engine object.
     * Details field is set to objectID since response has only one general field objectID.
     * @param {Object} data
     * @returns {Result}
     */
    ;

    ResultFactory.fromAlgoliaSearchEngine = function fromAlgoliaSearchEngine(data) {
      return new Result({
        raw: data,
        details: data.objectID,
        id: data.objectID
      });
    }
    /**
     * Truncates strings to 250 characters, attempting to preserve whole words
     * @param str {string} the string to truncate
     * @param limit {Number} the maximum character length to return
     * @param trailing {string} a trailing string to denote truncation, e.g. '...'
     * @param sep {string} the word separator
     * @returns {string}
     */
    ;

    ResultFactory.truncate = function truncate(str, limit, trailing, sep) {
      if (limit === void 0) {
        limit = 250;
      }

      if (trailing === void 0) {
        trailing = '...';
      }

      if (sep === void 0) {
        sep = ' ';
      }

      if (!str || str.length <= limit) {
        return str;
      } // TODO (bmcginnis): split punctuation too so we don't end up with "foo,..."


      var words = str.split(sep);
      var max = limit - trailing.length;
      var truncated = '';

      for (var i = 0; i < words.length; i++) {
        var word = words[i];

        if (truncated.length + word.length > max || i !== 0 && truncated.length + word.length + sep.length > max) {
          truncated += trailing;
          break;
        }

        truncated += i === 0 ? word : sep + word;
      }

      return truncated;
    };

    return ResultFactory;
  }();

  /** @module Section */

  var Section =
  /*#__PURE__*/
  function () {
    function Section(data, url, formatters) {
      this.searchState = SearchStates.SEARCH_COMPLETE;
      this.verticalConfigId = data.verticalConfigId || null;
      this.resultsCount = data.resultsCount || 0;
      this.encodedState = data.encodedState || '';
      this.appliedQueryFilters = AppliedQueryFilter.from(data.appliedQueryFilters);
      this.facets = data.facets || null;
      this.results = ResultFactory.from(data.results, formatters, this.verticalConfigId, data.source);
      this.map = Section.parseMap(data.results);
      this.verticalURL = url || null;
    }

    Section.parseMap = function parseMap(results) {
      var mapMarkers = [];
      var centerCoordinates = {};

      for (var j = 0; j < results.length; j++) {
        // TODO(billy) Remove legacy fallback from all data format
        var result = results[j].data || results[j];

        if (result && result.yextDisplayCoordinate) {
          if (!centerCoordinates.latitude) {
            centerCoordinates = {
              latitude: result.yextDisplayCoordinate.latitude,
              longitude: result.yextDisplayCoordinate.longitude
            };
          }

          mapMarkers.push({
            item: result,
            label: mapMarkers.length + 1,
            latitude: result.yextDisplayCoordinate.latitude,
            longitude: result.yextDisplayCoordinate.longitude
          });
        }
      }

      return {
        'mapCenter': centerCoordinates,
        'mapMarkers': mapMarkers
      };
    }
    /**
     * Create a section from the provided data
     * @param {Object|Array} modules The result modules
     * @param {Object} urls The tab urls
     * @param {Object.<string, function>} formatters Field formatters for results
     */
    ;

    Section.from = function from(modules, urls, formatters) {
      var sections = [];

      if (!modules) {
        return sections;
      }

      if (!Array.isArray(modules)) {
        return new Section(modules, null, formatters);
      } // Our sections should contain a property of mapMarker objects


      for (var i = 0; i < modules.length; i++) {
        sections.push(new Section(modules[i], urls[modules[i].verticalConfigId], formatters));
      }

      return sections;
    };

    return Section;
  }();

  var AppliedQueryFilter =
  /*#__PURE__*/
  function () {
    // Support legacy model and new model until fully migrated.
    // TODO(billy) Remove the left expression during assignment when migrated.
    function AppliedQueryFilter(appliedQueryFilter) {
      this.key = appliedQueryFilter.key || appliedQueryFilter.displayKey;
      this.value = appliedQueryFilter.value || appliedQueryFilter.displayValue;
    }

    AppliedQueryFilter.from = function from(appliedQueryFilters) {
      var filters = [];

      for (var i = 0; i < appliedQueryFilters.length; i++) {
        filters.push(new AppliedQueryFilter(appliedQueryFilters[i]));
      }

      return filters;
    };

    return AppliedQueryFilter;
  }();

  /** @module UniversalResults */

  var UniversalResults =
  /*#__PURE__*/
  function () {
    function UniversalResults(data) {
      this.queryId = data.queryId || null;
      this.sections = data.sections || [];
      /**
       * The current state of the search, used to render different templates before, during,
       * and after loading
       * @type {string}
       */

      this.searchState = data.searchState || SearchStates.SEARCH_COMPLETE;
    }
    /**
     * Create universal results from server data
     * @param {Object} response The server response
     * @param {Object} urls The tab urls
     * @param {Object.<string, function>} formatters The field formatters to use
     */


    UniversalResults.from = function from(response, urls, formatters) {
      return new UniversalResults({
        queryId: response.queryId,
        sections: Section.from(response.modules, urls, formatters)
      });
    }
    /**
     * Construct a UnivervalResults object representing loading results
     * @return {UniversalResults}
     */
    ;

    UniversalResults.searchLoading = function searchLoading() {
      return new UniversalResults({
        searchState: SearchStates.SEARCH_LOADING
      });
    };

    return UniversalResults;
  }();

  /** @module DirectAnswer */
  var DirectAnswer =
  /*#__PURE__*/
  function () {
    function DirectAnswer(directAnswer) {
      if (directAnswer === void 0) {
        directAnswer = {};
      }

      Object.assign(this, directAnswer);
      Object.freeze(this);
    }
    /**
     * Create a DirectAnswer model from the given server data and formatters
     * @param {Object} response The server direct answer
     * @param {Object.<string, function>} formatters The formatters to apply to this direct answer
     */


    DirectAnswer.from = function from(response, formatters) {
      var data = _objectSpread2({}, response);

      var answer = data.answer,
          relatedItem = data.relatedItem;

      if (answer && formatters[answer.fieldApiName]) {
        answer.value = formatters[answer.fieldApiName](answer.value, relatedItem.data.fieldValues, relatedItem.verticalConfigId, true);
      }

      return new DirectAnswer(data);
    };

    return DirectAnswer;
  }();

  /** @module Navigation */
  var Navigation =
  /*#__PURE__*/
  function () {
    function Navigation(tabOrder) {
      this.tabOrder = tabOrder || [];
      Object.freeze(this);
    }

    Navigation.from = function from(modules) {
      var nav = [];

      if (!modules || !Array.isArray(modules)) {
        return nav;
      }

      for (var i = 0; i < modules.length; i++) {
        nav.push(modules[i].verticalConfigId);
      }

      return new Navigation(nav);
    };

    return Navigation;
  }();

  var VerticalResults =
  /*#__PURE__*/
  function () {
    function VerticalResults(data) {
      if (data === void 0) {
        data = {};
      }

      Object.assign(this, {
        searchState: SearchStates.SEARCH_COMPLETE
      }, data);
      Object.freeze(this);
    }
    /**
     * Append the provided results to the current results
     * @param {VerticalResults} results the results to append to the current results
     */


    var _proto = VerticalResults.prototype;

    _proto.append = function append(results) {
      var merged = _objectSpread2({}, this);

      merged.results = this.results.concat(results.results);
      merged.map.mapMarkers = this.map.mapMarkers.concat(results.map.mapMarkers);
      return new VerticalResults(merged);
    }
    /**
     * Create vertical results from server data
     * @param {Object} response The server response
     * @param {Object.<string, function>} formatters The field formatters to use
     */
    ;

    VerticalResults.from = function from(response, formatters) {
      return new VerticalResults(Section.from(response, null, formatters));
    }
    /**
     * Construct a VerticalResults object representing loading results
     * @return {VerticalResults}
     */
    ;

    VerticalResults.searchLoading = function searchLoading() {
      return new VerticalResults({
        searchState: SearchStates.SEARCH_LOADING
      });
    };

    VerticalResults.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    };

    return VerticalResults;
  }();

  /** @module SpellCheck */
  /**
   * SpellCheck is the core state model
   * to power the SpellCheck component
   */

  var SpellCheck =
  /*#__PURE__*/
  function () {
    function SpellCheck(data) {
      /**
       * The original query
       * @type {string}
       */
      this.query = data.query || null;
      /**
       * The corrected query
       * @type {string}
       */

      this.correctedQuery = data.correctedQuery || null;
      /**
       * The corrected query with highlighted tags
       * @type {string}
       */

      this.correctedQueryDisplay = data.correctedQueryDisplay || null;
      /**
       * The spell check type
       * @type {string}
       */

      this.type = data.type || null;
      /**
       * Should show spell check or not
       * @type {boolean}
       */

      this.shouldShow = this.correctedQuery !== null;
    }
    /**
     * Create a spell check model from the provided data
     * @param {Object} response The spell check response
     */


    SpellCheck.from = function from(response) {
      if (!response) {
        return {};
      }

      return new SpellCheck({
        query: response.originalQuery,
        correctedQuery: response.correctedQuery,
        correctedQueryDisplay: new HighlightedValue(response.correctedQuery).get(),
        type: response.type
      });
    };

    return SpellCheck;
  }();

  /** @module StorageKeys */

  /**
   * StorageKeys is an ENUM are considered the root context
   * for how data is stored and scoped in the storage.
   *
   * @enum {string}
   */
  var StorageKeys = {
    NAVIGATION: 'navigation',
    UNIVERSAL_RESULTS: 'universal-results',
    VERTICAL_RESULTS: 'vertical-results',
    AUTOCOMPLETE: 'autocomplete',
    DIRECT_ANSWER: 'direct-answer',
    FILTER: 'filter',
    QUERY: 'query',
    QUERY_ID: 'query-id',
    FACET_FILTER: 'facet-filter',
    DYNAMIC_FILTERS: 'dynamic-filters',
    PARAMS: 'params',
    GEOLOCATION: 'geolocation',
    INTENTS: 'intents',
    QUESTION_SUBMISSION: 'question-submission',
    SEARCH_CONFIG: 'search-config',
    SEARCH_OFFSET: 'search-offset',
    SPELL_CHECK: 'spell-check',
    LOCATION_BIAS: 'location-bias',
    SESSIONS_OPT_IN: 'sessions-opt-in',
    NAVIGATION_CONFIG: 'navigation-config',
    LOCALE: 'locale',
    SORT_BYS: 'sort-bys'
  };

  /** @module DynamicFilters */

  /**
   * Model representing a set of dynamic filters
   */
  var DynamicFilters =
  /*#__PURE__*/
  function () {
    function DynamicFilters(data) {
      /**
       * The list of filters this model holds
       * @type {{label: string, fieldId: string, options: object[]}}
       */
      this.filters = data.filters || [];
      Object.freeze(this);
    }
    /**
     * Organize 'facets' from the api response into dynamic filters
     * @param {Object} response dynamic filter response from the api
     * @returns {DynamicFilters}
     */


    DynamicFilters.from = function from(response) {
      var facets = response.facets;
      var dynamicFilters = facets.map(function (f) {
        return {
          label: f['displayName'],
          fieldId: f['fieldId'],
          options: f.options.map(function (o) {
            return {
              label: o['displayName'],
              countLabel: o['count'],
              selected: o['selected'],
              filter: o['filter']
            };
          })
        };
      });
      return new DynamicFilters({
        filters: dynamicFilters
      });
    };

    return DynamicFilters;
  }();

  /** @module SearchIntents */
  var SearchIntents =
  /*#__PURE__*/
  function () {
    function SearchIntents(intents) {
      /**
       * The intent to find results based on the user's location
       * @type {boolean}
       */
      this.nearMe = intents.nearMe;
      Object.freeze(this);
    }
    /**
     * Create SearchIntents from server response
     * @param {Object} response The server response intents
     * @returns {SearchIntents}
     */


    SearchIntents.from = function from(response) {
      var intents = response || [];
      return new SearchIntents({
        nearMe: intents.includes('NEAR_ME')
      });
    };

    return SearchIntents;
  }();

  /** @module LocationBias */

  /**
   * LocationBias is the core state model
   * to power the LocationBias component
   */
  var LocationBias =
  /*#__PURE__*/
  function () {
    function LocationBias(data) {
      /**
       * The location bias accuracy which are IP, DEVICE and UNKNWON
       * @type {string}
       */
      this.accuracy = data.accuracy || null;
      /**
       * The latitude used for location bias
       * @type {number}
       */

      this.latitude = data.latitude || null;
      /**
       * The longitude used for location bias
       * @type {number}
       */

      this.longitude = data.longitude || null;
      /**
       * The location display name
       * @type {string}
       */

      this.locationDisplayName = data.locationDisplayName || null;
    }
    /**
     * Create a location bias model from the provided data
     * @param {Object} response The location bias response
     */


    LocationBias.from = function from(response) {
      if (!response) {
        return new LocationBias({
          accuracy: 'UNKNOWN'
        });
      }

      return new LocationBias({
        accuracy: response.accuracy,
        latitude: response.latitude,
        longitude: response.longitude,
        locationDisplayName: response.locationDisplayName
      });
    };

    return LocationBias;
  }();

  /** @module SearchDataTransformer */
  /**
   * A Data Transformer that takes the response object from a Search request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   */

  var SearchDataTransformer =
  /*#__PURE__*/
  function () {
    function SearchDataTransformer() {}

    SearchDataTransformer.transform = function transform(data, urls, formatters) {
      var _ref;

      if (urls === void 0) {
        urls = {};
      }

      var response = data.response;
      return _ref = {}, _ref[StorageKeys.QUERY_ID] = response.queryId, _ref[StorageKeys.NAVIGATION] = Navigation.from(response.modules), _ref[StorageKeys.DIRECT_ANSWER] = DirectAnswer.from(response.directAnswer, formatters), _ref[StorageKeys.UNIVERSAL_RESULTS] = UniversalResults.from(response, urls, formatters), _ref[StorageKeys.INTENTS] = SearchIntents.from(response.searchIntents), _ref[StorageKeys.SPELL_CHECK] = SpellCheck.from(response.spellCheck), _ref[StorageKeys.LOCATION_BIAS] = LocationBias.from(response.locationBias), _ref;
    };

    SearchDataTransformer.transformVertical = function transformVertical(data, formatters) {
      var _ref2;

      return _ref2 = {}, _ref2[StorageKeys.QUERY_ID] = data.response.queryId, _ref2[StorageKeys.NAVIGATION] = new Navigation(), _ref2[StorageKeys.VERTICAL_RESULTS] = VerticalResults.from(data.response, formatters), _ref2[StorageKeys.DYNAMIC_FILTERS] = DynamicFilters.from(data.response), _ref2[StorageKeys.INTENTS] = SearchIntents.from(data.response.searchIntents), _ref2[StorageKeys.SPELL_CHECK] = SpellCheck.from(data.response.spellCheck), _ref2[StorageKeys.LOCATION_BIAS] = LocationBias.from(data.response.locationBias), _ref2;
    };

    return SearchDataTransformer;
  }();

  /** @module QuestionSubmission */

  /**
   * QuestionSubmission is the core state model
   * to power the QuestionSubmission component
   */
  var QuestionSubmission =
  /*#__PURE__*/
  function () {
    function QuestionSubmission(question, errors) {
      if (question === void 0) {
        question = {};
      }

      /**
       * The author of the question
       * @type {string}
       */
      this.name = question.name || null;
      /**
       * The email address of the question
       * @type {string}
       */

      this.email = question.email || null;
      /**
       * True if the privacy policy was approved
       * @type {boolean}
       */

      this.privacyPolicy = question.privacyPolicy || null;
      /**
       * The question to be sent to the server
       * @type {string}
       */

      this.questionText = question.questionText || null;
      /**
       * Alternative question meta information
       * @type {string}
       */

      this.questionDescription = question.questionDescription || null;
      /**
       * Whether the form is expanded or not. Defaults to true.
       */

      this.questionExpanded = typeof question.expanded !== 'boolean' || question.expanded;
      /**
       * Contains any errors about the question submission
       * @type {object}
       */

      this.errors = errors || null;
      /**
       * Whether the form has been submitted or not. Defaults to false.
       */

      this.questionSubmitted = question.submitted || false;
      Object.freeze(this);
    }

    QuestionSubmission.submitted = function submitted() {
      return {
        questionSubmitted: true,
        questionExpanded: true
      };
    };

    QuestionSubmission.errors = function errors(question, _errors) {
      return QuestionSubmission(question, _errors);
    };

    return QuestionSubmission;
  }();

  /** @module Filter */

  /**
   * Represents an api filter and provides static methods for easily constructing Filters.
   * See https://developer.yext.com/docs/api-reference/#operation/listEntities for structure details
   */
  var Filter =
  /*#__PURE__*/
  function () {
    function Filter(data) {
      if (data === void 0) {
        data = {};
      }

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Parse a JSON format filter returned from the server into a Filter
     * @param {*} responseFilter A filter in JSON format returned from the backend
     * @returns {Filter}
     */


    Filter.fromResponse = function fromResponse(responseFilter) {
      return new Filter(JSON.parse(responseFilter));
    }
    /**
     * Return a new Filter representing the OR of all provided filters
     * @param  {...Filter} filters The filters to OR together
     * @returns {Filter}
     */
    ;

    Filter.or = function or() {
      for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
        filters[_key] = arguments[_key];
      }

      return new Filter({
        '$or': filters
      });
    }
    /**
     * Return a new Filter representing the AND of all provided filters
     * @param  {...Filter} filters The filters to AND together
     * @returns {Filter}
     */
    ;

    Filter.and = function and() {
      for (var _len2 = arguments.length, filters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        filters[_key2] = arguments[_key2];
      }

      return new Filter({
        '$and': filters
      });
    }
    /**
     * OR filters with the same keys, then AND the resulting groups
     * @param  {...Filter} filters The filters to group
     * @returns {Filter}
     */
    ;

    Filter.group = function group() {
      var groups = {};

      for (var _len3 = arguments.length, filters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        filters[_key3] = arguments[_key3];
      }

      for (var _i = 0, _filters = filters; _i < _filters.length; _i++) {
        var filter = _filters[_i];
        var key = Object.keys(filter)[0];

        if (!groups[key]) {
          groups[key] = [];
        }

        groups[key].push(filter);
      }

      var groupFilters = [];

      for (var _i2 = 0, _Object$keys = Object.keys(groups); _i2 < _Object$keys.length; _i2++) {
        var field = _Object$keys[_i2];
        groupFilters.push(groups[field].length > 1 ? Filter.or.apply(Filter, groups[field]) : groups[field][0]);
      }

      return groupFilters.length > 1 ? Filter.and.apply(Filter, groupFilters) : groupFilters[0];
    }
    /**
     * Create a new "equal to" filter for a field
     * @param {string} field The subject field of the filter
     * @param {*} value The value the field should be equal to
     * @returns {Filter}
     */
    ;

    Filter.equal = function equal(field, value) {
      return Filter._fromMatcher(field, '$eq', value);
    }
    /**
     * Create a new "less than" filter for a field
     * @param {string} field The subject field of the filter
     * @param {*} value The value the field should be less than
     * @returns {Filter}
     */
    ;

    Filter.lessThan = function lessThan(field, value) {
      return Filter._fromMatcher(field, '$lt', value);
    }
    /**
     * Create a new "less than or equal to" filter for a field
     * @param {string} field The subject field of the filter
     * @param {*} value The value the field should be less than or equal to
     * @returns {Filter}
     */
    ;

    Filter.lessThanEqual = function lessThanEqual(field, value) {
      return Filter._fromMatcher(field, '$le', value);
    }
    /**
     * Create a new "greater than" filter for a field
     * @param {string} field The subject field of the filter
     * @param {*} value The value the field should be greater than
     * @returns {Filter}
     */
    ;

    Filter.greaterThan = function greaterThan(field, value) {
      return Filter._fromMatcher(field, '$gt', value);
    }
    /**
     * Create a new "greater than or equal to" filter for a field
     * @param {string} field The subject field of the filter
     * @param {*} value The value the field should be greater than or equal to
     * @returns {Filter}
     */
    ;

    Filter.greaterThanEqual = function greaterThanEqual(field, value) {
      return Filter._fromMatcher(field, '$ge', value);
    }
    /**
     * Create a new inclusive range filter
     * @param {string} field The subject field of the filter
     * @param {*} min The minimum value
     * @param {*} max The maximum value
     * @returns {Filter}
     */
    ;

    Filter.inclusiveRange = function inclusiveRange(field, min, max) {
      var _ref;

      return new Filter((_ref = {}, _ref[field] = {
        '$ge': min,
        '$le': max
      }, _ref));
    }
    /**
     * Create a new exclusive range filter
     * @param {string} field The subject field of the filter
     * @param {*} min The minimum value
     * @param {*} max The maximum value
     * @returns {Filter}
     */
    ;

    Filter.exclusiveRange = function exclusiveRange(field, min, max) {
      var _ref2;

      return new Filter((_ref2 = {}, _ref2[field] = {
        '$gt': min,
        '$lt': max
      }, _ref2));
    }
    /**
     * Create a new position filter
     * @param {number} lat The latitude of the position
     * @param {number} lng The longitude of the position
     * @param {number} radius The search radius (in meters)
     */
    ;

    Filter.position = function position(lat, lng, radius) {
      return Filter._fromMatcher('builtin.location', '$near', {
        lat: lat,
        lng: lng,
        radius: radius
      });
    }
    /**
     * Create a new filter with the given matcher
     * @private
     * @param {string} field The subject field of the filter
     * @param {string} matcher The matcher for the filer
     * @param {*} value The value for the filter
     * @returns {Filter}
     */
    ;

    Filter._fromMatcher = function _fromMatcher(field, matcher, value) {
      var _field, _ref3;

      return new Filter((_ref3 = {}, _ref3[field] = (_field = {}, _field[matcher] = value, _field), _ref3));
    };

    return Filter;
  }();

  /** @typedef {import('./services/searchservice').default} SearchService */

  /** @typedef {import('./services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./services/questionanswerservice').default} QuestionAnswerService */

  /**
   * Core is the main application container for all of the network and storage
   * related behaviors of the application.
   */

  var Core =
  /*#__PURE__*/
  function () {
    function Core(config) {
      if (config === void 0) {
        config = {};
      }

      /**
       * A reference to the client API Key used for all requests
       * @type {string}
       * @private
       */
      this._apiKey = config.apiKey;
      /**
       * A reference to the client Answers Key used for all requests
       * @type {string}
       * @private
       */

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * A reference to the client locale used for all requests. If not specified, defaults to "en" (for
       * backwards compatibility).
       * @type {string}
       * @private
       */

      this._locale = config.locale;
      /**
       * A map of field formatters used to format results, if present
       * @type {Object.<string, function>}
       * @private
       */

      this._fieldFormatters = config.fieldFormatters || {};
      /**
       * A reference to the core data storage that powers the UI
       * @type {GlobalStorage}
       * @private
       */

      this.globalStorage = config.globalStorage;
      /**
       * A reference to the core persistent storage
       * @type {PersistentStorage}
       * @private
       */

      this.persistentStorage = config.persistentStorage;
      /**
       * An abstraction containing the integration with the RESTful search API
       * For both vertical and universal search
       * @type {SearchService}
       * @private
       */

      this._searcher = config.searchService;
      /**
       * An abstraction containing the integration with the RESTful autocomplete API
       * For filter search, vertical autocomplete, and universal autocomplete
       * @type {AutoCompleteService}
       * @private
       */

      this._autoComplete = config.autoCompleteService;
      /**
       * An abstraction for interacting with the Q&A rest interface
       * @type {QuestionAnswerService}
       * @private
       */

      this._questionAnswer = config.questionAnswerService;
    }
    /**
     * Search in the context of a vertical
     * @param {string} verticalKey vertical ID for the search
     * @param {object} query The query details
     * @param {string} query.input The input to search for
     * @param {string} query.filter The filter to use in the search
     * @param {string} query.facetFilter The facet filter to use in the search
     * @param {number} query.limit The max number of results to include, max of 50
     * @param {number} query.offset The results offset, for fetching more results of the same query
     * @param {string} query.id The query ID to use. If paging within a query, the same ID should be used
     * @param {boolean} query.append If true, adds the results of this query to the end of the current results, defaults false
     */


    var _proto = Core.prototype;

    _proto.verticalSearch = function verticalSearch(verticalKey, query) {
      var _this = this;

      if (!query.append) {
        this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading());
        this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
        this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
      }

      return this._searcher.verticalSearch(verticalKey, _objectSpread2({
        limit: this.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit,
        geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION)
      }, query, {
        isDynamicFiltersEnabled: this._isDynamicFiltersEnabled,
        skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
        queryTrigger: this.globalStorage.getState('queryTrigger'),
        sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN),
        sortBys: this.globalStorage.getState(StorageKeys.SORT_BYS)
      })).then(function (response) {
        return SearchDataTransformer.transformVertical(response, _this._fieldFormatters);
      }).then(function (data) {
        _this.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

        _this.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

        _this.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

        if (query.append) {
          var mergedResults = _this.globalStorage.getState(StorageKeys.VERTICAL_RESULTS).append(data[StorageKeys.VERTICAL_RESULTS]);

          _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, mergedResults);
        } else {
          _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, data[StorageKeys.VERTICAL_RESULTS]);
        }

        if (data[StorageKeys.DYNAMIC_FILTERS]) {
          _this.globalStorage.set(StorageKeys.DYNAMIC_FILTERS, data[StorageKeys.DYNAMIC_FILTERS]);
        }

        if (data[StorageKeys.SPELL_CHECK]) {
          _this.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);
        }

        if (data[StorageKeys.LOCATION_BIAS]) {
          _this.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);
        }

        _this.globalStorage["delete"]('skipSpellCheck');

        _this.globalStorage["delete"]('queryTrigger');
      });
    }
    /**
     * Page within the results of the last query
     * @param {string} verticalKey The vertical key to use in the search
     * @param {number} offset The offset to use in the search
     */
    ;

    _proto.verticalPage = function verticalPage(verticalKey, offset) {
      var allFilters = this.globalStorage.getAll(StorageKeys.FILTER);
      var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, allFilters) : allFilters[0];
      var facetFilter = this.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
      this.verticalSearch(verticalKey, {
        input: this.globalStorage.getState(StorageKeys.QUERY),
        id: this.globalStorage.getState(StorageKeys.QUERY_ID),
        filter: JSON.stringify(totalFilter),
        facetFilter: JSON.stringify(facetFilter),
        offset: offset
      });
    };

    _proto.search = function search(queryString, urls) {
      var _this2 = this;

      this.globalStorage.set(StorageKeys.DIRECT_ANSWER, {});
      this.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
      this.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, {});
      this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
      this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
      return this._searcher.universalSearch(queryString, {
        geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION),
        skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
        queryTrigger: this.globalStorage.getState('queryTrigger'),
        sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
      }).then(function (response) {
        return SearchDataTransformer.transform(response, urls, _this2._fieldFormatters);
      }).then(function (data) {
        _this2.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

        _this2.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

        _this2.globalStorage.set(StorageKeys.DIRECT_ANSWER, data[StorageKeys.DIRECT_ANSWER]);

        _this2.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, data[StorageKeys.UNIVERSAL_RESULTS], urls);

        _this2.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

        _this2.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);

        _this2.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);

        _this2.globalStorage["delete"]('skipSpellCheck');

        _this2.globalStorage["delete"]('queryTrigger');
      });
    }
    /**
     * Given an input, query for a list of similar results and set into storage
     *
     * @param {string} input     the string to autocomplete
     * @param {string} namespace the namespace to use for the storage key
     */
    ;

    _proto.autoCompleteUniversal = function autoCompleteUniversal(input, namespace) {
      var _this3 = this;

      return this._autoComplete.queryUniversal(input).then(function (data) {
        _this3.globalStorage.set(StorageKeys.AUTOCOMPLETE + "." + namespace, data);

        return data;
      });
    }
    /**
     * Given an input, query for a list of similar results in the provided vertical
     * and set into storage
     *
     * @param {string} input       the string to autocomplete
     * @param {string} namespace the namespace to use for the storage key
     * @param {string} verticalKey the vertical key for the experience
     */
    ;

    _proto.autoCompleteVertical = function autoCompleteVertical(input, namespace, verticalKey) {
      var _this4 = this;

      return this._autoComplete.queryVertical(input, verticalKey).then(function (data) {
        _this4.globalStorage.set(StorageKeys.AUTOCOMPLETE + "." + namespace, data);

        return data;
      });
    }
    /**
     * Given an input, provide a list of suitable filters for autocompletion
     *
     * @param {string} input  the string to search for filters with
     * @param {object} config  the config to serach for filters with
     * @param {string} config.namespace  the namespace to use for the storage key
     * @param {string} config.verticalKey the vertical key for the config
     * @param {object} config.searchParameters  the search parameters for the config v2
     */
    ;

    _proto.autoCompleteFilter = function autoCompleteFilter(input, config) {
      var _this5 = this;

      return this._autoComplete.queryFilter(input, config).then(function (data) {
        _this5.globalStorage.set(StorageKeys.AUTOCOMPLETE + "." + config.namespace, data);
      });
    }
    /**
     * Submits a question to the server and updates the underlying question model
     * @param {object} question The question object to submit to the server
     * @param {number} question.entityId The entity to associate with the question (required)
     * @param {string} question.lanuage The language of the question
     * @param {string} question.site The "publisher" of the (e.g. 'FIRST_PARTY')
     * @param {string} question.name The name of the author
     * @param {string} question.email The email address of the author
     * @param {string} question.questionText The question
     * @param {string} question.questionDescription Additional information about the question
     */
    ;

    _proto.submitQuestion = function submitQuestion(question) {
      var _this6 = this;

      return this._questionAnswer.submitQuestion(question).then(function (data) {
        _this6.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, QuestionSubmission.submitted());
      });
    }
    /**
     * Stores the given sortBy into storage, to be used for the next search
     * @param {Object} sortByOptions
     */
    ;

    _proto.setSortBys = function setSortBys() {
      for (var _len = arguments.length, sortByOptions = new Array(_len), _key = 0; _key < _len; _key++) {
        sortByOptions[_key] = arguments[_key];
      }

      var sortBys = sortByOptions.map(function (option) {
        return {
          type: option.type,
          field: option.field,
          direction: option.direction
        };
      });
      this.globalStorage.set(StorageKeys.SORT_BYS, JSON.stringify(sortBys));
    }
    /**
     * Clears the sortBys key in global storage.
     */
    ;

    _proto.clearSortBys = function clearSortBys() {
      this.globalStorage["delete"](StorageKeys.SORT_BYS);
    }
    /**
     * Stores the given query into storage, to be used for the next search
     * @param {string} query the query to store
     */
    ;

    _proto.setQuery = function setQuery(query) {
      this.globalStorage.set(StorageKeys.QUERY, query);
    }
    /**
     * Stores the provided query ID, to be used in analytics
     * @param {string} queryId The query id to store
     */
    ;

    _proto.setQueryId = function setQueryId(queryId) {
      this.globalStorage.set(StorageKeys.QUERY_ID, queryId);
    }
    /**
     * Stores the given filter into storage, to be used for the next search
     *
     * @param {string} namespace the namespace to use for the storage key
     * @param {Filter} filter    the filter to set
     */
    ;

    _proto.setFilter = function setFilter(namespace, filter) {
      this.globalStorage.set(StorageKeys.FILTER + "." + namespace, filter);
    };

    _proto.setFacetFilter = function setFacetFilter(namespace, filter) {
      this.globalStorage.set(StorageKeys.FACET_FILTER + "." + namespace, filter);
    };

    _proto.enableDynamicFilters = function enableDynamicFilters() {
      this._isDynamicFiltersEnabled = true;
    };

    _proto.on = function on(evt, moduleId, cb) {
      return this.globalStorage.on(evt, moduleId, cb);
    };

    return Core;
  }();

  /** @module DOM */

  /* global HTMLElement, HTMLDocument, Window, Event */
  var document$1 = window.document;
  /**
   * Static interface for interacting with the DOM API.
   * @namespace
   */

  var DOM =
  /*#__PURE__*/
  function () {
    function DOM() {}

    DOM.setup = function setup(d, p) {
      document$1 = d;
    }
    /**
     * create a HTMLElement from and HTML string
     * @param {string} html The HTML to parse to a DOM node.
     * @return {HTMLElement}
     */
    ;

    DOM.create = function create(html) {
      if ('createRange' in document$1) {
        // prefer this implementation as it has wider browser support
        // and it's better performing.
        // see https://davidwalsh.name/convert-html-stings-dom-nodes
        var container = document$1.createElement('div');
        var frag = document$1.createRange().createContextualFragment(html);
        container.appendChild(frag);
        return container;
      } // fallback to this because of a bug in jsdom that causes tests to fail
      // see: https://github.com/jsdom/jsdom/issues/399


      return new DOMParser().parseFromString(html, 'text/html').body;
    }
    /**
     * query the DOM for a given css selector
     * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
     * @param {string} selector the CSS selector to query for
     *
     * @returns {HTMLElement} the FIRST node it finds, if any
     */
    ;

    DOM.query = function query(parent, selector) {
      // Facade, shifting the selector to the parent argument if only one
      // argument is provided
      if (selector === undefined) {
        selector = parent;
        parent = document$1;
      }

      if (selector instanceof HTMLElement || selector instanceof Window || selector instanceof HTMLDocument) {
        return selector;
      }

      return parent.querySelector(selector);
    }
    /**
     * query the DOM for a given css selector
     * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
     * @param {string} selector the CSS selector to query for
     *
     * @returns {Array} the FIRST node it finds, if any
     */
    ;

    DOM.queryAll = function queryAll(parent, selector) {
      // Facade, shifting the selector to the parent argument if only one
      // argument is provided
      if (selector === undefined) {
        selector = parent;
        parent = document$1;
      } // handle the case where client code is using a pointer to a dom node and it's null, e.g. this._container


      if (parent == null) {
        parent = document$1;
      }

      if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof Window) {
        return [selector];
      }

      return Array.from(parent.querySelectorAll(selector));
    };

    DOM.onReady = function onReady(cb) {
      if (document$1.readyState === 'complete' || document$1.readyState === 'loaded' || document$1.readyState === 'interactive') {
        cb();
        return;
      }

      DOM.on(document$1, 'DOMContentLoaded', cb);
    }
    /**
     * createEle will create a {HTMLElement} and apply the properties attributes through an object provided.
     * @param {string} el The element `tag` name to construct
     * @param {Object} opts_data Optional attributes to apply to the new HTMLElement
     */
    ;

    DOM.createEl = function createEl(el, opts_data) {
      if (opts_data === void 0) {
        opts_data = {};
      }

      var node = document$1.createElement(el);
      var props = Object.keys(opts_data);

      for (var i = 0; i < props.length; i++) {
        if (props[i] === 'class') {
          DOM.addClass(node, opts_data[props[i]]);
          continue;
        }

        node[props[i]] = opts_data[props[i]];
      }

      return node;
    };

    DOM.append = function append(parent, node) {
      if (node === undefined) {
        node = parent;
        parent = document$1;
      }

      if (typeof parent === 'string') {
        parent = DOM.query(parent);
      } // Support HTML injection as well as HTMLElement appends


      if (typeof node === 'string') {
        parent.insertAdjacentHTML('afterBegin', node);
      } else {
        parent.appendChild(node);
      }
    };

    DOM.addClass = function addClass(node, className) {
      if (!node) {
        return;
      }

      var classes = className.split(',');
      var len = classes.length;

      for (var i = 0; i < len; i++) {
        node.classList.add(classes[i]);
      }
    };

    DOM.empty = function empty(parent) {
      parent.innerHTML = '';
    };

    DOM.css = function css(selector, styles) {
      var node = DOM.query(selector);

      for (var prop in styles) {
        node.style[prop] = styles[prop];
      }
    };

    DOM.attr = function attr(selector, _attr, val) {
      DOM.query(selector).setAttribute(_attr, val);
    };

    DOM.attributes = function attributes(selector, attrs) {
      var _this = this;

      Object.entries(attrs).forEach(function (_ref) {
        var attr = _ref[0],
            val = _ref[1];
        return _this.attr(selector, attr, val);
      });
    };

    DOM.trigger = function trigger(selector, event, settings) {
      var e = new Event(event, Object.assign({
        'bubbles': true,
        'cancelable': true
      }, settings || {}));
      DOM.query(selector).dispatchEvent(e);
    };

    DOM.on = function on(selector, evt, handler) {
      DOM.query(selector).addEventListener(evt, handler);
    };

    DOM.once = function once(selector, evt, handler) {
      DOM.query(selector).addEventListener(evt, handler, {
        once: true
      });
    };

    DOM.off = function off(selector, evt, handler) {
      DOM.query(selector).removeEventListener(evt, handler);
    };

    DOM.delegate = function delegate(ctxt, selector, evt, handler) {
      var el = DOM.query(ctxt);
      el.addEventListener(evt, function (event) {
        var target = event.target;

        while (!target.isEqualNode(el)) {
          if (target.matches(selector)) {
            handler(event, target);
            break;
          }

          target = target.parentNode;
        }
      });
    };

    return DOM;
  }();

  /** @module SearchParams */

  /* global window */

  /**
   * SearchParams is a class to get the search params in a URL.
   * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
   */
  var SearchParams =
  /*#__PURE__*/
  function () {
    function SearchParams(url) {
      /**
       * Mapping of all query parameters in the given url, query param -> value
       * Only used if URLSearchParams does not exist in the window
       * @type {Object}
       * @private
       */
      this._params = {};

      if (window && window.URLSearchParams) {
        return new URLSearchParams(url);
      } else {
        this._params = this.parse(url);
      }
    }
    /**
     * parse creates a mapping of all query params in a given url
     * The query param values are decoded before being put in the map
     * Three types of input are supported
     *   (1) full URL e.g. http://www.yext.com/?q=hello
     *   (2) params with ? e.g. ?q=hello
     *   (1) params without ? e.g. q=hello
     * @param {string} url The url
     * @returns {Object} mapping from query param -> value where value is '' if no value is provided
     */


    var _proto = SearchParams.prototype;

    _proto.parse = function parse(url) {
      var params = {};
      var search = url;

      if (search === '') {
        return params;
      } // Normalize all url inputs to string of query params separated by &


      if (url.indexOf('?') > -1) {
        search = url.slice(url.indexOf('?') + 1);
      }

      var encodedParams = search.split('&');

      for (var i = 0; i < encodedParams.length; i++) {
        var keyVal = encodedParams[i].split('=');

        if (keyVal.length > 1) {
          params[keyVal[0]] = SearchParams.decode(keyVal[1]);
        } else {
          params[keyVal[0]] = '';
        }
      }

      return params;
    }
    /**
     * get returns the value of the given query param
     * @param {string} query the query param key to get the value of
     * @return {string} param value, null otherwise
     */
    ;

    _proto.get = function get(query) {
      if (typeof this._params[String(query)] === 'undefined') {
        return null;
      }

      return this._params[query];
    }
    /**
     * set changes the value of a given query param
     * @param {string} name the query param key
     * @param {string} value the value of the query param update with
     */
    ;

    _proto.set = function set(name, value) {
      this._params[String(name)] = String(value);
    }
    /**
     * has checks to see if the given query param key exists in the params object
     * @param {string} query the query param to check
     * @return {boolean} true if the query param is in the params object, false o/w
     */
    ;

    _proto.has = function has(query) {
      return query in this._params;
    }
    /**
     * delete removes the given query param and its associated value from the params object
     * @param {string} name the query param key
     */
    ;

    _proto["delete"] = function _delete(name) {
      delete this._params[String(name)];
    }
    /**
     * toString returns a url with all the query params in the params object (without a ?)
     * @return {string}
     */
    ;

    _proto.toString = function toString() {
      var string = [];

      for (var key in this._params) {
        string.push(key + "=" + SearchParams.encode(this._params[key]));
      }

      return string.join('&');
    };

    _proto.entries = function entries() {
      var entries = [];

      for (var key in this._params) {
        entries.push([key, this._params[key]]);
      }

      return entries;
    }
    /**
     * decode returns the decoded representation of the given string
     * @param {string} string the string to decode
     * @return {string}
     */
    ;

    SearchParams.decode = function decode(string) {
      return decodeURIComponent(string.replace(/[ +]/g, '%20'));
    }
    /**
     * decode returns the encoded representation of the given string (e.g. + -> %2B)
     * @param {string} string the string to encode
     * @return {string}
     */
    ;

    SearchParams.encode = function encode(string) {
      var replace = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '%20': '+'
      };
      return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
        return replace[match];
      });
    };

    return SearchParams;
  }();

  /** @module Renderer */

  /**
   * Renderer is an abstract class that all Renderers should extend and implement
   */
  var Renderer =
  /*#__PURE__*/
  function () {
    function Renderer() {}

    var _proto = Renderer.prototype;

    /**
     * render is a core method for all renderers.
     * All implementations should override this class
     * @param {string} template
     * @param {object} data
     */
    _proto.render = function render(template, data) {
      return template;
    };

    _proto.registerHelper = function registerHelper(name, cb) {};

    _proto.compile = function compile(template) {};

    return Renderer;
  }();

  /**
   * HandlebarsRenderer is a wrapper around the nativate handlebars renderer.
   * @extends Renderer
   */

  var HandlebarsRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    _inheritsLoose(HandlebarsRenderer, _Renderer);

    function HandlebarsRenderer(templates, opts) {
      var _this;

      if (templates === void 0) {
        templates = {};
      }

      if (opts === void 0) {
        opts = {};
      }

      _this = _Renderer.call(this) || this;
      /**
       * A local reference to the handlebars compiler
       * @type {Handlebars}
       * @private
       */

      _this._handlebars = templates._hb || null;
      /**
       * A local reference to the pre-compiled handlebars templates
       * @type {Handlebars}
       * @private
       */

      _this._templates = templates || {};
      return _this;
    }

    var _proto = HandlebarsRenderer.prototype;

    _proto.init = function init(templates) {
      // Assign the handlebars compiler and templates based on
      // information provided from external dep (in default case, it comes from external server request)
      this._handlebars = templates._hb;
      this._templates = templates; // TODO(billy) Once we re-write templates using the new helpers library
      // we probably don't need these custom helpers anymore

      this._registerCustomHelpers();
    }
    /**
     * registerHelper is a public interface for external dependencies to
     * register their own custom helpers to our internal Handlebars Compiler
     */
    ;

    _proto.registerHelper = function registerHelper(name, cb) {
      this._handlebars.registerHelper(name, cb);
    }
    /**
     * compile a handlebars template so that it can be rendered,
     * using the {Handlebars} compiler
     * @param {string} template The template string to compile
     */
    ;

    _proto.compile = function compile(template) {
      if (typeof template !== 'string') {
        return '';
      }

      return this._handlebars.compile(template);
    }
    /**
     * render will render a template with data
     * @param {Object} config Provide either a templateName or a pre-compiled template
     * @param {Object} data The data to provide to the template
     */
    ;

    _proto.render = function render(config, data) {
      // If a custom template is provided, use it,
      // otherwise fall back to the template name
      // TODO(billy) This interface should probably be less ugly
      if (config.template !== null) {
        return config.template(data);
      }

      try {
        return this._templates[config.templateName](data);
      } catch (e) {
        throw new Error('Can not find/render template: ' + config.templateName, e);
      }
    };

    _proto._registerCustomHelpers = function _registerCustomHelpers() {
      this.registerHelper('ifeq', function (arg1, arg2, options) {
        return arg1 === arg2 ? options.fn(this) : options.inverse(this);
      });
      this.registerHelper('ifnoteq', function (arg1, arg2, options) {
        return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
      });
      this.registerHelper('formatPhoneNumber', function (phoneNumberString) {
        var cleaned = ('' + phoneNumberString).replace(/\D/g, '');
        var match = cleaned.match(/^(1|)?(\d{3})(\d{3})(\d{4})$/);

        if (match) {
          var intlCode = match[1] ? '+1 ' : '';
          return [intlCode, '(', match[2], ') ', match[3], '-', match[4]].join('');
        }

        return null;
      });
      this.registerHelper('assign', function (name, value, options) {
        var args = arguments;
        options = args[args.length - 1];

        if (!options.data.root) {
          options.data.root = {};
        }

        var v = '';

        for (var i = 1; i < args.length - 1; i++) {
          v = v + args[i];
        }

        options.data.root[name] = v;
      });
      this.registerHelper('json', function (name, value, options) {
        return name === undefined ? '' : JSON.stringify(name);
      });
    };

    return HandlebarsRenderer;
  }(Renderer);

  /** @module */
  // E.g. Mustache, SOY, HandleBars, React, etc.

  var Renderers = {
    SOY: Renderer,
    Handlebars: HandlebarsRenderer
  };

  /** @module */

  /** The current lib version, reported with errors and analytics */
  var LIB_VERSION = 'v0.12.1';
  /** The identifier of the production environment */

  var PRODUCTION = 'production';
  /** The identifier of the sandbox environment */

  var SANDBOX = 'sandbox';
  /** The default url for compiled component templates */

  var COMPILED_TEMPLATES_URL = "https://assets.sitescdn.net/answers/" + LIB_VERSION + "/answerstemplates.compiled.min.js";

  /** @module TemplateLoader */
  /**
   * TemplateLoader exposes an interface for loading templates asynchronously
   * from the server and registers them with the proper renderer.
   * It also allows you to assign them synchronously.
   */

  var TemplateLoader =
  /*#__PURE__*/
  function () {
    function TemplateLoader(config) {
      if (!TemplateLoader.setInstance(this)) {
        return TemplateLoader.getInstance();
      }
      /**
       * The template url to fetch compiled templates from
       * @type {string}
       * @private
       */


      this._templateUrl = config.templateUrl || COMPILED_TEMPLATES_URL;
      this._templates = {};

      this._onLoaded = function () {};

      this._init();
    }

    TemplateLoader.setInstance = function setInstance(instance) {
      if (!this.instance) {
        this.instance = instance;
        return true;
      }

      return false;
    };

    TemplateLoader.getInstance = function getInstance() {
      return this.instance;
    };

    var _proto = TemplateLoader.prototype;

    _proto._init = function _init() {
      this.fetchTemplates();
    };

    _proto.fetchTemplates = function fetchTemplates() {
      var _this = this;

      // If we already have templates loaded, do nothing
      var node = DOM.query('#yext-answers-templates');

      if (node) {
        return;
      } // Inject a script to fetch the compiled templates,
      // wrapping it a Promise for cleanliness


      new Promise(function (resolve, reject) {
        var script = DOM.createEl('script', {
          id: 'yext-answers-templates',
          onload: resolve,
          onerror: reject,
          async: true,
          src: _this._templateUrl
        });
        DOM.append('body', script);
      }).then(function (response) {
        // TODO(billy) Implmenet error handling here (e.g. request could fail)
        console.log('Templates loaded successfully!');
      });
      return this;
    }
    /**
     * register the templates internally so that they can be later consumed
     * (e.g. by components and renderers) with convienience.
     *
     * `fetchTemplates` will automatically call this, providing the compiled templates from the server.
     */
    ;

    _proto.register = function register(templates) {
      this._templates = templates; // Notify our consumers that the templates are here :)

      this._onLoaded(this._templates);

      return this;
    };

    _proto.onLoaded = function onLoaded(cb) {
      this._onLoaded = cb;
      return this;
    };

    _proto.get = function get(templateName) {
      return this._templates[templateName];
    }
    /**
     * @return The internal template collection
     */
    ;

    _proto.getTemplates = function getTemplates() {
      return this._templates;
    };

    return TemplateLoader;
  }();

  /** @module */

  /** @module EventEmitter */

  /**
   * EventEmitter is a base class for any object that wants to expose
   * a pub/sub interface, for emitting messages and providing listeners.
   */
  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      /**
       * The subscribers of messages
       * @type {object[]}
       * @private
       */
      this._listeners = {};
    }
    /**
     * on is the public interface for subscribing events that are emitted.
     * @param {string} evt the event name to listen to
     * @param {function} cb The callback to invoke when the {evt} is emitted
     * @param {boolean} once Optional value which will only handle the message once
     */


    var _proto = EventEmitter.prototype;

    _proto.on = function on(evt, cb, once) {
      if (typeof cb !== 'function') {
        throw new Error('callback handler should be of type {function}');
      }

      if (this._listeners[evt] === undefined) {
        this._listeners[evt] = [];
      }

      this._listeners[evt].push({
        event: evt,
        cb: cb,
        once: once || false
      });

      return this;
    }
    /**
     * once is the public interface for subscribing events that are emitted.
     * The handler will only be triggered once.
     *
     * @param {string} evt the event name to listen to
     * @param {function} cb The callback to invoke when the {evt} is emitted
     * @param {boolean} once Optional value which will only handle the message once
     */
    ;

    _proto.once = function once(evt, cb) {
      return this.on(evt, cb, true);
    }
    /**
     * off is the public interface for unsubscribing from an event
     * @param {string} evt the event name to unsubscribe from
     */
    ;

    _proto.off = function off(evt) {
      delete this._listeners[evt];
      return this;
    }
    /**
     * emit is the public interface for broadcasting messages/events
     * @param {string} evt the event name to publish from
     * @param {Object} data the data to send along to the subscribers
     */
    ;

    _proto.emit = function emit(evt, data) {
      var listeners = this._listeners[evt];

      if (listeners === undefined) {
        return;
      } // Invoke each of all the listener handlers and remove the ones that should fire only once.


      var keep = [];

      for (var i = 0; i < listeners.length; i++) {
        listeners[i].cb(data);

        if (listeners[i].once === true) {
          continue;
        } // Instead of having a 'dirty' array with deleted or 'undefined' entries,
        // we just create a brand new array without the listeners that were removed


        keep.push(listeners[i]);
      } // Update our old list of listeners to the newly created array


      this._listeners[evt] = keep;
      return this;
    };

    return EventEmitter;
  }();

  /**
   * State contains the data for the component
   * and exposes an {EventEmitter} interface so that external
   * dependencies can listen/hook subscribe to messages/updates.
   * @extends EventEmitter
   */

  var State =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inheritsLoose(State, _EventEmitter);

    function State(data) {
      var _this;

      _this = _EventEmitter.call(this) || this;
      /**
       * The initial state of the component
       * @type {Object}
       * @private
       */

      _this._state = data || {};
      return _this;
    }
    /**
     * Set the initial state of the component.
     * NOTE(billy): Does not fire an update message
     */


    var _proto = State.prototype;

    _proto.init = function init(prop, optVal) {
      this._set(prop, optVal);
    }
    /**
     * setter for the state
     * @param prop {string|Object} The property to set
     * @param optVal Optional, if prop is a {string}, it will assign the value to that property
     */
    ;

    _proto.set = function set(prop, optVal) {
      this._set(prop, optVal);

      this.emit('update');
    }
    /**
     * setter for the state enables you to update a single property, or complete state
     * depending on the arguments provided.
     * @param prop {string|Object} The property to set
     * @param optVal If prop is a {string}, provide its value
     * @private
     */
    ;

    _proto._set = function _set(prop, optVal) {
      if (optVal === undefined) {
        this._state = prop;
      } else {
        this._state[prop] = optVal;
      }
    };

    _proto.update = function update(data) {
      this._state = data;
      this.emit('update');
    }
    /**
     * Retrieve a properties value from the state
     * If no property provided, return the full state
     * @param {string} optProp optional property to retrieve
     */
    ;

    _proto.get = function get(optProp) {
      if (optProp === undefined) {
        return this._state;
      }

      return this._state[optProp];
    };

    _proto.has = function has(prop) {
      return this._state[prop] !== undefined;
    };

    _proto.asJSON = function asJSON() {
      return this._state;
    };

    return State;
  }(EventEmitter);

  /** @module HttpRequester */

  /* global fetch */

  /**
   * Types of HTTP requests
   */
  var Methods = {
    GET: 'get',
    POST: 'post',
    PUT: 'put',
    DELETE: 'delete'
  };
  /**
   * HttpRequester is a wrapper around the native implementation of AJAX
   * related matters. It's used to make all types of network requests
   * and exposes a promise interface.
   */

  var HttpRequester =
  /*#__PURE__*/
  function () {
    function HttpRequester() {}

    var _proto = HttpRequester.prototype;

    /**
     * Create a GET HTTP request
     * @param {string} url The url to make a request to
     * @param {Object} data The data to provide (gets encoded into the URL)
     * @param {Object} opts Configuration options to use for the request
     */
    _proto.get = function get(url, data, opts) {
      return this.request(Methods.GET, this.encodeParams(url, data), opts);
    }
    /**
     * Create a POST HTTP request
     * @param {string} url The url to make a request to
     * @param {Object} urlParams The params to encode into the URL
     * @param {Object} jsonBody The request body (json) to provide with the POST request
     * @param {Object} requestConfig Configuration options to use for the request
     */
    ;

    _proto.post = function post(url, urlParams, jsonBody, requestConfig) {
      return this.request(Methods.POST, this.encodeParams(url, urlParams), Object.assign({}, {
        body: JSON.stringify(jsonBody),
        credentials: undefined
      }, requestConfig));
    };

    _proto.request = function request(method, url, opts) {
      var reqArgs = Object.assign({}, {
        'method': method,
        'credentials': 'include'
      }, opts);
      return fetch(url, reqArgs);
    }
    /**
     * Send a beacon to the provided url which will send a non-blocking request
     * to the server that is guaranteed to send before page load. No response is returned,
     * so beacons are primarily used for analytics reporting.
     * @param {string} url The url to send the beacon to
     * @param {object} data The data payload to send in the beacon
     * @return {boolean} true if the request is successfully queued
     */
    ;

    _proto.beacon = function beacon(url, data) {
      return navigator.sendBeacon(url, JSON.stringify(data));
    };

    _proto.encodeParams = function encodeParams(url, params) {
      if (typeof params !== 'object') {
        return;
      }

      var hasParam = url.indexOf('?') > -1;
      var searchQuery = '';

      for (var key in params) {
        if (!hasParam) {
          hasParam = true;
          searchQuery += '?';
        } else {
          searchQuery += '&';
        }

        searchQuery += key + '=' + encodeURIComponent(params[key]);
      }

      return url + searchQuery;
    };

    return HttpRequester;
  }();

  /**
   * Returns the base url for the live api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getLiveApiUrl(env) {
    if (env === void 0) {
      env = PRODUCTION;
    }

    return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi.yext.com';
  }
  /**
   * Returns the base url for the knowledge api backend in the desired environment.
   * @param {string} env The desired environment.
   */

  function getKnowledgeApiUrl(env) {
    if (env === void 0) {
      env = PRODUCTION;
    }

    return env === SANDBOX ? 'https://api-sandbox.yext.com' : 'https://api.yext.com';
  }
  /**
   * Returns the base url for the analytics backend in the desired environment.
   * @param {string} env The desired environment.
   * @param {boolean} conversionTrackingEnabled If conversion tracking has been opted into.
   */

  function getAnalyticsUrl(env, conversionTrackingEnabled) {
    if (env === void 0) {
      env = PRODUCTION;
    }

    if (conversionTrackingEnabled === void 0) {
      conversionTrackingEnabled = false;
    }

    if (conversionTrackingEnabled) {
      return env === SANDBOX ? 'https://sandbox-realtimeanalytics.yext.com' : 'https://realtimeanalytics.yext.com';
    }

    return env === SANDBOX ? 'https://sandbox-answers.yext-pixel.com' : 'https://answers.yext-pixel.com';
  }

  /** @module ApiRequest */
  /**
   * ApiRequest is the base class for all API requests.
   * It defines all of the core properties required to make a request
   */

  var ApiRequest =
  /*#__PURE__*/
  function () {
    // TODO (tmeyer): Create an ApiService interface and pass an implementation to the current
    // consumers of ApiRequest as a dependency.
    function ApiRequest(opts, globalStorage) {
      if (opts === void 0) {
        opts = {};
      }

      /**
       * An abstraction used for making network request and handling errors
       * @type {HttpRequester}
       * @private
       */
      this._requester = new HttpRequester();
      /**
       * The environment the request should be made to
       * @type {string}
       * @private
       */

      this._environment = opts.environment || PRODUCTION;
      /**
       * The baseUrl to use for making a request
       * @type {string}
       * @private
       */

      this._baseUrl = opts.baseUrl || getLiveApiUrl(this._environment);
      /**
       * The endpoint to use in the url (appended to the {baseUrl})
       * @type {string}
       * @private
       */

      this._endpoint = opts.endpoint || null;
      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */

      this._apiKey = opts.apiKey || null;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = opts.version || 20190101;
      /**
       * Additional data params that are sent along with the request
       * @type {string}
       * @private
       */

      this._params = opts.params || {};

      if (!globalStorage) {
        throw new AnswersBasicError('Must include global storage', 'ApiRequest');
      }
      /**
       * @type {GlobalStorage}
       * @private
       */


      this._globalStorage = globalStorage;
    }
    /**
     * get creates a new `GET` request to the server using the configuration of the request class
     * @returns {Promise<Response>}
     */


    var _proto = ApiRequest.prototype;

    _proto.get = function get() {
      return this._requester.get(this._baseUrl + this._endpoint, Object.assign({}, this.baseParams(), this.sanitizeParams(this._params)));
    }
    /**
     * @param {Object} opts
     * @returns {Promise<Response>}
     */
    ;

    _proto.post = function post(opts) {
      return this._requester.post(this._baseUrl + this._endpoint, this.baseParams()
      /* urlParams */
      , this.sanitizeParams(this._params)
      /* jsonBody */
      , opts
      /* requestConfig */
      );
    }
    /**
     * @returns {Object}
     * @private
     */
    ;

    _proto.baseParams = function baseParams() {
      var baseParams = {
        'v': this._version,
        'api_key': this._apiKey,
        'jsLibVersion': LIB_VERSION,
        'sessionTrackingEnabled': this._globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
      };
      var urlParams = new SearchParams(window.location.search.substring(1));

      if (urlParams.has('beta')) {
        baseParams['beta'] = urlParams.get('beta');
      }

      return baseParams;
    };

    _proto.sanitizeParams = function sanitizeParams(params) {
      if (params === void 0) {
        params = {};
      }

      // Remove any paramaters whos value is `undefined`.
      //
      // NOTE(billy) Probably better to be explicit about how to handle this at the request building level,
      // but I can't see any cases where we'd ever want to send 'undefined' as a value to the server.
      // So it's probably fine to 'clean' the params object here
      Object.keys(params).forEach(function (key) {
        if (params[key] === undefined || params[key] === null) {
          delete params[key];
        }
      });
      return params;
    };

    return ApiRequest;
  }();

  /** @module SearchApi */
  /**
   * SearchApi is the API for doing various types of search
   * over the network (e.g. vertical or universal)
   *
   * @implements {SearchService}
   */

  var SearchApi =
  /*#__PURE__*/
  function () {
    function SearchApi(config) {
      if (config === void 0) {
        config = {};
      }

      /**
       * A local reference to the API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'Search');
      }

      this._apiKey = config.apiKey;
      /**
       * A local reference to the Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'Search');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * A local reference to the locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'Search');
      }

      this._locale = config.locale;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
    }
    /** @inheritdoc */


    var _proto = SearchApi.prototype;

    _proto.verticalSearch = function verticalSearch(verticalKey, _ref) {
      var input = _ref.input,
          filter = _ref.filter,
          facetFilter = _ref.facetFilter,
          limit = _ref.limit,
          offset = _ref.offset,
          id = _ref.id,
          geolocation = _ref.geolocation,
          isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
          skipSpellCheck = _ref.skipSpellCheck,
          queryTrigger = _ref.queryTrigger,
          sessionTrackingEnabled = _ref.sessionTrackingEnabled,
          sortBys = _ref.sortBys;

      if (limit > 50) {
        throw new AnswersCoreError('Provided search limit unsupported', 'SearchApi');
      }

      var requestConfig = {
        endpoint: '/v2/accounts/me/answers/vertical/query',
        apiKey: this._apiKey,
        version: this._version,
        environment: this._environment,
        params: {
          'input': input,
          'experienceKey': this._experienceKey,
          'version': this._experienceVersion,
          'filters': filter,
          'facetFilters': facetFilter,
          'verticalKey': verticalKey,
          'limit': limit,
          'offset': offset,
          'location': geolocation ? geolocation.lat + "," + geolocation.lng : null,
          'radius': geolocation ? geolocation.radius : null,
          'queryId': id,
          'retrieveFacets': isDynamicFiltersEnabled,
          'locale': this._locale,
          'skipSpellCheck': skipSpellCheck,
          'queryTrigger': queryTrigger,
          'sessionTrackingEnabled': sessionTrackingEnabled,
          'sortBys': sortBys
        }
      };
      var request = new ApiRequest(requestConfig, {
        getState: function getState() {
          return sessionTrackingEnabled;
        }
      });
      return request.get().then(function (response) {
        return response.json();
      });
    }
    /** @inheritdoc */
    ;

    _proto.universalSearch = function universalSearch(queryString, params) {
      var requestConfig = {
        endpoint: '/v2/accounts/me/answers/query',
        apiKey: this._apiKey,
        version: this._version,
        environment: this._environment,
        params: {
          'input': queryString,
          'experienceKey': this._experienceKey,
          'location': params.geolocation ? params.geolocation.lat + "," + params.geolocation.lng : null,
          'radius': params.geolocation ? params.geolocation.radius : null,
          'version': this._experienceVersion,
          'locale': this._locale,
          'skipSpellCheck': params.skipSpellCheck,
          'queryTrigger': params.queryTrigger
        }
      };
      var request = new ApiRequest(requestConfig, {
        getState: function getState() {
          return params.sessionTrackingEnabled;
        }
      });
      return request.get().then(function (response) {
        return response.json();
      });
    };

    return SearchApi;
  }();

  /**
   * Model for the analytics event type
   */
  var AnalyticsEvent =
  /*#__PURE__*/
  function () {
    function AnalyticsEvent(type, label) {
      /**
       * The type of event to report
       * @type {string}
       */
      this.eventType = type.toUpperCase();
      /**
       * An optional label to be provided for the event
       * @type {string}
       */

      if (label) {
        this.label = label;
      }
    }
    /**
     * Adds the provided options to the event
     * @param {object} options Additional options for the event
     */


    var _proto = AnalyticsEvent.prototype;

    _proto.addOptions = function addOptions(options) {
      Object.assign(this, options);
      return this;
    }
    /**
     * Return the event in the api format, typically for reporting to the api
     */
    ;

    _proto.toApiEvent = function toApiEvent() {
      return Object.assign({}, this);
    };

    return AnalyticsEvent;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * Class for reporting analytics events to the server via HTTP
   *
   * @implements {AnalyticsReporterService}
   */

  var AnalyticsReporter =
  /*#__PURE__*/
  function () {
    function AnalyticsReporter(core, experienceKey, experienceVersion, businessId, globalOptions, environment) {
      var _this = this;

      if (globalOptions === void 0) {
        globalOptions = {};
      }

      if (environment === void 0) {
        environment = PRODUCTION;
      }

      /**
       * The internal business identifier used for reporting
       * @type {number}
       */
      this._businessId = businessId;
      /**
       * Options to include with every analytic event reported to the server
       * @type {object}
       * @private
       */

      this._globalOptions = Object.assign({}, globalOptions, {
        experienceKey: experienceKey
      });
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = environment;
      /**
       * Base URL for the analytics API
       * @type {string}
       * @private
       */

      this._baseUrl = getAnalyticsUrl(this._environment);
      /**
       * Boolean indicating if opted in or out of conversion tracking
       * @type {boolean}
       * @private
       */

      this._conversionTrackingEnabled = false;

      if (experienceVersion) {
        this._globalOptions.experienceVersion = experienceVersion;
      } // listen to query id updates


      core.globalStorage.on('update', StorageKeys.QUERY_ID, function (id) {
        return _this.setQueryId(id);
      });
    }

    var _proto = AnalyticsReporter.prototype;

    _proto.setQueryId = function setQueryId(queryId) {
      this._globalOptions.queryId = queryId;
    }
    /** @inheritdoc */
    ;

    _proto.report = function report(event) {
      var cookieData = {};

      if (this._conversionTrackingEnabled && typeof ytag === 'function') {
        ytag('optin', true);
        cookieData = ytag('yfpc', null);
      } else if (this._conversionTrackingEnabled) {
        throw new AnswersAnalyticsError('Tried to enable conversion tracking without including ytag');
      }

      if (!(event instanceof AnalyticsEvent)) {
        throw new AnswersAnalyticsError('Tried to send invalid analytics event', event);
      }

      event.addOptions(this._globalOptions);
      return new HttpRequester().beacon(this._baseUrl + "/realtimeanalytics/data/answers/" + this._businessId, _objectSpread2({
        data: event.toApiEvent()
      }, cookieData));
    }
    /** @inheritdoc */
    ;

    _proto.setConversionTrackingEnabled = function setConversionTrackingEnabled(isEnabled) {
      this._conversionTrackingEnabled = isEnabled;
      this._baseUrl = getAnalyticsUrl(this._environment, isEnabled);
    };

    return AnalyticsReporter;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @implements {AnalyticsReporterService}
   */
  var NoopAnalyticsReporter =
  /*#__PURE__*/
  function () {
    function NoopAnalyticsReporter() {}

    var _proto = NoopAnalyticsReporter.prototype;

    /** @inheritdoc */
    _proto.report = function report(event) {
      return true;
    }
    /** @inheritdoc */
    ;

    _proto.setConversionTrackingEnabled = function setConversionTrackingEnabled(isEnabled) {};

    return NoopAnalyticsReporter;
  }();

  /**
   * ModuleData is used as a generic model for Storage.
   * Typically an instance of ModuleData powers a single component.

   * A data model that exposes an event emitter interface.
   * @extends EventEmitter
   */

  var ModuleData =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inheritsLoose(ModuleData, _EventEmitter);

    function ModuleData(id, data) {
      var _this;

      if (data === void 0) {
        data = {};
      }

      _this = _EventEmitter.call(this) || this;
      _this._id = id;
      _this._history = [];
      _this._data = data;

      _this.set(data);

      return _this;
    }
    /**
     * replaces the currently held data with the given data
     * @param {*} data the data to replace the current data
     */


    var _proto = ModuleData.prototype;

    _proto.set = function set(data) {
      this.capturePrevious();

      if (typeof data !== 'object' || Array.isArray(data) || Object.keys(data).length !== Object.keys(this._data).length) {
        this._data = data;
        this.emit('update', this._data);
        return;
      } // check for shallow equality


      for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (this._data[key] !== data[key]) {
          this._data = data;
          this.emit('update', this._data);
          return;
        }
      }
    };

    _proto.capturePrevious = function capturePrevious() {
      if (this._history === undefined) {
        this._history = [];
      }

      if (this._history.length + 1 > 5) {
        this._history.shift();
      } // If data is ever undefined, we default to empty object


      this._history.push(JSON.stringify(this._data || {}));
    };

    _proto.undo = function undo() {
      var previous = {};

      if (this._previous.length > 0) {
        previous = JSON.parse(this._previous.pop());
      }

      this._data.set(previous);
    };

    _proto.raw = function raw() {
      return this._data;
    };

    return ModuleData;
  }(EventEmitter);

  /** @module GlobalStorage */
  /**
   * Storage is a container around application state.
   * It exposes an interface for CRUD operations as well as listening
   * for stateful changes.
   */

  var GlobalStorage =
  /*#__PURE__*/
  function () {
    function GlobalStorage() {
      this._moduleDataContainer = {};
      this._futureListeners = {};
    }
    /**
     * Set the data in storage with the given key to the provided data,
     * completely overwriting any existing data.
     * @param {string} key the storage key to set
     * @param {*} data the data to set
     */


    var _proto = GlobalStorage.prototype;

    _proto.set = function set(key, data) {
      this._initDataContainer(key, data);

      this._moduleDataContainer[key].set(data);
    }
    /**
     * Add all key/value pairs in the provided map to the storage
     * @param {*} data The key/value pairs to set in the storage
     */
    ;

    _proto.setAll = function setAll(data) {
      for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
            key = _Object$entries$_i[0],
            val = _Object$entries$_i[1];

        if (key === StorageKeys.QUERY) {
          continue;
        }

        this.set(key, val);
      } // Update query last since it triggers a search
      // TODO: move listeners up so all of storage can be updated at the same time


      if (data[StorageKeys.QUERY]) {
        this.set(StorageKeys.QUERY, data[StorageKeys.QUERY]);
      }
    };

    _proto._initDataContainer = function _initDataContainer(key, data) {
      if (key === undefined || key === null || typeof key !== 'string') {
        throw new AnswersStorageError('Invalid storage key provided', key, data);
      }

      if (data === undefined || data === null) {
        throw new AnswersStorageError('No data provided', key, data);
      }

      if (this._moduleDataContainer[key] === undefined) {
        this._moduleDataContainer[key] = new ModuleData(key);

        this._applyFutureListeners(key);
      }
    };

    _proto.getState = function getState(moduleId) {
      if (this._moduleDataContainer[moduleId]) {
        return this._moduleDataContainer[moduleId].raw();
      }

      return null;
    };

    _proto.getAll = function getAll(key) {
      var data = [];

      for (var _i2 = 0, _Object$keys = Object.keys(this._moduleDataContainer); _i2 < _Object$keys.length; _i2++) {
        var dataKey = _Object$keys[_i2];

        if (dataKey.startsWith(key) && this._moduleDataContainer[dataKey].raw() !== null) {
          data.push(this._moduleDataContainer[dataKey].raw());
        }
      }

      return data;
    }
    /**
     * Remove the data in storage with the given key to the provided data,
     * @param {string} key the storage key to delete
     */
    ;

    _proto["delete"] = function _delete(key) {
      // Note: Do we need to clean up listeners here?
      delete this._moduleDataContainer[key];
    };

    _proto.on = function on(evt, moduleId, cb) {
      var moduleData = this._moduleDataContainer[moduleId];

      if (moduleData === undefined) {
        if (this._futureListeners[moduleId] === undefined) {
          this._futureListeners[moduleId] = [];
        }

        this._futureListeners[moduleId].push({
          event: evt,
          cb: cb
        });

        return;
      }

      this._moduleDataContainer[moduleId].on(evt, cb);

      return this;
    };

    _proto.off = function off(evt, moduleId, cb) {
      var moduleData = this._moduleDataContainer[moduleId];

      if (moduleData === undefined) {
        if (this._futureListeners[moduleId] !== undefined) {
          this._futureListeners[moduleId].pop();
        }

        return this;
      }

      this._moduleDataContainer[moduleId].off(evt, cb);

      return this;
    };

    _proto._applyFutureListeners = function _applyFutureListeners(moduleId) {
      var futures = this._futureListeners[moduleId];

      if (!futures) {
        return;
      }

      for (var i = 0; i < futures.length; i++) {
        var future = futures[i];
        this.on(future.event, moduleId, future.cb);
      }

      delete this._futureListeners[moduleId];
    };

    return GlobalStorage;
  }();

  /** @module */

  /**
   * Component is an abstraction that encapsulates state, behavior,
   * and view for a particular chunk of functionality on the page.
   *
   * The API exposes event life cycle hooks for when things are rendered,
   * mounted, created, etc.
   */

  var Component =
  /*#__PURE__*/
  function () {
    function Component(config, systemConfig) {
      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      this.moduleId = null;
      /**
       * Unique name of this component instance
       * Used to distinguish between other components of the same type
       * @type {String}
       */

      this.name = config.name || this.constructor.type;
      /**
       * Cache the options so that we can propogate properly to child components
       * @type {Object}
       */

      this._config = config;
      /**
       * An identifier used to classify the type of component.
       * The component manager uses this information in order to persist and organize components
       * @type {string|ComponentType}
       */

      this._type = this.constructor.name;
      /**
       * A local reference to the parent component, if exists
       * @type {Component}
       */

      this._parentContainer = config.parentContainer || null;
      /**
       * A container for all the child components
       * @type {Component[]}
       */

      this._children = [];
      /**
       * The state (data) of the component to be provided to the template for rendering
       * @type {object}
       */

      this._state = new State(config.state);
      /**
       * TODO(billy) This should be 'services'
       */

      this.core = systemConfig.core || null;
      /**
       * A local reference to the component manager, which contains all of the component classes
       * eligible to be created
       * @type {ComponentManager}
       */

      this.componentManager = systemConfig.componentManager || null;
      /**
       * A local reference to the analytics reporter, used to report events for this component
       * @type {AnalyticsReporter}
       */

      this.analyticsReporter = systemConfig.analyticsReporter || null;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      this._analyticsOptions = config.analyticsOptions || {};
      /**
       * A reference to the DOM node that the component will be appended to when mounted/rendered.
       * @type {HTMLElement}
       */

      if (this._parentContainer === null) {
        if (typeof config.container === 'string') {
          this._container = DOM.query(config.container) || null;

          if (this._container === null) {
            throw new Error('Cannot find container DOM node: ' + config.container);
          }
        }
      } else {
        this._container = DOM.query(this._parentContainer, config.container); // If we have a parent, and the container is missing from the DOM,
        // we construct the container and append it to the parent

        if (this._container === null) {
          this._container = DOM.createEl('div', {
            "class": config.container.substring(1, config.container.length)
          });
          DOM.append(this._parentContainer, this._container);
        }
      }
      /**
       * A custom class to be applied to {this._container} node
       * @type {string}
       */


      this._className = config["class"] || 'component';
      /**
       * A custom render function to be used instead of using the default renderer
       * @type {Renderer}
       */

      this._render = config.render || null;
      /**
       * A local reference to the default {Renderer} that will be used for rendering the template
       * @type {Renderer}
       */

      this._renderer = systemConfig.renderer || Renderers.Handlebars;
      /**
       * The template string to use for rendering the component
       * If this is left empty, we lookup the template the base templates using the templateName
       * @type {string}
       */

      this._template = config.template ? this._renderer.compile(config.template) : null;
      /**
       * The templateName to use for rendering the component.
       * This is only used if _template is empty.
       * @type {string}
       */

      this._templateName = config.templateName || this.constructor.defaultTemplateName(config);
      /**
       * An internal state indicating whether or not the component has been mounted to the DOM
       * @type {boolean}
       */

      this._isMounted = false;
      /**
       * A local reference to the callback, thats used to transform the internal data
       * models of the components, before it gets applied to the component state.
       * By default, no transformation happens.
       * @type {function}
       */

      this.transformData = config.transformData || this.transformData || function () {};
      /**
       * The a local reference to the callback that will be invoked when a component is created.
       * @type {function}
       */


      this.onCreate = config.onCreateOverride || this.onCreate || function () {};

      this.onCreate = this.onCreate.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a component is Mounted.
       * @type {function}
       */

      this.onMount = config.onMountOverride || this.onMount || function () {};

      this.onMount = this.onMount.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a components state is updated.
       * @type {function}
       */

      this.onUpdate = config.onUpdateOverride || this.onUpdate || function () {};

      this.onUpdate = this.onUpdate.bind(this);
      /**
       * A user provided onCreate callback
       * @type {function}
       */

      this.userOnCreate = config.onCreate || function () {};
      /**
       * A user provided onMount callback
       * @type {function}
       */


      this.userOnMount = config.onMount || function () {};
      /**
       * A user provided onUpdate callback
       * @type {function}
       */


      this.userOnUpdate = config.onUpdate || function () {};
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    Component.defaultTemplateName = function defaultTemplateName(config) {
      return 'default';
    };

    Component.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return false;
    };

    var _proto = Component.prototype;

    _proto.init = function init(opts) {
      var _this = this;

      try {
        this.setState(opts.data || opts.state || {});
        this.onCreate();
        this.userOnCreate();
      } catch (e) {
        throw new AnswersComponentError('Error initializing component', this.constructor.type, e);
      }

      this._state.on('update', function () {
        try {
          _this.onUpdate();

          _this.userOnUpdate();

          _this.unMount();

          _this.mount();
        } catch (e) {
          throw new AnswersComponentError('Error updating component', _this.constructor.type, e);
        }
      });

      DOM.addClass(this._container, this._className);
      return this;
    };

    _proto.setState = function setState(data) {
      var newState = Object.assign({}, {
        _config: this._config
      }, data);

      this._state.set(newState);

      return this;
    };

    _proto.getState = function getState(prop) {
      return this._state.get(prop);
    };

    _proto.hasState = function hasState(prop) {
      return this._state.has(prop);
    };

    _proto.transformData = function transformData(data) {
      return data;
    };

    _proto.addChild = function addChild(data, type, opts) {
      var childComponent = this.componentManager.create(type, Object.assign({
        name: data.name,
        parentContainer: this._container,
        data: data
      }, opts || {}, {
        _parentOpts: this._config
      }));

      this._children.push(childComponent);

      return childComponent;
    }
    /**
     * Unmount and remove this component and its children from the list
     * of active components
     */
    ;

    _proto.remove = function remove() {
      this._children.forEach(function (c) {
        return c.remove();
      });

      this.componentManager.remove(this);
    }
    /**
     * Set the render method to be used for rendering the component
     * @param {Function} render
     * @return {string}
     */
    ;

    _proto.setRender = function setRender(render) {
      this._render = render;
      return this;
    }
    /**
     * Set the renderer for the component
     * @param {RendererType} renderer
     */
    ;

    _proto.setRenderer = function setRenderer(renderer) {
      this._renderer = Renderers[renderer];
      return this;
    }
    /**
     * Sets the template for the component to use when rendering
     * @param {string} template
     */
    ;

    _proto.setTemplate = function setTemplate(template) {
      this._template = this._renderer.compile(template);
    };

    _proto.unMount = function unMount() {
      if (!this._container) {
        return this;
      }

      this._children.forEach(function (child) {
        child.unMount();
      });

      DOM.empty(this._container);

      this._children.forEach(function (c) {
        return c.remove();
      });

      this._children = [];
      this.onUnMount();
    };

    _proto.mount = function mount(container) {
      var _this2 = this;

      if (container) {
        this._container = container;
      }

      if (!this._container) {
        return this;
      }

      if (this.beforeMount() === false) {
        return this;
      }

      DOM.append(this._container, this.render(this._state.asJSON())); // Process the DOM to determine if we should create
      // in-memory sub-components for rendering

      var domComponents = DOM.queryAll(this._container, '[data-component]:not([data-is-component-mounted])');
      var data = this.transformData(JSON.parse(JSON.stringify(this._state.get())));
      domComponents.forEach(function (c) {
        return _this2._createSubcomponent(c, data);
      });

      this._children.forEach(function (child) {
        child.mount();
      }); // Attach analytics hooks as necessary


      if (this.analyticsReporter) {
        var domHooks = DOM.queryAll(this._container, '[data-eventtype]:not([data-is-analytics-attached])');
        domHooks.forEach(this._createAnalyticsHook.bind(this));
      }

      this._isMounted = true;
      this.onMount(this);
      this.userOnMount(this);
      return this;
    }
    /**
     * render the template using the {Renderer} with the current state and template of the component
     * @returns {string}
     */
    ;

    _proto.render = function render(data) {
      if (data === void 0) {
        data = this._state.get();
      }

      this.beforeRender(); // Temporary fix for passing immutable data to transformData().

      data = this.transformData(JSON.parse(JSON.stringify(data)));
      var html = ''; // Use either the custom render function or the internal renderer
      // dependant on the component configuration

      if (typeof this._render === 'function') {
        html = this._render(data);

        if (typeof html !== 'string') {
          throw new Error('Render method must return HTML as type {string}');
        }
      } else {
        // Render the existing templates as a string
        html = this._renderer.render({
          template: this._template,
          templateName: this._templateName
        }, data);
      } // We create an HTML Document fragment with the rendered string
      // So that we can query it for processing of sub components


      var el = DOM.create(html);
      this.afterRender();
      return el.innerHTML;
    };

    _proto._createSubcomponent = function _createSubcomponent(domComponent, data) {
      var _this3 = this;

      domComponent.dataset.isComponentMounted = true;
      var dataset = domComponent.dataset;
      var type = dataset.component;
      var prop = dataset.prop;
      var opts = dataset.opts ? JSON.parse(dataset.opts) : {};
      var childData = data[prop] || {};
      opts = _objectSpread2({}, opts, {
        container: domComponent
      }); // TODO(billy) Right now, if we provide an array as the data prop,
      // the behavior is to create many components for each item in the array.
      // THAT interface SHOULD change to use a different property that defines
      // whether to array data should be used for a single component or
      // to create many components for each item.
      // Overloading and having this side effect is unintuitive and WRONG

      if (!Array.isArray(childData)) {
        // Rendering a sub component should be within the context,
        // of the node that we processed it from
        this.addChild(childData, type, opts);
        return;
      }

      childData.reverse();
      childData.forEach(function (data) {
        _this3.addChild(data, type, opts);
      });
    };

    _proto._createAnalyticsHook = function _createAnalyticsHook(domComponent) {
      var _this4 = this;

      domComponent.dataset.isAnalyticsAttached = true;
      var dataset = domComponent.dataset;
      var type = dataset.eventtype;
      var label = dataset.eventlabel;
      var options = dataset.eventoptions ? JSON.parse(dataset.eventoptions) : {};
      DOM.on(domComponent, 'click', function (e) {
        var event = new AnalyticsEvent(type, label);
        event.addOptions(_this4._analyticsOptions);
        event.addOptions(options);

        _this4.analyticsReporter.report(event);
      });
    }
    /**
     * onCreate is triggered when the component is constructed
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.onCreate = function onCreate(cb) {}
    /**
     * onUpdate is triggered when the state of the component changes
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.onUpdate = function onUpdate(cb) {}
    /**
     * beforeRender event is triggered before the component is rendered
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.beforeRender = function beforeRender(cb) {}
    /**
     * afterRender event is triggered after the component is rendered
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.afterRender = function afterRender(cb) {}
    /**
     * onMount is triggered when the component is appended to the DOM
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.onMount = function onMount(cb) {}
    /**
     * onUnMount is triggered when the component is removed from the DOM
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.onUnMount = function onUnMount(cb) {}
    /**
     * beforeMount is triggered before the component is mounted to the DOM
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.beforeMount = function beforeMount(cb) {}
    /**
     * onDestroy is triggered when the component is destroyed
     * @param {function} the callback to invoke upon emit
     */
    ;

    _proto.onDestroy = function onDestroy(cb) {};

    _createClass(Component, null, [{
      key: "type",
      get: function get() {
        return 'Component';
      }
    }]);

    return Component;
  }();

  /** @module ErrorReporter */
  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * ErrorReporter is used for reporting errors to the console and API
   *
   * @implements {ErrorReporterService}
   */

  var ErrorReporter =
  /*#__PURE__*/
  function () {
    function ErrorReporter(config, globalStorage) {
      var _this = this;

      /**
       * The apiKey to use for reporting
       * @type {string}
       */
      this.apiKey = config.apiKey;
      /**
       * The experienceKey to use when reporting
       * @type {string}
       */

      this.experienceKey = config.experienceKey;
      /**
       * The answers config version used for api requests
       * @type {string|number}
       */

      this.experienceVersion = config.experienceVersion || 'config1.0';
      /**
       * If true, print entire error objects to the console for inspection
       * @type {boolean}
       */

      this.printVerbose = config.printVerbose;
      /**
       * If true, report the error the server for logging and monitoring
       * @type {boolean}
       */

      this.sendToServer = config.sendToServer;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       */

      if (this.sendToServer && !globalStorage) {
        throw new AnswersBasicError('Must include globalStorage to send errors to server', 'ErrorReporter');
      }

      this.globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this.environment = config.environment; // Attach reporting listeners to window

      window.addEventListener('error', function (e) {
        return _this.report(e.error);
      });
      window.addEventListener('unhandledrejection', function (e) {
        return _this.report(e.error);
      });
    }
    /**
     * report pretty prints the error to the console, optionally
     * prints the entire error if `printVerbose` is true, and sends the
     * error to the server to be logged if `sendToServer` is true
     * @param {AnswersBaseError} err The error to be reported
     * @returns {AnswersBaseError} The reported error
     */


    var _proto = ErrorReporter.prototype;

    _proto.report = function report(err) {
      if (!(err instanceof AnswersBaseError) || err.reported) {
        return;
      }

      err.reported = true;
      this.printError(err);

      if (this.sendToServer) {
        var requestConfig = {
          endpoint: '/v2/accounts/me/answers/errors',
          apiKey: this.apiKey,
          version: 20190301,
          environment: this.environment,
          params: {
            'libVersion': LIB_VERSION,
            'experienceVersion': this.experienceVersion,
            'experienceKey': this.experienceKey,
            'error': err.toJson()
          }
        };
        var request = new ApiRequest(requestConfig, this.globalStorage); // TODO(amullings): We should probably change this endpoint to POST,
        // ideally using the beacon API. Stack traces will likely easily hit URL
        // length limits.

        request.get()["catch"](console.err);
      }

      return err;
    }
    /**
     * prints the given error to the browser console
     * @param {AnswersBaseError} err The error to be printed
     */
    ;

    _proto.printError = function printError(err) {
      if (this.printVerbose) {
        console.error("error: " + err.errorMessage + "\ncode: " + err.errorCode + "\nboundary: " + err.boundary + "\nstack: " + err.stack);
      } else {
        console.error(err.toString());
      }
    };

    return ErrorReporter;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * @implements {ErrorReporterService}
   */
  var ConsoleErrorReporter =
  /*#__PURE__*/
  function () {
    function ConsoleErrorReporter() {}

    var _proto = ConsoleErrorReporter.prototype;

    /** @inheritdoc */
    _proto.report = function report(err) {
      console.error(err.toString());
    };

    return ConsoleErrorReporter;
  }();

  /** @module PersistentStorage */

  var PersistentStorage =
  /*#__PURE__*/
  function () {
    function PersistentStorage(config) {
      var _this = this;

      if (config === void 0) {
        config = {};
      }

      /**
       * The current params model
       * @type {SearchParams}
       */
      this._params = new SearchParams(window.location.search.substring(1));
      /**
       * The current history edit timer, if any
       * @type {number}
       */

      this._historyTimer = null;
      /**
       * The list of listeners to every storage update
       * @type {function[]}
       */

      this._updateListener = config.updateListener || function () {};
      /**
       * The list of listeners to storage resets
       * @type {function[]}
       */


      this._resetListener = config.resetListener || function () {};

      window.onpopstate = function () {
        _this._params = new SearchParams(window.location.search.substring(1));

        _this._callListener(_this._updateListener);

        _this._callListener(_this._resetListener);
      };
    }
    /**
     * Insert the given key/value pair into storage
     * @param {string} key The key to insert the data in
     * @param {*} data The data to insert
     * @param {boolean} replace history instead of pushing new state
     */


    var _proto = PersistentStorage.prototype;

    _proto.set = function set(key, data, replaceHistory) {
      if (replaceHistory === void 0) {
        replaceHistory = false;
      }

      if (typeof key !== 'string') {
        throw new AnswersStorageError('Storage data key must be a string', key, data);
      }

      var newData = data;

      if (typeof data !== 'string') {
        newData = JSON.stringify(data);
      }

      this._params.set(key, newData);

      this._updateHistory(replaceHistory);
    }
    /**
     * Delete the given key from storage
     * @param {string} key The key to delete
     * @param {boolean} replace history instead of pushing new state
     */
    ;

    _proto["delete"] = function _delete(key, replaceHistory) {
      if (replaceHistory === void 0) {
        replaceHistory = false;
      }

      this._params["delete"](key);

      this._updateHistory(replaceHistory);
    };

    _proto._updateHistory = function _updateHistory(replaceHistory) {
      var _this2 = this;

      if (replaceHistory === void 0) {
        replaceHistory = false;
      }

      if (this._historyTimer) {
        clearTimeout(this._historyTimer);
      } // batch update calls across components to avoid updating the url too much


      this._historyTimer = setTimeout(function () {
        _this2._historyTimer = null;

        if (replaceHistory) {
          window.history.replaceState(null, null, "?" + _this2._params.toString());
        } else {
          window.history.pushState(null, null, "?" + _this2._params.toString());
        }

        _this2._callListener(_this2._updateListener);
      });
    }
    /**
     * Invoke the given list of callbacks with the current storage data
     * @param {function[]} listeners The callbacks to invoke
     * @private
     */
    ;

    _proto._callListener = function _callListener(listener) {
      listener(this.getAll(), this._params.toString());
    }
    /**
     * Get all the key/value pairs in storage
     */
    ;

    _proto.getAll = function getAll() {
      var allParams = {};

      for (var _iterator = this._params.entries(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _ref2 = _ref,
            key = _ref2[0],
            val = _ref2[1];
        allParams[key] = val;
      }

      return allParams;
    };

    return PersistentStorage;
  }();

  /** @module SearchConfig */

  var SearchConfig =
  /*#__PURE__*/
  function () {
    function SearchConfig(config) {
      if (config === void 0) {
        config = {};
      }

      /**
       * The max results per search.
       * Also defines the number of results per page, if pagination is enabled
       * @type {number}
       */
      this.limit = config.limit || 20;
      /**
       * The vertical key to use for all searches
       * @type {string}
       */

      this.verticalKey = config.verticalKey || null;
      /**
       * A default search to use on initialization for vertical searchers, when the user has't provided a query
       * @type {string}
       */

      this.defaultInitialSearch = config.defaultInitialSearch;
      this.validate();
      Object.freeze(this);
    }

    var _proto = SearchConfig.prototype;

    _proto.validate = function validate() {
      if (typeof this.limit !== 'number' || this.limit < 1 || this.limit > 50) {
        throw new AnswersConfigError('Search Limit must be between 1 and 50', 'SearchConfig');
      }
    };

    return SearchConfig;
  }();

  /** @module AutoCompleteData */

  var AutoCompleteData =
  /*#__PURE__*/
  function () {
    function AutoCompleteData(data) {
      if (data === void 0) {
        data = {};
      }

      this.sections = data.sections || [];
      this.queryId = data.queryId || '';
      this.inputIntents = data.inputIntents || [];
      Object.freeze(this);
    }

    AutoCompleteData.from = function from(response) {
      var sections;

      if (response.sections) {
        sections = response.sections.map(function (s) {
          return {
            label: s.label,
            results: s.results.map(function (r) {
              return new AutoCompleteResult(r);
            })
          };
        });
      } else {
        sections = [{
          results: response.results.map(function (r) {
            return new AutoCompleteResult(r);
          })
        }];
      }

      var inputIntents = response.input ? response.input.queryIntents : [];
      return new AutoCompleteData({
        sections: sections,
        queryId: response.queryId,
        inputIntents: inputIntents
      });
    };

    return AutoCompleteData;
  }();
  var AutoCompleteResult = function AutoCompleteResult(data) {
    if (data === void 0) {
      data = {};
    }

    this.filter = data.filter || {};
    this.highlightedValue = new HighlightedValue(data).getInverted();
    this.key = data.key || '';
    this.matchedSubstrings = data.matchedSubstrings || [];
    this.value = data.value || '';
    this.shortValue = data.shortValue || this.value;
    this.intents = data.queryIntents || [];
    Object.freeze(this);
  };

  /** @module AutoCompleteDataTransformer */
  /**
   * A Data Transformer that takes the response object from a AutoComplete request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   *
   * TODO(billy) Create our own front-end data models
   */

  var AutoCompleteDataTransformer =
  /*#__PURE__*/
  function () {
    function AutoCompleteDataTransformer() {}

    AutoCompleteDataTransformer.clean = function clean(moduleId, data) {
      var _ref;

      if (data.sections && data.sections.length === 0) {
        delete data.sections;
      }

      if (data.sections && data.sections.length === 1 && data.sections[0].results.length === 0) {
        delete data.sections;
      }

      return _ref = {}, _ref[moduleId] = data, _ref;
    };

    AutoCompleteDataTransformer.universal = function universal(response) {
      return AutoCompleteData.from(response);
    };

    AutoCompleteDataTransformer.filter = function filter(response) {
      return AutoCompleteData.from(response);
    };

    AutoCompleteDataTransformer.vertical = function vertical(response) {
      return AutoCompleteData.from(response);
    };

    return AutoCompleteDataTransformer;
  }();

  /** @module AutoCompleteApi */
  /** @typedef {import('./autocompleteservice').default} AutoCompleteService */

  /**
   * AutoCompleteApi exposes an interface for network related matters
   * for all the autocomplete endpoints.
   *
   * @implements {AutoCompleteService}
   */

  var AutoCompleteApi =
  /*#__PURE__*/
  function () {
    function AutoCompleteApi(config, globalStorage) {
      if (config === void 0) {
        config = {};
      }

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'AutoComplete');
      }

      this._apiKey = config.apiKey;
      /**
       * The Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'AutoComplete');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'AutoComplete');
      }

      this._locale = config.locale;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'AutoComplete');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment;
    }
    /** @inheritdoc */


    var _proto = AutoCompleteApi.prototype;

    _proto.queryFilter = function queryFilter(input, config) {
      var requestConfig = {
        endpoint: '/v2/accounts/me/answers/filtersearch',
        apiKey: this._apiKey,
        version: this._version,
        environment: this._environment,
        params: {
          'input': input,
          'experienceKey': this._experienceKey,
          'version': this._experienceVersion,
          'verticalKey': config.verticalKey,
          'locale': this._locale,
          'search_parameters': JSON.stringify(config.searchParameters)
        }
      };
      var request = new ApiRequest(requestConfig, this._globalStorage);
      return request.get().then(function (response) {
        return response.json();
      }).then(function (response) {
        return AutoCompleteDataTransformer.filter(response.response);
      })["catch"](function (error) {
        throw new AnswersEndpointError('Filter search request failed', 'AutoComplete', error);
      });
    }
    /** @inheritdoc */
    ;

    _proto.queryVertical = function queryVertical(input, verticalKey) {
      var requestConfig = {
        endpoint: '/v2/accounts/me/answers/vertical/autocomplete',
        apiKey: this._apiKey,
        version: this._version,
        environment: this._environment,
        params: {
          'input': input,
          'experienceKey': this._experienceKey,
          'version': this._experienceVersion,
          'verticalKey': verticalKey,
          'locale': this._locale
        }
      };
      var request = new ApiRequest(requestConfig, this._globalStorage);
      return request.get().then(function (response) {
        return response.json();
      }).then(function (response) {
        return AutoCompleteDataTransformer.vertical(response.response);
      })["catch"](function (error) {
        throw new AnswersEndpointError('Vertical search request failed', 'AutoComplete', error);
      });
    }
    /** @inheritdoc */
    ;

    _proto.queryUniversal = function queryUniversal(queryString) {
      var requestConfig = {
        endpoint: '/v2/accounts/me/answers/autocomplete',
        apiKey: this._apiKey,
        version: this._version,
        environment: this._environment,
        params: {
          'input': queryString,
          'experienceKey': this._experienceKey,
          'version': this._experienceVersion,
          'locale': this._locale
        }
      };
      var request = new ApiRequest(requestConfig, this._globalStorage);
      return request.get(queryString).then(function (response) {
        return response.json();
      }).then(function (response) {
        return AutoCompleteDataTransformer.universal(response.response);
      })["catch"](function (error) {
        throw new AnswersEndpointError('Universal search request failed', 'AutoComplete', error);
      });
    };

    return AutoCompleteApi;
  }();

  /** @typedef {import('../services/autocompleteservice').default} AutoCompleteService */

  var universalOptions = ['what is yext', 'who is the ceo of yext'];
  var verticalOptions = ['near me', 'in new york', 'available now'];
  /**
   * MockAutoCompleteService serves autocomplete queries with mock data
   *
   * @implements {AutoCompleteService}
   */

  var MockAutoCompleteService =
  /*#__PURE__*/
  function () {
    function MockAutoCompleteService() {}

    var _proto = MockAutoCompleteService.prototype;

    /** @inheritdoc */
    _proto.queryFilter = function queryFilter(input, config) {
      // TODO(amullings): Simulate filter search, with sections
      return emptyResults();
    }
    /** @inheritdoc */
    ;

    _proto.queryVertical = function queryVertical(input, verticalKey) {
      return filterOptions(input, verticalOptions.map(function (opt) {
        return verticalKey + " " + opt;
      }).concat(universalOptions));
    }
    /** @inheritdoc */
    ;

    _proto.queryUniversal = function queryUniversal(input) {
      return filterOptions(input, universalOptions);
    };

    return MockAutoCompleteService;
  }();

  function filterOptions(input, options) {
    if (input.length === 0) {
      return emptyResults();
    }

    var lowercase = input.toLowerCase();
    var results = options.filter(function (opt) {
      return opt.includes(lowercase);
    }).map(function (opt) {
      return new AutoCompleteResult({
        value: opt,
        matchedSubstrings: [{
          offset: opt.indexOf(lowercase),
          length: lowercase.length
        }]
      });
    });
    return Promise.resolve(new AutoCompleteData({
      sections: [{
        results: results
      }],
      queryId: randomString()
    }));
  }
  /**
   * @returns {Promise<AutoCompleteData>}
   */


  function emptyResults() {
    return Promise.resolve(new AutoCompleteData({
      sections: [{}],
      queryId: randomString()
    }));
  }
  /**
   * @returns {string}
   */


  function randomString() {
    return Math.random().toString(36).substring(2);
  }

  /** @module QuestionAnswerApi */
  /** @typedef {import('./questionanswerservice').default} QuestionAnswerService */

  /**
   * QuestionAnswerApi submits questions via the Q&A REST API
   *
   * @implements {QuestionAnswerService}
   */

  var QuestionAnswerApi =
  /*#__PURE__*/
  function () {
    function QuestionAnswerApi(config, globalStorage) {
      if (config === void 0) {
        config = {};
      }

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'QuestionAnswerApi');
      }

      this._apiKey = config.apiKey;
      /**
       * The global storage instance of the experience
       * @type {GlobalStorage}
       * @private
       */

      if (!globalStorage) {
        throw new AnswersBasicError('Global storage is required', 'QuestionAnswerApi');
      }

      this._globalStorage = globalStorage;
      /**
       * The environment of the Answers experience
       * @type {string}
       * @private
       */

      this._environment = config.environment || PRODUCTION;
    }
    /** @inheritdoc */


    var _proto = QuestionAnswerApi.prototype;

    _proto.submitQuestion = function submitQuestion(question) {
      var requestConfig = {
        baseUrl: getKnowledgeApiUrl(this._environment),
        endpoint: '/v2/accounts/me/createQuestion',
        apiKey: this._apiKey,
        params: {
          'entityId': question.entityId,
          'site': question.site,
          'name': question.name,
          'email': question.email,
          'questionText': question.questionText,
          'questionDescription': question.questionDescription,
          'questionLanguage': question.questionLanguage
        }
      };
      var request = new ApiRequest(requestConfig, this._globalStorage);
      return request.post({
        mode: 'cors',
        headers: {
          'Content-Type': 'application/json'
        }
      }).then(function (response) {
        return response.json();
      })["catch"](function (error) {
        throw new AnswersEndpointError('Question submit failed', 'QuestionAnswerApi', error);
      });
    };

    return QuestionAnswerApi;
  }();

  /** @module MockQuestionAnswerService */

  /** @typedef {import('../services/questionanswerservice').default} QuestionAnswerService */

  /**
   * @implements {QuestionAnswerService}
   */
  var MockQuestionAnswerService =
  /*#__PURE__*/
  function () {
    function MockQuestionAnswerService() {}

    var _proto = MockQuestionAnswerService.prototype;

    /** @inheritdoc */
    _proto.submitQuestion = function submitQuestion(question) {
      // TODO(amullings): Make actual response object once we're using it for
      // something
      return Promise.resolve({});
    };

    return MockQuestionAnswerService;
  }();

  /* global fetch */

  /** @typedef {import('../models/section').default} Section */

  /** @typedef {import('../services/searchservice').default} SearchService */

  /**
   * @typedef {Object} ResultData
   * @property {Object} data
   * @property {string } htmlTitle
   */

  /**
   * @callback ResultsModifier
   * @param {ResultData[]} results
   * @returns {ResultData[]}
   */

  /**
   * @callback MockDataConsumer
   * @param {Section[]} sections
   * @returns {Promise<Object>}
   */
  var ARBITRARY_BUSINESS_ID = 919871;
  /**
   * @implements {SearchService}
   */

  var MockSearchService =
  /*#__PURE__*/
  function () {
    function MockSearchService() {
      /**
       * @type {Promise<string>}
       * @private
       */
      this._getMockDataJson = fetch('https://assets.sitescdn.net/answers/testdata/search/mockdata_v1.json').then(function (resp) {
        return resp.text();
      })["catch"](console.error);
    }
    /** @inheritdoc */


    var _proto = MockSearchService.prototype;

    _proto.verticalSearch = function verticalSearch(verticalKey, _ref) {
      var input = _ref.input,
          filter = _ref.filter,
          facetFilter = _ref.facetFilter,
          limit = _ref.limit,
          offset = _ref.offset,
          id = _ref.id,
          geolocation = _ref.geolocation,
          isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
          skipSpellCheck = _ref.skipSpellCheck,
          queryTrigger = _ref.queryTrigger;
      return this.useMockData(function (sections) {
        if (input === '') {
          return delayedResponse(constructVerticalResponse({
            results: [],
            appliedQueryFilters: []
          }));
        } // Either find a section with matching ID, or pick one at random


        var section = sections.find(function (verticalModule) {
          return verticalKey === verticalModule['verticalConfigId'];
        });

        if (section == null) {
          section = sections[Math.floor(Math.random() * sections.length)];
        }

        modifyResults(section, getResultsFilterer(input));

        if (offset != null && limit != null) {
          modifyResults(section, function limit(results) {
            return results.slice(offset, offset + limit);
          });
        }

        var resp = constructVerticalResponse(section);
        return delayedResponse(resp);
      });
    }
    /** @inheritdoc */
    ;

    _proto.universalSearch = function universalSearch(queryString, params) {
      return this.useMockData(function (sections) {
        if (queryString === '') {
          return delayedResponse(constructUniversalResponse([]));
        }

        sections.forEach(function (section) {
          modifyResults(section, getResultsFilterer(queryString));
        });
        sections = sections.filter(function (section) {
          return section.results.length > 0;
        });
        var resp = constructUniversalResponse(sections);
        return delayedResponse(resp);
      });
    }
    /**
     * @param {MockDataConsumer} consumer
     * @returns {Promise<Object>}
     * @private
     */
    ;

    _proto.useMockData = function useMockData(consumer) {
      return this._getMockDataJson.then(JSON.parse).then(consumer);
    };

    return MockSearchService;
  }();

  function getResultsFilterer(queryString) {
    return function (results) {
      return results.filter(function (result) {
        if (result.htmlTitle && result.htmlTitle.toLowerCase().includes(queryString)) {
          return true;
        }

        for (var prop in result.data) {
          var val = result.data[prop];

          if (typeof val === 'string' && val.toLowerCase().includes(queryString)) {
            return true;
          }
        }

        return false;
      });
    };
  }
  /**
   * @param {Section} section
   * @param {ResultsModifier} modifyFn
   */


  function modifyResults(section, modifyFn) {
    section.results = modifyFn(section.results);
  }
  /**
   * @param {Section[]} sections A list of mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructUniversalResponse(sections) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    sections = sections.map(fillSectionFields);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: {
        businessId: ARBITRARY_BUSINESS_ID,
        modules: sections,
        failedVerticals: [],
        queryId: uuidV4(),
        searchIntents: []
      }
    };
  }
  /**
   * @param {Section} section A mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructVerticalResponse(section) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    section = fillSectionFields(section);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: Object.assign(section, {
        businessId: ARBITRARY_BUSINESS_ID,
        queryId: uuidV4(),
        searchIntents: []
      })
    };
  }
  /**
   * @param {Section}
   * @returns {Section}
   */


  function fillSectionFields(section) {
    return {
      verticalConfigId: section.verticalConfigId,
      resultsCount: section.results.length,
      encodedState: '',
      results: section.results,
      appliedQueryFilters: section.appliedQueryFilters,
      queryDurationMillis: randomInt(50, 1000),
      facets: section.facets,
      source: section.source
    };
  }
  /**
   * @param {Object} resp
   * @returns {Promise<Object>}
   */


  function delayedResponse(resp) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(resp);
      }, randomInt(250, 1000));
    });
  }
  /**
   * Code-golf-y but legit basic UUID v4 implementation. Not cryptographically secure.
   * From https://gist.github.com/jed/982883
   * @returns {string} A v4-compliant UUID
   */


  function uuidV4() {
    return function b(a) {
      return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
    }();
  }
  /**
   * @param {number} min inclusive
   * @param {number} max exclusive
   * @returns {number} A random integer in the specified range
   */


  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }

  /**
   * The debounce duration for resize events
   * @type {number}
   */

  var RESIZE_DEBOUNCE = 100;
  /**
   * The breakpoint for mobile
   * @type {number}
   */

  var MOBILE_BREAKPOINT = 767;
  /**
   * Enum options for mobile overflow beahvior
   * @type {Object.<string, string>}
   */

  var MOBILE_OVERFLOW_BEHAVIOR_OPTION = {
    COLLAPSE: 'COLLAPSE',
    INNERSCROLL: 'INNERSCROLL'
  };
  /**
   * The Tab is a model that is used to power the Navigation tabs in the view.
   * It's initialized through the configuration provided to the component.
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(config) {
      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label;

      if (typeof this.label !== 'string') {
        throw new AnswersComponentError('label is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The complete URL, including the params
       * @type {string}
       */


      this.url = config.url;

      if (typeof this.url !== 'string') {
        throw new AnswersComponentError('url is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */


      this.configId = config.configId || null;
      /**
       * The base URL used for constructing the URL with params
       * @type {string}
       */

      this.baseUrl = config.url;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }
    /**
     * from will construct a map of configId to {Tab} from
     * a configuration file
     * @param {object} tabsConfig the configuration to use
     */


    Tab.from = function from(tabsConfig) {
      var tabs = {}; // Parse the options and build out our tabs and

      for (var i = 0; i < tabsConfig.length; i++) {
        var tab = tabsConfig[i]; // For tabs without config ids, map their URL to the configID
        // to avoid duplication of renders

        if (tab.configId === null && tabs[tab.configId] === undefined) {
          tab.configId = tab.url;
        }

        tabs[tab.configId] = new Tab(tab);
      }

      return tabs;
    };

    return Tab;
  }();
  /**
   * NavigationComponent exposes an interface for building a dynamic
   * navigation that is powered by universal search updates.
   * @extends Component
   */

  var NavigationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(NavigationComponent, _Component);

    function NavigationComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The label to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowLabel = config.overflowLabel || 'More';
      /**
       * The optional icon to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowIcon = config.overflowIcon || 'kabob';
      /**
       * The data storage key
       * @type {string}
       */

      _this.moduleId = StorageKeys.NAVIGATION;
      /**
       * Tabs config from global navigation config
       * @type {Array.<object>}
       * @private
       */

      _this._tabsConfig = _this.core.globalStorage.getState(StorageKeys.NAVIGATION_CONFIG).tabsConfig;
      /**
       * Unordered map of each tab, keyed by VS configId
       * @type {Object.<String, Object>}
       * @private
       */

      _this._tabs = Tab.from(_this._tabsConfig);
      /**
       * The order of the tabs, parsed from configuration or URL.
       * This gets updated based on the server results
       * @type {Array.<String>} The list of VS configIds
       * @private
       */

      _this._tabOrder = _this.getDefaultTabOrder(_this._tabsConfig, _this.getUrlParams());
      /**
       * Breakpoints at which navigation items move to the "more" dropdown
       * @type {number[]}
       * @private
       */

      _this._navBreakpoints = [];
      /**
       *  The mobile overflow behavior config
       *  @type {string}
       */

      _this._mobileOverflowBehavior = config.mobileOverflowBehavior || MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE;
      /**
       *  The ARIA label
       *  @type {string}
       */

      _this._ariaLabel = config.ariaLabel || 'Search Page Navigation';
      _this.checkOutsideClick = _this.checkOutsideClick.bind(_assertThisInitialized(_this));
      _this.checkMobileOverflowBehavior = _this.checkMobileOverflowBehavior.bind(_assertThisInitialized(_this));
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    NavigationComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'navigation/navigation';
    };

    var _proto = NavigationComponent.prototype;

    _proto.onCreate = function onCreate() {
      // TODO: Re-rendering and re-mounting the component every tim e the window changes size
      // is not great.
      DOM.on(window, 'resize', this.checkMobileOverflowBehavior);
    };

    _proto.onDestroy = function onDestroy() {
      DOM.off(window, 'resize', this.checkMobileOverflowBehavior);
    };

    _proto.onMount = function onMount() {
      if (this.shouldCollapse()) {
        this._navBreakpoints = [];
        this.bindOverflowHandlers();
        this.refitNav();
        DOM.on(DOM.query(this._container, '.yxt-Nav-more'), 'click', this.toggleMoreDropdown.bind(this));
      }
    };

    _proto.onUnMount = function onUnMount() {
      this.unbindOverflowHandlers();
    };

    _proto.bindOverflowHandlers = function bindOverflowHandlers() {
      DOM.on(window, 'click', this.checkOutsideClick);
    };

    _proto.unbindOverflowHandlers = function unbindOverflowHandlers() {
      DOM.off(window, 'click', this.checkOutsideClick);
    };

    _proto.refitNav = function refitNav() {
      var container = DOM.query(this._container, '.yxt-Nav-container');
      var moreButton = DOM.query(this._container, '.yxt-Nav-more');
      var mainLinks = DOM.query(this._container, '.yxt-Nav-expanded');
      var collapsedLinks = DOM.query(this._container, '.yxt-Nav-modal');
      var navWidth = moreButton.classList.contains('yxt-Nav-item--more') ? container.offsetWidth : container.offsetWidth - moreButton.offsetWidth;
      var numBreakpoints = this._navBreakpoints.length; // sum child widths instead of using parent's width to avoid
      // browser inconsistencies

      var mainLinksWidth = 0;

      for (var _iterator = mainLinks.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var el = _ref;
        mainLinksWidth += el.offsetWidth;
      }

      if (mainLinksWidth > navWidth) {
        this._navBreakpoints.push(mainLinksWidth);

        var lastLink = mainLinks.children.item(mainLinks.children.length - 1);

        if (lastLink === null) {
          return;
        }

        collapsedLinks.prepend(lastLink);

        if (moreButton.classList.contains('yxt-Nav-item--more')) {
          moreButton.classList.remove('yxt-Nav-item--more');
        }
      } else {
        if (numBreakpoints && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
          var firstLink = collapsedLinks.children.item(0);

          if (firstLink === null) {
            return;
          }

          mainLinks.append(firstLink);

          this._navBreakpoints.pop();

          numBreakpoints--;
        }

        if (collapsedLinks.children.length === 0) {
          moreButton.classList.add('yxt-Nav-item--more');
        }
      }

      this.closeMoreDropdown();

      if (mainLinksWidth > navWidth || numBreakpoints > 0 && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
        this.refitNav();
      }
    };

    _proto.closeMoreDropdown = function closeMoreDropdown() {
      var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
      collapsed.classList.remove('is-active');
      var moreButton = DOM.query(this._container, '.yxt-Nav-more');
      moreButton.setAttribute('aria-expanded', false);
    };

    _proto.openMoreDropdown = function openMoreDropdown() {
      var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
      collapsed.classList.add('is-active');
      var moreButton = DOM.query(this._container, '.yxt-Nav-more');
      moreButton.setAttribute('aria-expanded', true);
    };

    _proto.toggleMoreDropdown = function toggleMoreDropdown() {
      var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
      collapsed.classList.toggle('is-active');
      var moreButton = DOM.query(this._container, '.yxt-Nav-more');
      moreButton.setAttribute('aria-expanded', collapsed.classList.contains('is-active'));
    };

    _proto.checkOutsideClick = function checkOutsideClick(e) {
      if (e.target.closest('.yxt-Nav-container')) {
        return;
      }

      this.closeMoreDropdown();
    };

    _proto.checkMobileOverflowBehavior = function checkMobileOverflowBehavior() {
      if (this._checkMobileOverflowBehaviorTimer) {
        clearTimeout(this._checkMobileOverflowBehaviorTimer);
      }

      this._checkMobileOverflowBehaviorTimer = setTimeout(this.setState.bind(this), RESIZE_DEBOUNCE);
    }
    /**
     * Since the server data only provides a list of
     * VS configIds, we need to compute and transform
     * the data into the proper format for rendering.
     *
     * @override
     */
    ;

    _proto.setState = function setState(data) {
      if (data === void 0) {
        data = {};
      }

      if (data.tabOrder !== undefined) {
        this._tabOrder = this.mergeTabOrder(data.tabOrder, this._tabOrder);
      } // Since the tab ordering can change based on the server data
      // we need to update each tabs URL to include the order as part of their params.
      // This helps with persisting state across verticals.


      var tabs = [];

      for (var i = 0; i < this._tabOrder.length; i++) {
        var tab = this._tabs[this._tabOrder[i]];

        if (tab !== undefined) {
          tab.url = this.generateTabUrl(tab.baseUrl, this.getUrlParams());
          tabs.push(tab);
        }
      }

      return _Component.prototype.setState.call(this, {
        tabs: tabs,
        overflowLabel: this.overflowLabel,
        overflowIcon: this.overflowIcon,
        showCollapse: this.shouldCollapse(),
        ariaLabel: this._ariaLabel
      });
    };

    _proto.getUrlParams = function getUrlParams() {
      return new SearchParams(window.location.search.substring(1));
    };

    _proto.shouldCollapse = function shouldCollapse() {
      switch (this._mobileOverflowBehavior) {
        case MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE:
          return true;

        case MOBILE_OVERFLOW_BEHAVIOR_OPTION.INNERSCROLL:
          var container = DOM.query(this._container, '.yxt-Nav-container') || this._container;

          var navWidth = container.offsetWidth;
          return navWidth > MOBILE_BREAKPOINT;
      }
    }
    /**
     * getDefaultTabOrder will compute the initial tab ordering based
     * on a combination of the configuration provided directly to the component
     * and the url params.
     * @param {Object[]} tabsConfig
     * @param {SearchParams}
     */
    ;

    _proto.getDefaultTabOrder = function getDefaultTabOrder(tabsConfig, urlParams) {
      var tabOrder = []; // Use the ordering from the URL as the primary configuration
      // And then merge it with the local configuration, if provided.

      if (urlParams && urlParams.has('tabOrder')) {
        tabOrder = urlParams.get('tabOrder').split(',');
      }

      for (var i = 0; i < tabsConfig.length; i++) {
        var tab = tabsConfig[i]; // Some tabs don't have configId, so we map it from URL

        if (tab.configId === undefined) {
          tab.configId = tab.url;
        } // Avoid duplicates if config was provided from URL


        if (tabOrder.includes(tab.configId)) {
          continue;
        } // isFirst should always be the first element in the list


        if (tab.isFirst) {
          tabOrder.unshift(tab.configId);
        } else {
          tabOrder.push(tab.configId);
        }
      }

      return tabOrder;
    }
    /**
     * mergeTabOrder merges two arrays into one
     * by appending additional tabs to the end of the original array
     * @param {string[]} tabOrder Tab order provided by the server
     * @param {string[]} otherTabOrder Tab order provided by configuration
     * @return {string[]}
     */
    ;

    _proto.mergeTabOrder = function mergeTabOrder(tabOrder, otherTabOrder) {
      for (var i = 0; i < otherTabOrder.length; i++) {
        var tabConfig = otherTabOrder[i];

        if (tabOrder.includes(tabConfig)) {
          continue;
        } // isFirst should be an override to dynamic tab ordering.


        if (this._tabs[tabConfig] && this._tabs[tabConfig].isFirst) {
          tabOrder.unshift(tabConfig);
        } else {
          tabOrder.push(tabConfig);
        }
      }

      return tabOrder;
    };

    _proto.generateTabUrl = function generateTabUrl(baseUrl, params) {
      if (params === void 0) {
        params = new URLSearchParams();
      }

      // We want to persist the params from the existing URL to the new
      // URLS we create.
      params.set('tabOrder', this._tabOrder);
      return baseUrl + '?' + params.toString();
    };

    _createClass(NavigationComponent, null, [{
      key: "type",
      get: function get() {
        return 'Navigation';
      }
    }]);

    return NavigationComponent;
  }(Component);

  /**
   * SearchComponent exposes an interface in order to create
   * a UI Search experience for vertical and universal search.
   *
   * @extends Component
   */

  var SearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(SearchComponent, _Component);

    function SearchComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, auto-complete and search will be based on universal
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided. If not provided, no title will be included.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The label text is used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.labelText = config.labelText || 'Conduct a search';
      /**
       * The submit text is used for labeling the submit button, also provided to the template.
       * @type {string}
       */

      _this.submitText = config.submitText || 'Submit';
      /**
       * The clear text is used for labeling the clear button, also provided to the template.
       * @type {string}
       */

      _this.clearText = config.clearText || 'Clear';
      /**
       * The submit icon is an icon for the submit button, if provided it will be displayed and the
       * submit text will be used for screen readers.
       * @type {string|null}
       */

      _this.submitIcon = config.submitIcon || null;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * If true, show an "x" that allows the user to clear the current
       * query
       * @type {boolean}
       */

      _this.clearButton = config.clearButton === undefined ? true : config.clearButton;
      /**
       * When autofocusing on load, optionally open the autocomplete
       * (preset prompts)
       * @type {boolean}
       */

      _this.autocompleteOnLoad = config.autocompleteOnLoad || false;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * true if there is another search bar present on the page.
       * Twins only update the query, and do not search
       */

      _this._isTwin = config.isTwin;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string|null}
       */

      _this.query = config.query || _this.core.globalStorage.getState(StorageKeys.QUERY);

      _this.core.globalStorage.on('update', StorageKeys.QUERY, function (q) {
        _this.query = q;

        _this.setState();

        _this.debouncedSearch(q);
      });
      /**
       * The minimum time allowed in milliseconds between searches to prevent
       * many duplicate searches back-to-back
       * @type {number}
       * @private
       */


      _this._searchCooldown = config.searchCooldown || 300;
      /**
       * When true and "near me" intent is expressed, prompt the user for their geolocation
       * @type {boolean}
       * @private
       */

      _this._promptForLocation = config.promptForLocation === undefined ? true : Boolean(config.promptForLocation);
      /**
       * Controls showing and hiding the search clear button
       */

      _this._showClearButton = _this.clearButton && _this.query;
      /**
       * For vertical search bars, whether or not to allow empty searches.
       * @type {boolean}
       * @private
       */

      _this._allowEmptySearch = !!config.allowEmptySearch;
      /**
       * The name of the child AutoComplete component.
       * @type {string}
       * @private
       */

      _this._autoCompleteName = _this.name + ".autocomplete";
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    SearchComponent.defaultTemplateName = function defaultTemplateName() {
      return 'search/search';
    };

    var _proto = SearchComponent.prototype;

    _proto.onCreate = function onCreate() {
      if (this.query != null && !this.redirectUrl) {
        this.core.setQuery(this.query);
      }
    };

    _proto.onMount = function onMount() {
      // NOTE(amullings): If autocompleteOnLoad is false, we focus the input
      // element before loading the autocomplete component so that its focus
      // handler won't be triggered
      if (this.autoFocus === true && !this.query && !this.autocompleteOnLoad) {
        this.focusInputElement();
      } // Wire up our search handling and auto complete


      this.initSearch(this._formEl);
      this.initAutoComplete(this._inputEl);

      if (this.clearButton) {
        this.initClearButton();
      }

      if (this.autoFocus === true && !this.query && this.autocompleteOnLoad) {
        this.focusInputElement();
      }
    };

    _proto.remove = function remove() {
      this._autocomplete.remove();

      _Component.prototype.remove.call(this);
    };

    _proto.initClearButton = function initClearButton() {
      var _this2 = this;

      var button = DOM.query(this._container, '.js-yxt-SearchBar-clear');
      this._showClearButton = this._showClearButton || this.query;
      button.classList.toggle('yxt-SearchBar--hidden', !this._showClearButton);
      DOM.on(button, 'click', function () {
        _this2.query = '';
        _this2._showClearButton = false;
        button.classList.add('yxt-SearchBar--hidden');

        _this2.setState({});

        _this2.core.persistentStorage.set(StorageKeys.QUERY, _this2.query);

        _this2.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

        _this2.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

        _this2.core.setQuery(_this2.query); // Focus the input element after clearing the query, regardless of whether
        // or not the autoFocus option is enabled.
        // NOTE(amullings): This depends heavily on the fact that the re-renders
        // triggered by setState and core.setQuery happen synchronously; if this
        // stops being the case at some point, we'll need an alternative solution


        _this2.focusInputElement();
      });
      var input = DOM.query(this._container, this._inputEl);
      DOM.on(input, 'input', function (e) {
        var input = e.target.value;

        if (!_this2._showClearButton && input.length > 0) {
          _this2._showClearButton = true;
          button.classList.remove('yxt-SearchBar--hidden');
        } else if (_this2._showClearButton && input.length === 0) {
          _this2._showClearButton = false;
          button.classList.add('yxt-SearchBar--hidden');
        }
      });
    }
    /**
     * A helper method to use for wiring up searching on form submission
     * @param {string} formSelector CSS selector to bind our submit handling to
     */
    ;

    _proto.initSearch = function initSearch(formSelector) {
      var _this3 = this;

      this._formEl = formSelector;

      this._container.classList.add('yxt-SearchBar-wrapper');

      var form = DOM.query(this._container, formSelector);

      if (!form) {
        throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._formEl, '`.');
      }

      DOM.on(form, 'submit', function (e) {
        e.preventDefault();
        var inputEl = form.querySelector(_this3._inputEl);
        var query = inputEl.value;
        var params = new SearchParams(window.location.search.substring(1));
        params.set('query', query); // If we have a redirectUrl, we want the form to be
        // serialized and submitted.

        if (typeof _this3.redirectUrl === 'string') {
          window.location.href = _this3.redirectUrl + '?' + params.toString();
          return false;
        }

        inputEl.blur();

        _this3.core.persistentStorage.set(StorageKeys.QUERY, query);

        _this3.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

        _this3.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

        _this3.core.setQuery(query);

        _this3.debouncedSearch(query);

        return false;
      });
    }
    /**
     * A helper method to wire up our auto complete on an input selector
     * @param {string} inputSelector CSS selector to bind our auto complete component to
     */
    ;

    _proto.initAutoComplete = function initAutoComplete(inputSelector) {
      var _this4 = this;

      this._inputEl = inputSelector;

      if (this._autocomplete) {
        this._autocomplete.remove();
      }

      this._autocomplete = this.componentManager.create('AutoComplete', {
        parentContainer: this._container,
        name: this._autoCompleteName,
        container: '.yxt-SearchBar-autocomplete',
        autoFocus: this.autoFocus && !this.autocompleteOnLoad,
        verticalKey: this._verticalKey,
        promptHeader: this.promptHeader,
        originalQuery: this.query,
        inputEl: inputSelector,
        onSubmit: function onSubmit() {
          DOM.trigger(DOM.query(_this4._container, _this4._formEl), 'submit');
        },
        onChange: function onChange() {
          DOM.trigger(DOM.query(_this4._container, inputSelector), 'input');
        }
      });
    }
    /**
     * Performs a debounced query using the provided string input. Specifically, a new search is not
     * performed if we recently searched, if there's no query for universal search, or if this
     * is a twin searchbar.
     * @param {string} query The string to query against.
     * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
     */
    ;

    _proto.debouncedSearch = function debouncedSearch(query) {
      var _this5 = this;

      if (this._throttled || !query && !this._verticalKey || !query && this._verticalKey && !this._allowEmptySearch || this._isTwin) {
        return;
      }

      this._throttled = true;
      setTimeout(function () {
        _this5._throttled = false;
      }, this._searchCooldown); // If _promptForLocation is enabled, we will compute the query's intent and, from there,
      // determine if it's necessary to prompt the user for their location information. It will
      // be unnecessary if the query does not have near me intent or we already have their location
      // stored.

      if (this._promptForLocation) {
        this.fetchQueryIntents(query).then(function (queryIntents) {
          return queryIntents.includes('NEAR_ME');
        }).then(function (queryHasNearMeIntent) {
          if (queryHasNearMeIntent && !_this5.core.globalStorage.getState(StorageKeys.GEOLOCATION)) {
            return new Promise(function (resolve, reject) {
              return navigator.geolocation.getCurrentPosition(function (position) {
                _this5.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                  lat: position.coords.latitude,
                  lng: position.coords.longitude,
                  radius: position.coords.accuracy
                });

                resolve(_this5.search(query));
              }, function () {
                return resolve(_this5.search(query));
              });
            });
          } else {
            return _this5.search(query);
          }
        });
      } else {
        return this.search(query);
      }
    }
    /**
     * Performs a query using the provided string input.
     * @param {string} query The string to query against.
     * @returns {Promise} A promise that will perform the query and update globalStorage accordingly.
     */
    ;

    _proto.search = function search(query) {
      if (this._verticalKey) {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, allFilters) : allFilters[0];
        return this.core.verticalSearch(this._verticalKey, {
          input: query,
          filter: JSON.stringify(totalFilter),
          offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0
        });
      } else {
        // NOTE(billy) Temporary hack for DEMO
        // Remove me after the demo
        var nav = this.componentManager.getActiveComponent('Navigation');

        if (nav) {
          var tabs = nav.getState('tabs');
          var urls = {};

          if (tabs && Array.isArray(tabs)) {
            for (var i = 0; i < tabs.length; i++) {
              var params = new SearchParams(tabs[i].url.split('?')[1]);
              params.set('query', query);
              var url = tabs[i].baseUrl;

              if (params.toString().length > 0) {
                url += '?' + params.toString();
              }

              urls[tabs[i].configId] = url;
            }
          }

          return this.core.search(query, urls);
        }

        return this.core.search(query);
      }
    }
    /**
     * A helper method that computes the intents of the provided query. If the query was entered
     * manually into the search bar or selected via autocomplete, its intents will have been stored
     * already in globalStorage. Otherwise, a new API call will have to be issued to determine
     * intent.
     * @param {string} query The query whose intent is needed.
     * @returns {Promise} A promise containing the intents of the query.
     */
    ;

    _proto.fetchQueryIntents = function fetchQueryIntents(query) {
      var autocompleteData = this.core.globalStorage.getState(StorageKeys.AUTOCOMPLETE + "." + this._autoCompleteName);

      if (!autocompleteData) {
        var autocompleteRequest = this._verticalKey ? this.core.autoCompleteVertical(query, this._autoCompleteName, this._verticalKey) : this.core.autoCompleteUniversal(query, this._autoCompleteName);
        return autocompleteRequest.then(function (data) {
          return data.inputIntents;
        });
      } else {
        // There are two alternatives to consider here. The user could have selected the query
        // as an autocomplete option or manually input it themselves. If the former, use the intents
        // of the corresponding autocomplete option. If the latter, use the inputIntents of the
        // autocompleteData.
        var results = autocompleteData.sections.flatMap(function (section) {
          return section.results;
        });
        var matchingResult = results.find(function (result) {
          return result.value === query;
        });
        var queryIntents = matchingResult ? matchingResult.intents : autocompleteData.inputIntents;
        return Promise.resolve(queryIntents);
      }
    }
    /**
     * A helper method that constructs the meta information needed by the SEARCH_CLEAR_BUTTON
     * analytics event.
     */
    ;

    _proto.eventOptions = function eventOptions() {
      var queryId = this.core.globalStorage.getState(StorageKeys.QUERY_ID);
      var options = Object.assign({}, queryId && {
        queryId: queryId
      }, this._verticalKey && {
        verticalKey: this._verticalKey
      });
      return JSON.stringify(options);
    };

    _proto.setState = function setState(data) {
      return _Component.prototype.setState.call(this, Object.assign({
        title: this.title,
        labelText: this.labelText,
        submitIcon: this.submitIcon,
        submitText: this.submitText,
        clearText: this.clearText,
        showClearButton: this._showClearButton,
        query: this.query || '',
        eventOptions: this.eventOptions()
      }, data));
    };

    _proto.focusInputElement = function focusInputElement() {
      DOM.query(this._container, this._inputEl).focus();
    };

    _createClass(SearchComponent, null, [{
      key: "type",
      get: function get() {
        return 'SearchBar';
      }
    }]);

    return SearchComponent;
  }(Component);

  /** @module SearchParamsParser */
  function buildSearchParameters(searchParameterConfigs) {
    var searchParameters = {
      sectioned: false,
      fields: []
    };

    if (searchParameterConfigs === undefined) {
      return searchParameters;
    }

    if (searchParameterConfigs.sectioned) {
      searchParameters.sectioned = searchParameterConfigs.sectioned;
    }

    searchParameters.fields = buildFields(searchParameterConfigs.fields);
    return searchParameters;
  }

  function buildFields(fieldConfigs) {
    if (fieldConfigs === undefined) {
      return [];
    }

    return fieldConfigs.map(function (fc) {
      return _objectSpread2({
        fetchEntities: false
      }, fc);
    });
  }

  /**
   * FilterSearchComponent is used for autocomplete using the FilterSearch backend.
   * It'll allow you to pick pre-set filters that are setup on the backend within
   * a vertical search context.
   *
   * @extends Component
   */

  var FilterSearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(FilterSearchComponent, _Component);

    function FilterSearchComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The vertical key for vertical search configuration
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * If true, store the filter value but do not search on change
       * @type {boolean}
       * @private
       */

      _this._storeOnChange = config.storeOnChange || false;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The search text used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.searchText = config.searchText || 'What are you interested in?';
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string}
       */

      _this.query = config.query || _this.core.globalStorage.getState(StorageKeys.QUERY + "." + _this.name) || '';

      _this.core.globalStorage.on('update', StorageKeys.QUERY + "." + _this.name, function (q) {
        _this.query = q;

        _this.search();
      });
      /**
       * The filter string to use for the provided query
       * Optionally provided
       * @type {string}
       */


      _this.filter = config.filter || _this.core.globalStorage.getState(StorageKeys.FILTER + "." + _this.name) || '';

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.searchParameters = buildSearchParameters(config.searchParameters);

      _this.core.globalStorage.on('update', StorageKeys.FILTER + "." + _this.name, function (f) {
        _this.filter = f;
      });

      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    FilterSearchComponent.defaultTemplateName = function defaultTemplateName() {
      return 'search/filtersearch';
    };

    var _proto = FilterSearchComponent.prototype;

    _proto.onCreate = function onCreate() {
      if (this.query && this.filter) {
        this.search();
      }
    };

    _proto.onMount = function onMount() {
      // Wire up our search handling and auto complete
      this.initAutoComplete(this._inputEl);

      if (this.autoFocus === true && this.query.length === 0) {
        DOM.query(this._container, this._inputEl).focus();
      }
    }
    /**
     * A helper method to wire up our auto complete on an input selector
     * @param {string} inputSelector CSS selector to bind our auto complete component to
     */
    ;

    _proto.initAutoComplete = function initAutoComplete(inputSelector) {
      var _this2 = this;

      this._inputEl = inputSelector;
      this.componentManager.create('AutoComplete', {
        parentContainer: this._container,
        name: this.name + ".autocomplete",
        isFilterSearch: true,
        container: '.yxt-SearchBar-autocomplete',
        promptHeader: this.promptHeader,
        originalQuery: this.query,
        originalFilter: this.filter,
        inputEl: inputSelector,
        verticalKey: this._verticalKey,
        searchParameters: this.searchParameters,
        onSubmit: function onSubmit(query, filter) {
          var params = new SearchParams(window.location.search.substring(1));
          params.set(_this2.name + ".query", query);
          params.set(_this2.name + ".filter", filter); // If we have a redirectUrl, we want the params to be
          // serialized and submitted.

          if (typeof _this2.redirectUrl === 'string') {
            window.location.href = _this2.redirectUrl + '?' + params.toString();
            return false;
          } // save the filter to storage for the next search


          _this2.query = query;
          _this2.filter = Filter.fromResponse(filter);

          _this2.core.persistentStorage.set(StorageKeys.QUERY + "." + _this2.name, _this2.query);

          _this2.core.persistentStorage.set(StorageKeys.FILTER + "." + _this2.name, _this2.filter);

          _this2.core.setFilter(_this2.name, _this2.filter);

          _this2.search();
        }
      });
    }
    /**
     * Perform the vertical search with all saved filters and query,
     * optionally redirecting based on config
     */
    ;

    _proto.search = function search() {
      if (this._storeOnChange) {
        return;
      }

      var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
      var totalFilter = filters[0];

      if (filters.length > 1) {
        totalFilter = Filter.and.apply(Filter, filters);
      }

      var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
      var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
      this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.verticalSearch(this._verticalKey, {
        input: searchQuery,
        filter: JSON.stringify(totalFilter),
        facetFilter: JSON.stringify(facetFilter)
      });
    };

    _proto.setState = function setState(data) {
      return _Component.prototype.setState.call(this, Object.assign({
        title: this.title,
        searchText: this.searchText,
        query: this.query,
        filter: this.filter
      }, data));
    };

    _createClass(FilterSearchComponent, null, [{
      key: "type",
      get: function get() {
        return 'FilterSearch';
      }
    }]);

    return FilterSearchComponent;
  }(Component);

  var Keys = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESCAPE: 27,
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DELETE: 46,
    DOWN: 40,
    LEFT_OS_KEY: 91,
    RIGHT_OS_KEY: 92,
    SELECT_KEY: 93
  };

  var AutoCompleteComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(AutoCompleteComponent, _Component);

    function AutoCompleteComponent(opts, systemOpts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      if (systemOpts === void 0) {
        systemOpts = {};
      }

      _this = _Component.call(this, opts, systemOpts) || this;
      /**
       * Whether autocomplete is simple or filter
       * @type {boolean}
       */

      _this.isFilterSearch = opts.isFilterSearch || false;
      /**
       * The `verticalKey` of the vertical search to use for auto-complete
       * @type {string}
       */

      _this._verticalKey = opts.verticalKey || null;
      /**
       * A reference to the input el selector for auto complete
       * @type {string}
       */

      _this._inputEl = opts.inputEl || '.js-yext-query';
      /**
       * A selector for the autocomplete elementes
       * @type {string}
       */

      _this._autocompleteEls = opts.autoCompleteEls || '.js-yext-autocomplete-option';
      /**
       * An internal reference for the data-storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = StorageKeys.AUTOCOMPLETE + "." + _this.name;
      /**
       * An internal reference to the input value when typing.
       * We use this for resetting the state of the input value when other interactions (e.g. result navigation)
       * change based on interactions. For instance, hitting escape should reset the value to the original typed query.
       * @type {string}
       */

      _this._originalQuery = opts.originalQuery || '';
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current section we're navigating in.
       * @type {number}
       */

      _this._sectionIndex = 0;
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current result index we're navigating on.
       * @type {number}
       */

      _this._resultIndex = -1;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = opts.promptHeader || null;
      /**
       * Whether the input is autocomatically focused or not
       * @type {boolean}
       */

      _this._autoFocus = opts.autoFocus || false;
      /**
       * Callback invoked when the `Enter` key is pressed on auto complete.
       */

      _this._onSubmit = opts.onSubmit || function () {};
      /**
       * Callback invoked when keys are used to navigate through the auto complete. Note that this is
       * not called when either the `Enter` key is pressed or the mouse is used to select an
       * autocomplete option.
       */


      _this._onChange = opts.onChange || function () {};

      _this._searchParameters = opts.searchParameters || null;
      return _this;
    }
    /**
     * The aliased used by the component manager for creation.
     */


    /**
     * The template to render
     * @returns {string}
     * @override
     */
    AutoCompleteComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'search/autocomplete';
    }
    /**
     * setState is overridden so that we can provide additional meta data
     * to the template (e.g. the sectionIndex and resultIndex), since
     * those are client-interaction specific values and aren't returned from the server.
     */
    ;

    var _proto = AutoCompleteComponent.prototype;

    _proto.setState = function setState(data) {
      if (!this.isQueryInputFocused()) {
        this._sectionIndex = 0;
        this._resultIndex = -1;
        data = {};
      }

      _Component.prototype.setState.call(this, Object.assign({}, data, {
        hasResults: this.hasResults(data),
        sectionIndex: this._sectionIndex,
        resultIndex: this._resultIndex,
        promptHeader: this._originalQuery.length === 0 ? this.promptHeader : null
      }));
    };

    _proto.isQueryInputFocused = function isQueryInputFocused() {
      return document.activeElement && document.activeElement.className.includes(this._inputEl.substring(1));
    }
    /**
     * updateState is a helper to apply the current state with new client-state.
     */
    ;

    _proto.updateState = function updateState() {
      this.setState(this._state.get());
    }
    /**
     * onCreate is triggered when the component is constructed from the framework.
     * Once we're initalized, we wire up all of our user interactions
     */
    ;

    _proto.onCreate = function onCreate() {
      var _this2 = this;

      // Use the context of the parent component to find the input node.
      var queryInput = DOM.query(this._parentContainer, this._inputEl);

      if (!queryInput) {
        throw new Error('Could not initialize AutoComplete. Can not find {HTMLElement} `', this._inputEl, '`.');
      } // Disable the native autocomplete, autocorrect & spellcheck


      DOM.attributes(queryInput, {
        autocomplete: 'off',
        autocorrect: 'off',
        spellcheck: 'false'
      }); // The user exits the input, so we want to reset the state and close
      // the auto complete
      // TODO(jdelerme): Close logic to be moved to parent

      DOM.on(document, 'click', function (e) {
        if (e.target.matches('.js-yxt-AutoComplete-wrapper *') || e.target.matches(_this2._inputEl)) {
          return;
        }

        _this2.close();
      }); // When a user focuses the input, we should populate the autocomplete based
      // on the current value

      DOM.on(queryInput, 'focus', function () {
        _this2.reset();

        _this2.autoComplete(queryInput.value);
      }); // Allow the user to navigate between the results using the keyboard

      DOM.on(queryInput, 'keydown', function (e) {
        _this2.handleNavigateResults(e.keyCode, e);

        _this2.handleSubmitResult(e.keyCode, queryInput.value, e);
      });

      if (this._autoFocus) {
        DOM.once(queryInput, 'click', function () {
          _this2.autoComplete(queryInput.value);
        });
      } // Allow the user to select a result with the mouse


      DOM.delegate(this._container, '.js-yext-autocomplete-option', 'click', function (evt, target) {
        var data = target.dataset;
        var val = data["short"];

        _this2.updateQuery(val);

        _this2._onSubmit(val, data.filter);

        _this2.close();
      }); // When the user is typing in the input, process the auto complete.

      DOM.on(queryInput, 'keyup', function (e) {
        _this2.handleTyping(e.keyCode, queryInput.value, e);
      });
    }
    /**
     * close will hide the auto complete results and reset the state.
     */
    ;

    _proto.close = function close() {
      this.setState({});
      this.reset();
    }
    /**
     * resets the client state to their original values and triggers
     * a template-rerender via updateState
     */
    ;

    _proto.reset = function reset() {
      this._sectionIndex = 0;
      this._resultIndex = -1;
      this.updateState();
    }
    /**
     * Helper method to update the input text
     * @param {string} optValue Option value provided.
     * If no value provided, we'll try to find it based on the selection indexes.
     */
    ;

    _proto.updateQuery = function updateQuery(optValue) {
      // Only want to update the query string if theres a value.
      // If one is provided, great.
      // Otherwise, lets try to find it from the current selection in the results.
      if (optValue === undefined) {
        var sections = this._state.get('sections');

        var results = sections[this._sectionIndex].results;
        optValue = results[this._resultIndex].shortValue;
      }

      var queryEl = DOM.query(this._parentContainer, this._inputEl);
      queryEl.value = optValue;
    };

    _proto.handleTyping = function handleTyping(key, value, e) {
      var ignoredKeys = [Keys.DOWN, Keys.UP, Keys.CTRL, Keys.ALT, Keys.SHIFT, Keys.LEFT, Keys.RIGHT, Keys.LEFT_OS_KEY, Keys.RIGHT_OS_KEY, Keys.ENTER, Keys.TAB, Keys.SELECT_KEY];

      if (ignoredKeys.indexOf(key) > -1) {
        return;
      } // User escapes out of auto complete, so we reset it to the original input


      if (key === Keys.ESCAPE) {
        this.updateQuery(this._originalQuery);
        this.close();
        return;
      } // Update the original value based on the user input


      this._originalQuery = value;
      this.reset();
      this.autoComplete(value);
    };

    _proto.autoComplete = function autoComplete(input) {
      if (this.isFilterSearch) {
        this.core.autoCompleteFilter(input, {
          namespace: this.name,
          verticalKey: this._verticalKey,
          searchParameters: this._searchParameters
        });
      } else if (this._verticalKey) {
        this.core.autoCompleteVertical(input, this.name, this._verticalKey);
      } else {
        this.core.autoCompleteUniversal(input, this.name);
      }
    }
    /**
     * returns true if we have results in any section
     * @returns boolean
     */
    ;

    _proto.hasResults = function hasResults(data) {
      if (!data) {
        return false;
      }

      var sections = data['sections'];

      if (!sections) {
        return false;
      }

      for (var i = 0; i < sections.length; i++) {
        var _data = sections[i];

        if (!_data) {
          continue;
        }

        var results = _data.results;

        if (!results) {
          continue;
        }

        if (results.length > 0) {
          return true;
        }
      }

      return false;
    };

    _proto.handleNavigateResults = function handleNavigateResults(key, e) {
      var sections = this._state.get('sections');

      if (sections === undefined || sections.length <= 0) {
        return;
      } // Tabbing out or enter should close the auto complete.


      if (key === Keys.TAB) {
        this.close();
        return;
      }

      var results = sections[this._sectionIndex].results;

      if (key === Keys.UP) {
        e.preventDefault();

        if (this._resultIndex <= 0) {
          if (this._sectionIndex > 0) {
            this._sectionIndex--;
            this._resultIndex = sections[this._sectionIndex].results.length - 1;
          } else {
            this.updateQuery(this._originalQuery);
            this.reset();
            return;
          }

          this.updateQuery();
          this.updateState();
          return;
        }

        this._resultIndex--;
        this.updateState();
        this.updateQuery();
        return;
      }

      if (key === Keys.DOWN) {
        e.preventDefault();

        if (this._resultIndex >= results.length - 1) {
          if (this._sectionIndex < sections.length - 1) {
            this._sectionIndex++;
            this._resultIndex = 0;
          }

          this.updateQuery();
          this.updateState();
          return;
        }

        this._resultIndex++;
        this.updateQuery();
        this.updateState();
      }
    };

    _proto.handleSubmitResult = function handleSubmitResult(key, value, e) {
      var sections = this._state.get('sections');

      if (sections === undefined || sections.length <= 0) {
        if (this.isFilterSearch) {
          this.autoComplete(value);
        }

        return;
      } // submit the search on enter


      if (key === Keys.ENTER) {
        e.preventDefault();

        if (this.isFilterSearch && this._resultIndex === -1) {
          return;
        }

        var filter = '';

        if (this._sectionIndex >= 0 && this._resultIndex >= 0) {
          filter = JSON.stringify(sections[this._sectionIndex].results[this._resultIndex].filter);
        }

        this.updateQuery(value);
        this._originalQuery = value;

        this._onSubmit(value, filter);

        this.close();
      } else {
        this._onChange();
      }
    };

    _createClass(AutoCompleteComponent, null, [{
      key: "type",
      get: function get() {
        return 'AutoComplete';
      }
    }]);

    return AutoCompleteComponent;
  }(Component);

  /**
   * SpellCheckComponent will support displaying suggestion, autocorrect and combined(maybe in the future)
   * provided from spelling correction.
   *
   * @extends Component
   */

  var SpellCheckComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(SpellCheckComponent, _Component);

    function SpellCheckComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      _this.moduleId = StorageKeys.SPELL_CHECK;
      return _this;
    }

    SpellCheckComponent.defaultTemplateName = function defaultTemplateName() {
      return 'search/spellcheck';
    };

    var _proto = SpellCheckComponent.prototype;

    _proto.onCreate = function onCreate() {
      this.core.persistentStorage["delete"]('skipSpellCheck', true);
      this.core.persistentStorage["delete"]('queryTrigger', true);
    };

    _proto.setState = function setState(data, val) {
      return _Component.prototype.setState.call(this, Object.assign({}, data, {
        shouldShow: data.correctedQuery !== undefined,
        correctedQueryUrl: this._buildRedirectQueryUrl(data.correctedQuery, data.type),
        helpText: this._getHelpText(data.type)
      }, val));
    };

    _proto._buildRedirectQueryUrl = function _buildRedirectQueryUrl(query, type) {
      if (query === undefined) {
        return '';
      }

      var params = new SearchParams(window.location.search.substring(1));
      params.set('query', query.value);
      params.set('skipSpellCheck', true);
      params.set('queryTrigger', type.toLowerCase());
      return '?' + params.toString();
    };

    _proto._getHelpText = function _getHelpText(type) {
      switch (type) {
        case 'SUGGEST':
          return 'Did you mean:';

        default:
          return '';
      }
    };

    _createClass(SpellCheckComponent, null, [{
      key: "type",
      get: function get() {
        return 'SpellCheck';
      }
    }]);

    return SpellCheckComponent;
  }(Component);

  /**
   * LocationBiasComponent will show the user where is used for location bias and allow user to
   * improve accuracy with HTML5 geolocation.
   *
   * @extends Component
   */

  var LocationBiasComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(LocationBiasComponent, _Component);

    function LocationBiasComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.LOCATION_BIAS;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, when location updated,
       * a universal search will be triggered.
       * @type {string}
       */
      // TODO: Remove config.verticalKey

      _this._verticalKey = config.verticalKey || _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey || null;
      /**
       * The element used for updating location
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._updateLocationEl = config.updateLocationEl || '.js-locationBias-update-location';
      _this._locationDisplayName = '';
      _this._accuracy = '';
      _this._allowUpdate = true;
      return _this;
    }

    LocationBiasComponent.defaultTemplateName = function defaultTemplateName() {
      return 'search/locationbias';
    };

    var _proto = LocationBiasComponent.prototype;

    _proto.onMount = function onMount() {
      var _this2 = this;

      if (!this._allowUpdate) {
        return;
      }

      this._disableLocationUpdateIfGeolocationDenied();

      DOM.on(this._updateLocationEl, 'click', function (e) {
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(function (position) {
            _this2.core.globalStorage.set(StorageKeys.GEOLOCATION, {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              radius: position.coords.accuracy
            });

            _this2._doSearch();
          }, function (err) {
            if (err.code === 1) {
              _this2._disableLocationUpdate();
            }
          });
        } // TODO: Should we throw error or warning here if no geolocation?

      });
    };

    _proto.setState = function setState(data, val) {
      this._locationDisplayName = data.locationDisplayName;
      this._accuracy = data.accuracy;
      return _Component.prototype.setState.call(this, Object.assign({}, data, {
        locationDisplayName: this._getLocationDisplayName(data),
        accuracyText: this._getAccuracyHelpText(data.accuracy),
        isPreciseLocation: data.accuracy === 'DEVICE' && this._allowUpdate,
        isUnknownLocation: data.accuracy === 'UNKNOWN',
        shouldShow: data.accuracy !== undefined,
        allowUpdate: this._allowUpdate
      }, val));
    };

    _proto._getLocationDisplayName = function _getLocationDisplayName(data) {
      if (data.accuracy === 'UNKNOWN') {
        return 'Unknown Location';
      }

      return data.locationDisplayName;
    };

    _proto._getAccuracyHelpText = function _getAccuracyHelpText(accuracy) {
      switch (accuracy) {
        case 'IP':
          return 'based on your internet address';

        case 'DEVICE':
          return 'based on your device';

        default:
          return '';
      }
    };

    _proto._doSearch = function _doSearch() {
      var query = this.core.globalStorage.getState(StorageKeys.QUERY);

      if (this._verticalKey) {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, allFilters) : allFilters[0];
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.verticalSearch(this._verticalKey, {
          input: query,
          filter: JSON.stringify(totalFilter),
          offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0,
          facetFilter: JSON.stringify(facetFilter)
        });
      } else {
        this.core.search(query);
      }
    };

    _proto._disableLocationUpdateIfGeolocationDenied = function _disableLocationUpdateIfGeolocationDenied() {
      var _this3 = this;

      if ('permissions' in navigator) {
        navigator.permissions.query({
          name: 'geolocation'
        }).then(function (result) {
          if (result.state === 'denied') {
            _this3._disableLocationUpdate();
          }
        });
      }
    };

    _proto._disableLocationUpdate = function _disableLocationUpdate() {
      this.core.globalStorage["delete"](StorageKeys.GEOLOCATION);
      this._allowUpdate = false;
      this.setState({
        locationDisplayName: this._locationDisplayName,
        accuracy: this._accuracy
      });
    };

    _createClass(LocationBiasComponent, null, [{
      key: "type",
      get: function get() {
        return 'LocationBias';
      }
    }]);

    return LocationBiasComponent;
  }(Component);

  /** @module Facet */

  /**
   * Model representing a facet filter with the format of
   * {
   *   "field_name": [ Filters... ],
   *   ...
   * }
   *
   * @see {@link Filter}
   */
  var Facet =
  /*#__PURE__*/
  function () {
    function Facet(data) {
      if (data === void 0) {
        data = {};
      }

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Create a facet filter from a list of Filters
     * @param  {...Filter} filters The filters to use in this facet
     * @returns {Facet}
     */


    Facet.fromFilters = function fromFilters(availableFieldIds) {
      var groups = {};
      availableFieldIds.forEach(function (fieldId) {
        groups[fieldId] = [];
      });

      for (var _len = arguments.length, filters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        filters[_key - 1] = arguments[_key];
      }

      var flatFilters = filters.flatMap(function (f) {
        return f.$or || f;
      });
      flatFilters.forEach(function (f) {
        var key = Object.keys(f)[0];

        if (!groups[key]) {
          groups[key] = [];
        }

        groups[key].push(f);
      });
      return new Facet(groups);
    };

    return Facet;
  }();

  var FilterBoxConfig =
  /*#__PURE__*/
  function () {
    function FilterBoxConfig(config) {
      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFilter = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFilterLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFilters = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFiltersLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The selector of the apply button
       * @type {string}
       */

      this.applyButtonSelector = config.applyButtonSelector || '.js-yext-filterbox-apply';
      /**
       * The list of filters to display and control, ignoring empty sections
       * @type {object[]}
       */

      this.filterConfigs = config.filters.filter(function (f) {
        return f.options.length !== 0;
      });
      /**
       * Whether or not this filterbox contains facets. This affects the
       * the way the filters are used in the search
       * @type {boolean}
       */

      this.isDynamic = config.isDynamic || false;
      this.validate();
    }

    var _proto = FilterBoxConfig.prototype;

    _proto.validate = function validate() {};

    return FilterBoxConfig;
  }();
  /**
   * Renders a set of filters, and searches with them when applied.
   * Multiple FilterBox components will AND together but will not share state.
   * @extends Component
   */


  var FilterBoxComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(FilterBoxComponent, _Component);

    function FilterBoxComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      _this.config = new FilterBoxConfig(config);

      if (!config.filters || !(config.filters instanceof Array)) {
        throw new AnswersComponentError('FilterBox requires filters to be provided as an array', 'FilterBox');
      }
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */


      _this._verticalKey = config.verticalKey || null;
      /**
       * The components created for each filter config
       * @type {Component[]}
       * @private
       */

      _this._filterComponents = [];
      /**
       * The current state of the filter components in the box
       * @type {Filter}
       * @private
       */

      _this._filters = [];

      if (!_this.config.showCount) {
        _this.config.filterConfigs.forEach(function (config) {
          config.options.forEach(function (option) {
            option.countLabel = null;
          });
        });
      }

      return _this;
    }

    FilterBoxComponent.defaultTemplateName = function defaultTemplateName() {
      return 'filters/filterbox';
    };

    var _proto2 = FilterBoxComponent.prototype;

    _proto2.setState = function setState(data) {
      _Component.prototype.setState.call(this, Object.assign({}, data, this.config, {
        showReset: this.config.resetFilters,
        resetLabel: this.config.resetFiltersLabel,
        showApplyButton: !this.config.searchOnChange
      }));
    };

    _proto2.onMount = function onMount() {
      var _this2 = this;

      if (this._filterComponents.length) {
        this._filterComponents.forEach(function (c) {
          return c.remove();
        });

        this._filterComponents = [];
        this._filters = [];
      } // Initialize filters from configs


      var _loop = function _loop(i) {
        var config = _this2.config.filterConfigs[i];

        var component = _this2.componentManager.create(config.type, Object.assign({}, config, _this2.config, {
          parentContainer: _this2._container,
          name: _this2.name + ".filter" + i,
          storeOnChange: false,
          container: ".js-yext-filterbox-filter" + i,
          showReset: _this2.config.resetFilter,
          resetLabel: _this2.config.resetFilterLabel,
          showExpand: _this2.config.expand,
          onChange: function onChange(filter) {
            _this2.onFilterChange(i, filter);
          }
        }));

        component.mount();

        _this2._filterComponents.push(component);

        _this2._filters[i] = component.getFilter();

        _this2._saveFiltersToStorage();
      };

      for (var i = 0; i < this.config.filterConfigs.length; i++) {
        _loop(i);
      } // Initialize apply button


      if (!this.config.searchOnChange) {
        var button = DOM.query(this._container, this.config.applyButtonSelector);

        if (button) {
          DOM.on(button, 'click', function () {
            _this2._saveFiltersToStorage();

            _this2._search();
          });
        }
      } // Initialize reset button


      if (this.config.resetFilters) {
        DOM.on(DOM.query(this._container, '.js-yxt-FilterBox-reset'), 'click', this.resetFilters.bind(this));
      }
    };

    _proto2.resetFilters = function resetFilters() {
      this._filterComponents.forEach(function (filter) {
        return filter.clearOptions();
      });
    }
    /**
     * Handle changes to child filter components
     * @param {number} index The index of the changed filter
     * @param {Filter} filter The new filter
     */
    ;

    _proto2.onFilterChange = function onFilterChange(index, filter) {
      this._filters[index] = filter;

      if (this.config.searchOnChange) {
        this._saveFiltersToStorage();

        this._search();
      }
    }
    /**
     * Remove all filter components along with this component
     */
    ;

    _proto2.remove = function remove() {
      this._filterComponents.forEach(function (c) {
        return c.remove();
      });

      _Component.prototype.remove.call(this);
    }
    /**
     * Save current filters to storage to be used in the next search
     * @private
     */
    ;

    _proto2._saveFiltersToStorage = function _saveFiltersToStorage() {
      var validFilters = this._filters.filter(function (f) {
        return f !== undefined && f !== null && Object.keys(f).length > 0;
      });

      if (this.config.isDynamic) {
        var availableFieldIds = this.config.filterConfigs.map(function (config) {
          return config.fieldId;
        });
        var combinedFilter = Facet.fromFilters.apply(Facet, [availableFieldIds].concat(validFilters));
        this.core.setFacetFilter(this.name, combinedFilter || {});
      } else {
        var _combinedFilter = validFilters.length > 1 ? Filter.and.apply(Filter, validFilters) : validFilters[0];

        this.core.setFilter(this.name, _combinedFilter || {});
      }
    }
    /**
     * Trigger a search with all filters in storage
     */
    ;

    _proto2._search = function _search() {
      var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
      var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, allFilters) : allFilters[0];
      var query = this.core.globalStorage.getState(StorageKeys.QUERY);
      var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
      this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.verticalSearch(this._verticalKey, {
        input: query,
        filter: JSON.stringify(totalFilter),
        facetFilter: JSON.stringify(facetFilter)
      });
    };

    _createClass(FilterBoxComponent, null, [{
      key: "type",
      get: function get() {
        return 'FilterBox';
      }
    }]);

    return FilterBoxComponent;
  }(Component);

  /**
   * The currently supported controls
   * @type {string[]}
   */

  var SUPPORTED_CONTROLS = ['singleoption', 'multioption'];

  var FilterOptionsConfig =
  /*#__PURE__*/
  function () {
    function FilterOptionsConfig(config) {
      /**
       * The type of control to display
       * @type {string}
       */
      this.control = config.control;
      /**
       * The list of filter options to display with checked status
       * @type {object[]}
       */

      this.options = config.options;
      /**
       * The label to be used in the legend
       * @type {string}
       */

      this.label = config.label || 'Filters';
      /**
       * The callback function to call when changed
       * @type {function}
       */

      this.onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       */


      this.storeOnChange = config.storeOnChange || false;
      /**
       * If true, show a button to reset the current filter selection
       * @type {boolean}
       */

      this.showReset = config.showReset && this.options.length > 0;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetLabel = config.resetLabel || 'reset';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      this.showMore = this.showMore && this.options.length > this.showMoreLimit;
      /**
       * If true, allow expanding and collapsing the group of facets
       * @type {boolean}
       */

      this.showExpand = config.showExpand === undefined ? true : config.showExpand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * The selector used for options in the template
       * @type {string}
       */

      this.optionSelector = config.optionSelector || '.js-yext-filter-option';
      this.validate();

      if (typeof config.previousOptions === 'string') {
        try {
          config.previousOptions = JSON.parse(config.previousOptions);
        } catch (e) {
          config.previousOptions = [];
        }
      }

      var selectedOptions = config.previousOptions || [];
      this.options = this.setDefaultSelectedValues(this.options, selectedOptions);
    }

    var _proto = FilterOptionsConfig.prototype;

    _proto.setDefaultSelectedValues = function setDefaultSelectedValues(options, selectedOptions) {
      return options.map(function (o) {
        return _objectSpread2({}, o, {
          selected: selectedOptions.length ? selectedOptions.includes(o.label) : o.selected
        });
      });
    };

    _proto.getSelectedCount = function getSelectedCount() {
      return this.options.reduce(function (numSelected, option) {
        return option.selected ? numSelected + 1 : numSelected;
      }, 0);
    };

    _proto.validate = function validate() {
      if (!this.control || !SUPPORTED_CONTROLS.includes(this.control)) {
        throw new AnswersComponentError('FilterOptions requires a valid "control" to be provided', 'FilterOptions');
      }

      if (!this.options) {
        throw new AnswersComponentError('FilterOptions component requires options to be provided', 'FilterOptions');
      }
    };

    return FilterOptionsConfig;
  }();
  /**
   * Renders a set of options, each one representing a filter in a search.
   */


  var FilterOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(FilterOptionsComponent, _Component);

    function FilterOptionsComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;

      var previousOptions = _this.core.globalStorage.getState(_this.name);

      _this.core.globalStorage["delete"](_this.name);
      /**
       * The component config
       * @type {FilterOptionsConfig}
       */


      _this.config = new FilterOptionsConfig(_objectSpread2({
        previousOptions: previousOptions
      }, config));

      var selectedCount = _this.config.getSelectedCount();
      /**
       * True if the option list is expanded and visible
       * @type {boolean}
       */


      _this.expanded = _this.config.showExpand ? selectedCount > 0 : true;
      /**
       * True if all options are shown, false if some are hidden based on config
       * @type {boolean}
       */

      _this.allShown = false;
      return _this;
    }

    /**
     * The template to render, based on the control
     * @returns {string}
     * @override
     */
    FilterOptionsComponent.defaultTemplateName = function defaultTemplateName(config) {
      return "controls/filteroptions";
    };

    var _proto2 = FilterOptionsComponent.prototype;

    _proto2.setState = function setState(data) {
      var options = this.config.options;

      if (this.config.showMore && !this.allShown) {
        options = this.config.options.slice(0, this.config.showMoreLimit);
      }

      var selectedCount = this.config.getSelectedCount();

      _Component.prototype.setState.call(this, Object.assign({}, data, _objectSpread2({
        name: this.name.toLowerCase()
      }, this.config, {
        showReset: this.config.showReset && selectedCount > 0,
        expanded: this.expanded,
        allShown: this.allShown,
        selectedCount: selectedCount,
        isSingleOption: this.config.control === 'singleoption',
        options: options
      })));
    };

    _proto2.onMount = function onMount() {
      var _this2 = this;

      DOM.delegate(DOM.query(this._container, ".yxt-FilterOptions-options"), this.config.optionSelector, 'click', function (event) {
        _this2._updateOption(parseInt(event.target.dataset.index), event.target.checked);
      });
      var selectedCount = this.config.getSelectedCount(); // reset button

      if (this.config.showReset && selectedCount > 0) {
        DOM.on(DOM.query(this._container, '.yxt-FilterOptions-reset'), 'click', this.clearOptions.bind(this));
      } // show more/less button


      if (this.config.showMore) {
        DOM.on(DOM.query(this._container, '.yxt-FilterOptions-showToggle'), 'click', function () {
          _this2.allShown = !_this2.allShown;

          _this2.setState();
        });
      } // expand button


      if (this.config.showExpand) {
        var legend = DOM.query(this._container, '.yxt-FilterOptions-clickableLegend');
        DOM.on(legend, 'mousedown', function (click) {
          if (click.button === 0) {
            _this2.expanded = !_this2.expanded;

            _this2.setState();
          }
        });
        DOM.on(legend, 'keydown', function (key) {
          if (key.key === ' ' || key.key === 'Enter') {
            key.preventDefault();
            _this2.expanded = !_this2.expanded;

            _this2.setState();
          }
        });
      }
    };

    _proto2.clearOptions = function clearOptions() {
      this.config.options = this.config.options.map(function (o) {
        return Object.assign({}, o, {
          selected: false
        });
      });
      this.updateListeners();
      this.setState();
    };

    _proto2.updateListeners = function updateListeners() {
      var filter = this._buildFilter();

      if (this.config.storeOnChange) {
        this.core.setFilter(this.name, filter);
      }

      this.config.onChange(filter);
    };

    _proto2._updateOption = function _updateOption(index, selected) {
      if (this.config.control === 'singleoption') {
        this.config.options = this.config.options.map(function (o) {
          return Object.assign({}, o, {
            selected: false
          });
        });
      }

      this.config.options[index] = Object.assign({}, this.config.options[index], {
        selected: selected
      });
      this.updateListeners();
      this.setState();
    };

    _proto2.getFilter = function getFilter() {
      return this._buildFilter();
    }
    /**
     * Clear all options
     */
    ;

    _proto2.clear = function clear() {
      var elements = DOM.queryAll(this._container, this.config.optionSelector);
      elements.forEach(function (e) {
        return e.setAttribute('checked', 'false');
      });

      this._applyFilter();
    }
    /**
     * Build and return the Filter that represents the current state
     * @returns {Filter}
     * @private
     */
    ;

    _proto2._buildFilter = function _buildFilter() {
      var filters = this.config.options.filter(function (o) {
        return o.selected;
      }).map(function (o) {
        return o.filter ? o.filter : Filter.equal(o.field, o.value);
      });
      this.core.persistentStorage.set(this.name, this.config.options.filter(function (o) {
        return o.selected;
      }).map(function (o) {
        return o.label;
      }));
      return filters.length > 0 ? Filter.group.apply(Filter, filters) : {};
    };

    _createClass(FilterOptionsComponent, null, [{
      key: "type",
      get: function get() {
        return 'FilterOptions';
      }
    }]);

    return FilterOptionsComponent;
  }(Component);

  var RangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(RangeFilterComponent, _Component);

    function RangeFilterComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The field to filter on
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The callback function to call when the filter value changes
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;

      var minVal = _this.core.globalStorage.getState(_this.name + ".min");

      if (typeof minVal === 'string') {
        try {
          minVal = Number.parseInt(minVal);
        } catch (e) {}
      }

      var maxVal = _this.core.globalStorage.getState(_this.name + ".max");

      if (typeof minVal === 'string') {
        try {
          maxVal = Number.parseInt(maxVal);
        } catch (e) {}
      }
      /**
       * The current range represented
       * @type {object}
       * @private
       */


      _this._range = {
        min: minVal || config.initialMin || 0,
        max: maxVal || config.initialMax || 10
      };
      /**
       * The title to display for the range control
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to display for the min input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to display for the max input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The template to render
       * @type {string}
       * @private
       */

      _this._templateName = "controls/range";
      return _this;
    }

    var _proto = RangeFilterComponent.prototype;

    _proto.setState = function setState(data) {
      _Component.prototype.setState.call(this, Object.assign({}, data, {
        name: this.name,
        title: this._title,
        minLabel: this._minLabel,
        maxLabel: this._maxLabel,
        minValue: this._range.min,
        maxValue: this._range.max
      }));
    };

    _proto.onCreate = function onCreate() {
      var _this2 = this;

      DOM.delegate(this._container, '.js-yext-range', 'change', function (event) {
        _this2._updateRange(event.target.dataset.key, Number.parseInt(event.target.value));
      });
    };

    _proto.setMin = function setMin(value) {
      this._updateRange('min', value);
    };

    _proto.setMax = function setMax(value) {
      this._updateRange('max', value);
    };

    _proto.getFilter = function getFilter() {
      return this._buildFilter();
    }
    /**
     * Update the current range state
     * @param {string} key The range key to update
     * @param {number} value The new value for the key
     */
    ;

    _proto._updateRange = function _updateRange(key, value) {
      var _Object$assign;

      this._range = Object.assign({}, this._range, (_Object$assign = {}, _Object$assign[key] = value, _Object$assign));
      this.setState();

      var filter = this._buildFilter();

      if (this._storeOnChange) {
        this.core.setFilter(this.name, filter);
      }

      this.core.persistentStorage.set(this.name + ".min", this._range.min);
      this.core.persistentStorage.set(this.name + ".max", this._range.max);

      this._onChange(filter);
    }
    /**
     * Build the filter representation of the current state
     * @returns {Filter}
     */
    ;

    _proto._buildFilter = function _buildFilter() {
      return Filter.inclusiveRange(this._field, this._range.min, this._range.max);
    };

    _createClass(RangeFilterComponent, null, [{
      key: "type",
      get: function get() {
        return 'RangeFilter';
      }
    }]);

    return RangeFilterComponent;
  }(Component);

  /**
   * A filter for a range of dates
   */

  var DateRangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(DateRangeFilterComponent, _Component);

    function DateRangeFilterComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The api field this filter controls
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The title to display for the date range
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to show for the min date input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to show for the max date input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The callback used when a date is changed
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
      /**
       * If true, this filter represents an exclusive range, rather than an inclusive one
       * @type {boolean}
       * @private
       */

      _this._isExclusive = config.isExclusive;
      /**
       * The template for this component
       * @private
       */

      _this._templateName = "controls/date";
      var today = new Date();
      var todayString = today.getFullYear() + "-" + ("" + (today.getMonth() + 1)).padStart(2, '0') + "-" + ("" + today.getDate()).padStart(2, '0');

      var minDate = _this.core.globalStorage.getState(_this.name + ".min");

      var maxDate = _this.core.globalStorage.getState(_this.name + ".max");
      /**
       * The current date range
       * @private
       */


      _this._date = {
        min: minDate || config.initialMin || todayString,
        max: maxDate || config.initialMax || todayString
      };
      return _this;
    }

    var _proto = DateRangeFilterComponent.prototype;

    _proto.setState = function setState(data) {
      _Component.prototype.setState.call(this, Object.assign({}, data, {
        name: this.name,
        title: this._title,
        minLabel: this._minLabel,
        maxLabel: this._maxLabel,
        dateMin: this._date.min,
        dateMax: this._date.max
      }));
    };

    _proto.onCreate = function onCreate() {
      var _this2 = this;

      DOM.delegate(this._container, '.js-yext-date', 'change', function (event) {
        _this2._updateRange(event.target.dataset.key, event.target.value);
      });
    }
    /**
     * Set the min date to the one provided
     * @param {string} date Date to set in yyyy-mm-dd string format
     */
    ;

    _proto.setMin = function setMin(date) {
      this._updateRange('min', date);
    }
    /**
     * Set the max date to the one provided
     * @param {string} date Date to set in yyyy-mm-dd string format
     */
    ;

    _proto.setMax = function setMax(date) {
      this._updateRange('max', date);
    };

    _proto.getFilter = function getFilter() {
      return this._buildFilter();
    }
    /**
     * Updates the current state of the date range
     * @param {string} key The key for the date value
     * @param {string} value The string date value
     * @private
     */
    ;

    _proto._updateRange = function _updateRange(key, value) {
      var _Object$assign;

      this._date = Object.assign({}, this._date, (_Object$assign = {}, _Object$assign[key] = value, _Object$assign));
      this.setState();

      var filter = this._buildFilter();

      if (this._storeOnChange) {
        this.core.setFilter(this.name, filter);
      }

      this.core.persistentStorage.set(this.name + ".min", this._date.min);
      this.core.persistentStorage.set(this.name + ".max", this._date.max);

      this._onChange(filter);
    }
    /**
     * Construct an api filter with the current date state
     * @private
     */
    ;

    _proto._buildFilter = function _buildFilter() {
      if (this._date.min === '' || this._date.max === '') {
        return {};
      }

      return this._isExclusive ? Filter.exclusiveRange(this._field, this._date.min, this._date.max) : Filter.inclusiveRange(this._field, this._date.min, this._date.max);
    };

    _createClass(DateRangeFilterComponent, null, [{
      key: "type",
      get: function get() {
        return 'DateRangeFilter';
      }
    }]);

    return DateRangeFilterComponent;
  }(Component);

  var FacetsConfig =
  /*#__PURE__*/
  function () {
    function FacetsConfig(config) {
      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFacet = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFacetLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFacets = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFacetsLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The controls to use for each field. Each type of filter has a default
       * $eq : multioption (checkbox)
       * @type {Object}
       */

      this.fieldControls = config.fieldControls || {};
      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      this.applyButtonSelector = config.applyButtonSelector || null;
      this.validate();
    }

    var _proto = FacetsConfig.prototype;

    _proto.validate = function validate() {};

    return FacetsConfig;
  }();
  /**
   * Displays a set of dynamic filters returned from the backend
   * @extends Component
   */


  var FacetsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(FacetsComponent, _Component);

    function FacetsComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      _this.config = new FacetsConfig(config);
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */

      _this._verticalKey = config.verticalKey; // config.verticalKey || null;

      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      _this._applyButtonSelector = config.applyButtonSelector || null;
      /**
       * An internal reference for the data storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
      /**
       * The filter box that displays the dynamic filters
       * @type {FilterBoxComponent}
       * @private
       */

      _this._filterbox = null;
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    FacetsComponent.defaultTemplateName = function defaultTemplateName() {
      return 'filters/facets';
    };

    var _proto2 = FacetsComponent.prototype;

    _proto2.remove = function remove() {
      if (this._filterbox) {
        this._filterbox.remove();
      }

      _Component.prototype.remove.call(this);
    };

    _proto2.onMount = function onMount() {
      var _this2 = this;

      this.core.enableDynamicFilters();

      if (this._filterbox) {
        this._filterbox.remove();
      }

      var _this$_state$get = this._state.get(),
          filters = _this$_state$get.filters;

      if (!filters) {
        return;
      }

      filters = filters.map(function (f) {
        return Object.assign({}, f, {
          type: 'FilterOptions',
          control: _this2.config.fieldControls[f.fieldId] || 'multioption'
        });
      });
      this._filterbox = this.componentManager.create('FilterBox', Object.assign({}, this.config, {
        parentContainer: this._container,
        name: this.name + ".filterbox",
        container: '.js-yxt-Facets',
        verticalKey: this._verticalKey,
        resetFilter: this.config.resetFacet,
        resetFilters: this.config.resetFacets,
        resetFilterLabel: this.config.resetFacetLabel,
        resetFiltersLabel: this.config.resetFacetsLabel,
        isDynamic: true,
        filters: filters
      }));

      this._filterbox.mount();
    };

    _createClass(FacetsComponent, null, [{
      key: "type",
      get: function get() {
        return 'Facets';
      }
    }]);

    return FacetsComponent;
  }(Component);

  var METERS_PER_MILE = 1609.344;
  var DEFAULT_CONFIG = {
    /**
     * The radius, in miles, around the user's location to find results.
     * If location accuracy is low, a larger radius may be used automatically
     * @type {number}
     */
    radius: 50,

    /**
     * The vertical key to use
     * @type {string}
     */
    verticalKey: null,

    /**
     * If true, submits a search when the value is changed
     * @type {boolean}
     */
    searchOnChange: false,

    /**
     * The title to display
     * @type {string}
     */
    title: 'Location',

    /**
     * The label to display
     * @type {string}
     */
    label: 'Location',

    /**
     * The icon url to show in the geo button
     * @type {string}
     */
    geoButtonIcon: '',

    /**
     * The text to show in the geo button
     * @type {string}
     */
    geoButtonText: 'Use My Location',

    /**
     * The text to show when geolocation is enabled
     * @type {string}
     */
    enabledText: 'Current Location',

    /**
     * The text to show when loading the user's location
     * @type {string}
     */
    loadingText: 'Finding Your Location...',

    /**
     * The text to show if the user's location cannot be found
     * @type {string}
     */
    errorText: 'Could Not Find Your Location',

    /**
     * The CSS selector of the toggle button
     * @type {string}
     */
    buttonSelector: '.js-yxt-GeoLocationFilter-button',

    /**
     * The CSS selector of the query input
     * @type {string}
     */
    inputSelector: '.js-yxt-GeoLocationFilter-input'
  };
  /**
   * Renders a button that when clicked adds a static filter representing the user's location
   * @extends Component
   */

  var GeoLocationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(GeoLocationComponent, _Component);

    function GeoLocationComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, _objectSpread2({}, DEFAULT_CONFIG, {}, config), systemConfig) || this;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * @type {string}
       */

      _this.query = _this.core.globalStorage.getState(StorageKeys.QUERY + "." + _this.name) || '';

      _this.core.globalStorage.on('update', StorageKeys.QUERY + "." + _this.name, function (q) {
        _this.query = q;

        _this.setState();
      });
      /**
       * The filter to use for the current query
       * @type {Filter}
       */


      _this.filter = _this.core.globalStorage.getState(StorageKeys.FILTER + "." + _this.name) || {};

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.core.globalStorage.on('update', StorageKeys.FILTER + "." + _this.name, function (f) {
        _this.filter = f;
      });

      _this.searchParameters = buildSearchParameters(config.searchParameters);
      return _this;
    }

    GeoLocationComponent.defaultTemplateName = function defaultTemplateName() {
      return 'controls/geolocation';
    };

    var _proto = GeoLocationComponent.prototype;

    _proto.setState = function setState(data) {
      var placeholder = '';

      if (this._enabled) {
        placeholder = this._config.enabledText;
      }

      if (data.geoLoading) {
        placeholder = this._config.loadingText;
      }

      if (data.geoError) {
        placeholder = this._config.errorText;
      }

      _Component.prototype.setState.call(this, _objectSpread2({}, data, {
        title: this._config.title,
        geoEnabled: this._enabled,
        query: this.query,
        labelText: this._config.label,
        enabledText: this._config.enabledText,
        loadingText: this._config.loadingText,
        errorText: this._config.errorText,
        geoButtonIcon: this._config.geoButtonIcon,
        geoValue: this._enabled || data.geoLoading || data.geoError ? '' : this.query,
        geoPlaceholder: placeholder,
        geoButtonText: this._config.geoButtonText
      }));
    };

    _proto.onMount = function onMount() {
      var _this2 = this;

      if (this._autocomplete) {
        this._autocomplete.remove();
      }

      this._initAutoComplete(this._config.inputSelector);

      DOM.on(this._config.buttonSelector, 'click', function () {
        return _this2._toggleGeoFilter();
      });
    }
    /**
     * A helper method to wire up our auto complete on an input selector
     * @param {string} inputSelector CSS selector to bind our auto complete component to
     * @private
     */
    ;

    _proto._initAutoComplete = function _initAutoComplete(inputSelector) {
      var _this3 = this;

      if (this._autocomplete) {
        this._autocomplete.remove();
      }

      this._autocomplete = this.componentManager.create('AutoComplete', {
        parentContainer: this._container,
        name: this.name + ".autocomplete",
        isFilterSearch: true,
        container: '.js-yxt-GeoLocationFilter-autocomplete',
        originalQuery: this.query,
        originalFilter: this.filter,
        inputEl: inputSelector,
        verticalKey: this._config.verticalKey,
        searchParameters: this.searchParameters,
        onSubmit: function onSubmit(query, filter) {
          _this3.query = query;
          _this3.filter = Filter.fromResponse(filter);

          _this3._saveDataToStorage(query, _this3.filter);

          _this3._enabled = false;
        }
      });
    }
    /**
     * Toggles the static filter representing the user's location
     * @private
     */
    ;

    _proto._toggleGeoFilter = function _toggleGeoFilter() {
      var _this4 = this;

      if (!navigator.geolocation) {
        this.setState({
          geoError: true
        });
        return;
      }

      if (!this._enabled) {
        this.setState({
          geoLoading: true
        });
        navigator.geolocation.getCurrentPosition(function (position) {
          var filter = _this4._buildFilter(position);

          _this4._saveDataToStorage('', filter, position);

          _this4._enabled = true;

          _this4.setState({});

          _this4.core.persistentStorage["delete"](StorageKeys.QUERY + "." + _this4.name);

          _this4.core.persistentStorage["delete"](StorageKeys.FILTER + "." + _this4.name);
        }, function () {
          return _this4.setState({
            geoError: true
          });
        });
      }
    }
    /**
     * Saves the provided filter under this component's name
     * @param {string} query The query to save
     * @param {Filter} filter The filter to save
     * @param {Object} position The position to save
     * @private
     */
    ;

    _proto._saveDataToStorage = function _saveDataToStorage(query, filter, position) {
      this.core.persistentStorage.set(StorageKeys.QUERY + "." + this.name, query);
      this.core.persistentStorage.set(StorageKeys.FILTER + "." + this.name, filter);
      this.core.setFilter(this.name, filter);

      if (position) {
        this.core.globalStorage.set(StorageKeys.GEOLOCATION, {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          radius: position.coords.accuracy
        });
      }

      if (this._config.searchOnChange) {
        var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = filters[0];

        if (filters.length > 1) {
          totalFilter = Filter.and.apply(Filter, filters);
        }

        var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._config.verticalKey, {
          input: searchQuery,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }
    /**
     * Given a position, construct a Filter object
     * @param {Postition} position The position
     * @returns {Filter}
     * @private
     */
    ;

    _proto._buildFilter = function _buildFilter(position) {
      var _position$coords = position.coords,
          latitude = _position$coords.latitude,
          longitude = _position$coords.longitude,
          accuracy = _position$coords.accuracy;
      var radius = Math.max(accuracy, this._config.radius * METERS_PER_MILE);
      return Filter.position(latitude, longitude, radius);
    };

    _createClass(GeoLocationComponent, null, [{
      key: "type",
      get: function get() {
        return 'GeoLocationFilter';
      }
    }]);

    return GeoLocationComponent;
  }(Component);

  /**
   * Renders configuration options for sorting Vertical Results.
   * TODO: how to deal with multiple instances of this component (and filters in general),
   * ideally "identical" filters/sorts would be synced up.
   */

  var SortOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(SortOptionsComponent, _Component);

    function SortOptionsComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, assignDefaults(config), systemConfig) || this;
      _this.options = _this._config.options;
      _this.selectedOptionIndex = parseInt(_this.core.globalStorage.getState(_this.name)) || 0;
      _this.options[_this.selectedOptionIndex].isSelected = true;
      _this.hideExcessOptions = _this._config.showMore && _this.selectedOptionIndex <= _this._config.showMoreLimit;
      _this.showReset = _this._config.showReset && _this.selectedOptionIndex !== 0;
      return _this;
    }

    var _proto = SortOptionsComponent.prototype;

    _proto.setState = function setState(data) {
      var options = this.options;

      if (this.hideExcessOptions) {
        options = this.options.slice(0, this._config.showMoreLimit);
      }

      _Component.prototype.setState.call(this, Object.assign({}, data, {
        options: options,
        hideExcessOptions: this.hideExcessOptions,
        name: this.name,
        showReset: this.showReset
      }));
    };

    _proto.onMount = function onMount() {
      var _this2 = this;

      // Handle radio button selections
      DOM.on(DOM.query(this._container, '.yxt-SortOptions-fieldSet'), 'change', function (evt) {
        return _this2.handleOptionSelection(parseInt(evt.target.value));
      }); // Register more/less button

      if (this._config.showMore) {
        DOM.on(DOM.query(this._container, '.yxt-SortOptions-showToggle'), 'click', function () {
          _this2.hideExcessOptions = !_this2.hideExcessOptions;

          _this2.setState();
        });
      } // Register show reset button


      if (this.showReset) {
        DOM.on(DOM.query(this._container, '.yxt-SortOptions-reset'), 'click', function () {
          return _this2.handleOptionSelection(0);
        });
      } // Register apply button


      if (!this._config.searchOnChange) {
        DOM.on(DOM.query(this._container, '.yxt-SortOptions-apply'), 'click', function () {
          return _this2._sortResults();
        });
      }
    };

    _proto.handleOptionSelection = function handleOptionSelection(optionIndex) {
      this._updateSelectedOption(optionIndex);

      if (this._config.searchOnChange) {
        this._sortResults();
      }
    };

    _proto._updateSelectedOption = function _updateSelectedOption(optionIndex) {
      this.options[this.selectedOptionIndex].isSelected = false;
      this.options[optionIndex].isSelected = true;
      this.selectedOptionIndex = optionIndex;
      this.showReset = this._config.showReset && optionIndex !== 0;
      this.setState();
    };

    _proto._sortResults = function _sortResults() {
      var optionIndex = this.selectedOptionIndex;
      var option = this.options[optionIndex]; // searchOnChange really means sort on change here, just that the sort is done through a search,
      // This was done to have a consistent option name between filters.

      this.core.persistentStorage.set(this.name, optionIndex);

      if (this._config.storeOnChange && optionIndex === 0) {
        this.core.clearSortBys();
      } else if (this._config.storeOnChange) {
        this.core.setSortBys(option);
      }

      this._search();

      this._config.onChange(option);

      this.setState();
    }
    /**
     * Trigger a search with all filters in storage
     */
    ;

    _proto._search = function _search() {
      var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
      var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, allFilters) : allFilters[0];
      var input = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
      var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
      this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
      this.core.verticalSearch(this._config.verticalKey, {
        input: input,
        filter: JSON.stringify(totalFilter),
        facetFilter: JSON.stringify(facetFilter)
      });
    };

    SortOptionsComponent.defaultTemplateName = function defaultTemplateName() {
      return 'controls/sortoptions';
    };

    _createClass(SortOptionsComponent, null, [{
      key: "type",
      get: function get() {
        return 'SortOptions';
      }
    }]);

    return SortOptionsComponent;
  }(Component);

  function assignDefaults(config) {
    var updatedConfig = Object.assign({}, config); // Optional, The label used for the default sort (aka the sort specified by the experience config").

    updatedConfig.defaultSortLabel = config.defaultSortLabel || 'Best Match'; // Array of search options, where an option has type, label, and if is type FIELD also a label and direction

    if (!config.options) {
      throw new AnswersBasicError('config.options are required', 'SortOptions');
    }

    var OPTION_TYPES = ['FIELD', 'RELEVANCE', 'ENTITY_DISTANCE'];

    if (!Array.isArray(config.options)) {
      throw new AnswersBasicError('options must be an array of objects', 'SortOptions');
    }

    updatedConfig.options = config.options.map(function (option) {
      if (!option.label || !option.type) {
        throw new AnswersBasicError("option.label and option.type are required option " + option, 'SortOptions');
      }

      var newOption = {
        isSelected: false
      };
      newOption.label = option.label;
      newOption.type = option.type;
      var isField = OPTION_TYPES.indexOf(newOption.type) === 0;

      if (isField && option.field && option.direction) {
        newOption.field = option.field;
        newOption.direction = option.direction;
      } else if (isField) {
        throw new AnswersBasicError("option.field and option.direction are required for option: " + option, 'SortOptions');
      }

      return newOption;
    }); // Add default option to the front of the options array

    updatedConfig.options.unshift({
      label: updatedConfig.defaultSortLabel,
      isSelected: false
    }); // Optional, the selector used for options in the template

    updatedConfig.optionSelector = config.optionSelector || 'yxt-SortOptions-optionSelector'; // Optional, if true, triggers a search on each change to a filter,
    // if false the component also renders an apply button, defaults to false

    updatedConfig.searchOnChange = config.searchOnChange === undefined ? true : config.searchOnChange; // Optional, show a reset button. Clicking it will always return the user to the default sorting option.

    updatedConfig.showReset = config.showReset || false; // Optional, the label to use for the reset button

    updatedConfig.resetLabel = config.resetLabel || 'reset'; // Optional, the max number of filter options to show before collapsing extras

    updatedConfig.showMoreLimit = config.showMoreLimit || 5; // Optional, allow collapsing excess sort options after a limit

    updatedConfig.showMore = config.showMore === undefined ? true : config.showMore;
    updatedConfig.showMore = updatedConfig.showMore && updatedConfig.options.length > updatedConfig.showMoreLimit; // Optional, the label to show for displaying more options

    updatedConfig.showMoreLabel = config.showMoreLabel || 'Show more'; // Optional, the label to show for displaying less options

    updatedConfig.showLessLabel = config.showLessLabel || 'Show less'; // Optional, the callback function to call when changed

    updatedConfig.onChange = config.onChange || function () {}; // Optional, Top title for the sorting component


    updatedConfig.label = config.label || 'Sorting'; // Optional, when true component does not update globalStorage
    // possibly delegating that to a higher-order/composite component

    updatedConfig.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
    updatedConfig.applyLabel = config.applyLabel || 'Apply';
    updatedConfig.verticalKey = config.verticalKey || this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

    if (!updatedConfig.verticalKey) {
      throw new AnswersBasicError('vertical key is required', 'SortOptions');
    } // note: showExpand and showNumberApplied explicitly not included, on the grounds that
    // sorting should always be exposed to the user if added.


    return updatedConfig;
  }

  /**
   * EventTypes are explicit strings defined
   * for what the server expects for analytics.
   *
   * @enum
   */

  var EventTypes = {
    THUMBS_UP: 'THUMBS_UP',
    THUMBS_DOWN: 'THUMBS_DOWN'
  };

  var DirectAnswerComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(DirectAnswerComponent, _Component);

    function DirectAnswerComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.DIRECT_ANSWER;
      /**
       * The form used for submitting the feedback
       * @type {string}
       */

      _this._formEl = config.formEl || '.js-directAnswer-feedback-form';
      /**
       * The `thumbs up` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsUpSelector = config.thumbsUpSelector || '.js-directAnswer-thumbUp';
      /**
       * The `thumbs down` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsDownSelector = config.thumbsDownSelector || '.js-directAnswer-thumbDown';
      /**
       * The display text for the View Details click to action link
       * @type {string}
       */

      _this._viewDetailsText = config.viewDetailsText || 'View Details';
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    DirectAnswerComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/directanswer';
    }
    /**
     * beforeMount, only display the direct answer component if it has data
     */
    ;

    var _proto = DirectAnswerComponent.prototype;

    _proto.beforeMount = function beforeMount() {
      if (!this.hasState('answer')) {
        return false;
      }

      return true;
    }
    /**
     * When the DOM is constructed,
     * we want to wire up the behavior for interacting with the quality feedback reporting (thumbsup/down)
     */
    ;

    _proto.onMount = function onMount() {
      var _this2 = this;

      // Avoid bindings if the feedback has previously been submitted
      if (this.getState('feedbackSubmitted') === true) {
        return this;
      } // For WCAG compliance, the feedback should be a submittable form


      DOM.on(this._formEl, 'submit', function (e) {
        var formEl = e.target;
        var checkedValue = DOM.query(formEl, 'input:checked').value === 'true';

        _this2.reportQuality(checkedValue);

        _this2.updateState({
          'feedbackSubmitted': true
        });
      }); // Is this actually necessary? I guess it's only necessary if the
      // submit button is hidden.

      DOM.on(this._thumbsUpSelector, 'click', function () {
        DOM.trigger(_this2._formEl, 'submit');
      });
      DOM.on(this._thumbsDownSelector, 'click', function () {
        DOM.trigger(_this2._formEl, 'submit');
      });
    }
    /**
     * updateState enables for partial updates (the delta between the old and new)
     * @type {object} The new state to apply to the old
     */
    ;

    _proto.updateState = function updateState(state) {
      if (state === void 0) {
        state = {};
      }

      var newState = Object.assign({}, this.getState(), state);
      this.setState(newState);
    };

    _proto.setState = function setState(data) {
      return _Component.prototype.setState.call(this, Object.assign({}, data, {
        eventOptions: this.eventOptions(data),
        viewDetailsText: this._viewDetailsText
      }));
    };

    _proto.eventOptions = function eventOptions(data) {
      if (!data || Object.keys(data).length === 0) {
        return data;
      }

      return JSON.stringify({
        verticalConfigId: data.relatedItem.verticalConfigId,
        searcher: 'UNIVERSAL',
        entityId: data.relatedItem.data.id,
        ctaLabel: this._viewDetailsText.toUpperCase().replace(' ', '_')
      });
    }
    /**
     * reportQuality will send the quality feedback to analytics
     * @param {boolean} isGood true if the answer is what you were looking for
     */
    ;

    _proto.reportQuality = function reportQuality(isGood) {
      var eventType = isGood === true ? EventTypes.THUMBS_UP : EventTypes.THUMBS_DOWN;
      var event = new AnalyticsEvent(eventType).addOptions({
        'directAnswer': true
      });
      this.analyticsReporter.report(event);
    };

    _createClass(DirectAnswerComponent, null, [{
      key: "type",
      get: function get() {
        return 'DirectAnswer';
      }
    }]);

    return DirectAnswerComponent;
  }(Component);

  var ResultsItemComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(ResultsItemComponent, _Component);

    function ResultsItemComponent(opts, systemConfig) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, opts, systemConfig) || this;
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = opts.verticalConfigId;
      /**
       * isUniversal is used for analytics and passed to children and is set to
       * true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = opts.isUniversal || false;
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    ResultsItemComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/resultsitem';
    };

    ResultsItemComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    }
    /**
     * helper to construct the eventOptions object for the title link
     * @param entityId The ID of the result item, if present
     * @param url The url of the result item, if present
     * @returns {string}
     */
    ;

    var _proto = ResultsItemComponent.prototype;

    _proto.eventOptions = function eventOptions(entityId, url) {
      var options = {
        verticalConfigId: this._verticalConfigId,
        searcher: this._isUniversal ? 'UNIVERSAL' : 'VERTICAL'
      };

      if (entityId) {
        options.entityId = entityId;
      } else {
        options.url = url;
      }

      return JSON.stringify(options);
    }
    /**
     * passes eventOptions to the viewModel
     * @override
     * @param data
     * @returns {ResultsItemComponent}
     */
    ;

    _proto.setState = function setState(data) {
      return _Component.prototype.setState.call(this, Object.assign(data, {
        eventOptions: this.eventOptions(data.id, data.link)
      }));
    };

    _createClass(ResultsItemComponent, null, [{
      key: "type",
      get: function get() {
        return 'ResultsItemComponent';
      }
    }]);

    return ResultsItemComponent;
  }(Component);

  var LocationResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inheritsLoose(LocationResultsItemComponent, _ResultsItemComponent);

    function LocationResultsItemComponent(opts, systemConfig) {
      if (opts === void 0) {
        opts = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      return _ResultsItemComponent.call(this, opts, systemConfig) || this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    LocationResultsItemComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/locationresultsitem';
    };

    LocationResultsItemComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    };

    _createClass(LocationResultsItemComponent, null, [{
      key: "type",
      get: function get() {
        return 'LocationResultsItemComponent';
      }
    }]);

    return LocationResultsItemComponent;
  }(ResultsItemComponent);

  var EventResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inheritsLoose(EventResultsItemComponent, _ResultsItemComponent);

    function EventResultsItemComponent(opts, systemConfig) {
      if (opts === void 0) {
        opts = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      return _ResultsItemComponent.call(this, opts, systemConfig) || this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    EventResultsItemComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/eventresultsitem';
    };

    EventResultsItemComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    };

    _createClass(EventResultsItemComponent, null, [{
      key: "type",
      get: function get() {
        return 'EventResultsItemComponent';
      }
    }]);

    return EventResultsItemComponent;
  }(ResultsItemComponent);

  var PeopleResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inheritsLoose(PeopleResultsItemComponent, _ResultsItemComponent);

    function PeopleResultsItemComponent(opts, systemOpts) {
      if (opts === void 0) {
        opts = {};
      }

      if (systemOpts === void 0) {
        systemOpts = {};
      }

      return _ResultsItemComponent.call(this, opts, systemOpts) || this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    PeopleResultsItemComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/peopleresultsitem';
    };

    PeopleResultsItemComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    };

    _createClass(PeopleResultsItemComponent, null, [{
      key: "type",
      get: function get() {
        return 'PeopleResultsItemComponent';
      }
    }]);

    return PeopleResultsItemComponent;
  }(ResultsItemComponent);

  /** @module MapProvider */

  /**
   * A MapProvider is an interface that represents that should be implemented
   * in order to integrate with a Third Party Map provider for
   * interactive maps. MapProviders are used by the MapComponent.
   *
   * Implementations should extend this interface.
   */
  var MapProvider =
  /*#__PURE__*/
  function () {
    function MapProvider(config) {
      if (config === void 0) {
        config = {};
      }

      /**
       * The API Key used for interacting with the map provider
       * @type {string}
       */
      this._apiKey = config.apiKey;
      /**
       * The zoom level of the map, defaults to 14
       * @type {number}
       */

      this._zoom = config.zoom || 14;
      /**
       * The default coordinates to display if there are no results returned
       * Only used if showEmptyMap is set to true
       * @type {Object}
       */

      this._defaultPosition = config.defaultPosition || {
        lat: 37.0902,
        lng: -95.7129
      };
      /**
       * Determines if an empty map should be shown when there are no results
       * @type {boolean}
       */

      this._showEmptyMap = config.showEmptyMap || false;
      /**
       * A reference to the underlying map instance, created by the external lib.
       * @type {number}
       */

      this._map = null;
      /**
       * Temporary boolean tracking whether or not the external JS library is loaded (see TODO below)
       * @type {boolean}
       */

      this._isLoaded = false;
      /**
       * Callback to invoke when a pin is clicked. The clicked item(s) are passed to the callback
       * @type {function}
       */

      this._onPinClick = config.onPinClick || null;
      /**
       * Callback to invoke once the Javascript is loaded
       * @type {function}
       */

      this._onLoaded = config.onLoaded || function () {};
      /**
       * The custom configuration override to use for the map markers
       * @type {Object|Function}
       */


      this._pinConfig = typeof config.pin === 'function' ? config.pin : Object.assign(MapProvider.DEFAULT_PIN_CONFIG, config.pin);
      /**
       * Determines whether or not to collapse pins at the same lat/lng
       * @type {boolean}
       */

      this._collapsePins = config.collapsePins || false;
    }
    /**
     * The default configuration to use for the map markers
     * @type {Object}
     * TODO(billy) Create a configuration model
     */


    var _proto = MapProvider.prototype;

    _proto.onLoaded = function onLoaded(cb) {
      if (typeof cb !== 'function') {
        return;
      }

      this._onLoaded = cb;

      if (this.isLoaded()) {
        this._onLoaded();
      }
    };

    _proto.isLoaded = function isLoaded() {
      return this._isLoaded;
    };

    _proto.loadJS = function loadJS() {
      throw new Error('Unimplemented Method: loadJS');
    };

    _proto.init = function init(mapData) {
      // TODO(billy) This should be based off a promise that gets created from loadJS
      throw new Error('Unimplemented Method: init');
    }
    /**
     * Given a list of markers, combine markers with the same lat/lng into a single marker
     * @param {object[]} markers The markers to collapse
     */
    ;

    _proto._collapseMarkers = function _collapseMarkers(markers) {
      var locationToItem = {};
      markers.forEach(function (m) {
        locationToItem["" + m.latitude + m.longitude] ? locationToItem["" + m.latitude + m.longitude].push(m) : locationToItem["" + m.latitude + m.longitude] = [m];
      });
      var collapsedMarkers = [];

      for (var _i = 0, _Object$entries = Object.entries(locationToItem); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
            _markers = _Object$entries$_i[1];

        if (_markers.length > 1) {
          var collapsedMarker = {
            item: _markers.map(function (m) {
              return m.item;
            }),
            label: _markers.length,
            latitude: _markers[0].latitude,
            longitude: _markers[0].longitude
          };
          collapsedMarkers.push(collapsedMarker);
        } else {
          collapsedMarkers.push(_markers[0]);
        }
      }

      return collapsedMarkers;
    };

    _createClass(MapProvider, null, [{
      key: "DEFAULT_PIN_CONFIG",
      get: function get() {
        return {
          icon: {
            anchor: null,
            // e.g. { x: 1, y: 1 }
            svg: null,
            url: null,
            scaledSize: null // e.g. { w: 20, h: 20 }

          },
          labelType: 'numeric'
        };
      }
    }]);

    return MapProvider;
  }();

  /* global google */

  /**
   * GoogleMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var GoogleMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inheritsLoose(GoogleMapProvider, _MapProvider);

    function GoogleMapProvider(opts) {
      var _this;

      _this = _MapProvider.call(this, opts) || this; // normalize because google's zoom is effectively 1 unit of difference away from mapbox zoom

      _this._zoomOffset = 1;
      _this._zoom += _this._zoomOffset;
      _this._clientId = opts.clientId;
      _this._signature = opts.signature;

      if (!_this.hasValidClientCredentials() && !_this._apiKey) {
        throw new Error('GoogleMapsProvider: Missing `apiKey` or {`clientId`, `signature`}');
      }

      return _this;
    }

    var _proto = GoogleMapProvider.prototype;

    _proto.loadJS = function loadJS(onLoad) {
      var _this2 = this;

      if (DOM.query('#yext-map-js')) {
        this._isLoaded = true;

        if (typeof onLoad === 'function') {
          onLoad();
        }

        return;
      }

      var script = DOM.createEl('script', {
        id: 'yext-map-js',
        onload: function onload() {
          _this2._isLoaded = true;

          _this2._onLoaded();
        },
        async: true,
        src: "https://maps.googleapis.com/maps/api/js?" + this.generateCredentials()
      });
      DOM.append('body', script);
    };

    _proto.generateCredentials = function generateCredentials() {
      if (this.hasValidClientCredentials()) {
        return "client=" + this._clientId;
      } else {
        return "key=" + this._apiKey;
      }
    };

    _proto.hasValidClientCredentials = function hasValidClientCredentials() {
      return this._clientId;
    };

    _proto.init = function init(el, mapData) {
      var _this3 = this;

      if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
        this._map = null;
        return this;
      } // NOTE(billy) This timeout is a hack for dealing with async nature.
      // Only here for demo purposes, so we'll fix later.


      setTimeout(function () {
        var container = DOM.query(el);
        _this3.map = new google.maps.Map(container, {
          zoom: _this3._zoom,
          center: _this3.getCenterMarker(mapData)
        }); // Apply our search data to our GoogleMap

        if (mapData && mapData.mapMarkers.length) {
          (function () {
            var collapsedMarkers = _this3._collapsePins ? _this3._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
            var googleMapMarkerConfigs = GoogleMapMarkerConfig.from(collapsedMarkers, _this3._pinConfig, _this3.map);
            var bounds = new google.maps.LatLngBounds();

            var _loop = function _loop(i) {
              var marker = new google.maps.Marker(googleMapMarkerConfigs[i]);

              if (_this3._onPinClick) {
                marker.addListener('click', function () {
                  return _this3._onPinClick(collapsedMarkers[i].item);
                });
              }

              bounds.extend(marker.position);
            };

            for (var i = 0; i < googleMapMarkerConfigs.length; i++) {
              _loop(i);
            }

            if (googleMapMarkerConfigs.length >= 2) {
              _this3.map.fitBounds(bounds);
            }
          })();
        }
      }, 100);
    };

    _proto.getCenterMarker = function getCenterMarker(mapData) {
      return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? {
        lng: mapData.mapCenter.longitude,
        lat: mapData.mapCenter.latitude
      } : {
        lng: this._defaultPosition.lng,
        lat: this._defaultPosition.lat
      };
    };

    return GoogleMapProvider;
  }(MapProvider); // TODO(billy) Move to own class
  var GoogleMapMarkerConfig =
  /*#__PURE__*/
  function () {
    function GoogleMapMarkerConfig(opts) {
      /**
       * A reference to the google map, that the marker is appended to
       * @type {GoogleMap}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        lat: undefined,
        lng: undefined
      };
      /**
       * The properties/settings of the icon used for the marker
       * e.g. {
       *        anchor: { x: 0, y: 0 }
       *        url: 'path/to/url.jpg'
       *        scaledSize: { w: 0, h: 0 }
       *       }
       *
       * @type {object}
       */

      this.icon = opts.icon || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {GoogleMapMarkerConfig[]} googleMapMarkerConfigs
     * @returns {string[]}
     */


    GoogleMapMarkerConfig.serialize = function serialize(googleMapMarkerConfigs) {
      var serializedMarkers = [];
      googleMapMarkerConfigs.forEach(function (marker) {
        serializedMarkers.push("markers=label:" + marker.label + "|" + marker.position.lat + "," + marker.position.lng);
      });
      return serializedMarkers.join('&');
    }
    /**
     * Converts the storage data model of markers into GoogleAPIMarker
     * @param {object[]} markers The data of the marker
     * @param {(Object|function)} pinConfig The configuration to apply to the marker
     * @param {GoogleMap} map reference to the google map to apply the marker to
     * @returns {GoogleMapMarkerConfig[]}
     */
    ;

    GoogleMapMarkerConfig.from = function from(markers, pinConfig, map) {
      var googleMapMarkerConfigs = [];

      if (!Array.isArray(markers)) {
        markers = [markers];
      }

      markers.forEach(function (marker) {
        // Support configuration as a function
        var pinConfigObj = pinConfig;

        if (typeof pinConfig === 'function') {
          pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
        } // Transform our Configuration Object into the expected
        // Google API format.


        var icon = {};

        if (pinConfigObj.anchor) {
          icon.anchor = google.maps.Point(pinConfigObj.anchor.x, pinConfigObj.anchor.y);
        }

        if (pinConfigObj.scaledSize) {
          icon.scaledSize = new google.maps.Size(pinConfigObj.scaledSize.w, pinConfigObj.scaledSize.h);
        }

        if (pinConfigObj.url) {
          icon.url = pinConfigObj.url;
        }

        if (pinConfigObj.svg) {
          icon.url = "data:image/svg+xml;charset=utf-8, " + encodeURIComponent(pinConfigObj.svg);
        }

        var label;

        if (pinConfigObj.label) {
          label = pinConfigObj.label;
        } else {
          label = marker.label.toString();
        } // NOTE(billy) Google maps doesn't handle empty icon objects nicely
        // Make google maps happy if no settings for icon are provided;


        if (Object.keys(icon).length === 0) {
          icon = undefined;
        }

        googleMapMarkerConfigs.push(new GoogleMapMarkerConfig({
          map: map,
          position: {
            lat: marker.latitude,
            lng: marker.longitude
          },
          icon: icon,
          label: label
        }));
      });
      return googleMapMarkerConfigs;
    };

    return GoogleMapMarkerConfig;
  }();

  /* global mapboxgl */

  /**
   * MapBoxMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var MapBoxMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inheritsLoose(MapBoxMapProvider, _MapProvider);

    function MapBoxMapProvider() {
      return _MapProvider.apply(this, arguments) || this;
    }

    var _proto = MapBoxMapProvider.prototype;

    /**
     * Load the external JS Library
     * @param {function} onLoad An optional callback to invoke once the JS is loaded.
     */
    _proto.loadJS = function loadJS(onLoad) {
      var _this = this;

      var script = DOM.createEl('script', {
        id: 'yext-map-js',
        onload: function onload() {
          _this._isLoaded = true;
          mapboxgl.accessToken = _this._apiKey;

          if (typeof onLoad === 'function') {
            onLoad();
          }

          if (typeof _this._onLoaded === 'function') {
            _this._onLoaded();
          }
        },
        async: true,
        src: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'
      });
      var css = DOM.createEl('link', {
        id: 'yext-map-css',
        rel: 'stylesheet',
        href: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css'
      });
      DOM.append('body', css);
      DOM.append('body', script);
    };

    _proto.init = function init(el, mapData) {
      var _this2 = this;

      if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
        this._map = null;
        return this;
      }

      var container = DOM.query(el);
      this._map = new mapboxgl.Map({
        container: container,
        zoom: this._zoom,
        style: 'mapbox://styles/mapbox/streets-v9',
        center: this.getCenterMarker(mapData)
      });

      if (mapData && mapData.mapMarkers.length) {
        (function () {
          var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
          var mapboxMapMarkerConfigs = MapBoxMarkerConfig.from(collapsedMarkers, _this2._pinConfig, _this2._map);
          var bounds = new mapboxgl.LngLatBounds();

          var _loop = function _loop(i) {
            var wrapper = mapboxMapMarkerConfigs[i].wrapper;
            var coords = new mapboxgl.LngLat(mapboxMapMarkerConfigs[i].position.longitude, mapboxMapMarkerConfigs[i].position.latitude);
            var marker = new mapboxgl.Marker(wrapper).setLngLat(coords);
            bounds.extend(marker.getLngLat());
            marker.addTo(_this2._map);

            if (_this2._onPinClick) {
              marker.getElement().addEventListener('click', function () {
                return _this2._onPinClick(collapsedMarkers[i].item);
              });
            }
          };

          for (var i = 0; i < mapboxMapMarkerConfigs.length; i++) {
            _loop(i);
          }

          if (mapboxMapMarkerConfigs.length >= 2) {
            _this2._map.fitBounds(bounds, {
              padding: 50
            });
          }
        })();
      }
    };

    _proto.getCenterMarker = function getCenterMarker(mapData) {
      return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? [mapData.mapCenter.longitude, mapData.mapCenter.latitude] : {
        lng: this._defaultPosition.lng,
        lat: this._defaultPosition.lat
      };
    };

    return MapBoxMapProvider;
  }(MapProvider);
  var MapBoxMarkerConfig =
  /*#__PURE__*/
  function () {
    function MapBoxMarkerConfig(opts) {
      /**
       * A reference to the mapbox map, that the marker is appended to
       * @type {MapBox}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        latitude: undefined,
        longitude: undefined
      };
      /**
       * The html element to be used as the map marker
       * @type {object}
       */

      this.wrapper = opts.wrapper || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
      /**
       * The url of the pin for the static map
       * @type {string}
       */

      this.staticMapPin = opts.staticMapPin || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {MapBoxMarkerConfig[]} mapboxMapMarkerConfigs
     * @returns {string[]}
     */


    MapBoxMarkerConfig.serialize = function serialize(mapboxMapMarkerConfigs) {
      var serializedMarkers = [];
      mapboxMapMarkerConfigs.forEach(function (marker) {
        if (marker.staticMapPin) {
          serializedMarkers.push("url-" + marker.staticMapPin + "(" + marker.position.longitude + "," + marker.position.latitude + ")");
        } else {
          serializedMarkers.push("pin-s-" + marker.label + "(" + marker.position.longitude + "," + marker.position.latitude + ")");
        }
      });
      return serializedMarkers.join(',');
    }
    /**
     * Converts the storage data model of markers into MapBoxMarkerConfig
     * @param {MapBox} A reference to the mapbox map to apply the marker to
     * @param {object[]} markers The data of the marker
     * @param {Object} pinConfig The configuration to apply to the marker
     * @returns {MapBoxMarkerConfig[]}
     */
    ;

    MapBoxMarkerConfig.from = function from(markers, pinConfig, map) {
      var mapboxMapMarkerConfigs = [];

      if (!Array.isArray(markers)) {
        markers = [markers];
      }

      markers.forEach(function (marker) {
        // Support configuration as a function
        var pinConfigObj = pinConfig;

        if (typeof pinConfig === 'function') {
          pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
        }

        var wrapper = pinConfigObj.wrapper ? pinConfigObj.wrapper : null;
        var staticMapPin = pinConfigObj.staticMapPin ? pinConfigObj.staticMapPin : null;
        mapboxMapMarkerConfigs.push(new MapBoxMarkerConfig({
          map: map,
          position: {
            latitude: marker.latitude,
            longitude: marker.longitude
          },
          wrapper: wrapper,
          label: marker.label,
          staticMapPin: staticMapPin
        }));
      });
      return mapboxMapMarkerConfigs;
    };

    return MapBoxMarkerConfig;
  }();

  var ProviderTypes = {
    'google': GoogleMapProvider,
    'mapbox': MapBoxMapProvider
  };

  var MapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(MapComponent, _Component);

    function MapComponent(opts, systemOpts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      if (systemOpts === void 0) {
        systemOpts = {};
      }

      _this = _Component.call(this, opts, systemOpts) || this;
      /**
       * Bind this component to listen to the storage based on this key
       */

      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      /**
       * An aliased used to determine the type of map provider to use
       * @type {string}
       */

      _this._mapProvider = opts.mapProvider;

      if (!_this._mapProvider || !(_this._mapProvider.toLowerCase() in ProviderTypes)) {
        throw new Error('MapComponent: Invalid Map Provider; must be `google` or `mapBox`');
      }
      /**
       * A reference to an instance of the {MapProvider} that's constructed
       * @type {MapProvider}
       */


      _this._map = null;
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    MapComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/map';
    } // TODO(billy) Make ProviderTypes a factory class
    ;

    var _proto = MapComponent.prototype;

    _proto.getProviderInstance = function getProviderInstance(type) {
      return new ProviderTypes[type.toLowerCase()](this._config);
    };

    _proto.onCreate = function onCreate() {
      this._map = this.getProviderInstance(this._mapProvider);

      this._map.loadJS();
    };

    _proto.onMount = function onMount() {
      var _this2 = this;

      this._map.onLoaded(function () {
        _this2._map.init(_this2._container, _this2.getState('map'));
      });
    };

    _proto.setState = function setState(data, val) {
      if (Object.keys(data).length === 0) {
        return this;
      }

      return _Component.prototype.setState.call(this, data, val);
    };

    _createClass(MapComponent, null, [{
      key: "type",
      get: function get() {
        return 'Map';
      }
    }]);

    return MapComponent;
  }(Component);

  var ResultType = {
    EVENT: 'event',
    LOCATION: 'location',
    PEOPLE: 'people'
  };

  var ResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(ResultsComponent, _Component);

    function ResultsComponent(config, systemConfig) {
      var _this$_itemConfig;

      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = config.verticalConfigId;
      /**
       * isUniversal is set to true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = config.isUniversal || false;
      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      _this._itemConfig = (_this$_itemConfig = {
        global: {
          render: null,
          template: null
        }
      }, _this$_itemConfig[EventResultsItemComponent.type] = {
        render: null,
        template: null
      }, _this$_itemConfig[LocationResultsItemComponent.type] = {
        render: null,
        template: null
      }, _this$_itemConfig[PeopleResultsItemComponent.type] = {
        render: null,
        template: null
      }, _this$_itemConfig);

      if (config.renderItem === undefined && config._parentOpts !== undefined) {
        config.renderItem = config._parentOpts.renderItem;
      }

      if (config.itemTemplate === undefined && config._parentOpts !== undefined) {
        config.itemTemplate = config._parentOpts.itemTemplate;
      }

      _this.configureItem({
        render: config.renderItem,
        template: config.itemTemplate
      });
      /**
       * The url to the universal page for the no results page to link back to with current query
       * @type {string|null}
       */


      _this._universalUrl = config.universalUrl;
      return _this;
    }

    var _proto = ResultsComponent.prototype;

    _proto.mount = function mount() {
      if (Object.keys(this.getState()).length > 0) {
        _Component.prototype.mount.call(this);
      }

      return this;
    };

    _proto.setState = function setState(data, val) {
      var results = data.results || [];
      var searchState = data.searchState || SearchStates.PRE_SEARCH;
      return _Component.prototype.setState.call(this, Object.assign({
        results: []
      }, data, {
        isPreSearch: searchState === SearchStates.PRE_SEARCH,
        isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
        isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
        includeMap: this._config.includeMap,
        mapConfig: this._config.mapConfig,
        eventOptions: this.eventOptions(),
        universalUrl: this._universalUrl ? this._universalUrl + window.location.search : '',
        showNoResults: results.length === 0,
        query: this.core.globalStorage.getState(StorageKeys.QUERY)
      }), val);
    }
    /**
     * helper to construct the eventOptions object for the view all link
     * @returns {string}
     */
    ;

    _proto.eventOptions = function eventOptions() {
      return JSON.stringify({
        verticalConfigId: this._verticalConfigId
      });
    };

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    ResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/results';
    };

    _proto.configureItem = function configureItem(config) {
      if (typeof config.render === 'function') {
        this._itemConfig.global.render = config.render;
      } else {
        for (var key in config.render) {
          this.setItemRender(key, config.render[key]);
        }
      }

      if (typeof config.template === 'string') {
        this._itemConfig.global.template = config.template;
      } else {
        for (var _key in config.template) {
          this.setItemTemplate(_key, config.template[_key]);
        }
      }
    };

    _proto.setItemTemplate = function setItemTemplate(type, template) {
      var clazz = this.getItemComponent(type);
      this._itemConfig[clazz.type].template = template;
    };

    _proto.setItemRender = function setItemRender(type, render) {
      var clazz = this.getItemComponent(type);
      this._itemConfig[clazz.type].render = render;
    };

    _proto.getItemComponent = function getItemComponent(type) {
      var comp = ResultsItemComponent;

      switch (type) {
        case ResultType.EVENT:
          comp = EventResultsItemComponent;
          break;

        case ResultType.LOCATION:
          comp = LocationResultsItemComponent;
          break;

        case ResultType.PEOPLE:
          comp = PeopleResultsItemComponent;
          break;
      }

      return comp;
    };

    _proto.addChild = function addChild(data, type, opts) {
      // TODO(billy) Refactor the way configuration and data flows
      // through top level components to child components.
      if (type === ResultsItemComponent.type) {
        var clazz = this.getItemComponent(data.type);

        if (clazz) {
          type = clazz.type;
        }
      } else if (type === MapComponent.type) {
        data = {
          map: data
        };
        var newOpts = Object.assign({}, this._config.mapConfig, opts);
        return _Component.prototype.addChild.call(this, data, type, newOpts);
      } // Apply the proper item renders to the the components
      // have just been constructed. Prioritize global over individual items.


      var comp = _Component.prototype.addChild.call(this, data, type, Object.assign(opts, {
        verticalConfigId: this._verticalConfigId,
        isUniversal: this._isUniversal
      }));

      var globalConfig = this._itemConfig.global;
      var itemConfig = this._itemConfig[comp.type];
      var hasGlobalRender = typeof globalConfig.render === 'function';
      var hasGlobalTemplate = typeof globalConfig.template === 'string';

      if (hasGlobalRender) {
        comp.setRender(globalConfig.render);
      }

      if (hasGlobalTemplate) {
        comp.setTemplate(globalConfig.template);
      }

      if (!itemConfig) {
        return comp;
      }

      if (!hasGlobalRender && itemConfig.render) {
        comp.setRender(itemConfig.render);
      } // Apply template specific situation


      if (!hasGlobalTemplate && itemConfig.template) {
        comp.setTemplate(itemConfig.template);
      }

      return comp;
    };

    _createClass(ResultsComponent, null, [{
      key: "duplicatesAllowed",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'VerticalResults';
      }
    }]);

    return ResultsComponent;
  }(Component);

  var AccordionResultsComponent =
  /*#__PURE__*/
  function (_ResultsComponent) {
    _inheritsLoose(AccordionResultsComponent, _ResultsComponent);

    function AccordionResultsComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _ResultsComponent.call(this, config, systemConfig) || this;
      /**
       * base selector to use when finding DOM targets
       * @type {string}
       */

      _this._selectorBase = config.selectorBase || '.js-yxt-AccordionResult';
      /**
       * collapsed state class
       * @type {string}
       */

      _this.collapsedClass = config.collapsedClass || 'is-collapsed';
      /**
       * vertical config id is required for analytics
       * @type {string|null}
       */

      _this.verticalConfigId = config.verticalConfigId || config._parentOpts.verticalConfigId || null;
      return _this;
    }
    /**
     * the component type
     * @returns {string}
     * @override
     */


    /**
     * The template to render
     * @returns {string}
     * @override
     */
    AccordionResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/resultsaccordion';
    }
    /**
     * overrides onMount to add bindings to change the height on click
     * @returns {AccordionResultsComponent}
     * @override
     */
    ;

    var _proto = AccordionResultsComponent.prototype;

    _proto.onMount = function onMount() {
      var _this2 = this;

      _ResultsComponent.prototype.onMount.call(this); // NOTE(amullings): This is a hack, since currently components with siblings
      // have no way of referring to their own element. We have to grab the first
      // element since sections get added in reverse.


      var selfEl = this._container.firstElementChild;
      var accordionEls = DOM.queryAll(selfEl, this._selectorBase);
      accordionEls.forEach(function (accordionEl) {
        var toggleEl = DOM.query(accordionEl, _this2.toggleSelector());
        var contentEl = DOM.query(accordionEl, _this2.bodySelector());

        _this2.changeHeight(contentEl, accordionEl);

        toggleEl.addEventListener('click', function () {
          _this2.handleClick(accordionEl, toggleEl, contentEl);
        });
      });
      return this;
    };

    _proto.setState = function setState(data) {
      return _ResultsComponent.prototype.setState.call(this, Object.assign({}, data, {
        modifier: this.verticalConfigId
      }));
    }
    /**
     * click handler for the accordion toggle button
     * @param wrapperEl {HTMLElement} the toggle container
     * @param toggleEl {HTMLElement} the button
     * @param contentEl {HTMLElement} the toggle target
     */
    ;

    _proto.handleClick = function handleClick(wrapperEl, toggleEl, contentEl) {
      var event = new AnalyticsEvent(this.isCollapsed(wrapperEl) ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
        verticalConfigId: this.verticalConfigId,
        entityId: toggleEl.dataset.entityId
      });
      wrapperEl.classList.toggle(this.collapsedClass);
      this.changeHeight(contentEl, wrapperEl);
      toggleEl.setAttribute('aria-expanded', this.isCollapsed(wrapperEl) ? 'false' : 'true');
      this.analyticsReporter.report(event);
    }
    /**
     * returns true if the element is currently collapsed
     * @param wrapperEl {HTMLElement} the toggle container
     * @returns {boolean}
     */
    ;

    _proto.isCollapsed = function isCollapsed(wrapperEl) {
      if (!wrapperEl) {
        return false;
      }

      return wrapperEl.classList.contains(this.collapsedClass);
    }
    /**
     * toggles the height between 0 and the content height for smooth animation
     * @param targetEl {HTMLElement}
     * @param wrapperEl {HTMLElement}
     */
    ;

    _proto.changeHeight = function changeHeight(targetEl, wrapperEl) {
      targetEl.style.height = (this.isCollapsed(wrapperEl) ? 0 : targetEl.scrollHeight) + "px";
    }
    /**
     * helper for composing child element selectors
     * @param child {string}
     * @returns {string}
     */
    ;

    _proto.buildSelector = function buildSelector(child) {
      return "" + this._selectorBase + child;
    }
    /**
     * helper for the toggle button selector
     * @returns {string}
     */
    ;

    _proto.toggleSelector = function toggleSelector() {
      return this.buildSelector('-toggle');
    }
    /**
     * helper for the content element selector
     * @returns {string}
     */
    ;

    _proto.bodySelector = function bodySelector() {
      return this.buildSelector('-body');
    };

    _createClass(AccordionResultsComponent, null, [{
      key: "type",
      get: function get() {
        return 'AccordionResults';
      }
    }]);

    return AccordionResultsComponent;
  }(ResultsComponent);

  var UniversalResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UniversalResultsComponent, _Component);

    function UniversalResultsComponent(opts, systemOpts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      if (systemOpts === void 0) {
        systemOpts = {};
      }

      _this = _Component.call(this, opts, systemOpts) || this;
      _this.moduleId = StorageKeys.UNIVERSAL_RESULTS;
      _this._limit = opts.limit || 10;
      return _this;
    }

    /**
     * The template to render
     * @returns {string}
     * @override
     */
    UniversalResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'results/universalresults';
    };

    UniversalResultsComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    };

    var _proto = UniversalResultsComponent.prototype;

    _proto.init = function init(opts) {
      _Component.prototype.init.call(this, opts);

      return this;
    };

    _proto.setState = function setState(data, val) {
      var sections = data.sections || [];
      var searchState = data.searchState || SearchStates.PRE_SEARCH;
      return _Component.prototype.setState.call(this, Object.assign({
        sections: []
      }, data, {
        isPreSearch: searchState === SearchStates.PRE_SEARCH,
        isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
        isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
        showNoResults: sections.length === 0,
        query: this.core.globalStorage.getState(StorageKeys.QUERY)
      }), val);
    };

    _proto.addChild = function addChild(data, type, opts) {
      if (data === void 0) {
        data = {};
      }

      var childOpts = _objectSpread2({}, opts, {}, this.getChildConfig([data['verticalConfigId']]));

      if (childOpts.useAccordion === true) {
        return _Component.prototype.addChild.call(this, data, AccordionResultsComponent.type, childOpts);
      }

      return _Component.prototype.addChild.call(this, data, type, childOpts);
    };

    _proto.getChildConfig = function getChildConfig(configId) {
      var defaultConfig = {
        verticalConfigId: configId,
        isUniversal: true
      };
      var config = this._config.config;

      if (config === undefined) {
        return defaultConfig;
      }

      return Object.assign(defaultConfig, this._config['config'][configId] || this._config['config']);
    };

    _createClass(UniversalResultsComponent, null, [{
      key: "type",
      get: function get() {
        return 'UniversalResults';
      }
    }]);

    return UniversalResultsComponent;
  }(Component);

  var PaginationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(PaginationComponent, _Component);

    function PaginationComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, config, systemConfig) || this;
      /**
       * The vertical key to use for searches
       * @type {string}
       * @private
       */

      _this._verticalKey = _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

      if (typeof _this._verticalKey !== 'string') {
        throw new AnswersComponentError('verticalKey not provided, but necessary for pagination', 'PaginationComponent');
      }
      /**
       * If true, displays the first page button
       * @type {boolean}
       * @private
       */


      _this._firstPageButtonEnabled = config.showFirst === undefined ? true : config.showFirst;
      /**
       * If true, displays the last page button
       * @type {boolean}
       * @private
       */

      _this._lastPageButtonEnabled = config.showLast === undefined ? true : config.showLast;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      _this._analyticsOptions = {
        verticalKey: _this._verticalKey
      };
      /**
       * Label for a page of results.
       * @type {string}
       * @private
       */

      _this._pageLabel = config.pageLabel || 'Page';
      var offset = _this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

      _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));

      _this.core.globalStorage.on('update', StorageKeys.SEARCH_OFFSET, function (offset) {
        if (typeof offset === 'number') {
          return;
        }

        _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));
      });

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, function (results) {
        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
          _this.setState();
        }
      });

      return _this;
    }

    PaginationComponent.defaultTemplateName = function defaultTemplateName() {
      return 'results/pagination';
    };

    var _proto = PaginationComponent.prototype;

    _proto.onMount = function onMount() {
      var _this2 = this;

      var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
      var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
      var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
      var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

      if (!showControls) {
        return;
      }

      var previousPageButton = DOM.query(this._container, '.js-yxt-Pagination-previous');
      var nextPageButton = DOM.query(this._container, '.js-yxt-Pagination-next');
      var maxPage = Math.trunc((results.resultsCount - 1) / limit);
      DOM.on(previousPageButton, 'click', function () {
        return _this2.updatePage(offset - limit);
      });
      DOM.on(nextPageButton, 'click', function () {
        return _this2.updatePage(offset + limit);
      });

      if (this._firstPageButtonEnabled) {
        var firstPageButton = DOM.query(this._container, '.js-yxt-Pagination-first');
        DOM.on(firstPageButton, 'click', function () {
          return _this2.updatePage(0);
        });
      }

      if (this._lastPageButtonEnabled) {
        var lastPageButton = DOM.query(this._container, '.js-yxt-Pagination-last');
        DOM.on(lastPageButton, 'click', function () {
          return _this2.updatePage(maxPage * limit);
        });
      }
    };

    _proto.updatePage = function updatePage(offset) {
      this.scrollToTop();
      this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, offset);
      this.core.persistentStorage.set(StorageKeys.SEARCH_OFFSET, offset);
      this.core.verticalPage(this._verticalKey, offset);
    };

    _proto.scrollToTop = function scrollToTop() {
      document.documentElement.scrollTop = 0; // Safari

      document.body.scrollTop = 0;
    };

    _proto.setState = function setState(data) {
      var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
      var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;
      var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
      var pageNumber = offset / limit;
      var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
      var isMoreResults = results.resultsCount > offset + limit;
      var maxPage = Math.trunc((results.resultsCount - 1) / limit);
      return _Component.prototype.setState.call(this, _objectSpread2({
        showControls: showControls,
        firstPageButtonEnabled: this._firstPageButtonEnabled,
        lastPageButtonEnabled: this._lastPageButtonEnabled,
        pageNumber: pageNumber + 1,
        pageLabel: this._pageLabel,
        showFirstPageButton: pageNumber > 1,
        showPreviousPageButton: pageNumber > 0,
        showNextPageButton: isMoreResults,
        showLastPageButton: pageNumber < maxPage - 1
      }, data));
    };

    _createClass(PaginationComponent, null, [{
      key: "type",
      get: function get() {
        return 'Pagination';
      }
    }]);

    return PaginationComponent;
  }(Component);

  /**
   * Configurable options for the component
   * @type {Object}
   */

  var DEFAULT_CONFIG$1 = {
    /**
     * The entity identifier that the question is associated with.
     * This is typically an organization object
     * @type {number}
     */
    'entityId': null,

    /**
     * The main CSS selector used to reference the form for the component.
     * @type {string} CSS selector
     */
    'formSelector': 'form',

    /**
     * An optional label to use for the e-mail address input
     * @type {string}
     */
    'emailLabel': 'Email',

    /**
     * An optional label to use for the name input
     * @type {string}
     */
    'nameLabel': 'Name',

    /**
     * An optional label to use for the question
     * @type {string}
     */
    'questionLabel': 'Question',

    /**
     * An optional label to use for the Privacy Policy
     * @type {string}
     */
    'privacyPolicyText': 'By submitting my email address, I consent to being contacted via email at the address provided.',

    /**
     * The label to use for the Submit button
     * @type {string}
     */
    'buttonLabel': 'Submit',

    /**
     * The title to display in the title bar
     * @type {string}
     */
    'sectionTitle': 'Ask a Question',

    /**
     * The description to display in the title bar
     * @type {string}
     */
    'teaser': 'Cant find what you\'re looking for? Ask a question below.',

    /**
     * The name of the icon to use in the title bar
     * @type {string}
     */
    'sectionTitleIconName': 'support',

    /**
     * The text to display in the feedback form ahead of the Question input
     * @type {string}
     */
    'description': 'Enter your question and contact information, and we\'ll get back to you with a response shortly.',

    /**
     * The placeholder text for required inputs
     * @type {string}
     */
    'requiredInputPlaceholder': '(required)',

    /**
     * The placeholder text for the question text area
     * @type {string}
     */
    'questionInputPlaceholder': 'Enter your question here',

    /**
     * The confirmation text to display after successfully submitting feedback
     * @type {string}
     */
    'questionSubmissionConfirmationText': 'Thank you for your question!',

    /**
     * The default privacy policy url label
     * @type {string}
    */
    'privacyPolicyUrlLabel': 'Learn more here.',

    /**
     * The default privacy policy url
     * @type {string}
     */
    'privacyPolicyUrl': '',

    /**
     * The default privacy policy error text, shown when the user does not agree
     * @type {string}
     */
    'privacyPolicyErrorText': '* You must agree to the privacy policy to submit a question.',

    /**
     * The default email format error text, shown when the user submits an invalid email
     * @type {string}
     */
    'emailFormatErrorText': '* Please enter a valid email address.',

    /**
     * The default network error text, shown when there is an issue with the QA Submission
     * request.
     * @type {string}
     */
    'networkErrorText': 'We\'re sorry, an error occurred.',

    /**
     * Whether or not this component is expanded by default.
     * @type {boolean}
     */
    'expanded': true
  };
  /**
   * QuestionSubmissionComponent is a component that creates a form
   * thats displayed whenever a query is run. It enables the user
   * to submit questions that they cant find the answer for.
   */

  var QuestionSubmissionComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(QuestionSubmissionComponent, _Component);

    function QuestionSubmissionComponent(config, systemConfig) {
      var _this;

      if (config === void 0) {
        config = {};
      }

      if (systemConfig === void 0) {
        systemConfig = {};
      }

      _this = _Component.call(this, Object.assign({}, DEFAULT_CONFIG$1, config), systemConfig) || this;
      /**
       * Reference to the storage model
       * @type {string}
       */

      _this.moduleId = StorageKeys.QUESTION_SUBMISSION;
      /**
       * Reference to the locale as set in the global config
       * @type {string}
       */

      _this.locale = _this.core.globalStorage.getState(StorageKeys.LOCALE);
      /**
       * NOTE(billy) if this is a pattern we want to follow for configuration
       * we should bake it into the core class.
       */

      _this.validateConfig();
      /**
       * The QuestionSubmission component should be rendered only once a search has completed. If the
       * search results are still loading, the component should not be displayed.
       */


      var onResultsUpdate = function onResultsUpdate(results) {
        if (results.searchState !== SearchStates.SEARCH_LOADING) {
          var questionText = _this.core.globalStorage.getState(StorageKeys.QUERY);

          _this.setState(new QuestionSubmission({
            questionText: questionText,
            expanded: _this._config.expanded
          }));
        } else {
          _this.unMount();
        }
      };

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, onResultsUpdate);

      _this.core.globalStorage.on('update', StorageKeys.UNIVERSAL_RESULTS, onResultsUpdate);

      return _this;
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    QuestionSubmissionComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'questions/questionsubmission';
    }
    /**
     * The public interface alias for the component
     * @returns {string}
     * @override
     */
    ;

    var _proto = QuestionSubmissionComponent.prototype;

    /**
     * validationConfig contains a bunch of rules
     * that are used to validate aginst configuration provided by the user
     */
    _proto.validateConfig = function validateConfig() {
      if (this._config.entityId === null || this._config.entityId === undefined) {
        throw new AnswersComponentError('`entityId` is a required configuration option for Question Submission', 'QuestionSubmission');
      }
    };

    _proto.beforeMount = function beforeMount() {
      // Avoid mounting the component if theres no data
      // Note, 1 because `config` is always part of the state.
      return Object.keys(this.getState()).length > 1;
    };

    _proto.onMount = function onMount() {
      var triggerEl = DOM.query(this._container, '.js-content-visibility-toggle');

      if (triggerEl !== null) {
        this.bindFormToggle(triggerEl);
      }

      var formEl = DOM.query(this._container, this._config.formSelector);

      if (formEl === null) {
        return;
      }

      this.bindFormFocus(formEl);
      this.bindFormSubmit(formEl);
    }
    /**
     * bindFormFocus will wire up the DOM focus event to serverside reporting
     * @param {HTMLElement} formEl
     */
    ;

    _proto.bindFormFocus = function bindFormFocus(formEl) {
      var _this2 = this;

      if (this.analyticsReporter === null) {
        return;
      }

      var questionText = DOM.query(formEl, '.js-question-text');
      DOM.on(questionText, 'focus', function () {
        _this2.analyticsReporter.report(_this2.getAnalyticsEvent('QUESTION_FOCUS'));
      });
    }
    /**
     * bindFormSubmit handles submitting the question to the server,
     * and submits an event to serverside reporting
     * @param {HTMLElement} formEl
     */
    ;

    _proto.bindFormSubmit = function bindFormSubmit(formEl) {
      var _this3 = this;

      DOM.on(formEl, 'submit', function (e) {
        e.preventDefault();

        _this3.analyticsReporter.report(_this3.getAnalyticsEvent('QUESTION_SUBMIT')); // TODO(billy) we probably want to disable the form from being submitted twice


        var errors = _this3.validate(formEl);

        var formData = _this3.parse(formEl);

        if (Object.keys(errors).length) {
          return _this3.setState(new QuestionSubmission(formData, errors));
        }

        _this3.core.submitQuestion({
          'entityId': _this3._config.entityId,
          'questionLanguage': _this3.locale,
          'site': 'FIRSTPARTY',
          'name': formData.name,
          'email': formData.email,
          'questionText': formData.questionText,
          'questionDescription': formData.questionDescription
        })["catch"](function (error) {
          _this3.setState(new QuestionSubmission(formData, {
            'network': 'We\'re sorry, an error occurred.'
          }));

          throw error;
        });
      });
    }
    /**
     * bindFormToggle handles expanding and mimimizing the component's form.
     * @param {HTMLElement} triggerEl
     */
    ;

    _proto.bindFormToggle = function bindFormToggle(triggerEl) {
      var _this4 = this;

      DOM.on(triggerEl, 'click', function (e) {
        var formData = _this4.getState();

        _this4.setState(new QuestionSubmission(_objectSpread2({}, formData, {
          'expanded': !formData.questionExpanded,
          'submitted': formData.questionSubmitted
        }), formData.errors));
      });
    }
    /**
     * Takes the form, and builds a object that represents the input names
     * and text fields.
     * @param {HTMLElement} formEl
     * @returns {object}
     */
    ;

    _proto.parse = function parse(formEl) {
      var inputFields = DOM.queryAll(formEl, '.js-question-field');

      if (!inputFields || inputFields.length === 0) {
        return {};
      }

      var obj = {};

      for (var i = 0; i < inputFields.length; i++) {
        var val = inputFields[i].value;

        if (inputFields[i].type === 'checkbox') {
          val = inputFields[i].checked;
        }

        obj[inputFields[i].name] = val;
      }

      return obj;
    }
    /**
     * Validates the fields for correct formatting
     * @param {HTMLElement} formEl
     * @returns {Object} errors object if any errors found
     */
    ;

    _proto.validate = function validate(formEl) {
      var errors = {};
      var fields = DOM.queryAll(formEl, '.js-question-field');

      for (var i = 0; i < fields.length; i++) {
        if (!fields[i].checkValidity()) {
          if (i === 0) {
            // set focus state on first error
            fields[i].focus();
          }

          switch (fields[i].name) {
            case 'email':
              errors['emailError'] = true;

              if (!fields[i].validity.valueMissing) {
                errors['emailErrorText'] = this._config.emailFormatErrorText;
              }

              break;

            case 'name':
              errors['nameError'] = true;
              break;

            case 'privacyPolicy':
              errors['privacyPolicyErrorText'] = this._config.privacyPolicyErrorText;
              errors['privacyPolicyError'] = true;
              break;

            case 'questionText':
              errors['questionTextError'] = true;
              break;
          }
        }
      }

      return errors;
    }
    /**
     * Returns an options object describing the context of a reportable event
     */
    ;

    _proto.getAnalyticsEvent = function getAnalyticsEvent(eventType) {
      var analyticsEvent = new AnalyticsEvent(eventType);
      analyticsEvent.addOptions({
        verticalConfigId: this._verticalKey,
        searcher: this._verticalKey ? 'VERTICAL' : 'UNIVERSAL'
      });
      return analyticsEvent;
    };

    _createClass(QuestionSubmissionComponent, null, [{
      key: "type",
      get: function get() {
        return 'QASubmission';
      }
    }]);

    return QuestionSubmissionComponent;
  }(Component);

  var SVGIcon =
  /*#__PURE__*/
  function () {
    /**
     * @param config
     * @param config.name
     * @param config.path
     * @param config.complexContents
     * @param config.viewBox
     * @constructor
     */
    function SVGIcon(config) {
      /**
       * the name of the icon
       */
      this.name = config.name;
      /**
       * an svg path definition
       */

      this.path = config.path;
      /**
       * if not using a path, a the markup for a complex SVG
       */

      this.complexContents = config.complexContents;
      /**
       * the view box definition, defaults to 24x24
       * @type {string}
       */

      this.viewBox = config.viewBox || '0 0 24 24';
      /**
       * actual contents used
       */

      this.contents = this.pathDefinition();
    }

    var _proto = SVGIcon.prototype;

    _proto.pathDefinition = function pathDefinition() {
      if (this.complexContents) {
        return this.complexContents;
      }

      return "<path d=\"" + this.path + "\"></path>";
    }
    /**
     * returns the svg markup
     */
    ;

    _proto.markup = function markup() {
      return "<svg viewBox=\"" + this.viewBox + "\" xmlns=\"http://www.w3.org/2000/svg\">" + this.contents + "</svg>";
    };

    return SVGIcon;
  }();

  var thumbIcon = new SVGIcon({
    name: 'thumb',
    viewBox: '0 0 24 22',
    path: 'M15.273 1H5.455c-.906 0-1.68.55-2.008 1.342L.153 10.097A2.19 2.19 0 000 10.9v2.2c0 1.21.982 2.2 2.182 2.2h6.883L8.03 20.327l-.033.352c0 .451.186.869.48 1.166L9.633 23l7.178-7.249a2.16 2.16 0 00.644-1.551v-11c0-1.21-.982-2.2-2.182-2.2zm0 13.2l-4.735 4.774L11.75 13.1H2.182v-2.2l3.273-7.7h9.818v11zM19.636 1H24v13.2h-4.364V1z'
  });

  var receiptIcon = new SVGIcon({
    name: 'receipt',
    path: 'M14.606 9.5c-.671-.515-1.591-.833-2.606-.833 1.015 0 1.935.318 2.606.833zm-7.985 0H1.655A1.66 1.66 0 010 7.833V3.667C0 2.747.741 2 1.655 2h20.69A1.66 1.66 0 0124 3.667v4.166A1.66 1.66 0 0122.345 9.5h-4.966V22H6.621V9.5h2.773H6.62zm10.758-1.667h4.966V3.667H1.655v4.166h4.966v-2.5h10.758v2.5z'
  });

  var pantheonIcon = new SVGIcon({
    name: 'pantheon',
    path: 'M9.947 16.598h.252V9.412h-.252a.432.432 0 01-.23-.065c-.07-.043-.106-.093-.106-.15L9.15 7.82v-.15c0-.044.028-.08.084-.109a.691.691 0 01.105-.086.254.254 0 01.146-.043H13.6c.056 0 .104.015.146.043.042.03.091.058.147.086a.271.271 0 01.063.108c.014.043.007.093-.02.15l-.42 1.378a.374.374 0 01-.147.15.37.37 0 01-.19.065h-.251v7.186h.252a.37.37 0 01.189.065c.07.043.119.093.147.15l.42 1.378c.027.028.034.071.02.129a.275.275 0 01-.063.129 1.364 1.364 0 00-.147.086.254.254 0 01-.146.043H9.485a.254.254 0 01-.146-.043.691.691 0 01-.105-.086c-.056-.029-.084-.072-.084-.13v-.128l.461-1.377c0-.058.035-.108.105-.151a.432.432 0 01.231-.065zm5.792 0h.252V9.412h-.252a.432.432 0 01-.23-.065.374.374 0 01-.148-.15l-.42-1.377c-.027-.029-.034-.072-.02-.13a.275.275 0 01.063-.129c.056-.028.105-.057.146-.086a.254.254 0 01.147-.043h4.114c.055 0 .104.015.146.043a.691.691 0 01.105.086c.056.03.084.072.084.13v.129l-.42 1.377a.374.374 0 01-.146.15.432.432 0 01-.231.065h-.21v7.186h.21a.43.43 0 01.23.065c.07.043.12.093.148.15l.42 1.378v.15c0 .043-.029.08-.085.108a.691.691 0 01-.105.086.254.254 0 01-.146.043h-4.114a.254.254 0 01-.147-.043 1.364 1.364 0 00-.146-.086.271.271 0 01-.063-.108c-.014-.043-.007-.093.02-.15l.42-1.377a.374.374 0 01.147-.151.432.432 0 01.231-.065zm-11.794-.086h.252V9.498h-.252a.334.334 0 01-.21-.065.386.386 0 01-.126-.193l-.42-1.377a.248.248 0 01-.02-.172.854.854 0 01.063-.173c.028-.057.07-.1.126-.129a.365.365 0 01.168-.043h4.07c.057 0 .113.015.169.043a.278.278 0 01.126.13.854.854 0 01.062.172.248.248 0 01-.02.172l-.42 1.377a.386.386 0 01-.126.193.334.334 0 01-.21.065h-.21v7.014h.21c.084 0 .154.029.21.086a.673.673 0 01.126.172l.42 1.378a.248.248 0 01.02.172.854.854 0 01-.062.172.278.278 0 01-.126.129.365.365 0 01-.168.043H3.526a.365.365 0 01-.168-.043.278.278 0 01-.126-.13.854.854 0 01-.063-.171.248.248 0 01.02-.172l.42-1.378a.673.673 0 01.126-.172.281.281 0 01.21-.086zM1.763 6.658a.717.717 0 01-.504-.194.644.644 0 01-.21-.495v-.43a.73.73 0 01.105-.387.68.68 0 01.273-.259C4.309 3.402 6.54 2.276 8.121 1.515 9.702.755 10.493.361 10.493.332c.531-.258.972-.366 1.322-.323.35.043.734.165 1.154.366l8.31 4.518c.14.058.245.144.315.259a.73.73 0 01.105.387v.43c0 .201-.07.366-.21.495a.717.717 0 01-.504.194H1.763zm-.714 13.34a.54.54 0 01.168-.387.516.516 0 01.378-.172h19.642c.168 0 .308.057.42.172a.541.541 0 01.168.387v.818a.522.522 0 01-.168.408.605.605 0 01-.42.151H1.595a.551.551 0 01-.378-.15.522.522 0 01-.168-.41v-.817zm21.405 2.022c.14 0 .266.058.378.173a.592.592 0 01.168.43v.818a.541.541 0 01-.168.387.516.516 0 01-.378.172L.546 23.957a.516.516 0 01-.378-.172.541.541 0 01-.168-.387v-.818a.59.59 0 01.168-.43.516.516 0 01.378-.173l21.908.043z'
  });

  var micIcon = new SVGIcon({
    name: 'mic',
    path: 'M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z'
  });

  var directionsIcon = new SVGIcon({
    name: 'directions',
    path: 'M23.649 11.154L12.846.35a1.195 1.195 0 00-1.692 0L.35 11.154a1.195 1.195 0 000 1.692L11.154 23.65a1.195 1.195 0 001.692 0L23.65 12.846c.468-.456.468-1.212 0-1.692zm-9.254 3.853v-3.001H9.593v3.6h-2.4v-4.8c0-.66.54-1.2 1.2-1.2h6.002V6.604l4.2 4.2-4.2 4.202z'
  });

  var calendarIcon = new SVGIcon({
    name: 'calendar',
    path: 'M18.111 13.2H12v6h6.111v-6zM16.89 0v2.4H7.11V0H4.667v2.4H3.444c-1.356 0-2.432 1.08-2.432 2.4L1 21.6C1 22.92 2.088 24 3.444 24h17.112C21.9 24 23 22.92 23 21.6V4.8c0-1.32-1.1-2.4-2.444-2.4h-1.223V0H16.89zm3.667 21.6H3.444V8.4h17.112v13.2z'
  });

  var calloutIcon = new SVGIcon({
    name: 'callout',
    path: 'M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z'
  });

  var infoIcon = new SVGIcon({
    name: 'info',
    path: 'M12 8.4A1.2 1.2 0 1012 6a1.2 1.2 0 000 2.4zM12 0c6.624 0 12 5.376 12 12s-5.376 12-12 12S0 18.624 0 12 5.376 0 12 0zm0 18c.66 0 1.2-.54 1.2-1.2V12c0-.66-.54-1.2-1.2-1.2-.66 0-1.2.54-1.2 1.2v4.8c0 .66.54 1.2 1.2 1.2z'
  });

  var briefcaseIcon = new SVGIcon({
    name: 'briefcase',
    path: 'M20 7h-4V5c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 20c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V9c0-1.11-.89-2-2-2zm-6 0h-4V5h4v2z'
  });

  var kabobIcon = new SVGIcon({
    name: 'kabob',
    viewBox: '0 0 3 11',
    complexContents: "<circle cx=\"1.5\" cy=\"1.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"5.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"9.5\" r=\"1.5\"/>"
  });

  var personIcon = new SVGIcon({
    name: 'person',
    viewBox: '0 0 18 18',
    path: 'M9 9c2.486 0 4.5-2.014 4.5-4.5S11.486 0 9 0a4.499 4.499 0 00-4.5 4.5C4.5 6.986 6.514 9 9 9zm0 2.25c-3.004 0-9 1.508-9 4.5v1.125C0 17.494.506 18 1.125 18h15.75c.619 0 1.125-.506 1.125-1.125V15.75c0-2.992-5.996-4.5-9-4.5z'
  });

  var magnifyingGlassIcon = new SVGIcon({
    name: 'magnifying_glass',
    path: 'M16.124 13.051a5.154 5.154 0 110-10.308 5.154 5.154 0 010 10.308M16.114 0a7.886 7.886 0 00-6.46 12.407L0 22.06 1.94 24l9.653-9.653A7.886 7.886 0 1016.113 0'
  });

  var officeIcon = new SVGIcon({
    name: 'office',
    path: 'M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z'
  });

  var linkIcon = new SVGIcon({
    name: 'link',
    path: 'M2.28 12A3.723 3.723 0 016 8.28h4.8V6H6c-3.312 0-6 2.688-6 6s2.688 6 6 6h4.8v-2.28H6A3.723 3.723 0 012.28 12zm4.92 1.2h9.6v-2.4H7.2v2.4zM18 6h-4.8v2.28H18A3.723 3.723 0 0121.72 12 3.723 3.723 0 0118 15.72h-4.8V18H18c3.312 0 6-2.688 6-6s-2.688-6-6-6z'
  });

  var windowIcon = new SVGIcon({
    name: 'window',
    path: 'M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z'
  });

  var phoneIcon = new SVGIcon({
    name: 'phone',
    path: 'M4.827 10.387a20.198 20.198 0 008.786 8.786l2.934-2.933c.36-.36.893-.48 1.36-.32a15.21 15.21 0 004.76.76c.733 0 1.333.6 1.333 1.333v4.654C24 23.4 23.4 24 22.667 24 10.147 24 0 13.853 0 1.333 0 .6.6 0 1.333 0H6c.733 0 1.333.6 1.333 1.333 0 1.667.267 3.267.76 4.76.147.467.04.987-.333 1.36l-2.933 2.934z'
  });

  var tagIcon = new SVGIcon({
    name: 'tag',
    viewBox: '0 0 18 18',
    path: 'M17.469 8.622l-8.1-8.1A1.789 1.789 0 008.1 0H1.8C.81 0 0 .81 0 1.8v6.3c0 .495.198.945.531 1.278l8.1 8.1c.324.324.774.522 1.269.522a1.76 1.76 0 001.269-.531l6.3-6.3A1.76 1.76 0 0018 9.9c0-.495-.207-.954-.531-1.278zM3.15 4.5c-.747 0-1.35-.603-1.35-1.35 0-.747.603-1.35 1.35-1.35.747 0 1.35.603 1.35 1.35 0 .747-.603 1.35-1.35 1.35z'
  });

  var documentIcon = new SVGIcon({
    name: 'document',
    path: 'M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z'
  });

  var chevronIcon = new SVGIcon({
    name: 'chevron',
    viewBox: '0 0 7 9',
    complexContents: "<g fill-rule=\"evenodd\" transform=\"translate(-1 -8)\"><path d=\"m2.6417004 8-1.1417004 1.0575 3.70850202 3.4425-3.70850202 3.4425 1.1417004 1.0575 4.8582996-4.5z\"/></g>"
  });

  var supportIcon = new SVGIcon({
    name: 'support',
    path: 'M12,0 C5.376,0 0,5.376 0,12 C0,18.624 5.376,24 12,24 C18.624,24 24,18.624 24,12 C24,5.376 18.624,0 12,0 Z M13,19 L11,19 L11,17 L13,17 L13,19 Z M15.07,11.25 L14.17,12.17 C13.45,12.9 13,13.5 13,15 L11,15 L11,14.5 C11,13.4 11.45,12.4 12.17,11.67 L13.41,10.41 C13.78,10.05 14,9.55 14,9 C14,7.9 13.1,7 12,7 C10.9,7 10,7.9 10,9 L8,9 C8,6.79 9.79,5 12,5 C14.21,5 16,6.79 16,9 C16,9.88 15.64,10.68 15.07,11.25 Z'
  });

  var yextIcon = new SVGIcon({
    name: 'yext',
    viewBox: '0 0 30 30',
    path: 'M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z'
  });

  var pinIcon = new SVGIcon({
    name: 'pin',
    viewBox: '0 0 13 18',
    path: 'm9.375 0c-3.52446429 0-6.375 2.817-6.375 6.3 0 4.725 6.375 11.7 6.375 11.7s6.375-6.975 6.375-11.7c0-3.483-2.8505357-6.3-6.375-6.3zm.00000018 8.55000007c-1.25678576 0-2.27678579-1.008-2.27678579-2.25s1.02000003-2.25 2.27678579-2.25c1.25678572 0 2.27678582 1.008 2.27678582 2.25s-1.0200001 2.25-2.27678582 2.25z'
  });

  var gearIcon = new SVGIcon({
    name: 'gear',
    path: 'M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42a.353.353 0 01.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16a.353.353 0 01-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z'
  });

  var lightBulbIcon = new SVGIcon({
    name: 'light_bulb',
    viewBox: '0 0 32 35',
    path: 'M11.585 31.056l8.38-.493v-.986l-8.38.493zM11.585 33.028L15.775 35l4.19-1.972V31.55l-8.38.493v.986zm6.926-.407l-2.736 1.29-2.13-1.004 4.866-.286zM15.775 7.394c-4.63 0-8.38 3.205-8.38 8.38 0 5.177 4.19 6.902 4.19 12.818v.493l8.38-.493c0-5.916 4.19-8.188 4.19-12.817a8.38 8.38 0 00-8.38-8.38zm5.617 13.48c-1.025 1.837-2.174 3.892-2.381 6.786l-6.44.38c-.129-3.01-1.29-5.021-2.32-6.808-.493-.8-.928-1.636-1.299-2.5h13.556c-.325.708-.704 1.403-1.116 2.142zm1.479-3.128H8.627a7.793 7.793 0 01-.247-1.971c0-4.353 3.042-7.395 7.395-7.395a7.394 7.394 0 017.394 7.395 6.739 6.739 0 01-.3 1.971h.002zM26.62 15.282h4.93v1h-4.93zM23.094 7.756l2.091-2.091.698.697-2.092 2.092zM15.282 0h1v4.93h-1zM5.666 6.362l.697-.697 2.091 2.091-.697.697zM0 15.282h4.93v1H0z'
  });

  var starIcon = new SVGIcon({
    name: 'receipt',
    viewBox: '0 0 18 18',
    path: 'M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z'
  });

  var close = new SVGIcon({
    name: 'close',
    complexContents: "\n    <path d=\"M7 8l9.716 9.716m0-9.716L7 17.716\" \n          stroke=\"currentColor\" \n          stroke-width=\"2\"/>\n  "
  });

  var elements = new SVGIcon({
    name: 'elements',
    path: 'M13,15 L13,17 L21,17 L21,19 L13,19 L13,21 L11,21 L11,15 L13,15 Z M9,17 L9,19 L3,19 L3,17 L9,17 Z M9,15 L7,15 L7,13 L3,13 L3,11 L7,11 L7,9 L9,9 L9,15 Z M21,11 L21,13 L11,13 L11,11 L21,11 Z M17,3 L17,5 L21,5 L21,7 L17,7 L17,9 L15,9 L15,3 L17,3 Z M13,5 L13,7 L3,7 L3,5 L13,5 Z'
  });

  var iconsArray = [thumbIcon, receiptIcon, pantheonIcon, micIcon, directionsIcon, calendarIcon, calloutIcon, infoIcon, briefcaseIcon, kabobIcon, personIcon, magnifyingGlassIcon, officeIcon, linkIcon, windowIcon, phoneIcon, tagIcon, documentIcon, chevronIcon, supportIcon, yextIcon, pinIcon, gearIcon, lightBulbIcon, elements, close];
  var Icons = {};
  iconsArray.forEach(function (icon) {
    Icons[icon.name] = icon.markup();
  });
  Icons["default"] = starIcon.markup();

  var IconComponent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(IconComponent, _Component);

    /**
     * IconComponent
     * @param opts
     * @param opts.iconName {string}
     * @param opts.customIcon {string}
     * @param opts.iconUrl {string}
     */
    function IconComponent(opts, systemOpts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      if (systemOpts === void 0) {
        systemOpts = {};
      }

      _this = _Component.call(this, opts, systemOpts) || this;
      /**
       * name of an icon from the default icon set
       * @type {string}
       */

      _this.iconName = opts.iconName || 'default';
      /**
       * the markup for a fully custom icon
       * @type {*|null}
       */

      _this.customIcon = opts.customIcon || null;
      /**
       * the url to a custom image icon
       * @type {null}
       */

      _this.iconUrl = opts.iconUrl || null;
      return _this;
    }
    /**
     * getter for the image pasted to handlebars
     * @returns {string}
     */


    /**
     * The template to render
     * @returns {string}
     * @override
     */
    IconComponent.defaultTemplateName = function defaultTemplateName(config) {
      return 'icons/icon';
    }
    /**
     * allowing duplicates
     * @returns {boolean}
     * @override
     */
    ;

    IconComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
      return true;
    }
    /**
     * overrides default functionality to provide name and markup
     * @param data
     * @returns {IconComponent}
     */
    ;

    var _proto = IconComponent.prototype;

    _proto.setState = function setState(data) {
      return _Component.prototype.setState.call(this, Object.assign(data, {
        image: this.image,
        name: this.iconName ? this.iconName : 'custom'
      }));
    };

    _createClass(IconComponent, [{
      key: "image",
      get: function get() {
        if (this.customIcon) {
          return this.customIcon;
        }

        if (this.iconUrl) {
          return "<img src=\"" + this.iconUrl + "\" alt=\"\" class=\"Icon-image\">";
        }

        if (Icons[this.iconName]) {
          return Icons[this.iconName];
        }

        return Icons["default"];
      }
    }], [{
      key: "type",
      get: function get() {
        return 'IconComponent';
      }
    }]);

    return IconComponent;
  }(Component);

  /** @module */
  var COMPONENT_CLASS_LIST = [// Core Component
  Component, // Navigation Components
  NavigationComponent, // Search Components
  SearchComponent, FilterSearchComponent, AutoCompleteComponent, SpellCheckComponent, LocationBiasComponent, // Filter Components
  FilterBoxComponent, FilterOptionsComponent, RangeFilterComponent, DateRangeFilterComponent, FacetsComponent, GeoLocationComponent, SortOptionsComponent, // Results Components
  DirectAnswerComponent, UniversalResultsComponent, ResultsComponent, PaginationComponent, ResultsItemComponent, AccordionResultsComponent, LocationResultsItemComponent, EventResultsItemComponent, PeopleResultsItemComponent, MapComponent, // Questions Components
  QuestionSubmissionComponent, // Helper Components
  IconComponent];
  /**
   * The component registry is a map that contains
   * all available component classes used for creation or extension.
   * Each component class has a unique type, which is used as the key for the registry
   * @type {Object.<string, Component>}
   */

  var COMPONENT_REGISTRY = COMPONENT_CLASS_LIST.reduce(function (registry, clazz) {
    registry[clazz.type] = clazz;
    return registry;
  }, {});

  /**
   * ComponentManager is a Singletone that contains both an internal registry of
   * eligible components to be created, as well as keeps track of the current
   * instantiated and active components.
   *
   * ALL components should be constructed using the {ComponentManager} via its `create` method.
   */

  var ComponentManager =
  /*#__PURE__*/
  function () {
    function ComponentManager() {
      /**
       * The active components is an internal container to keep track
       * of all of the components that have been constructed
       */
      this._activeComponents = [];
      /**
       * A local reference to the core library dependency
       *
       * The Core contains both the storage AND services that are needed for performing operations
       * like search and auto complete.
       *
       * The storage is the source of truth for the state of ALL components.
       * Whenever the storage is updated, the state gets pushed down to the necessary components.
       * @type {Core}
       */

      this._core = null;
      /**
       * The primary renderer to use for all components
       * @type {HandlebarsRenderer}
       */

      this._renderer = null;
      /**
       * A local reference to the analytics reporter dependency
       */

      this._analyticsReporter = null;
    }

    ComponentManager.getInstance = function getInstance() {
      if (!this.instance) {
        this.instance = new ComponentManager();
      }

      return this.instance;
    };

    var _proto = ComponentManager.prototype;

    _proto.setRenderer = function setRenderer(renderer) {
      this._renderer = renderer;
      return this;
    };

    _proto.setCore = function setCore(core) {
      this._core = core;
      return this;
    };

    _proto.setAnalyticsReporter = function setAnalyticsReporter(reporter) {
      this._analyticsReporter = reporter;
      return this;
    }
    /**
     * registers a component to be eligible for creation and override.
     * @param {Component} The Component Class to register
     */
    ;

    _proto.register = function register(componentClazz) {
      COMPONENT_REGISTRY[componentClazz.type] = componentClazz;
      return this;
    }
    /**
     * create is the entry point for constructing any and all components.
     * It will instantiate a new instance of the component, and both apply
     * initial state from the storage and bind it to the storage for updates.
     * @param {string} componentType The component type to create
     * @param {Object} opts The options to pipe to the construction of the component
     */
    ;

    _proto.create = function create(componentType, opts) {
      // Every component needs local access to the component manager
      // because sometimes components have subcomponents that need to be
      // constructed during creation
      var systemOpts = {
        core: this._core,
        renderer: this._renderer,
        analyticsReporter: this._analyticsReporter,
        componentManager: this
      };
      var componentClass = COMPONENT_REGISTRY[componentType];

      if (!componentClass.areDuplicateNamesAllowed() && this._activeComponents.some(function (c) {
        return c.name === opts.name;
      })) {
        throw new AnswersComponentError("Another component with name " + opts.name + " already exists", componentType);
      }

      var config = _objectSpread2({
        isTwin: this._activeComponents.some(function (component) {
          return component.constructor.type === componentType;
        })
      }, opts); // Instantiate our new component and keep track of it


      var component = new COMPONENT_REGISTRY[componentType](config, systemOpts).init(config);

      this._activeComponents.push(component); // If there is a global storage to power state, apply the state
      // from the storage to the component, and then bind the component
      // state to the storage via its updates


      if (this._core && this._core.globalStorage !== null) {
        if (component.moduleId === undefined || component.moduleId === null) {
          return component;
        }

        this._core.globalStorage.on('update', component.moduleId, function (data) {
          component.setState(data);
        });
      }

      return component;
    }
    /**
     * Remove the provided component from the list of active components and remove
     * the associated storage event listener
     * @param {Component} component The component to remove
     */
    ;

    _proto.remove = function remove(component) {
      this._core.globalStorage.off('update', component.moduleId);

      var index = this._activeComponents.findIndex(function (c) {
        return c.name === component.name;
      });

      this._activeComponents.splice(index, 1);
    }
    /**
     * Remove the component with the given name
     * @param {string} name The name of the compnent to remove
     */
    ;

    _proto.removeByName = function removeByName(name) {
      var component = this._activeComponents.find(function (c) {
        return c.name === name;
      });

      component.remove();
      DOM.empty(component._container);
    };

    _proto.getActiveComponent = function getActiveComponent(type) {
      return this._activeComponents.find(function (c) {
        return c.constructor.type === type;
      });
    };

    return ComponentManager;
  }();

  /** @module NavigationConfig */
  var TabConfig =
  /*#__PURE__*/
  function () {
    function TabConfig(config) {
      if (config === void 0) {
        config = {};
      }

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label || null;
      /**
       * The complete URL, including the params
       * @type {string}
       */

      this.url = config.url || null;
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */

      this.configId = config.configId || null;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }

    var _proto = TabConfig.prototype;

    _proto.validate = function validate() {};

    TabConfig.from = function from(tabs) {
      var tabConfigs = [];

      if (tabs === undefined) {
        return tabConfigs;
      }

      for (var i = 0; i < tabs.length; i++) {
        var tab = tabs[i];
        tabConfigs.push(new TabConfig(tab));
      }

      return tabConfigs;
    };

    return TabConfig;
  }();

  var NavigationConfig = function NavigationConfig(config) {
    if (config === void 0) {
      config = {};
    }

    this.tabsConfig = TabConfig.from(config.tabs);
  };

  /* eslint-env browser */

  /* global ActiveXObject */

  if (!Element.prototype.matches) {
    // Element.matches polyfill from MDN
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  } // Event constructor polyfill


  (function () {
    if (typeof window.CustomEvent === 'function') {
      return false;
    }

    function CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: null
      };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    window.CustomEvent = CustomEvent;
    window.Event = CustomEvent;
  })(); // Element.closest polyfill
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill


  (function () {
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }

    if (!Element.prototype.closest) {
      Element.prototype.closest = function (s) {
        var el = this;

        do {
          if (el.matches(s)) return el;
          el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);

        return null;
      };
    }
  })(); // ParentNode.prepend polyfill
  // https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend#Polyfill


  (function () {
    (function (arr) {
      arr.forEach(function (item) {
        if (item.hasOwnProperty('prepend')) {
          return;
        }

        Object.defineProperty(item, 'prepend', {
          configurable: true,
          enumerable: true,
          writable: true,
          value: function prepend() {
            var argArr = Array.prototype.slice.call(arguments);
            var docFrag = document.createDocumentFragment();
            argArr.forEach(function (argItem) {
              var isNode = argItem instanceof Node;
              docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
            });
            this.insertBefore(docFrag, this.firstChild);
          }
        });
      });
    })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
  })(); // Navigator.sendBeacon polyfill
  // Combination of the compact Financial Times polyfill:
  // https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/navigator/sendBeacon/polyfill.js
  // with the async-by-default behavior of Miguel Mota's polyfill:
  // https://github.com/miguelmota/Navigator.sendBeacon/blob/master/sendbeacon.js


  (function () {
    if (window.navigator && window.navigator.sendBeacon) {
      return;
    }

    if (!('navigator' in window)) window.navigator = {};

    window.navigator.sendBeacon = function sendBeacon(url, data) {
      var event = window.event && window.event.type;
      var sync = event === 'unload' || event === 'beforeunload';
      var xhr = 'XMLHttpRequest' in window ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
      xhr.open('POST', url, !sync);
      xhr.setRequestHeader('Accept', '*/*');

      if (typeof data === 'string') {
        xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
      } else if (Object.prototype.toString.call(data) === '[object Blob]') {
        if (data.type) {
          xhr.setRequestHeader('Content-Type', data.type);
        }
      }

      xhr.send(data);
      return true;
    };
  })();
  /** @typedef {import('./core/services/searchservice').default} SearchService */

  /** @typedef {import('./core/services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./core/services/questionanswerservice').default} QuestionAnswerService */

  /** @typedef {import('./core/services/errorreporterservice').default} ErrorReporterService */

  /** @typedef {import('./core/services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @typedef Services
   * @property {SearchService} searchService
   * @property {AutoCompleteService} autoCompleteService
   * @property {QuestionAnswerService} questionAnswerService
   * @property {ErrorReporterService} errorReporterService
   */

  var DEFAULTS = {
    locale: 'en'
  };
  /**
   * The main Answers interface
   */

  var Answers =
  /*#__PURE__*/
  function () {
    function Answers() {
      if (!Answers.setInstance(this)) {
        return Answers.getInstance();
      }
      /**
       * A reference to the Component base class for custom
       * components to extend
       */


      this.Component = Component;
      /**
       * A reference to the AnalyticsEvent base class for reporting
       * custom analytics
       */

      this.AnalyticsEvent = AnalyticsEvent;
      /**
       * A reference of the renderer to use for the components
       * This is provided during initialization.
       * @type {Renderer}
       */

      this.renderer = new Renderers.Handlebars();
      /**
       * A local reference to the component manager
       * @type {ComponentManager}
       */

      this.components = ComponentManager.getInstance();
      /**
       * A local reference to the core api
       * @type {Core}
       */

      this.core = null;
      /**
       * A callback function to invoke once the library is ready.
       * Typically fired after templates are fetched from server for rendering.
       */

      this._onReady = function () {};
      /**
       * @type {boolean}
       * @private
       */


      this._eligibleForAnalytics = false;
      /**
       * @type {Services}
       * @private
       */

      this._services = null;
      /**
       * @type {AnalyticsReporterService}
       * @private
       */

      this._analyticsReporterService = null;
    }

    Answers.setInstance = function setInstance(instance) {
      if (!this.instance) {
        this.instance = instance;
        return true;
      }

      return false;
    };

    Answers.getInstance = function getInstance() {
      return this.instance;
    };

    var _proto = Answers.prototype;

    _proto.init = function init(config) {
      var _this = this;

      var parsedConfig = this.parseConfig(config);
      this.validateConfig(parsedConfig);
      parsedConfig.search = new SearchConfig(parsedConfig.search);
      parsedConfig.navigation = new NavigationConfig(parsedConfig.navigation);
      var globalStorage = new GlobalStorage();
      var persistentStorage = new PersistentStorage({
        updateListener: parsedConfig.onStateChange,
        resetListener: function resetListener(data) {
          return globalStorage.setAll(data);
        }
      });
      globalStorage.setAll(persistentStorage.getAll());
      globalStorage.set(StorageKeys.SEARCH_CONFIG, parsedConfig.search);
      globalStorage.set(StorageKeys.NAVIGATION_CONFIG, parsedConfig.navigation);
      globalStorage.set(StorageKeys.LOCALE, parsedConfig.locale);
      globalStorage.set(StorageKeys.SESSIONS_OPT_IN, parsedConfig.sessionTrackingEnabled);
      this._services = parsedConfig.mock ? getMockServices() : getServices(parsedConfig, globalStorage);
      this.core = new Core({
        apiKey: parsedConfig.apiKey,
        globalStorage: globalStorage,
        persistentStorage: persistentStorage,
        experienceKey: parsedConfig.experienceKey,
        fieldFormatters: parsedConfig.fieldFormatters,
        experienceVersion: parsedConfig.experienceVersion,
        locale: parsedConfig.locale,
        searchService: this._services.searchService,
        autoCompleteService: this._services.autoCompleteService,
        questionAnswerService: this._services.questionAnswerService
      });

      if (parsedConfig.onStateChange && typeof parsedConfig.onStateChange === 'function') {
        parsedConfig.onStateChange(persistentStorage.getAll(), window.location.search.substr(1));
      }

      this.components.setCore(this.core).setRenderer(this.renderer);
      this._eligibleForAnalytics = parsedConfig.businessId != null;

      if (this._eligibleForAnalytics) {
        // TODO(amullings): Initialize with other services
        var reporter = parsedConfig.mock ? new NoopAnalyticsReporter() : new AnalyticsReporter(this.core, parsedConfig.experienceKey, parsedConfig.experienceVersion, parsedConfig.businessId, parsedConfig.analyticsOptions, parsedConfig.environment);
        this._analyticsReporterService = reporter;
        this.components.setAnalyticsReporter(reporter);
        initScrollListener(reporter);
      }

      this._setDefaultInitialSearch(parsedConfig.search);

      this._onReady = parsedConfig.onReady || function () {};

      if (parsedConfig.useTemplates === false || parsedConfig.templateBundle) {
        if (parsedConfig.templateBundle) {
          this.renderer.init(parsedConfig.templateBundle);
        }

        this._onReady();

        return this;
      } // Templates are currently downloaded separately from the CORE and UI bundle.
      // Future enhancement is to ship the components with templates in a separate bundle.


      this.templates = new TemplateLoader({
        templateUrl: parsedConfig.templateUrl
      }).onLoaded(function (templates) {
        _this.renderer.init(templates);

        _this._onReady();
      });
      return this;
    };

    _proto.domReady = function domReady(cb) {
      DOM.onReady(cb);
    };

    _proto.onReady = function onReady(cb) {
      this._onReady = cb;
      return this;
    }
    /**
     * Parses the config provided by the user. In the parsed config, any options not supplied by the
     * user are given default values.
     * @param {Object} config The user supplied config.
     */
    ;

    _proto.parseConfig = function parseConfig(config) {
      var parsedConfig = Object.assign({}, DEFAULTS, config);
      var sessionTrackingEnabled = true;

      if (typeof config.sessionTrackingEnabled === 'boolean') {
        sessionTrackingEnabled = config.sessionTrackingEnabled;
      }

      parsedConfig.sessionTrackingEnabled = sessionTrackingEnabled;
      var sandboxPrefix = SANDBOX + "-";
      parsedConfig.apiKey.includes(sandboxPrefix) ? parsedConfig.environment = SANDBOX : parsedConfig.environment = PRODUCTION;
      parsedConfig.apiKey = parsedConfig.apiKey.replace(sandboxPrefix, '');
      return parsedConfig;
    }
    /**
     * Validates the Answers config object to ensure things like api key and experience key are
     * properly set.
     * @param {Object} config The Answers config.
     */
    ;

    _proto.validateConfig = function validateConfig(config) {
      // TODO (tmeyer): Extract this method into it's own class. Investigate the use of JSON schema
      // to validate these configs.
      if (typeof config.apiKey !== 'string') {
        throw new Error('Missing required `apiKey`. Type must be {string}');
      }

      if (typeof config.experienceKey !== 'string') {
        throw new Error('Missing required `experienceKey`. Type must be {string}');
      }
    }
    /**
     * Register a custom component type so it can be created via
     * addComponent and used as a child component
     * @param {Component} componentClass
     */
    ;

    _proto.registerComponentType = function registerComponentType(componentClass) {
      this.components.register(componentClass);
    };

    _proto.addComponent = function addComponent(type, opts) {
      if (typeof opts === 'string') {
        opts = {
          container: opts
        };
      }

      try {
        this.components.create(type, opts).mount();
      } catch (e) {
        throw new AnswersComponentError('Failed to add component', type, e);
      }

      return this;
    }
    /**
     * Remove the component - and all of its children - with the given name
     * @param {string} name The name of the component to remove
     */
    ;

    _proto.removeComponent = function removeComponent(name) {
      this.components.removeByName(name);
    };

    _proto.createComponent = function createComponent(opts) {
      return this.components.create('Component', opts).mount();
    };

    _proto.registerHelper = function registerHelper(name, cb) {
      this.renderer.registerHelper(name, cb);
      return this;
    }
    /**
     * Opt in or out of convertion tracking analytics
     * @param {boolean} optIn
     */
    ;

    _proto.setConversionsOptIn = function setConversionsOptIn(optIn) {
      if (this._eligibleForAnalytics) {
        this._analyticsReporterService.setConversionTrackingEnabled(optIn);
      }
    }
    /**
     * Opt in or out of session cookies
     * @param {boolean} optIn
     */
    ;

    _proto.setSessionsOptIn = function setSessionsOptIn(optIn) {
      this.core.globalStorage.set(StorageKeys.SESSIONS_OPT_IN, optIn);
    }
    /**
     * Sets a search query on initialization for vertical searchers that have a
     * defaultInitialSearch provided, if the user hasn't already provided their
     * own via URL param.
     * @param {SearchConfig} searchConfig
     * @private
     */
    ;

    _proto._setDefaultInitialSearch = function _setDefaultInitialSearch(searchConfig) {
      if (searchConfig.defaultInitialSearch == null || !searchConfig.verticalKey) {
        return;
      }

      var prepopulatedQuery = this.core.globalStorage.getState(StorageKeys.QUERY);

      if (prepopulatedQuery != null) {
        return;
      }

      this.core.globalStorage.set('queryTrigger', 'initialize');
      this.core.setQuery(searchConfig.defaultInitialSearch);
    };

    return Answers;
  }();
  /**
   * @param {Object} config
   * @param {GlobalStorage} globalStorage
   * @returns {Services}
   */


  function getServices(config, globalStorage) {
    return {
      searchService: new SearchApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }),
      autoCompleteService: new AutoCompleteApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale,
        environment: config.environment
      }, globalStorage),
      questionAnswerService: new QuestionAnswerApi({
        apiKey: config.apiKey,
        environment: config.environment
      }, globalStorage),
      errorReporterService: new ErrorReporter({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        printVerbose: config.debug,
        sendToServer: !config.suppressErrorReports,
        environment: config.environment
      }, globalStorage)
    };
  }
  /**
   * @returns {Services}
   */


  function getMockServices() {
    return {
      searchService: new MockSearchService(),
      autoCompleteService: new MockAutoCompleteService(),
      questionAnswerService: new MockQuestionAnswerService(),
      errorReporterService: new ConsoleErrorReporter()
    };
  }
  /**
   * Initialize the scroll event listener to send analytics events
   * when the user scrolls to the bottom. Debounces scroll events so
   * they are processed after the user stops scrolling
   */


  function initScrollListener(reporter) {
    var DEBOUNCE_TIME = 100;
    var timeout = null;

    var sendEvent = function sendEvent() {
      if (window.innerHeight + window.pageYOffset >= document.body.scrollHeight) {
        var event = new AnalyticsEvent('SCROLL_TO_BOTTOM_OF_PAGE');
        reporter.report(event);
      }
    };

    document.addEventListener('scroll', function () {
      clearTimeout(timeout);
      timeout = setTimeout(sendEvent, DEBOUNCE_TIME);
    });
  }

  var ANSWERS = new Answers();

  return ANSWERS;

}(null, _objectSpread2, _inheritsLoose, _wrapNativeSuper, _createClass, _assertThisInitialized));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5zd2Vycy11bWQuanMiLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCJzcmMvY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcy5qcyIsInNyYy9jb3JlL21vZGVscy9yZXN1bHQuanMiLCJzcmMvY29yZS9tb2RlbHMvaGlnaGxpZ2h0ZWR2YWx1ZS5qcyIsInNyYy9jb3JlL2Vycm9ycy9lcnJvcnMuanMiLCJzcmMvY29yZS9tb2RlbHMvcmVzdWx0ZmFjdG9yeS5qcyIsInNyYy9jb3JlL21vZGVscy9zZWN0aW9uLmpzIiwic3JjL2NvcmUvbW9kZWxzL3VuaXZlcnNhbHJlc3VsdHMuanMiLCJzcmMvY29yZS9tb2RlbHMvZGlyZWN0YW5zd2VyLmpzIiwic3JjL2NvcmUvbW9kZWxzL25hdmlnYXRpb24uanMiLCJzcmMvY29yZS9tb2RlbHMvdmVydGljYWxyZXN1bHRzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3NwZWxsY2hlY2suanMiLCJzcmMvY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzLmpzIiwic3JjL2NvcmUvbW9kZWxzL2R5bmFtaWNmaWx0ZXJzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3NlYXJjaGludGVudHMuanMiLCJzcmMvY29yZS9tb2RlbHMvbG9jYXRpb25iaWFzLmpzIiwic3JjL2NvcmUvc2VhcmNoL3NlYXJjaGRhdGF0cmFuc2Zvcm1lci5qcyIsInNyYy9jb3JlL21vZGVscy9xdWVzdGlvbnN1Ym1pc3Npb24uanMiLCJzcmMvY29yZS9tb2RlbHMvZmlsdGVyLmpzIiwic3JjL2NvcmUvY29yZS5qcyIsInNyYy91aS9kb20vZG9tLmpzIiwic3JjL3VpL2RvbS9zZWFyY2hwYXJhbXMuanMiLCJzcmMvdWkvcmVuZGVyaW5nL3JlbmRlcmVyLmpzIiwic3JjL3VpL3JlbmRlcmluZy9oYW5kbGViYXJzcmVuZGVyZXIuanMiLCJzcmMvdWkvcmVuZGVyaW5nL2NvbnN0LmpzIiwic3JjL2NvcmUvY29uc3RhbnRzLmpzIiwic3JjL3VpL3JlbmRlcmluZy90ZW1wbGF0ZWxvYWRlci5qcyIsInNyYy91aS9pbmRleC5qcyIsInNyYy9jb3JlL2V2ZW50ZW1pdHRlci9ldmVudGVtaXR0ZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zdGF0ZS5qcyIsInNyYy9jb3JlL2h0dHAvaHR0cHJlcXVlc3Rlci5qcyIsInNyYy9jb3JlL3V0aWxzL3VybHV0aWxzLmpzIiwic3JjL2NvcmUvaHR0cC9hcGlyZXF1ZXN0LmpzIiwic3JjL2NvcmUvc2VhcmNoL3NlYXJjaGFwaS5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudC5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NyZXBvcnRlci5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9ub29wYW5hbHl0aWNzcmVwb3J0ZXIuanMiLCJzcmMvY29yZS9zdG9yYWdlL21vZHVsZWRhdGEuanMiLCJzcmMvY29yZS9zdG9yYWdlL2dsb2JhbHN0b3JhZ2UuanMiLCJzcmMvY29yZS9pbmRleC5qcyIsInNyYy91aS9jb21wb25lbnRzL2NvbXBvbmVudC5qcyIsInNyYy9jb3JlL2Vycm9ycy9lcnJvcnJlcG9ydGVyLmpzIiwic3JjL2NvcmUvZXJyb3JzL2NvbnNvbGVlcnJvcnJlcG9ydGVyLmpzIiwic3JjL3VpL3N0b3JhZ2UvcGVyc2lzdGVudHN0b3JhZ2UuanMiLCJzcmMvY29yZS9tb2RlbHMvc2VhcmNoY29uZmlnLmpzIiwic3JjL2NvcmUvbW9kZWxzL2F1dG9jb21wbGV0ZWRhdGEuanMiLCJzcmMvY29yZS9zZWFyY2gvYXV0b2NvbXBsZXRlZGF0YXRyYW5zZm9ybWVyLmpzIiwic3JjL2NvcmUvc2VhcmNoL2F1dG9jb21wbGV0ZWFwaS5qcyIsInNyYy9jb3JlL3NlYXJjaC9tb2NrYXV0b2NvbXBsZXRlc2VydmljZS5qcyIsInNyYy9jb3JlL3NlYXJjaC9xdWVzdGlvbmFuc3dlcmFwaS5qcyIsInNyYy9jb3JlL3NlYXJjaC9tb2NrcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2tzZWFyY2hzZXJ2aWNlLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL3NlYXJjaGNvbXBvbmVudC5qcyIsInNyYy91aS90b29scy9zZWFyY2hwYXJhbXNwYXJzZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvZmlsdGVyc2VhcmNoY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL2F1dG9jb21wbGV0ZWNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3NlYXJjaC9zcGVsbGNoZWNrY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL2xvY2F0aW9uYmlhc2NvbXBvbmVudC5qcyIsInNyYy9jb3JlL21vZGVscy9mYWNldC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyYm94Y29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXJvcHRpb25zY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9yYW5nZWZpbHRlcmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ZpbHRlcnMvZGF0ZXJhbmdlZmlsdGVyY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9mYWNldHNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2dlb2xvY2F0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9zb3J0b3B0aW9uc2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvZGlyZWN0YW5zd2VyY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9yZXN1bHRzaXRlbWNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvbG9jYXRpb25yZXN1bHRzaXRlbWNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvZXZlbnRyZXN1bHRzaXRlbWNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvcGVvcGxlcmVzdWx0c2l0ZW1jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvcHJvdmlkZXJzL21hcHByb3ZpZGVyLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbWFwL3Byb3ZpZGVycy9nb29nbGVtYXBwcm92aWRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL21hcC9wcm92aWRlcnMvbWFwYm94bWFwcHJvdmlkZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvbWFwY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9yZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9hY2NvcmRpb25yZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy91bml2ZXJzYWxyZXN1bHRzY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVzdWx0cy9wYWdpbmF0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcXVlc3Rpb25zL3F1ZXN0aW9uc3VibWlzc2lvbmNvbXBvbmVudC5qcyIsInNyYy91aS9pY29ucy9pY29uLmpzIiwic3JjL3VpL2ljb25zL3RodW1iLmpzIiwic3JjL3VpL2ljb25zL3JlY2VpcHQuanMiLCJzcmMvdWkvaWNvbnMvcGFudGhlb24uanMiLCJzcmMvdWkvaWNvbnMvbWljLmpzIiwic3JjL3VpL2ljb25zL2RpcmVjdGlvbnMuanMiLCJzcmMvdWkvaWNvbnMvY2FsZW5kYXIuanMiLCJzcmMvdWkvaWNvbnMvY2FsbG91dC5qcyIsInNyYy91aS9pY29ucy9pbmZvLmpzIiwic3JjL3VpL2ljb25zL2JyaWVmY2FzZS5qcyIsInNyYy91aS9pY29ucy9rYWJvYi5qcyIsInNyYy91aS9pY29ucy9wZXJzb24uanMiLCJzcmMvdWkvaWNvbnMvbWFnbmlmeWluZ19nbGFzcy5qcyIsInNyYy91aS9pY29ucy9vZmZpY2UuanMiLCJzcmMvdWkvaWNvbnMvbGluay5qcyIsInNyYy91aS9pY29ucy93aW5kb3cuanMiLCJzcmMvdWkvaWNvbnMvcGhvbmUuanMiLCJzcmMvdWkvaWNvbnMvdGFnLmpzIiwic3JjL3VpL2ljb25zL2RvY3VtZW50LmpzIiwic3JjL3VpL2ljb25zL2NoZXZyb24uanMiLCJzcmMvdWkvaWNvbnMvc3VwcG9ydC5qcyIsInNyYy91aS9pY29ucy95ZXh0LmpzIiwic3JjL3VpL2ljb25zL3Bpbi5qcyIsInNyYy91aS9pY29ucy9nZWFyLmpzIiwic3JjL3VpL2ljb25zL2xpZ2h0X2J1bGIuanMiLCJzcmMvdWkvaWNvbnMvc3Rhci5qcyIsInNyYy91aS9pY29ucy9jbG9zZS5qcyIsInNyYy91aS9pY29ucy9lbGVtZW50cy5qcyIsInNyYy91aS9pY29ucy9pbmRleC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ljb25zL2ljb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZWdpc3RyeS5qcyIsInNyYy91aS9jb21wb25lbnRzL2NvbXBvbmVudG1hbmFnZXIuanMiLCJzcmMvY29yZS9tb2RlbHMvbmF2aWdhdGlvbmNvbmZpZy5qcyIsInNyYy9hbnN3ZXJzLXVtZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICdCbG9iJyBpbiBzZWxmICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG52YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbFxuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgaWYgKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvblxudHJ5IHtcbiAgbmV3IERPTUV4Y2VwdGlvbigpXG59IGNhdGNoIChlcnIpIHtcbiAgRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSlcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2tcbiAgfVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET01FeGNlcHRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICB9XG5cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgfVxuXG4gICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgIH0pXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghc2VsZi5mZXRjaCkge1xuICBzZWxmLmZldGNoID0gZmV0Y2hcbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoU3RhdGVzICovXG5cbi8qKlxuICogU2VhcmNoU3RhdGVzIGlzIGFuIEVOVU0gZm9yIHRoZSB2YXJpb3VzIHN0YWdlcyBvZiBzZWFyY2hpbmcsXG4gKiB1c2VkIHRvIHNob3cgZGlmZmVyZW50IHRlbXBsYXRlc1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQUkVfU0VBUkNIOiAncHJlLXNlYXJjaCcsXG4gIFNFQVJDSF9MT0FESU5HOiAnc2VhcmNoLWxvYWRpbmcnLFxuICBTRUFSQ0hfQ09NUExFVEU6ICdzZWFyY2gtY29tcGxldGUnXG59O1xuIiwiLyoqIEBtb2R1bGUgUmVzdWx0ICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHByb2ZpbGUgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yYXcgPSBkYXRhLnJhdyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBwcm9maWxlIGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZm9ybWF0dGVkID0gZGF0YS5mb3JtYXR0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaGxpZ2h0ZWQgcHJvZmlsZSBkYXRhIHdpdGggaGlnaGxpZ2h0cyBhcHBsaWVkIHRvIGFwcGxpY2FibGUgZmllbGRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hpZ2hsaWdodGVkID0gZGF0YS5oaWdobGlnaHRlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBudW1iZXIgb2YgdGhlIHJlc3VsdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmRpbmFsID0gZGF0YS5vcmRpbmFsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBvZiB0aGUgZGV0YWlscyBzZWN0aW9uIG9mIHRoZSByZXN1bHQgY2FyZCwgY2FuIGNvbnRhaW4gSFRNTFxuICAgICAqIEB0eXBlIHtzdHJpbmd8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzdGluYXRpb24gbGluayBmb3IgdGhlIHRpdGxlIG9mIHRoZSByZXN1bHQgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmsgPSBkYXRhLmxpbmsgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBFbnRpdHkgSUQsIG9yIG90aGVyIHVuaXF1ZSBpZGVudGlmaWVyLCB1c2VkIGZvciB0byBwb3dlciBpbnRlcmFjdGl2aXR5XG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VidGl0bGUgb24gdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3VidGl0bGUgPSBkYXRhLnN1YnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgbW9kaWZpZXIsIHVzdWFsbHkgZGVyaXZlZCBmcm9tIHRoZSB2ZXJ0aWNhbCBjb25maWd1cmF0aW9uIElEXG4gICAgICogVXNlZCB0byBhcHBseSBkaWZmZXJlbnQgc3R5bGluZyB0byBkaWZmZXJlbnQgcmVzdWx0IGNhcmQgdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tb2RpZmllciA9IGRhdGEubW9kaWZpZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbGFyZ2UgZGF0ZSwgb2YgdGhlIGZvcm1hdCB7IG1vbnRoOiAnSmFuJywgZGF5OiAnMDEnIH1cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iaWdEYXRlID0gZGF0YS5iaWdEYXRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbWFnZSBwcm9maWxlIG9iamVjdCwgZXhwZWN0ZWQgdG8gaGF2ZSBhIHVybCBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gZGF0YS5pbWFnZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2FsbHMgdG8gYWN0aW9uLCBvZiB0aGUgZm9ybWF0OlxuICAgICAqIHsgaWNvbjogJycsIHVybDogJycsIHRleHQ6ICcnLCBldmVudFR5cGU6ICcnLCBldmVudE9wdGlvbnM6IHt9fVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSBkYXRhLmNhbGxzVG9BY3Rpb24gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGFjY29yZGlhbiByZXN1bHQgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzZWQgPSBkYXRhLmNvbGxhcHNlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGRhdGEuY29sbGFwc2VkO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIaWdobGlnaHRlZFZhbHVlICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgaGlnaGxpZ2h0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpZ2hsaWdodGVkVmFsdWUge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWUgfHwgZGF0YS5zaG9ydFZhbHVlIHx8ICcnO1xuICAgIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MgPSBkYXRhLm1hdGNoZWRTdWJzdHJpbmdzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCAoKSB7XG4gICAgdGhpcy5fc29ydE1hdGNoZWRTdWJzdHJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRIaWdobGlnaHRlZFZhbHVlKHRoaXMudmFsdWUsIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBpbnZlcnRlZCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEludmVydGVkICgpIHtcbiAgICB0aGlzLl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MoKTtcbiAgICBjb25zdCBpbnZlcnRlZFN1YnN0cmluZ3MgPSB0aGlzLl9nZXRJbnZlcnRlZFN1YnN0cmluZ3ModGhpcy5tYXRjaGVkU3Vic3RyaW5ncywgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZSh0aGlzLnZhbHVlLCBpbnZlcnRlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGludHJvZHVjZXMgaGlnaGxpZ2h0aW5nIHRvIGlucHV0IGRhdGEgYWNjb3JkaW5nIHRvIGhpZ2hsaWdodGluZyBzcGVjaWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgaW5wdXQgb2JqZWN0IHRvIGFwcGx5IGhpZ2hsaWdodGluZyB0b1xuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnQVRNJyxcbiAgICogICAgZmVhdHVyZWRNZXNzYWdlOiB7XG4gICAqICAgICAgZGVzY3JpcHRpb246ICdTYXZlIHRpbWUgJiBiYW5rIG9uIHlvdXIgdGVybXMgYXQgb3ZlciAxLDgwMCBBVE1zJ1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZFN1YnN0cmluZ3MgaGlnaGxpZ2h0aW5nIHNwZWNpZmllcnMgdG8gYXBwbHkgdG8gaW5wdXQgb2JqZWN0XG4gICAqXG4gICAqICBleGFtcGxlIG9iamVjdCA6XG4gICAqICB7XG4gICAqICAgIG5hbWU6IHtcbiAgICogICAgICBtYXRjaGVkU3Vic3RyaW5nczogW3tcbiAgICogICAgICAgIGxlbmd0aDogMyxcbiAgICogICAgICAgIG9mZnNldDogMFxuICAgKiAgICAgIH1dLFxuICAgKiAgICAgIHZhbHVlOiAnQVRNJ1xuICAgKiAgICB9LFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjoge1xuICAgKiAgICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAqICAgICAgICAgIGxlbmd0aDogNCxcbiAgICogICAgICAgICAgb2Zmc2V0OiA0NVxuICAgKiAgICAgICAgfV0sXG4gICAqICAgICAgICB2YWx1ZTogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIEFUTXMnXG4gICAqICAgICAgfVxuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvcHkgb2YgaW5wdXQgdmFsdWUgd2l0aCBoaWdobGlnaHRpbmcgYXBwbGllZFxuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnPHN0cm9uZz5BVE08L3N0cm9uZz4nLFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIDxzdHJvbmc+QVRNczwvc3Ryb25nPidcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKi9cbiAgYnVpbGRIaWdobGlnaHRlZFZhbHVlICh2YWwsIGhpZ2hsaWdodGVkU3Vic3RyaW5ncykge1xuICAgIGxldCBoaWdobGlnaHRlZFZhbHVlID0gJyc7XG4gICAgbGV0IG5leHRTdGFydCA9IDA7XG5cbiAgICBpZiAoaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IHN0YXJ0ID0gTnVtYmVyKGhpZ2hsaWdodGVkU3Vic3RyaW5nc1tqXS5vZmZzZXQpO1xuICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzW2pdLmxlbmd0aDtcblxuICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSBbdmFsLnNsaWNlKG5leHRTdGFydCwgc3RhcnQpLCAnPHN0cm9uZz4nLCB2YWwuc2xpY2Uoc3RhcnQsIGVuZCksICc8L3N0cm9uZz4nXS5qb2luKCcnKTtcblxuICAgICAgaWYgKGogPT09IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGggLSAxICYmIGVuZCA8IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSB2YWwuc2xpY2UoZW5kKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBoaWdobGlnaHRlZFZhbHVlO1xuICB9XG5cbiAgX3NvcnRNYXRjaGVkU3Vic3RyaW5ncyAoKSB7XG4gICAgdGhpcy5tYXRjaGVkU3Vic3RyaW5ncy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5vZmZzZXQgPCBiLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLm9mZnNldCA+IGIub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRJbnZlcnRlZFN1YnN0cmluZ3MgKG1hdGNoZWRTdWJzdHJpbmdzLCB2YWx1ZUxlbmd0aCkge1xuICAgIGNvbnN0IGludmVydGVkU3Vic3RyaW5ncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1YnN0cmluZyA9IG1hdGNoZWRTdWJzdHJpbmdzW2ldO1xuICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHN1YnN0cmluZy5vZmZzZXQgKyBzdWJzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGkgPT09IDAgJiYgc3Vic3RyaW5nLm9mZnNldCAhPT0gMCkge1xuICAgICAgICBpbnZlcnRlZFN1YnN0cmluZ3MucHVzaCh7IG9mZnNldDogMCwgbGVuZ3RoOiBzdWJzdHJpbmcub2Zmc2V0IH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVMZW5ndGggPiBuZXh0T2Zmc2V0KSB7XG4gICAgICAgIGludmVydGVkU3Vic3RyaW5ncy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IG5leHRPZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoIC0gMVxuICAgICAgICAgICAgPyBtYXRjaGVkU3Vic3RyaW5nc1tpICsgMV0ub2Zmc2V0IC0gbmV4dE9mZnNldFxuICAgICAgICAgICAgOiB2YWx1ZUxlbmd0aCAtIG5leHRPZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFN1YnN0cmluZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEVycm9ycyAqL1xuXG4vKipcbiAqIEFuc3dlcnNCYXNlRXJyb3IgaXMgYW4gZXh0ZW5zaW9uIG9mIHRoZSBiYXNlIEVycm9yIG9iamVjdC5cbiAqIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gd2hlbiByZXBvcnRpbmcgdG8gdGhlIHNlcnZlci5cbiAqIEBleHRlbmRzIEVycm9yXG4gKlxuICogRXJyb3IgY29kZXMgZmFsbCBpbnRvIG9uZSBvZiBmb3VyIGNhdGVnb3JpZXM6XG4gKiAxWFggZXJyb3JzOiBCYXNpYyBlcnJvcnNcbiAqIDJYWCBlcnJvcnM6IFVJIGVycm9yc1xuICogM1hYIGVycm9yczogRW5kcG9pbnQgZXJyb3JzXG4gKiA0WFggZXJyb3JzOiBDb3JlIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0Jhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycm9yQ29kZSwgbWVzc2FnZSwgYm91bmRhcnkgPSAndW5rbm93bicsIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnJlcG9ydGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2F1c2VkQnkpIHtcbiAgICAgIHRoaXMuY2F1c2VkQnkgPSBjYXVzZWRCeSBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3JcbiAgICAgICAgPyBjYXVzZWRCeVxuICAgICAgICA6IEFuc3dlcnNCYXNlRXJyb3IuZnJvbShjYXVzZWRCeSk7XG4gICAgICB0aGlzLnN0YWNrID0gYCR7dGhpcy5zdGFja31cXG5DYXVzZWQgQnk6ICR7dGhpcy5jYXVzZWRCeS5zdGFja31gO1xuICAgIH1cbiAgfVxuXG4gIHRvSnNvbiAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHJpbmcgPSBgJHt0aGlzLmVycm9yTWVzc2FnZX0gKCR7dGhpcy5ib3VuZGFyeX0pYDtcbiAgICBpZiAodGhpcy5jYXVzZWRCeSkge1xuICAgICAgc3RyaW5nICs9IGBcXG4gIENhdXNlZCBCeTogJHt0aGlzLmNhdXNlZEJ5LnRvU3RyaW5nKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChidWlsdGluRXJyb3IsIGJvdW5kYXJ5KSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoYnVpbHRpbkVycm9yLm1lc3NhZ2UsIGJvdW5kYXJ5KTtcbiAgICBlcnJvci5zdGFjayA9IGJ1aWx0aW5FcnJvci5zdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzQmFzaWNFcnJvciBpcyBhIHdyYXBwZXIgYXJvdW5kIGFsbCB0aGUgYnVpbHQtaW4gZXJyb3JzXG4gKiBlLmcuIHVuZGVmaW5lZCB2YXJpYWJsZXMsIGluY29ycmVjdCBzeW50YXgsIHR5cGVzLCBtaXNzaW5nIG1ldGhvZHMsIGV0Yy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNCYXNpY0Vycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigxMDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzVWlFcnJvciB1c2VkIGZvciB0aGluZ3MgbGlrZSBET00gZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0NvbmZpZ0Vycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcigxMDEsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzVWlFcnJvciB1c2VkIGZvciB0aGluZ3MgbGlrZSBET00gZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc1VpRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDIwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNDb21wb25lbnRFcnJvciBpcyB1c2VkIGZvciBDb21wb25lbnQgb3JpZW50ZWQgZXJyb3JzXG4gKiBlLmcuIGZhaWx1cmUgdG8gcmVuZGVyLCBvciBjYXRjaGluZyB1bmtub3ducy5cbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNDb21wb25lbnRFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29tcG9uZW50LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDIwMSwgbWVzc2FnZSwgY29tcG9uZW50LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzRW5kcG9pbnRFcnJvciByZXByZXNlbnRzIGFsbCBuZXR3b3JrIHJlbGF0ZWQgZXJyb3JzLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0VuZHBvaW50RXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDMwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNDb3JlRXJyb3IgcmVwcmVzZW50cyBlcnJvcnMgZm9yIHByZWNvbmRpdGlvbiBmYWlsdXJlcyBpbiB0aGUgY29yZSBsaWJyYXJ5XG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQ29yZUVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcig0MDAsIG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnN3ZXJzU3RvcmFnZUVycm9yIHJlcHJlc2VudHMgc3RvcmFnZSByZWxhdGVkIGVycm9yc1xuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc1N0b3JhZ2VFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RvcmFnZUtleSwgZGF0YSwgY2F1c2VkQnkpIHtcbiAgICBzdXBlcig0MDEsIG1lc3NhZ2UsICdTdG9yYWdlJywgY2F1c2VkQnkpO1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNBbmFseXRpY3NFcnJvciBpcyB1c2VkIGZvciBlcnJvcnMgd2hlbiByZXBvcnRpbmcgYW5hbHl0aWNzXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGV2ZW50LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDQwMiwgbWVzc2FnZSwgJ0FuYWx5dGljcycsIGNhdXNlZEJ5KTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdEZhY3RvcnkgKi9cblxuaW1wb3J0IFJlc3VsdCBmcm9tICcuL3Jlc3VsdCc7XG5pbXBvcnQgSGlnaGxpZ2h0ZWRWYWx1ZSBmcm9tICcuL2hpZ2hsaWdodGVkdmFsdWUnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvcmVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXN1bHRGYWN0b3J5IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSBSZXN1bHQgdmlldyBtb2RlbC5cbiAgICogSW5jbHVkZXMgZGVmYXVsdCBtYXBwaW5ncyBvZiBHb29nbGVDdXN0b21TZWFyY2hFbmdpbmUgcmVzdWx0cyB0b1xuICAgKiB0aGUgZmllbGRzIGV4cG9zZWQgYnkgdGhlIHRlbXBsYXRlLlxuICAgKiBAcGFyYW0gcmVzdWx0c0RhdGEgIHtBcnJheX0gZXhwZWN0ZWQgZm9ybWF0OiB7IGRhdGE6IHsgLi4uIH0sIGhpZ2hsaWdodGVkRmllbGRzOiB7IC4uLiB9fVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZvcm1hdHRlcnMgdG8gYXBwbHkgdG8gdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxJZCBUaGUgdmVydGljYWwgb2YgdGhlc2UgcmVzdWx0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIEJhY2tlbmQgc291cmNlIG9mIHRoZXNlIHJlc3VsdHNcbiAgICogQHJldHVybnMge1Jlc3VsdFtdfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3VsdHNEYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBzb3VyY2UpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHJlc3VsdHNEYXRhW2ldLmRhdGEgfHwgcmVzdWx0c0RhdGFbaV07XG5cbiAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgJ0dPT0dMRV9DU0UnOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21Hb29nbGVDdXN0b21TZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCSU5HX0NTRSc6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUJpbmdDdXN0b21TZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaRU5ERVNLJzpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tWmVuZGVza1NlYXJjaEVuZ2luZShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FMR09MSUEnOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21BbGdvbGlhU2VhcmNoRW5naW5lKGRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS05PV0xFREdFX01BTkFHRVInOlxuICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodGVkRmllbGRzID0gcmVzdWx0c0RhdGFbaV0uaGlnaGxpZ2h0ZWRGaWVsZHMgfHwge307XG5cbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tS25vd2xlZGdlTWFuYWdlcihcbiAgICAgICAgICAgIGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRmllbGRzLCBpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUdlbmVyaWMoZGF0YSwgaSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZmllbGQgZm9ybWF0dGVycyB0byBLbm93bGVkZ2UgTWFuYWdlciBFbnRpdHkgUHJvZmlsZSBEYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlQcm9maWxlRGF0YSBFbnRpdHkgUHJvZmlsZSBEYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXR0ZXJzIERldmVsb3BlciBzcGVjaWZpZWQgRmllbGQgRm9ybWF0dGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxJZCBJZGVudGlmaWVyIGZvciBWZXJ0aWNhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSBTdWJzZXQgb2YgRW50aXR5IFByb2ZpbGUgRGF0YSB3aXRoIGhpZ2hsaWdodGluZyBhcHBsaWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFN1YnNldCBvZiBFbnRpdHkgUHJvZmlsZSBEYXRhIEZpZWxkcyB3aXRoIGZpZWxkIGZvcm1hdHRlcnMgYXBwbGllZFxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVGb3JtYXR0ZWREYXRhIChlbnRpdHlQcm9maWxlRGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSkge1xuICAgIC8vIGlmIG5vIGZpZWxkIGZvcm1hdHRlcnMgc3BlY2lmaWVkLCBub3RoaW5nIHRvIGZvcm1hdFxuICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXR0ZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZWREYXRhID0ge307XG5cbiAgICBPYmplY3QuZW50cmllcyhlbnRpdHlQcm9maWxlRGF0YSkuZm9yRWFjaCgoW2ZpZWxkTmFtZSwgZmllbGRWYWxdKSA9PiB7XG4gICAgICAvLyBjaGVjayBpZiBhIGZpZWxkIGZvcm1hdHRlciBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGVudGl0eSBwcm9maWxlIGZpZWxkXG4gICAgICBpZiAoZm9ybWF0dGVyc1tmaWVsZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdmVyaWZ5IHRoZSBmaWVsZCBmb3JtYXR0ZXIgcHJvdmlkZWQgaXMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gYXMgZXhwZWN0ZWRcbiAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyc1tmaWVsZE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29yZUVycm9yKCdGaWVsZCBmb3JtYXR0ZXIgaXMgbm90IG9mIGV4cGVjdGVkIHR5cGUgZnVuY3Rpb24nLCAnUmVzdWx0RmFjdG9yeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBoaWdobGlnaHRlZCB2ZXJzaW9uIG9mIGZpZWxkIHZhbHVlIGlzIGF2YWlsYWJsZSwgbWFrZSBpdCBhdmFpbGFibGUgdG8gZmllbGQgZm9ybWF0dGVyXG4gICAgICBsZXQgaGlnaGxpZ2h0ZWRGaWVsZFZhbCA9IG51bGw7XG4gICAgICBpZiAoaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSAmJiBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZFZhbCA9IGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGFbZmllbGROYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCBmb3JtYXR0ZXIgZnVuY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBmaWVsZCBuYW1lXG4gICAgICAvLyB0aGUgaW5wdXQgb2JqZWN0IGRlZmluZXMgdGhlIGludGVyZmFjZSB0aGF0IGZpZWxkIGZvcm1hdHRlciBmdW5jdGlvbnMgd29yayB3aXRoXG4gICAgICBmb3JtYXR0ZWREYXRhW2ZpZWxkTmFtZV0gPSBmb3JtYXR0ZXJzW2ZpZWxkTmFtZV0oe1xuICAgICAgICBlbnRpdHlQcm9maWxlRGF0YTogZW50aXR5UHJvZmlsZURhdGEsXG4gICAgICAgIGVudGl0eUZpZWxkVmFsdWU6IGZpZWxkVmFsLFxuICAgICAgICBoaWdobGlnaHRlZEVudGl0eUZpZWxkVmFsdWU6IGhpZ2hsaWdodGVkRmllbGRWYWwsXG4gICAgICAgIHZlcnRpY2FsSWQ6IHZlcnRpY2FsSWQsXG4gICAgICAgIGlzRGlyZWN0QW5zd2VyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBzdWJzdHJpbmdzIHdpdGhpbiBLbm93bGVkZ2UgTWFuYWdlciBFbnRpdHkgRmllbGQgVmFsdWVzXG4gICAqIGFjY29yZGluZyB0byBoaWdobGlnaHRpbmcgc3BlY2lmaWVycyByZXR1cm5lZCBmcm9tIHRoZSBLbm93bGVkZ2UgTWFuYWdlciBTZWFyY2ggQmFja2VuZFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5UHJvZmlsZURhdGEgRW50aXR5IFByb2ZpbGUgRGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRGaWVsZHMgS00gc3BlY2lmaWVkIGhpZ2hsaWdodGluZyBpbnN0cnVjdGlvbnMgdG8gaGlnaGxpZ2h0IGNlcnRhaW4gRmllbGRzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFN1YnNldCBvZiBFbnRpdHkgUHJvZmlsZSBEYXRhIEZpZWxkcyB3aXRoIGhpZ2hsaWdodGluZyBhcHBsaWVkXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUhpZ2hsaWdodGVkRGF0YSAoZW50aXR5UHJvZmlsZURhdGEsIGhpZ2hsaWdodGVkRmllbGRzKSB7XG4gICAgLy8gaWYgbm8gaGlnaGxpZ2h0ZWQgZmllbGRzIHNwZWNpZmllZCwgbm90aGluZyB0byBoaWdobGlnaHRcbiAgICBpZiAoT2JqZWN0LmtleXMoaGlnaGxpZ2h0ZWRGaWVsZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0YSA9IHt9O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVudGl0eSBmaWVsZHMgdGhhdCBoYXZlIGhpZ2hsaWdodGluZyBpbnN0cnVjdGlvbnNcbiAgICBPYmplY3QuZW50cmllcyhoaWdobGlnaHRlZEZpZWxkcykuZm9yRWFjaCgoW2hpZ2hsaWdodGVkRmllbGROYW1lXSkgPT4ge1xuICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGhpZ2hsaWdodGVkIGZpZWxkIG5hbWUgY29ycmVzcG9uZHMgdG8gYW4gZXhpc3RpbmcgZW50aXR5IHByb2ZpbGUgZmllbGRcbiAgICAgIGlmIChlbnRpdHlQcm9maWxlRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignSGlnaGxpZ2h0ZWQgRmllbGQgTmFtZSBkb2VzIG5vdCBleGlzdCBpbiBFbnRpdHkgUHJvZmlsZScsICdSZXN1bHRGYWN0b3J5Jyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBoaWdobGlnaHRlZEZpZWxkID0gaGlnaGxpZ2h0ZWRGaWVsZHNbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdO1xuXG4gICAgICAvLyBjaGVjayBmb3IgbmVzdGVkIGZpZWxkc1xuICAgICAgaWYgKHR5cGVvZiBoaWdobGlnaHRlZEZpZWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIE9iamVjdC5rZXlzKGhpZ2hsaWdodGVkRmllbGQpLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkWydtYXRjaGVkU3Vic3RyaW5ncyddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVjdXJzZSB0byBjaGlsZHJlbiBmaWVsZHNcbiAgICAgICAgaGlnaGxpZ2h0ZWREYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSA9IFJlc3VsdEZhY3RvcnkuY29tcHV0ZUhpZ2hsaWdodGVkRGF0YShcbiAgICAgICAgICBlbnRpdHlQcm9maWxlRGF0YVtoaWdobGlnaHRlZEZpZWxkTmFtZV0sXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZHNbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBoaWdobGlnaHRlZERhdGFWYWx1ZSA9IG5ldyBIaWdobGlnaHRlZFZhbHVlKGVudGl0eVByb2ZpbGVEYXRhKS5idWlsZEhpZ2hsaWdodGVkVmFsdWUoXG4gICAgICAgICAgaGlnaGxpZ2h0ZWRGaWVsZC52YWx1ZSxcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkLm1hdGNoZWRTdWJzdHJpbmdzKTtcbiAgICAgICAgaGlnaGxpZ2h0ZWREYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSA9IGhpZ2hsaWdodGVkRGF0YVZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgZ2VuZXJpYyByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUdlbmVyaWMgKGRhdGEsIGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEubmFtZSxcbiAgICAgIGRldGFpbHM6IHRoaXMudHJ1bmNhdGUoZGF0YS5kZXNjcmlwdGlvbiksXG4gICAgICBsaW5rOiBkYXRhLndlYnNpdGUsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIG9yZGluYWw6IGluZGV4ICsgMVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSBLbm93bGVkZ2UgTWFuYWdlciByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdHRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsSWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZ2hsaWdodGVkRmllbGRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Lbm93bGVkZ2VNYW5hZ2VyIChkYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBoaWdobGlnaHRlZEZpZWxkcywgaW5kZXgpIHtcbiAgICAvLyBjb21wdXRlIGhpZ2hsaWdodGVkIGVudGl0eSBwcm9maWxlIGRhdGFcbiAgICBsZXQgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSA9IFJlc3VsdEZhY3RvcnkuY29tcHV0ZUhpZ2hsaWdodGVkRGF0YShkYXRhLCBoaWdobGlnaHRlZEZpZWxkcyk7XG4gICAgLy8gY29tcHV0ZSBmb3JtYXR0ZWQgZW50aXR5IHByb2ZpbGUgZGF0YVxuICAgIGNvbnN0IGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhID0gUmVzdWx0RmFjdG9yeS5jb21wdXRlRm9ybWF0dGVkRGF0YShcbiAgICAgIGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEpO1xuXG4gICAgLy8gc2V0IHJlc3VsdCBkZXRhaWxzIGNoZWNraW5nIHRoZSBmb2xsb3dpbmcgaW4gb3JkZXIgb2YgcHJpb3JpdHkgOiBmb3JtYXR0ZWQsIGhpZ2hsaWdodGVkLCByYXdcbiAgICBsZXQgcmVzdWx0RGV0YWlscyA9IG51bGw7XG4gICAgaWYgKGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdERldGFpbHMgPSBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0RGV0YWlscyA9IHRoaXMudHJ1bmNhdGUoaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdERldGFpbHMgPSB0aGlzLnRydW5jYXRlKGRhdGEuZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEsXG4gICAgICBoaWdobGlnaHRlZDogaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSxcbiAgICAgIHRpdGxlOiBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YS5uYW1lIHx8IGRhdGEubmFtZSxcbiAgICAgIGRldGFpbHM6IHJlc3VsdERldGFpbHMsXG4gICAgICBsaW5rOiBkYXRhLndlYnNpdGUsXG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIG9yZGluYWw6IGluZGV4ICsgMVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgR29vZ2xlIEN1c3RvbSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tR29vZ2xlQ3VzdG9tU2VhcmNoRW5naW5lIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEuaHRtbFRpdGxlLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJyksXG4gICAgICBkZXRhaWxzOiBkYXRhLmh0bWxTbmlwcGV0LFxuICAgICAgbGluazogZGF0YS5saW5rXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBNYXBzIHZpZXcgbW9kZWwgZmllbGRzIGJhc2VkIG9uIHRoZSBBUEkgZGF0YSBmb3IgYSBCaW5nIEN1c3RvbSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tQmluZ0N1c3RvbVNlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLm5hbWUsXG4gICAgICBkZXRhaWxzOiBkYXRhLnNuaXBwZXQsXG4gICAgICBsaW5rOiBkYXRhLnVybFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgWmVuZGVzayBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tWmVuZGVza1NlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgZGV0YWlsczogZGF0YS5zbmlwcGV0LFxuICAgICAgbGluazogZGF0YS5odG1sX3VybFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSByZXN1bHQgdmlldyBtb2RlbC5cbiAgICogTWFwcyB2aWV3IG1vZGVsIGZpZWxkcyBiYXNlZCBvbiB0aGUgQVBJIGRhdGEgZm9yIGEgQWxnb2xpYSBTZWFyY2ggRW5naW5lIG9iamVjdC5cbiAgICogRGV0YWlscyBmaWVsZCBpcyBzZXQgdG8gb2JqZWN0SUQgc2luY2UgcmVzcG9uc2UgaGFzIG9ubHkgb25lIGdlbmVyYWwgZmllbGQgb2JqZWN0SUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUFsZ29saWFTZWFyY2hFbmdpbmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICBkZXRhaWxzOiBkYXRhLm9iamVjdElELFxuICAgICAgaWQ6IGRhdGEub2JqZWN0SURcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgc3RyaW5ncyB0byAyNTAgY2hhcmFjdGVycywgYXR0ZW1wdGluZyB0byBwcmVzZXJ2ZSB3aG9sZSB3b3Jkc1xuICAgKiBAcGFyYW0gc3RyIHtzdHJpbmd9IHRoZSBzdHJpbmcgdG8gdHJ1bmNhdGVcbiAgICogQHBhcmFtIGxpbWl0IHtOdW1iZXJ9IHRoZSBtYXhpbXVtIGNoYXJhY3RlciBsZW5ndGggdG8gcmV0dXJuXG4gICAqIEBwYXJhbSB0cmFpbGluZyB7c3RyaW5nfSBhIHRyYWlsaW5nIHN0cmluZyB0byBkZW5vdGUgdHJ1bmNhdGlvbiwgZS5nLiAnLi4uJ1xuICAgKiBAcGFyYW0gc2VwIHtzdHJpbmd9IHRoZSB3b3JkIHNlcGFyYXRvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHRydW5jYXRlIChzdHIsIGxpbWl0ID0gMjUwLCB0cmFpbGluZyA9ICcuLi4nLCBzZXAgPSAnICcpIHtcbiAgICBpZiAoIXN0ciB8fCBzdHIubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKGJtY2dpbm5pcyk6IHNwbGl0IHB1bmN0dWF0aW9uIHRvbyBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aCBcImZvbywuLi5cIlxuICAgIGNvbnN0IHdvcmRzID0gc3RyLnNwbGl0KHNlcCk7XG4gICAgY29uc3QgbWF4ID0gbGltaXQgLSB0cmFpbGluZy5sZW5ndGg7XG4gICAgbGV0IHRydW5jYXRlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgaWYgKHRydW5jYXRlZC5sZW5ndGggKyB3b3JkLmxlbmd0aCA+IG1heCB8fFxuICAgICAgICAoaSAhPT0gMCAmJiB0cnVuY2F0ZWQubGVuZ3RoICsgd29yZC5sZW5ndGggKyBzZXAubGVuZ3RoID4gbWF4KSkge1xuICAgICAgICB0cnVuY2F0ZWQgKz0gdHJhaWxpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cnVuY2F0ZWQgKz0gaSA9PT0gMCA/IHdvcmQgOiBzZXAgKyB3b3JkO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVuY2F0ZWQ7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlY3Rpb24gKi9cblxuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5pbXBvcnQgUmVzdWx0RmFjdG9yeSBmcm9tICcuL3Jlc3VsdGZhY3RvcnknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWN0aW9uIHtcbiAgY29uc3RydWN0b3IgKGRhdGEsIHVybCwgZm9ybWF0dGVycykge1xuICAgIHRoaXMuc2VhcmNoU3RhdGUgPSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFO1xuICAgIHRoaXMudmVydGljYWxDb25maWdJZCA9IGRhdGEudmVydGljYWxDb25maWdJZCB8fCBudWxsO1xuICAgIHRoaXMucmVzdWx0c0NvdW50ID0gZGF0YS5yZXN1bHRzQ291bnQgfHwgMDtcbiAgICB0aGlzLmVuY29kZWRTdGF0ZSA9IGRhdGEuZW5jb2RlZFN0YXRlIHx8ICcnO1xuICAgIHRoaXMuYXBwbGllZFF1ZXJ5RmlsdGVycyA9IEFwcGxpZWRRdWVyeUZpbHRlci5mcm9tKGRhdGEuYXBwbGllZFF1ZXJ5RmlsdGVycyk7XG4gICAgdGhpcy5mYWNldHMgPSBkYXRhLmZhY2V0cyB8fCBudWxsO1xuICAgIHRoaXMucmVzdWx0cyA9IFJlc3VsdEZhY3RvcnkuZnJvbShkYXRhLnJlc3VsdHMsIGZvcm1hdHRlcnMsIHRoaXMudmVydGljYWxDb25maWdJZCwgZGF0YS5zb3VyY2UpO1xuICAgIHRoaXMubWFwID0gU2VjdGlvbi5wYXJzZU1hcChkYXRhLnJlc3VsdHMpO1xuICAgIHRoaXMudmVydGljYWxVUkwgPSB1cmwgfHwgbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hcCAocmVzdWx0cykge1xuICAgIGxldCBtYXBNYXJrZXJzID0gW107XG5cbiAgICBsZXQgY2VudGVyQ29vcmRpbmF0ZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0cy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gVE9ETyhiaWxseSkgUmVtb3ZlIGxlZ2FjeSBmYWxsYmFjayBmcm9tIGFsbCBkYXRhIGZvcm1hdFxuICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbal0uZGF0YSB8fCByZXN1bHRzW2pdO1xuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlKSB7XG4gICAgICAgIGlmICghY2VudGVyQ29vcmRpbmF0ZXMubGF0aXR1ZGUpIHtcbiAgICAgICAgICBjZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxvbmdpdHVkZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWFwTWFya2Vycy5wdXNoKHtcbiAgICAgICAgICBpdGVtOiByZXN1bHQsXG4gICAgICAgICAgbGFiZWw6IG1hcE1hcmtlcnMubGVuZ3RoICsgMSxcbiAgICAgICAgICBsYXRpdHVkZTogcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZS5sYXRpdHVkZSxcbiAgICAgICAgICBsb25naXR1ZGU6IHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUubG9uZ2l0dWRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAnbWFwQ2VudGVyJzogY2VudGVyQ29vcmRpbmF0ZXMsXG4gICAgICAnbWFwTWFya2Vycyc6IG1hcE1hcmtlcnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlY3Rpb24gZnJvbSB0aGUgcHJvdmlkZWQgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbW9kdWxlcyBUaGUgcmVzdWx0IG1vZHVsZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVybHMgVGhlIHRhYiB1cmxzXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBGaWVsZCBmb3JtYXR0ZXJzIGZvciByZXN1bHRzXG4gICAqL1xuICBzdGF0aWMgZnJvbSAobW9kdWxlcywgdXJscywgZm9ybWF0dGVycykge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgcmV0dXJuIHNlY3Rpb25zO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWN0aW9uKG1vZHVsZXMsIG51bGwsIGZvcm1hdHRlcnMpO1xuICAgIH1cblxuICAgIC8vIE91ciBzZWN0aW9ucyBzaG91bGQgY29udGFpbiBhIHByb3BlcnR5IG9mIG1hcE1hcmtlciBvYmplY3RzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKFxuICAgICAgICBuZXcgU2VjdGlvbihcbiAgICAgICAgICBtb2R1bGVzW2ldLFxuICAgICAgICAgIHVybHNbbW9kdWxlc1tpXS52ZXJ0aWNhbENvbmZpZ0lkXSxcbiAgICAgICAgICBmb3JtYXR0ZXJzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zO1xuICB9XG59XG5cbmNsYXNzIEFwcGxpZWRRdWVyeUZpbHRlciB7XG4gIC8vIFN1cHBvcnQgbGVnYWN5IG1vZGVsIGFuZCBuZXcgbW9kZWwgdW50aWwgZnVsbHkgbWlncmF0ZWQuXG4gIC8vIFRPRE8oYmlsbHkpIFJlbW92ZSB0aGUgbGVmdCBleHByZXNzaW9uIGR1cmluZyBhc3NpZ25tZW50IHdoZW4gbWlncmF0ZWQuXG4gIGNvbnN0cnVjdG9yIChhcHBsaWVkUXVlcnlGaWx0ZXIpIHtcbiAgICB0aGlzLmtleSA9IGFwcGxpZWRRdWVyeUZpbHRlci5rZXkgfHwgYXBwbGllZFF1ZXJ5RmlsdGVyLmRpc3BsYXlLZXk7XG4gICAgdGhpcy52YWx1ZSA9IGFwcGxpZWRRdWVyeUZpbHRlci52YWx1ZSB8fCBhcHBsaWVkUXVlcnlGaWx0ZXIuZGlzcGxheVZhbHVlO1xuICB9XG5cbiAgc3RhdGljIGZyb20gKGFwcGxpZWRRdWVyeUZpbHRlcnMpIHtcbiAgICBsZXQgZmlsdGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXBwbGllZFF1ZXJ5RmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZmlsdGVycy5wdXNoKG5ldyBBcHBsaWVkUXVlcnlGaWx0ZXIoYXBwbGllZFF1ZXJ5RmlsdGVyc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVycztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVW5pdmVyc2FsUmVzdWx0cyAqL1xuXG5pbXBvcnQgU2VjdGlvbiBmcm9tICcuL3NlY3Rpb24nO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaXZlcnNhbFJlc3VsdHMge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMucXVlcnlJZCA9IGRhdGEucXVlcnlJZCB8fCBudWxsO1xuICAgIHRoaXMuc2VjdGlvbnMgPSBkYXRhLnNlY3Rpb25zIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNlYXJjaCwgdXNlZCB0byByZW5kZXIgZGlmZmVyZW50IHRlbXBsYXRlcyBiZWZvcmUsIGR1cmluZyxcbiAgICAgKiBhbmQgYWZ0ZXIgbG9hZGluZ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hTdGF0ZSA9IGRhdGEuc2VhcmNoU3RhdGUgfHwgU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdW5pdmVyc2FsIHJlc3VsdHMgZnJvbSBzZXJ2ZXIgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXJscyBUaGUgdGFiIHVybHNcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmaWVsZCBmb3JtYXR0ZXJzIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlLCB1cmxzLCBmb3JtYXR0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxSZXN1bHRzKHtcbiAgICAgIHF1ZXJ5SWQ6IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBzZWN0aW9uczogU2VjdGlvbi5mcm9tKHJlc3BvbnNlLm1vZHVsZXMsIHVybHMsIGZvcm1hdHRlcnMpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgVW5pdmVydmFsUmVzdWx0cyBvYmplY3QgcmVwcmVzZW50aW5nIGxvYWRpbmcgcmVzdWx0c1xuICAgKiBAcmV0dXJuIHtVbml2ZXJzYWxSZXN1bHRzfVxuICAgKi9cbiAgc3RhdGljIHNlYXJjaExvYWRpbmcgKCkge1xuICAgIHJldHVybiBuZXcgVW5pdmVyc2FsUmVzdWx0cyh7IHNlYXJjaFN0YXRlOiBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIERpcmVjdEFuc3dlciAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RBbnN3ZXIge1xuICBjb25zdHJ1Y3RvciAoZGlyZWN0QW5zd2VyID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRpcmVjdEFuc3dlcik7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEaXJlY3RBbnN3ZXIgbW9kZWwgZnJvbSB0aGUgZ2l2ZW4gc2VydmVyIGRhdGEgYW5kIGZvcm1hdHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgZGlyZWN0IGFuc3dlclxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZvcm1hdHRlcnMgdG8gYXBwbHkgdG8gdGhpcyBkaXJlY3QgYW5zd2VyXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UsIGZvcm1hdHRlcnMpIHtcbiAgICBjb25zdCBkYXRhID0geyAuLi5yZXNwb25zZSB9O1xuICAgIGNvbnN0IHsgYW5zd2VyLCByZWxhdGVkSXRlbSB9ID0gZGF0YTtcblxuICAgIGlmIChhbnN3ZXIgJiYgZm9ybWF0dGVyc1thbnN3ZXIuZmllbGRBcGlOYW1lXSkge1xuICAgICAgYW5zd2VyLnZhbHVlID0gZm9ybWF0dGVyc1thbnN3ZXIuZmllbGRBcGlOYW1lXShcbiAgICAgICAgYW5zd2VyLnZhbHVlLFxuICAgICAgICByZWxhdGVkSXRlbS5kYXRhLmZpZWxkVmFsdWVzLFxuICAgICAgICByZWxhdGVkSXRlbS52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgICB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERpcmVjdEFuc3dlcihkYXRhKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTmF2aWdhdGlvbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uIHtcbiAgY29uc3RydWN0b3IgKHRhYk9yZGVyKSB7XG4gICAgdGhpcy50YWJPcmRlciA9IHRhYk9yZGVyIHx8IFtdO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAobW9kdWxlcykge1xuICAgIGxldCBuYXYgPSBbXTtcbiAgICBpZiAoIW1vZHVsZXMgfHwgIUFycmF5LmlzQXJyYXkobW9kdWxlcykpIHtcbiAgICAgIHJldHVybiBuYXY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmF2LnB1c2gobW9kdWxlc1tpXS52ZXJ0aWNhbENvbmZpZ0lkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uKG5hdik7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFZlcnRpY2FsUmVzdWx0cyAqL1xuXG5pbXBvcnQgU2VjdGlvbiBmcm9tICcuL3NlY3Rpb24nO1xuaW1wb3J0IFNlYXJjaFN0YXRlcyBmcm9tICcuLi9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsUmVzdWx0cyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgc2VhcmNoU3RhdGU6IFNlYXJjaFN0YXRlcy5TRUFSQ0hfQ09NUExFVEUgfSwgZGF0YSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHByb3ZpZGVkIHJlc3VsdHMgdG8gdGhlIGN1cnJlbnQgcmVzdWx0c1xuICAgKiBAcGFyYW0ge1ZlcnRpY2FsUmVzdWx0c30gcmVzdWx0cyB0aGUgcmVzdWx0cyB0byBhcHBlbmQgdG8gdGhlIGN1cnJlbnQgcmVzdWx0c1xuICAgKi9cbiAgYXBwZW5kIChyZXN1bHRzKSB7XG4gICAgY29uc3QgbWVyZ2VkID0geyAuLi50aGlzIH07XG4gICAgbWVyZ2VkLnJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuY29uY2F0KHJlc3VsdHMucmVzdWx0cyk7XG4gICAgbWVyZ2VkLm1hcC5tYXBNYXJrZXJzID0gdGhpcy5tYXAubWFwTWFya2Vycy5jb25jYXQocmVzdWx0cy5tYXAubWFwTWFya2Vycyk7XG4gICAgcmV0dXJuIG5ldyBWZXJ0aWNhbFJlc3VsdHMobWVyZ2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdmVydGljYWwgcmVzdWx0cyBmcm9tIHNlcnZlciBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBUaGUgZmllbGQgZm9ybWF0dGVycyB0byB1c2VcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSwgZm9ybWF0dGVycykge1xuICAgIHJldHVybiBuZXcgVmVydGljYWxSZXN1bHRzKFNlY3Rpb24uZnJvbShyZXNwb25zZSwgbnVsbCwgZm9ybWF0dGVycykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIFZlcnRpY2FsUmVzdWx0cyBvYmplY3QgcmVwcmVzZW50aW5nIGxvYWRpbmcgcmVzdWx0c1xuICAgKiBAcmV0dXJuIHtWZXJ0aWNhbFJlc3VsdHN9XG4gICAqL1xuICBzdGF0aWMgc2VhcmNoTG9hZGluZyAoKSB7XG4gICAgcmV0dXJuIG5ldyBWZXJ0aWNhbFJlc3VsdHMoeyBzZWFyY2hTdGF0ZTogU2VhcmNoU3RhdGVzLlNFQVJDSF9MT0FESU5HIH0pO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNwZWxsQ2hlY2sgKi9cblxuaW1wb3J0IEhpZ2hsaWdodGVkVmFsdWUgZnJvbSAnLi9oaWdobGlnaHRlZHZhbHVlJztcblxuLyoqXG4gKiBTcGVsbENoZWNrIGlzIHRoZSBjb3JlIHN0YXRlIG1vZGVsXG4gKiB0byBwb3dlciB0aGUgU3BlbGxDaGVjayBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlbGxDaGVjayB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsIHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gZGF0YS5xdWVyeSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvcnJlY3RlZCBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb3JyZWN0ZWRRdWVyeSA9IGRhdGEuY29ycmVjdGVkUXVlcnkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JyZWN0ZWQgcXVlcnkgd2l0aCBoaWdobGlnaHRlZCB0YWdzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvcnJlY3RlZFF1ZXJ5RGlzcGxheSA9IGRhdGEuY29ycmVjdGVkUXVlcnlEaXNwbGF5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlbGwgY2hlY2sgdHlwZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gZGF0YS50eXBlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgc2hvdyBzcGVsbCBjaGVjayBvciBub3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZFNob3cgPSB0aGlzLmNvcnJlY3RlZFF1ZXJ5ICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNwZWxsIGNoZWNrIG1vZGVsIGZyb20gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzcGVsbCBjaGVjayByZXNwb25zZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3BlbGxDaGVjayh7XG4gICAgICBxdWVyeTogcmVzcG9uc2Uub3JpZ2luYWxRdWVyeSxcbiAgICAgIGNvcnJlY3RlZFF1ZXJ5OiByZXNwb25zZS5jb3JyZWN0ZWRRdWVyeSxcbiAgICAgIGNvcnJlY3RlZFF1ZXJ5RGlzcGxheTogbmV3IEhpZ2hsaWdodGVkVmFsdWUocmVzcG9uc2UuY29ycmVjdGVkUXVlcnkpLmdldCgpLFxuICAgICAgdHlwZTogcmVzcG9uc2UudHlwZVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTdG9yYWdlS2V5cyAqL1xuXG4vKipcbiAqIFN0b3JhZ2VLZXlzIGlzIGFuIEVOVU0gYXJlIGNvbnNpZGVyZWQgdGhlIHJvb3QgY29udGV4dFxuICogZm9yIGhvdyBkYXRhIGlzIHN0b3JlZCBhbmQgc2NvcGVkIGluIHRoZSBzdG9yYWdlLlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTkFWSUdBVElPTjogJ25hdmlnYXRpb24nLFxuICBVTklWRVJTQUxfUkVTVUxUUzogJ3VuaXZlcnNhbC1yZXN1bHRzJyxcbiAgVkVSVElDQUxfUkVTVUxUUzogJ3ZlcnRpY2FsLXJlc3VsdHMnLFxuICBBVVRPQ09NUExFVEU6ICdhdXRvY29tcGxldGUnLFxuICBESVJFQ1RfQU5TV0VSOiAnZGlyZWN0LWFuc3dlcicsXG4gIEZJTFRFUjogJ2ZpbHRlcicsXG4gIFFVRVJZOiAncXVlcnknLFxuICBRVUVSWV9JRDogJ3F1ZXJ5LWlkJyxcbiAgRkFDRVRfRklMVEVSOiAnZmFjZXQtZmlsdGVyJyxcbiAgRFlOQU1JQ19GSUxURVJTOiAnZHluYW1pYy1maWx0ZXJzJyxcbiAgUEFSQU1TOiAncGFyYW1zJyxcbiAgR0VPTE9DQVRJT046ICdnZW9sb2NhdGlvbicsXG4gIElOVEVOVFM6ICdpbnRlbnRzJyxcbiAgUVVFU1RJT05fU1VCTUlTU0lPTjogJ3F1ZXN0aW9uLXN1Ym1pc3Npb24nLFxuICBTRUFSQ0hfQ09ORklHOiAnc2VhcmNoLWNvbmZpZycsXG4gIFNFQVJDSF9PRkZTRVQ6ICdzZWFyY2gtb2Zmc2V0JyxcbiAgU1BFTExfQ0hFQ0s6ICdzcGVsbC1jaGVjaycsXG4gIExPQ0FUSU9OX0JJQVM6ICdsb2NhdGlvbi1iaWFzJyxcbiAgU0VTU0lPTlNfT1BUX0lOOiAnc2Vzc2lvbnMtb3B0LWluJyxcbiAgTkFWSUdBVElPTl9DT05GSUc6ICduYXZpZ2F0aW9uLWNvbmZpZycsXG4gIExPQ0FMRTogJ2xvY2FsZScsXG4gIFNPUlRfQllTOiAnc29ydC1ieXMnXG59O1xuIiwiLyoqIEBtb2R1bGUgRHluYW1pY0ZpbHRlcnMgKi9cblxuLyoqXG4gKiBNb2RlbCByZXByZXNlbnRpbmcgYSBzZXQgb2YgZHluYW1pYyBmaWx0ZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNGaWx0ZXJzIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBmaWx0ZXJzIHRoaXMgbW9kZWwgaG9sZHNcbiAgICAgKiBAdHlwZSB7e2xhYmVsOiBzdHJpbmcsIGZpZWxkSWQ6IHN0cmluZywgb3B0aW9uczogb2JqZWN0W119fVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVycyA9IGRhdGEuZmlsdGVycyB8fCBbXTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9yZ2FuaXplICdmYWNldHMnIGZyb20gdGhlIGFwaSByZXNwb25zZSBpbnRvIGR5bmFtaWMgZmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgZHluYW1pYyBmaWx0ZXIgcmVzcG9uc2UgZnJvbSB0aGUgYXBpXG4gICAqIEByZXR1cm5zIHtEeW5hbWljRmlsdGVyc31cbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGNvbnN0IHsgZmFjZXRzIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBkeW5hbWljRmlsdGVycyA9IGZhY2V0cy5tYXAoZiA9PiAoe1xuICAgICAgbGFiZWw6IGZbJ2Rpc3BsYXlOYW1lJ10sXG4gICAgICBmaWVsZElkOiBmWydmaWVsZElkJ10sXG4gICAgICBvcHRpb25zOiBmLm9wdGlvbnMubWFwKG8gPT4gKHtcbiAgICAgICAgbGFiZWw6IG9bJ2Rpc3BsYXlOYW1lJ10sXG4gICAgICAgIGNvdW50TGFiZWw6IG9bJ2NvdW50J10sXG4gICAgICAgIHNlbGVjdGVkOiBvWydzZWxlY3RlZCddLFxuICAgICAgICBmaWx0ZXI6IG9bJ2ZpbHRlciddXG4gICAgICB9KSlcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gbmV3IER5bmFtaWNGaWx0ZXJzKHsgZmlsdGVyczogZHluYW1pY0ZpbHRlcnMgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaEludGVudHMgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoSW50ZW50cyB7XG4gIGNvbnN0cnVjdG9yIChpbnRlbnRzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVudCB0byBmaW5kIHJlc3VsdHMgYmFzZWQgb24gdGhlIHVzZXIncyBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubmVhck1lID0gaW50ZW50cy5uZWFyTWU7XG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBTZWFyY2hJbnRlbnRzIGZyb20gc2VydmVyIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIHJlc3BvbnNlIGludGVudHNcbiAgICogQHJldHVybnMge1NlYXJjaEludGVudHN9XG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBjb25zdCBpbnRlbnRzID0gcmVzcG9uc2UgfHwgW107XG5cbiAgICByZXR1cm4gbmV3IFNlYXJjaEludGVudHMoe1xuICAgICAgbmVhck1lOiBpbnRlbnRzLmluY2x1ZGVzKCdORUFSX01FJylcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTG9jYXRpb25CaWFzICovXG5cbi8qKlxuICogTG9jYXRpb25CaWFzIGlzIHRoZSBjb3JlIHN0YXRlIG1vZGVsXG4gKiB0byBwb3dlciB0aGUgTG9jYXRpb25CaWFzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhdGlvbkJpYXMge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhdGlvbiBiaWFzIGFjY3VyYWN5IHdoaWNoIGFyZSBJUCwgREVWSUNFIGFuZCBVTktOV09OXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFjY3VyYWN5ID0gZGF0YS5hY2N1cmFjeSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhdGl0dWRlIHVzZWQgZm9yIGxvY2F0aW9uIGJpYXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGF0aXR1ZGUgPSBkYXRhLmxhdGl0dWRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIHVzZWQgZm9yIGxvY2F0aW9uIGJpYXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG9uZ2l0dWRlID0gZGF0YS5sb25naXR1ZGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhdGlvbiBkaXNwbGF5IG5hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubG9jYXRpb25EaXNwbGF5TmFtZSA9IGRhdGEubG9jYXRpb25EaXNwbGF5TmFtZSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2F0aW9uIGJpYXMgbW9kZWwgZnJvbSB0aGUgcHJvdmlkZWQgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIGxvY2F0aW9uIGJpYXMgcmVzcG9uc2VcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBuZXcgTG9jYXRpb25CaWFzKHtcbiAgICAgICAgYWNjdXJhY3k6ICdVTktOT1dOJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhdGlvbkJpYXMoe1xuICAgICAgYWNjdXJhY3k6IHJlc3BvbnNlLmFjY3VyYWN5LFxuICAgICAgbGF0aXR1ZGU6IHJlc3BvbnNlLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiByZXNwb25zZS5sb25naXR1ZGUsXG4gICAgICBsb2NhdGlvbkRpc3BsYXlOYW1lOiByZXNwb25zZS5sb2NhdGlvbkRpc3BsYXlOYW1lXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaERhdGFUcmFuc2Zvcm1lciAqL1xuXG5pbXBvcnQgVW5pdmVyc2FsUmVzdWx0cyBmcm9tICcuLi9tb2RlbHMvdW5pdmVyc2FscmVzdWx0cyc7XG5pbXBvcnQgRGlyZWN0QW5zd2VyIGZyb20gJy4uL21vZGVscy9kaXJlY3RhbnN3ZXInO1xuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi4vbW9kZWxzL25hdmlnYXRpb24nO1xuaW1wb3J0IFZlcnRpY2FsUmVzdWx0cyBmcm9tICcuLi9tb2RlbHMvdmVydGljYWxyZXN1bHRzJztcbmltcG9ydCBTcGVsbENoZWNrIGZyb20gJy4uL21vZGVscy9zcGVsbGNoZWNrJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBEeW5hbWljRmlsdGVycyBmcm9tICcuLi9tb2RlbHMvZHluYW1pY2ZpbHRlcnMnO1xuaW1wb3J0IFNlYXJjaEludGVudHMgZnJvbSAnLi4vbW9kZWxzL3NlYXJjaGludGVudHMnO1xuaW1wb3J0IExvY2F0aW9uQmlhcyBmcm9tICcuLi9tb2RlbHMvbG9jYXRpb25iaWFzJztcblxuLyoqXG4gKiBBIERhdGEgVHJhbnNmb3JtZXIgdGhhdCB0YWtlcyB0aGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gYSBTZWFyY2ggcmVxdWVzdFxuICogQW5kIHRyYW5zZm9ybXMgaW4gdG8gYSBmcm9udC1lbmQgb3JpZW50ZWQgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBvdXJcbiAqIGNvbXBvbmVudCBsaWJyYXJ5IGFuZCBjb3JlIHN0b3JhZ2UgdW5kZXJzdGFuZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoRGF0YVRyYW5zZm9ybWVyIHtcbiAgc3RhdGljIHRyYW5zZm9ybSAoZGF0YSwgdXJscyA9IHt9LCBmb3JtYXR0ZXJzKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gZGF0YS5yZXNwb25zZTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N0b3JhZ2VLZXlzLlFVRVJZX0lEXTogcmVzcG9uc2UucXVlcnlJZCxcbiAgICAgIFtTdG9yYWdlS2V5cy5OQVZJR0FUSU9OXTogTmF2aWdhdGlvbi5mcm9tKHJlc3BvbnNlLm1vZHVsZXMpLFxuICAgICAgW1N0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVJdOiBEaXJlY3RBbnN3ZXIuZnJvbShyZXNwb25zZS5kaXJlY3RBbnN3ZXIsIGZvcm1hdHRlcnMpLFxuICAgICAgW1N0b3JhZ2VLZXlzLlVOSVZFUlNBTF9SRVNVTFRTXTogVW5pdmVyc2FsUmVzdWx0cy5mcm9tKHJlc3BvbnNlLCB1cmxzLCBmb3JtYXR0ZXJzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5JTlRFTlRTXTogU2VhcmNoSW50ZW50cy5mcm9tKHJlc3BvbnNlLnNlYXJjaEludGVudHMpLFxuICAgICAgW1N0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLXTogU3BlbGxDaGVjay5mcm9tKHJlc3BvbnNlLnNwZWxsQ2hlY2spLFxuICAgICAgW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdOiBMb2NhdGlvbkJpYXMuZnJvbShyZXNwb25zZS5sb2NhdGlvbkJpYXMpXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFuc2Zvcm1WZXJ0aWNhbCAoZGF0YSwgZm9ybWF0dGVycykge1xuICAgIHJldHVybiB7XG4gICAgICBbU3RvcmFnZUtleXMuUVVFUllfSURdOiBkYXRhLnJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBbU3RvcmFnZUtleXMuTkFWSUdBVElPTl06IG5ldyBOYXZpZ2F0aW9uKCksIC8vIFZlcnRpY2FsIGRvZXNuJ3QgcmVzcG9uZCB3aXRoIG9yZGVyaW5nLCBzbyB1c2UgZW1wdHkgbmF2LlxuICAgICAgW1N0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFNdOiBWZXJ0aWNhbFJlc3VsdHMuZnJvbShkYXRhLnJlc3BvbnNlLCBmb3JtYXR0ZXJzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdOiBEeW5hbWljRmlsdGVycy5mcm9tKGRhdGEucmVzcG9uc2UpLFxuICAgICAgW1N0b3JhZ2VLZXlzLklOVEVOVFNdOiBTZWFyY2hJbnRlbnRzLmZyb20oZGF0YS5yZXNwb25zZS5zZWFyY2hJbnRlbnRzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS106IFNwZWxsQ2hlY2suZnJvbShkYXRhLnJlc3BvbnNlLnNwZWxsQ2hlY2spLFxuICAgICAgW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdOiBMb2NhdGlvbkJpYXMuZnJvbShkYXRhLnJlc3BvbnNlLmxvY2F0aW9uQmlhcylcbiAgICB9O1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBRdWVzdGlvblN1Ym1pc3Npb24gKi9cblxuLyoqXG4gKiBRdWVzdGlvblN1Ym1pc3Npb24gaXMgdGhlIGNvcmUgc3RhdGUgbW9kZWxcbiAqIHRvIHBvd2VyIHRoZSBRdWVzdGlvblN1Ym1pc3Npb24gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXN0aW9uU3VibWlzc2lvbiB7XG4gIGNvbnN0cnVjdG9yIChxdWVzdGlvbiA9IHt9LCBlcnJvcnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aG9yIG9mIHRoZSBxdWVzdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gcXVlc3Rpb24ubmFtZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHF1ZXN0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmVtYWlsID0gcXVlc3Rpb24uZW1haWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHByaXZhY3kgcG9saWN5IHdhcyBhcHByb3ZlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucHJpdmFjeVBvbGljeSA9IHF1ZXN0aW9uLnByaXZhY3lQb2xpY3kgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVzdGlvbiB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucXVlc3Rpb25UZXh0ID0gcXVlc3Rpb24ucXVlc3Rpb25UZXh0IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSBxdWVzdGlvbiBtZXRhIGluZm9ybWF0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uRGVzY3JpcHRpb24gPSBxdWVzdGlvbi5xdWVzdGlvbkRlc2NyaXB0aW9uIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBmb3JtIGlzIGV4cGFuZGVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uRXhwYW5kZWQgPSB0eXBlb2YgcXVlc3Rpb24uZXhwYW5kZWQgIT09ICdib29sZWFuJyB8fCBxdWVzdGlvbi5leHBhbmRlZDtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIGFueSBlcnJvcnMgYWJvdXQgdGhlIHF1ZXN0aW9uIHN1Ym1pc3Npb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBmb3JtIGhhcyBiZWVuIHN1Ym1pdHRlZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqL1xuICAgIHRoaXMucXVlc3Rpb25TdWJtaXR0ZWQgPSBxdWVzdGlvbi5zdWJtaXR0ZWQgfHwgZmFsc2U7XG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHN1Ym1pdHRlZCAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXN0aW9uU3VibWl0dGVkOiB0cnVlLFxuICAgICAgcXVlc3Rpb25FeHBhbmRlZDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZXJyb3JzIChxdWVzdGlvbiwgZXJyb3JzKSB7XG4gICAgcmV0dXJuIFF1ZXN0aW9uU3VibWlzc2lvbihxdWVzdGlvbiwgZXJyb3JzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRmlsdGVyICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhcGkgZmlsdGVyIGFuZCBwcm92aWRlcyBzdGF0aWMgbWV0aG9kcyBmb3IgZWFzaWx5IGNvbnN0cnVjdGluZyBGaWx0ZXJzLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLnlleHQuY29tL2RvY3MvYXBpLXJlZmVyZW5jZS8jb3BlcmF0aW9uL2xpc3RFbnRpdGllcyBmb3Igc3RydWN0dXJlIGRldGFpbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGF0YSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIEpTT04gZm9ybWF0IGZpbHRlciByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgaW50byBhIEZpbHRlclxuICAgKiBAcGFyYW0geyp9IHJlc3BvbnNlRmlsdGVyIEEgZmlsdGVyIGluIEpTT04gZm9ybWF0IHJldHVybmVkIGZyb20gdGhlIGJhY2tlbmRcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBmcm9tUmVzcG9uc2UgKHJlc3BvbnNlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoSlNPTi5wYXJzZShyZXNwb25zZUZpbHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBGaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSBPUiBvZiBhbGwgcHJvdmlkZWQgZmlsdGVyc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gT1IgdG9nZXRoZXJcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBvciAoLi4uZmlsdGVycykge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgICckb3InOiBmaWx0ZXJzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IEZpbHRlciByZXByZXNlbnRpbmcgdGhlIEFORCBvZiBhbGwgcHJvdmlkZWQgZmlsdGVyc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gQU5EIHRvZ2V0aGVyXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgYW5kICguLi5maWx0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoe1xuICAgICAgJyRhbmQnOiBmaWx0ZXJzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT1IgZmlsdGVycyB3aXRoIHRoZSBzYW1lIGtleXMsIHRoZW4gQU5EIHRoZSByZXN1bHRpbmcgZ3JvdXBzXG4gICAqIEBwYXJhbSAgey4uLkZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBncm91cFxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGdyb3VwICguLi5maWx0ZXJzKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMoZmlsdGVyKVswXTtcbiAgICAgIGlmICghZ3JvdXBzW2tleV0pIHtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1trZXldLnB1c2goZmlsdGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBncm91cEZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC5rZXlzKGdyb3VwcykpIHtcbiAgICAgIGdyb3VwRmlsdGVycy5wdXNoKGdyb3Vwc1tmaWVsZF0ubGVuZ3RoID4gMSA/IEZpbHRlci5vciguLi5ncm91cHNbZmllbGRdKSA6IGdyb3Vwc1tmaWVsZF1bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cEZpbHRlcnMubGVuZ3RoID4gMSA/IEZpbHRlci5hbmQoLi4uZ3JvdXBGaWx0ZXJzKSA6IGdyb3VwRmlsdGVyc1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJlcXVhbCB0b1wiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGVxdWFsIHRvXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZXF1YWwgKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGVxJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImxlc3MgdGhhblwiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGxlc3MgdGhhblxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGxlc3NUaGFuIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRsdCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBsZXNzVGhhbkVxdWFsIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJncmVhdGVyIHRoYW5cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBncmVhdGVyIHRoYW5cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBncmVhdGVyVGhhbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckZ3QnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ3JlYXRlclRoYW5FcXVhbCAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckZ2UnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluY2x1c2l2ZSByYW5nZSBmaWx0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSBtaW4gVGhlIG1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBtYXggVGhlIG1heGltdW0gdmFsdWVcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBpbmNsdXNpdmVSYW5nZSAoZmllbGQsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoe1xuICAgICAgW2ZpZWxkXToge1xuICAgICAgICAnJGdlJzogbWluLFxuICAgICAgICAnJGxlJzogbWF4XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGV4Y2x1c2l2ZSByYW5nZSBmaWx0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSBtaW4gVGhlIG1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBtYXggVGhlIG1heGltdW0gdmFsdWVcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBleGNsdXNpdmVSYW5nZSAoZmllbGQsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoe1xuICAgICAgW2ZpZWxkXToge1xuICAgICAgICAnJGd0JzogbWluLFxuICAgICAgICAnJGx0JzogbWF4XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHBvc2l0aW9uIGZpbHRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGF0IFRoZSBsYXRpdHVkZSBvZiB0aGUgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxuZyBUaGUgbG9uZ2l0dWRlIG9mIHRoZSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzZWFyY2ggcmFkaXVzIChpbiBtZXRlcnMpXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb24gKGxhdCwgbG5nLCByYWRpdXMpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcignYnVpbHRpbi5sb2NhdGlvbicsICckbmVhcicsIHsgbGF0LCBsbmcsIHJhZGl1cyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZmlsdGVyIHdpdGggdGhlIGdpdmVuIG1hdGNoZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoZXIgVGhlIG1hdGNoZXIgZm9yIHRoZSBmaWxlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIGZpbHRlclxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIF9mcm9tTWF0Y2hlciAoZmllbGQsIG1hdGNoZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoe1xuICAgICAgW2ZpZWxkXToge1xuICAgICAgICBbbWF0Y2hlcl06IHZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIENvcmUgKi9cblxuaW1wb3J0IFNlYXJjaERhdGFUcmFuc2Zvcm1lciBmcm9tICcuL3NlYXJjaC9zZWFyY2hkYXRhdHJhbnNmb3JtZXInO1xuXG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBWZXJ0aWNhbFJlc3VsdHMgZnJvbSAnLi9tb2RlbHMvdmVydGljYWxyZXN1bHRzJztcbmltcG9ydCBVbml2ZXJzYWxSZXN1bHRzIGZyb20gJy4vbW9kZWxzL3VuaXZlcnNhbHJlc3VsdHMnO1xuaW1wb3J0IFF1ZXN0aW9uU3VibWlzc2lvbiBmcm9tICcuL21vZGVscy9xdWVzdGlvbnN1Ym1pc3Npb24nO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL21vZGVscy9maWx0ZXInO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zZXJ2aWNlcy9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2VydmljZXMvYXV0b2NvbXBsZXRlc2VydmljZScpLmRlZmF1bHR9IEF1dG9Db21wbGV0ZVNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlcnZpY2VzL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKipcbiAqIENvcmUgaXMgdGhlIG1haW4gYXBwbGljYXRpb24gY29udGFpbmVyIGZvciBhbGwgb2YgdGhlIG5ldHdvcmsgYW5kIHN0b3JhZ2VcbiAqIHJlbGF0ZWQgYmVoYXZpb3JzIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZSB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGllbnQgQVBJIEtleSB1c2VkIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGllbnQgQW5zd2VycyBLZXkgdXNlZCBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2V4cGVyaWVuY2VLZXkgPSBjb25maWcuZXhwZXJpZW5jZUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbnN3ZXJzIGNvbmZpZyB2ZXJzaW9uIHRvIHVzZSBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uID0gY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNsaWVudCBsb2NhbGUgdXNlZCBmb3IgYWxsIHJlcXVlc3RzLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBcImVuXCIgKGZvclxuICAgICAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbG9jYWxlID0gY29uZmlnLmxvY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGZpZWxkIGZvcm1hdHRlcnMgdXNlZCB0byBmb3JtYXQgcmVzdWx0cywgaWYgcHJlc2VudFxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGRGb3JtYXR0ZXJzID0gY29uZmlnLmZpZWxkRm9ybWF0dGVycyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIGRhdGEgc3RvcmFnZSB0aGF0IHBvd2VycyB0aGUgVUlcbiAgICAgKiBAdHlwZSB7R2xvYmFsU3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZSA9IGNvbmZpZy5nbG9iYWxTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICogQHR5cGUge1BlcnNpc3RlbnRTdG9yYWdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wZXJzaXN0ZW50U3RvcmFnZSA9IGNvbmZpZy5wZXJzaXN0ZW50U3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFic3RyYWN0aW9uIGNvbnRhaW5pbmcgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIFJFU1RmdWwgc2VhcmNoIEFQSVxuICAgICAqIEZvciBib3RoIHZlcnRpY2FsIGFuZCB1bml2ZXJzYWwgc2VhcmNoXG4gICAgICogQHR5cGUge1NlYXJjaFNlcnZpY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hlciA9IGNvbmZpZy5zZWFyY2hTZXJ2aWNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWJzdHJhY3Rpb24gY29udGFpbmluZyB0aGUgaW50ZWdyYXRpb24gd2l0aCB0aGUgUkVTVGZ1bCBhdXRvY29tcGxldGUgQVBJXG4gICAgICogRm9yIGZpbHRlciBzZWFyY2gsIHZlcnRpY2FsIGF1dG9jb21wbGV0ZSwgYW5kIHVuaXZlcnNhbCBhdXRvY29tcGxldGVcbiAgICAgKiBAdHlwZSB7QXV0b0NvbXBsZXRlU2VydmljZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9Db21wbGV0ZSA9IGNvbmZpZy5hdXRvQ29tcGxldGVTZXJ2aWNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWJzdHJhY3Rpb24gZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFEmQSByZXN0IGludGVyZmFjZVxuICAgICAqIEB0eXBlIHtRdWVzdGlvbkFuc3dlclNlcnZpY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9xdWVzdGlvbkFuc3dlciA9IGNvbmZpZy5xdWVzdGlvbkFuc3dlclNlcnZpY2U7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGluIHRoZSBjb250ZXh0IG9mIGEgdmVydGljYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsS2V5IHZlcnRpY2FsIElEIGZvciB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSBUaGUgcXVlcnkgZGV0YWlsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkuaW5wdXQgVGhlIGlucHV0IHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmZpbHRlciBUaGUgZmlsdGVyIHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeS5mYWNldEZpbHRlciBUaGUgZmFjZXQgZmlsdGVyIHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxdWVyeS5saW1pdCBUaGUgbWF4IG51bWJlciBvZiByZXN1bHRzIHRvIGluY2x1ZGUsIG1heCBvZiA1MFxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVlcnkub2Zmc2V0IFRoZSByZXN1bHRzIG9mZnNldCwgZm9yIGZldGNoaW5nIG1vcmUgcmVzdWx0cyBvZiB0aGUgc2FtZSBxdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkuaWQgVGhlIHF1ZXJ5IElEIHRvIHVzZS4gSWYgcGFnaW5nIHdpdGhpbiBhIHF1ZXJ5LCB0aGUgc2FtZSBJRCBzaG91bGQgYmUgdXNlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1ZXJ5LmFwcGVuZCBJZiB0cnVlLCBhZGRzIHRoZSByZXN1bHRzIG9mIHRoaXMgcXVlcnkgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZXN1bHRzLCBkZWZhdWx0cyBmYWxzZVxuICAgKi9cbiAgdmVydGljYWxTZWFyY2ggKHZlcnRpY2FsS2V5LCBxdWVyeSkge1xuICAgIGlmICghcXVlcnkuYXBwZW5kKSB7XG4gICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIFZlcnRpY2FsUmVzdWx0cy5zZWFyY2hMb2FkaW5nKCkpO1xuICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TUEVMTF9DSEVDSywge30pO1xuICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaGVyXG4gICAgICAudmVydGljYWxTZWFyY2godmVydGljYWxLZXksIHtcbiAgICAgICAgbGltaXQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHKS5saW1pdCxcbiAgICAgICAgZ2VvbG9jYXRpb246IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiksXG4gICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICBpc0R5bmFtaWNGaWx0ZXJzRW5hYmxlZDogdGhpcy5faXNEeW5hbWljRmlsdGVyc0VuYWJsZWQsXG4gICAgICAgIHNraXBTcGVsbENoZWNrOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3NraXBTcGVsbENoZWNrJyksXG4gICAgICAgIHF1ZXJ5VHJpZ2dlcjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdxdWVyeVRyaWdnZXInKSxcbiAgICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTiksXG4gICAgICAgIHNvcnRCeXM6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TT1JUX0JZUylcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBTZWFyY2hEYXRhVHJhbnNmb3JtZXIudHJhbnNmb3JtVmVydGljYWwocmVzcG9uc2UsIHRoaXMuX2ZpZWxkRm9ybWF0dGVycykpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWV9JRCwgZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV9JRF0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLk5BVklHQVRJT04sIGRhdGFbU3RvcmFnZUtleXMuTkFWSUdBVElPTl0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLklOVEVOVFMsIGRhdGFbU3RvcmFnZUtleXMuSU5URU5UU10pO1xuXG4gICAgICAgIGlmIChxdWVyeS5hcHBlbmQpIHtcbiAgICAgICAgICBjb25zdCBtZXJnZWRSZXN1bHRzID0gdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMpXG4gICAgICAgICAgICAuYXBwZW5kKGRhdGFbU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUU10pO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgbWVyZ2VkUmVzdWx0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTLCBkYXRhW1N0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhW1N0b3JhZ2VLZXlzLkRZTkFNSUNfRklMVEVSU10pIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkRZTkFNSUNfRklMVEVSUywgZGF0YVtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS10pIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCBkYXRhW1N0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbU3RvcmFnZUtleXMuTE9DQVRJT05fQklBU10pIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVMsIGRhdGFbU3RvcmFnZUtleXMuTE9DQVRJT05fQklBU10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3NraXBTcGVsbENoZWNrJyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3F1ZXJ5VHJpZ2dlcicpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFnZSB3aXRoaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgcXVlcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnRpY2FsS2V5IFRoZSB2ZXJ0aWNhbCBrZXkgdG8gdXNlIGluIHRoZSBzZWFyY2hcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqL1xuICB2ZXJ0aWNhbFBhZ2UgKHZlcnRpY2FsS2V5LCBvZmZzZXQpIHtcbiAgICBjb25zdCBhbGxGaWx0ZXJzID0gdGhpcy5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgIDogYWxsRmlsdGVyc1swXTtcbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcbiAgICB0aGlzLnZlcnRpY2FsU2VhcmNoKHZlcnRpY2FsS2V5LCB7XG4gICAgICBpbnB1dDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSxcbiAgICAgIGlkOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUllfSUQpLFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpLFxuICAgICAgb2Zmc2V0XG4gICAgfSk7XG4gIH1cblxuICBzZWFyY2ggKHF1ZXJ5U3RyaW5nLCB1cmxzKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSLCB7fSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUUywgVW5pdmVyc2FsUmVzdWx0cy5zZWFyY2hMb2FkaW5nKCkpO1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFU1RJT05fU1VCTUlTU0lPTiwge30pO1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0ssIHt9KTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVMsIHt9KTtcblxuICAgIHJldHVybiB0aGlzLl9zZWFyY2hlclxuICAgICAgLnVuaXZlcnNhbFNlYXJjaChxdWVyeVN0cmluZywge1xuICAgICAgICBnZW9sb2NhdGlvbjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OKSxcbiAgICAgICAgc2tpcFNwZWxsQ2hlY2s6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSgnc2tpcFNwZWxsQ2hlY2snKSxcbiAgICAgICAgcXVlcnlUcmlnZ2VyOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3F1ZXJ5VHJpZ2dlcicpLFxuICAgICAgICBzZXNzaW9uVHJhY2tpbmdFbmFibGVkOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VTU0lPTlNfT1BUX0lOKVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IFNlYXJjaERhdGFUcmFuc2Zvcm1lci50cmFuc2Zvcm0ocmVzcG9uc2UsIHVybHMsIHRoaXMuX2ZpZWxkRm9ybWF0dGVycykpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWV9JRCwgZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV9JRF0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLk5BVklHQVRJT04sIGRhdGFbU3RvcmFnZUtleXMuTkFWSUdBVElPTl0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVIsIGRhdGFbU3RvcmFnZUtleXMuRElSRUNUX0FOU1dFUl0pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlVOSVZFUlNBTF9SRVNVTFRTLCBkYXRhW1N0b3JhZ2VLZXlzLlVOSVZFUlNBTF9SRVNVTFRTXSwgdXJscyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuSU5URU5UUywgZGF0YVtTdG9yYWdlS2V5cy5JTlRFTlRTXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0ssIGRhdGFbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCBkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLmRlbGV0ZSgnc2tpcFNwZWxsQ2hlY2snKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLmRlbGV0ZSgncXVlcnlUcmlnZ2VyJyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBpbnB1dCwgcXVlcnkgZm9yIGEgbGlzdCBvZiBzaW1pbGFyIHJlc3VsdHMgYW5kIHNldCBpbnRvIHN0b3JhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICAgICB0aGUgc3RyaW5nIHRvIGF1dG9jb21wbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIHRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgc3RvcmFnZSBrZXlcbiAgICovXG4gIGF1dG9Db21wbGV0ZVVuaXZlcnNhbCAoaW5wdXQsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvQ29tcGxldGVcbiAgICAgIC5xdWVyeVVuaXZlcnNhbChpbnB1dClcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHtuYW1lc3BhY2V9YCwgZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHF1ZXJ5IGZvciBhIGxpc3Qgb2Ygc2ltaWxhciByZXN1bHRzIGluIHRoZSBwcm92aWRlZCB2ZXJ0aWNhbFxuICAgKiBhbmQgc2V0IGludG8gc3RvcmFnZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgICAgICAgdGhlIHN0cmluZyB0byBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSB0aGUgdmVydGljYWwga2V5IGZvciB0aGUgZXhwZXJpZW5jZVxuICAgKi9cbiAgYXV0b0NvbXBsZXRlVmVydGljYWwgKGlucHV0LCBuYW1lc3BhY2UsIHZlcnRpY2FsS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9Db21wbGV0ZVxuICAgICAgLnF1ZXJ5VmVydGljYWwoaW5wdXQsIHZlcnRpY2FsS2V5KVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuQVVUT0NPTVBMRVRFfS4ke25hbWVzcGFjZX1gLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBpbnB1dCwgcHJvdmlkZSBhIGxpc3Qgb2Ygc3VpdGFibGUgZmlsdGVycyBmb3IgYXV0b2NvbXBsZXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICB0aGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IgZmlsdGVycyB3aXRoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgIHRoZSBjb25maWcgdG8gc2VyYWNoIGZvciBmaWx0ZXJzIHdpdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5uYW1lc3BhY2UgIHRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgc3RvcmFnZSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy52ZXJ0aWNhbEtleSB0aGUgdmVydGljYWwga2V5IGZvciB0aGUgY29uZmlnXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcuc2VhcmNoUGFyYW1ldGVycyAgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIGZvciB0aGUgY29uZmlnIHYyXG4gICAqL1xuICBhdXRvQ29tcGxldGVGaWx0ZXIgKGlucHV0LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlXG4gICAgICAucXVlcnlGaWx0ZXIoaW5wdXQsIGNvbmZpZylcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHtjb25maWcubmFtZXNwYWNlfWAsIGRhdGEpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHF1ZXN0aW9uIHRvIHRoZSBzZXJ2ZXIgYW5kIHVwZGF0ZXMgdGhlIHVuZGVybHlpbmcgcXVlc3Rpb24gbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXN0aW9uIFRoZSBxdWVzdGlvbiBvYmplY3QgdG8gc3VibWl0IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1ZXN0aW9uLmVudGl0eUlkIFRoZSBlbnRpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHF1ZXN0aW9uIChyZXF1aXJlZClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLmxhbnVhZ2UgVGhlIGxhbmd1YWdlIG9mIHRoZSBxdWVzdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24uc2l0ZSBUaGUgXCJwdWJsaXNoZXJcIiBvZiB0aGUgKGUuZy4gJ0ZJUlNUX1BBUlRZJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLm5hbWUgVGhlIG5hbWUgb2YgdGhlIGF1dGhvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24uZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIGF1dGhvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24ucXVlc3Rpb25UZXh0IFRoZSBxdWVzdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24ucXVlc3Rpb25EZXNjcmlwdGlvbiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBxdWVzdGlvblxuICAgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXN0aW9uQW5zd2VyXG4gICAgICAuc3VibWl0UXVlc3Rpb24ocXVlc3Rpb24pXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChcbiAgICAgICAgICBTdG9yYWdlS2V5cy5RVUVTVElPTl9TVUJNSVNTSU9OLFxuICAgICAgICAgIFF1ZXN0aW9uU3VibWlzc2lvbi5zdWJtaXR0ZWQoKSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIHNvcnRCeSBpbnRvIHN0b3JhZ2UsIHRvIGJlIHVzZWQgZm9yIHRoZSBuZXh0IHNlYXJjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gc29ydEJ5T3B0aW9uc1xuICAgKi9cbiAgc2V0U29ydEJ5cyAoLi4uc29ydEJ5T3B0aW9ucykge1xuICAgIGNvbnN0IHNvcnRCeXMgPSBzb3J0QnlPcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogb3B0aW9uLnR5cGUsXG4gICAgICAgIGZpZWxkOiBvcHRpb24uZmllbGQsXG4gICAgICAgIGRpcmVjdGlvbjogb3B0aW9uLmRpcmVjdGlvblxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNPUlRfQllTLCBKU09OLnN0cmluZ2lmeShzb3J0QnlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBzb3J0QnlzIGtleSBpbiBnbG9iYWwgc3RvcmFnZS5cbiAgICovXG4gIGNsZWFyU29ydEJ5cyAoKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TT1JUX0JZUyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBxdWVyeSBpbnRvIHN0b3JhZ2UsIHRvIGJlIHVzZWQgZm9yIHRoZSBuZXh0IHNlYXJjaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHF1ZXJ5IHRvIHN0b3JlXG4gICAqL1xuICBzZXRRdWVyeSAocXVlcnkpIHtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCBxdWVyeSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBwcm92aWRlZCBxdWVyeSBJRCwgdG8gYmUgdXNlZCBpbiBhbmFseXRpY3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5SWQgVGhlIHF1ZXJ5IGlkIHRvIHN0b3JlXG4gICAqL1xuICBzZXRRdWVyeUlkIChxdWVyeUlkKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5RVUVSWV9JRCwgcXVlcnlJZCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiBmaWx0ZXIgaW50byBzdG9yYWdlLCB0byBiZSB1c2VkIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXIgICAgdGhlIGZpbHRlciB0byBzZXRcbiAgICovXG4gIHNldEZpbHRlciAobmFtZXNwYWNlLCBmaWx0ZXIpIHtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHtuYW1lc3BhY2V9YCwgZmlsdGVyKTtcbiAgfVxuXG4gIHNldEZhY2V0RmlsdGVyIChuYW1lc3BhY2UsIGZpbHRlcikge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuRkFDRVRfRklMVEVSfS4ke25hbWVzcGFjZX1gLCBmaWx0ZXIpO1xuICB9XG5cbiAgZW5hYmxlRHluYW1pY0ZpbHRlcnMgKCkge1xuICAgIHRoaXMuX2lzRHluYW1pY0ZpbHRlcnNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIG9uIChldnQsIG1vZHVsZUlkLCBjYikge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbFN0b3JhZ2Uub24oZXZ0LCBtb2R1bGVJZCwgY2IpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBET00gKi9cblxuLyogZ2xvYmFsIEhUTUxFbGVtZW50LCBIVE1MRG9jdW1lbnQsIFdpbmRvdywgRXZlbnQgKi9cblxubGV0IGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4vKipcbiAqIFN0YXRpYyBpbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIERPTSBBUEkuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERPTSB7XG4gIHN0YXRpYyBzZXR1cCAoZCwgcCkge1xuICAgIGRvY3VtZW50ID0gZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBIVE1MRWxlbWVudCBmcm9tIGFuZCBIVE1MIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgSFRNTCB0byBwYXJzZSB0byBhIERPTSBub2RlLlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUgKGh0bWwpIHtcbiAgICBpZiAoJ2NyZWF0ZVJhbmdlJyBpbiBkb2N1bWVudCkge1xuICAgICAgLy8gcHJlZmVyIHRoaXMgaW1wbGVtZW50YXRpb24gYXMgaXQgaGFzIHdpZGVyIGJyb3dzZXIgc3VwcG9ydFxuICAgICAgLy8gYW5kIGl0J3MgYmV0dGVyIHBlcmZvcm1pbmcuXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvY29udmVydC1odG1sLXN0aW5ncy1kb20tbm9kZXNcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGh0bWwpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayB0byB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4ganNkb20gdGhhdCBjYXVzZXMgdGVzdHMgdG8gZmFpbFxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pzZG9tL2pzZG9tL2lzc3Vlcy8zOTlcbiAgICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCAndGV4dC9odG1sJykuYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBxdWVyeSB0aGUgRE9NIGZvciBhIGdpdmVuIGNzcyBzZWxlY3RvclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgT3B0aW9uYWwgY29udGV4dCB0byB1c2UgZm9yIGEgc2VhcmNoLiBEZWZhdWx0cyB0byBkb2N1bWVudCBpZiBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciB0aGUgQ1NTIHNlbGVjdG9yIHRvIHF1ZXJ5IGZvclxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRoZSBGSVJTVCBub2RlIGl0IGZpbmRzLCBpZiBhbnlcbiAgICovXG4gIHN0YXRpYyBxdWVyeSAocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIC8vIEZhY2FkZSwgc2hpZnRpbmcgdGhlIHNlbGVjdG9yIHRvIHRoZSBwYXJlbnQgYXJndW1lbnQgaWYgb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCBpcyBwcm92aWRlZFxuICAgIGlmIChzZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWxlY3RvciA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgV2luZG93IHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgSFRNTERvY3VtZW50KSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBxdWVyeSB0aGUgRE9NIGZvciBhIGdpdmVuIGNzcyBzZWxlY3RvclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgT3B0aW9uYWwgY29udGV4dCB0byB1c2UgZm9yIGEgc2VhcmNoLiBEZWZhdWx0cyB0byBkb2N1bWVudCBpZiBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciB0aGUgQ1NTIHNlbGVjdG9yIHRvIHF1ZXJ5IGZvclxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBGSVJTVCBub2RlIGl0IGZpbmRzLCBpZiBhbnlcbiAgICovXG4gIHN0YXRpYyBxdWVyeUFsbCAocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIC8vIEZhY2FkZSwgc2hpZnRpbmcgdGhlIHNlbGVjdG9yIHRvIHRoZSBwYXJlbnQgYXJndW1lbnQgaWYgb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCBpcyBwcm92aWRlZFxuICAgIGlmIChzZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWxlY3RvciA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50O1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBjbGllbnQgY29kZSBpcyB1c2luZyBhIHBvaW50ZXIgdG8gYSBkb20gbm9kZSBhbmQgaXQncyBudWxsLCBlLmcuIHRoaXMuX2NvbnRhaW5lclxuICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgc2VsZWN0b3IgaW5zdGFuY2VvZiBIVE1MRG9jdW1lbnQgfHwgc2VsZWN0b3IgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgIHJldHVybiBbc2VsZWN0b3JdO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gIH1cblxuICBzdGF0aWMgb25SZWFkeSAoY2IpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XG4gICAgICBjYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIERPTS5vbihkb2N1bWVudCwgJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlRWxlIHdpbGwgY3JlYXRlIGEge0hUTUxFbGVtZW50fSBhbmQgYXBwbHkgdGhlIHByb3BlcnRpZXMgYXR0cmlidXRlcyB0aHJvdWdoIGFuIG9iamVjdCBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsIFRoZSBlbGVtZW50IGB0YWdgIG5hbWUgdG8gY29uc3RydWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzX2RhdGEgT3B0aW9uYWwgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgbmV3IEhUTUxFbGVtZW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRWwgKGVsLCBvcHRzX2RhdGEgPSB7fSkge1xuICAgIGxldCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbCk7XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmtleXMob3B0c19kYXRhKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wc1tpXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBET00uYWRkQ2xhc3Mobm9kZSwgb3B0c19kYXRhW3Byb3BzW2ldXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlW3Byb3BzW2ldXSA9IG9wdHNfZGF0YVtwcm9wc1tpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBzdGF0aWMgYXBwZW5kIChwYXJlbnQsIG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJlbnQgPSBET00ucXVlcnkocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IEhUTUwgaW5qZWN0aW9uIGFzIHdlbGwgYXMgSFRNTEVsZW1lbnQgYXBwZW5kc1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyQmVnaW4nLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhZGRDbGFzcyAobm9kZSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJywnKTtcbiAgICBsZXQgbGVuID0gY2xhc3Nlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGVtcHR5IChwYXJlbnQpIHtcbiAgICBwYXJlbnQuaW5uZXJIVE1MID0gJyc7XG4gIH1cblxuICBzdGF0aWMgY3NzIChzZWxlY3Rvciwgc3R5bGVzKSB7XG4gICAgbGV0IG5vZGUgPSBET00ucXVlcnkoc2VsZWN0b3IpO1xuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdHlsZXMpIHtcbiAgICAgIG5vZGUuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGF0dHIgKHNlbGVjdG9yLCBhdHRyLCB2YWwpIHtcbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpO1xuICB9XG5cbiAgc3RhdGljIGF0dHJpYnV0ZXMgKHNlbGVjdG9yLCBhdHRycykge1xuICAgIE9iamVjdC5lbnRyaWVzKGF0dHJzKVxuICAgICAgLmZvckVhY2goKFthdHRyLCB2YWxdKSA9PiB0aGlzLmF0dHIoc2VsZWN0b3IsIGF0dHIsIHZhbCkpO1xuICB9XG5cbiAgc3RhdGljIHRyaWdnZXIgKHNlbGVjdG9yLCBldmVudCwgc2V0dGluZ3MpIHtcbiAgICBsZXQgZSA9IG5ldyBFdmVudChldmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAnYnViYmxlcyc6IHRydWUsXG4gICAgICAnY2FuY2VsYWJsZSc6IHRydWVcbiAgICB9LCBzZXR0aW5ncyB8fCB7fSkpO1xuXG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgc3RhdGljIG9uIChzZWxlY3RvciwgZXZ0LCBoYW5kbGVyKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcik7XG4gIH1cblxuICBzdGF0aWMgb25jZSAoc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIERPTS5xdWVyeShzZWxlY3RvcikuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHN0YXRpYyBvZmYgKHNlbGVjdG9yLCBldnQsIGhhbmRsZXIpIHtcbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWxlZ2F0ZSAoY3R4dCwgc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIGxldCBlbCA9IERPTS5xdWVyeShjdHh0KTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgd2hpbGUgKCF0YXJnZXQuaXNFcXVhbE5vZGUoZWwpKSB7XG4gICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICBoYW5kbGVyKGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hQYXJhbXMgKi9cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG4vKipcbiAqIFNlYXJjaFBhcmFtcyBpcyBhIGNsYXNzIHRvIGdldCB0aGUgc2VhcmNoIHBhcmFtcyBpbiBhIFVSTC5cbiAqIEl0IGlzIGEgcmVwbGFjZW1lbnQgZm9yIFVSTC5zZWFyY2hQYXJhbXMgYW5kIFVSTFNlYXJjaFBhcmFtcyBmb3IgYnJvd3NlcnMgbGlrZSBJRTExXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0cnVjdG9yICh1cmwpIHtcbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIG9mIGFsbCBxdWVyeSBwYXJhbWV0ZXJzIGluIHRoZSBnaXZlbiB1cmwsIHF1ZXJ5IHBhcmFtIC0+IHZhbHVlXG4gICAgICogT25seSB1c2VkIGlmIFVSTFNlYXJjaFBhcmFtcyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd2luZG93XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJhbXMgPSB0aGlzLnBhcnNlKHVybCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIGNyZWF0ZXMgYSBtYXBwaW5nIG9mIGFsbCBxdWVyeSBwYXJhbXMgaW4gYSBnaXZlbiB1cmxcbiAgICogVGhlIHF1ZXJ5IHBhcmFtIHZhbHVlcyBhcmUgZGVjb2RlZCBiZWZvcmUgYmVpbmcgcHV0IGluIHRoZSBtYXBcbiAgICogVGhyZWUgdHlwZXMgb2YgaW5wdXQgYXJlIHN1cHBvcnRlZFxuICAgKiAgICgxKSBmdWxsIFVSTCBlLmcuIGh0dHA6Ly93d3cueWV4dC5jb20vP3E9aGVsbG9cbiAgICogICAoMikgcGFyYW1zIHdpdGggPyBlLmcuID9xPWhlbGxvXG4gICAqICAgKDEpIHBhcmFtcyB3aXRob3V0ID8gZS5nLiBxPWhlbGxvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtYXBwaW5nIGZyb20gcXVlcnkgcGFyYW0gLT4gdmFsdWUgd2hlcmUgdmFsdWUgaXMgJycgaWYgbm8gdmFsdWUgaXMgcHJvdmlkZWRcbiAgICovXG4gIHBhcnNlICh1cmwpIHtcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgbGV0IHNlYXJjaCA9IHVybDtcblxuICAgIGlmIChzZWFyY2ggPT09ICcnKSB7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBhbGwgdXJsIGlucHV0cyB0byBzdHJpbmcgb2YgcXVlcnkgcGFyYW1zIHNlcGFyYXRlZCBieSAmXG4gICAgaWYgKHVybC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgc2VhcmNoID0gdXJsLnNsaWNlKHVybC5pbmRleE9mKCc/JykgKyAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmNvZGVkUGFyYW1zID0gc2VhcmNoLnNwbGl0KCcmJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkUGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlWYWwgPSBlbmNvZGVkUGFyYW1zW2ldLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAoa2V5VmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFyYW1zW2tleVZhbFswXV0gPSBTZWFyY2hQYXJhbXMuZGVjb2RlKGtleVZhbFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXNba2V5VmFsWzBdXSA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBxdWVyeSBwYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHF1ZXJ5IHBhcmFtIGtleSB0byBnZXQgdGhlIHZhbHVlIG9mXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcGFyYW0gdmFsdWUsIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBnZXQgKHF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wYXJhbXNbU3RyaW5nKHF1ZXJ5KV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtc1txdWVyeV07XG4gIH1cblxuICAvKipcbiAgICogc2V0IGNoYW5nZXMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gcXVlcnkgcGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHF1ZXJ5IHBhcmFtIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBxdWVyeSBwYXJhbSB1cGRhdGUgd2l0aFxuICAgKi9cbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX3BhcmFtc1tTdHJpbmcobmFtZSldID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoYXMgY2hlY2tzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gcXVlcnkgcGFyYW0ga2V5IGV4aXN0cyBpbiB0aGUgcGFyYW1zIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIHF1ZXJ5IHBhcmFtIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHF1ZXJ5IHBhcmFtIGlzIGluIHRoZSBwYXJhbXMgb2JqZWN0LCBmYWxzZSBvL3dcbiAgICovXG4gIGhhcyAocXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkgaW4gdGhpcy5fcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZSByZW1vdmVzIHRoZSBnaXZlbiBxdWVyeSBwYXJhbSBhbmQgaXRzIGFzc29jaWF0ZWQgdmFsdWUgZnJvbSB0aGUgcGFyYW1zIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcXVlcnkgcGFyYW0ga2V5XG4gICAqL1xuICBkZWxldGUgKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fcGFyYW1zW1N0cmluZyhuYW1lKV07XG4gIH1cblxuICAvKipcbiAgICogdG9TdHJpbmcgcmV0dXJucyBhIHVybCB3aXRoIGFsbCB0aGUgcXVlcnkgcGFyYW1zIGluIHRoZSBwYXJhbXMgb2JqZWN0ICh3aXRob3V0IGEgPylcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICBzdHJpbmcucHVzaChgJHtrZXl9PSR7U2VhcmNoUGFyYW1zLmVuY29kZSh0aGlzLl9wYXJhbXNba2V5XSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmcuam9pbignJicpO1xuICB9XG5cbiAgZW50cmllcyAoKSB7XG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICBlbnRyaWVzLnB1c2goW2tleSwgdGhpcy5fcGFyYW1zW2tleV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICAvKipcbiAgICogZGVjb2RlIHJldHVybnMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgdG8gZGVjb2RlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKHN0cmluZykge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyaW5nLnJlcGxhY2UoL1sgK10vZywgJyUyMCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGUgcmV0dXJucyB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nIChlLmcuICsgLT4gJTJCKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUgKHN0cmluZykge1xuICAgIGxldCByZXBsYWNlID0ge1xuICAgICAgJyEnOiAnJTIxJyxcbiAgICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAgICcoJzogJyUyOCcsXG4gICAgICAnKSc6ICclMjknLFxuICAgICAgJyUyMCc6ICcrJ1xuICAgIH07XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpLnJlcGxhY2UoL1shJygpXXwlMjAvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlbmRlcmVyICovXG5cbi8qKlxuICogUmVuZGVyZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBhbGwgUmVuZGVyZXJzIHNob3VsZCBleHRlbmQgYW5kIGltcGxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciB7XG4gIC8qKlxuICAgKiByZW5kZXIgaXMgYSBjb3JlIG1ldGhvZCBmb3IgYWxsIHJlbmRlcmVycy5cbiAgICogQWxsIGltcGxlbWVudGF0aW9ucyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICovXG4gIHJlbmRlciAodGVtcGxhdGUsIGRhdGEpIHtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICByZWdpc3RlckhlbHBlciAobmFtZSwgY2IpIHtcblxuICB9XG5cbiAgY29tcGlsZSAodGVtcGxhdGUpIHtcblxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIYW5kbGViYXJzUmVuZGVyZXIgKi9cblxuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXInO1xuXG4vKipcbiAqIEhhbmRsZWJhcnNSZW5kZXJlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmF0ZSBoYW5kbGViYXJzIHJlbmRlcmVyLlxuICogQGV4dGVuZHMgUmVuZGVyZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGFuZGxlYmFyc1JlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvciAodGVtcGxhdGVzID0ge30sIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgaGFuZGxlYmFycyBjb21waWxlclxuICAgICAqIEB0eXBlIHtIYW5kbGViYXJzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGFuZGxlYmFycyA9IHRlbXBsYXRlcy5faGIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBwcmUtY29tcGlsZWQgaGFuZGxlYmFycyB0ZW1wbGF0ZXNcbiAgICAgKiBAdHlwZSB7SGFuZGxlYmFyc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCB7fTtcbiAgfVxuXG4gIGluaXQgKHRlbXBsYXRlcykge1xuICAgIC8vIEFzc2lnbiB0aGUgaGFuZGxlYmFycyBjb21waWxlciBhbmQgdGVtcGxhdGVzIGJhc2VkIG9uXG4gICAgLy8gaW5mb3JtYXRpb24gcHJvdmlkZWQgZnJvbSBleHRlcm5hbCBkZXAgKGluIGRlZmF1bHQgY2FzZSwgaXQgY29tZXMgZnJvbSBleHRlcm5hbCBzZXJ2ZXIgcmVxdWVzdClcbiAgICB0aGlzLl9oYW5kbGViYXJzID0gdGVtcGxhdGVzLl9oYjtcbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG5cbiAgICAvLyBUT0RPKGJpbGx5KSBPbmNlIHdlIHJlLXdyaXRlIHRlbXBsYXRlcyB1c2luZyB0aGUgbmV3IGhlbHBlcnMgbGlicmFyeVxuICAgIC8vIHdlIHByb2JhYmx5IGRvbid0IG5lZWQgdGhlc2UgY3VzdG9tIGhlbHBlcnMgYW55bW9yZVxuICAgIHRoaXMuX3JlZ2lzdGVyQ3VzdG9tSGVscGVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVySGVscGVyIGlzIGEgcHVibGljIGludGVyZmFjZSBmb3IgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIHRvXG4gICAqIHJlZ2lzdGVyIHRoZWlyIG93biBjdXN0b20gaGVscGVycyB0byBvdXIgaW50ZXJuYWwgSGFuZGxlYmFycyBDb21waWxlclxuICAgKi9cbiAgcmVnaXN0ZXJIZWxwZXIgKG5hbWUsIGNiKSB7XG4gICAgdGhpcy5faGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogY29tcGlsZSBhIGhhbmRsZWJhcnMgdGVtcGxhdGUgc28gdGhhdCBpdCBjYW4gYmUgcmVuZGVyZWQsXG4gICAqIHVzaW5nIHRoZSB7SGFuZGxlYmFyc30gY29tcGlsZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBzdHJpbmcgdG8gY29tcGlsZVxuICAgKi9cbiAgY29tcGlsZSAodGVtcGxhdGUpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGFuZGxlYmFycy5jb21waWxlKHRlbXBsYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW5kZXIgd2lsbCByZW5kZXIgYSB0ZW1wbGF0ZSB3aXRoIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBQcm92aWRlIGVpdGhlciBhIHRlbXBsYXRlTmFtZSBvciBhIHByZS1jb21waWxlZCB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBwcm92aWRlIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVuZGVyIChjb25maWcsIGRhdGEpIHtcbiAgICAvLyBJZiBhIGN1c3RvbSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCwgdXNlIGl0LFxuICAgIC8vIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIHRlbXBsYXRlIG5hbWVcbiAgICAvLyBUT0RPKGJpbGx5KSBUaGlzIGludGVyZmFjZSBzaG91bGQgcHJvYmFibHkgYmUgbGVzcyB1Z2x5XG4gICAgaWYgKGNvbmZpZy50ZW1wbGF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy50ZW1wbGF0ZShkYXRhKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlc1tjb25maWcudGVtcGxhdGVOYW1lXShkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZmluZC9yZW5kZXIgdGVtcGxhdGU6ICcgKyBjb25maWcudGVtcGxhdGVOYW1lLCBlKTtcbiAgICB9XG4gIH1cblxuICBfcmVnaXN0ZXJDdXN0b21IZWxwZXJzICgpIHtcbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdpZmVxJywgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoYXJnMSA9PT0gYXJnMikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignaWZub3RlcScsIGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKGFyZzEgIT09IGFyZzIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2Zvcm1hdFBob25lTnVtYmVyJywgZnVuY3Rpb24gKHBob25lTnVtYmVyU3RyaW5nKSB7XG4gICAgICB2YXIgY2xlYW5lZCA9ICgnJyArIHBob25lTnVtYmVyU3RyaW5nKS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgdmFyIG1hdGNoID0gY2xlYW5lZC5tYXRjaCgvXigxfCk/KFxcZHszfSkoXFxkezN9KShcXGR7NH0pJC8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBpbnRsQ29kZSA9IChtYXRjaFsxXSA/ICcrMSAnIDogJycpO1xuICAgICAgICByZXR1cm4gW2ludGxDb2RlLCAnKCcsIG1hdGNoWzJdLCAnKSAnLCBtYXRjaFszXSwgJy0nLCBtYXRjaFs0XV0uam9pbignJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2Fzc2lnbicsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgbGV0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuZGF0YS5yb290KSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YS5yb290ID0ge307XG4gICAgICB9XG5cbiAgICAgIGxldCB2ID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHYgPSB2ICsgYXJnc1tpXTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5kYXRhLnJvb3RbbmFtZV0gPSB2O1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignanNvbicsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5hbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICcnXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkobmFtZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyJztcbmltcG9ydCBIYW5kbGViYXJzUmVuZGVyZXIgZnJvbSAnLi9oYW5kbGViYXJzcmVuZGVyZXInO1xuXG4vLyBJbiB0aGUgZnV0dXJlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgZGlmZmVyZW50IHR5cGVzIG9mIHJlbmRlcmVyc1xuLy8gRS5nLiBNdXN0YWNoZSwgU09ZLCBIYW5kbGVCYXJzLCBSZWFjdCwgZXRjLlxuZXhwb3J0IGNvbnN0IFJlbmRlcmVycyA9IHtcbiAgU09ZOiBSZW5kZXJlcixcbiAgSGFuZGxlYmFyczogSGFuZGxlYmFyc1JlbmRlcmVyXG59O1xuIiwiLyoqIEBtb2R1bGUgKi9cblxuLyoqIFRoZSBjdXJyZW50IGxpYiB2ZXJzaW9uLCByZXBvcnRlZCB3aXRoIGVycm9ycyBhbmQgYW5hbHl0aWNzICovXG5leHBvcnQgY29uc3QgTElCX1ZFUlNJT04gPSAndjAuMTIuMSc7XG5cbi8qKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCAqL1xuZXhwb3J0IGNvbnN0IFBST0RVQ1RJT04gPSAncHJvZHVjdGlvbic7XG5cbi8qKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgc2FuZGJveCBlbnZpcm9ubWVudCAqL1xuZXhwb3J0IGNvbnN0IFNBTkRCT1ggPSAnc2FuZGJveCc7XG5cbi8qKiBUaGUgZGVmYXVsdCB1cmwgZm9yIGNvbXBpbGVkIGNvbXBvbmVudCB0ZW1wbGF0ZXMgKi9cbmV4cG9ydCBjb25zdCBDT01QSUxFRF9URU1QTEFURVNfVVJMID0gYGh0dHBzOi8vYXNzZXRzLnNpdGVzY2RuLm5ldC9hbnN3ZXJzLyR7TElCX1ZFUlNJT059L2Fuc3dlcnN0ZW1wbGF0ZXMuY29tcGlsZWQubWluLmpzYDtcbiIsIi8qKiBAbW9kdWxlIFRlbXBsYXRlTG9hZGVyICovXG5cbmltcG9ydCBET00gZnJvbSAnLi4vZG9tL2RvbSc7XG5pbXBvcnQgeyBDT01QSUxFRF9URU1QTEFURVNfVVJMIH0gZnJvbSAnLi4vLi4vY29yZS9jb25zdGFudHMnO1xuXG4vKipcbiAqIFRlbXBsYXRlTG9hZGVyIGV4cG9zZXMgYW4gaW50ZXJmYWNlIGZvciBsb2FkaW5nIHRlbXBsYXRlcyBhc3luY2hyb25vdXNseVxuICogZnJvbSB0aGUgc2VydmVyIGFuZCByZWdpc3RlcnMgdGhlbSB3aXRoIHRoZSBwcm9wZXIgcmVuZGVyZXIuXG4gKiBJdCBhbHNvIGFsbG93cyB5b3UgdG8gYXNzaWduIHRoZW0gc3luY2hyb25vdXNseS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcGxhdGVMb2FkZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgaWYgKCFUZW1wbGF0ZUxvYWRlci5zZXRJbnN0YW5jZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIFRlbXBsYXRlTG9hZGVyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlIHVybCB0byBmZXRjaCBjb21waWxlZCB0ZW1wbGF0ZXMgZnJvbVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wbGF0ZVVybCA9IGNvbmZpZy50ZW1wbGF0ZVVybCB8fCBDT01QSUxFRF9URU1QTEFURVNfVVJMO1xuXG4gICAgdGhpcy5fdGVtcGxhdGVzID0ge307XG4gICAgdGhpcy5fb25Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICBzdGF0aWMgc2V0SW5zdGFuY2UgKGluc3RhbmNlKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIF9pbml0ICgpIHtcbiAgICB0aGlzLmZldGNoVGVtcGxhdGVzKCk7XG4gIH1cblxuICBmZXRjaFRlbXBsYXRlcyAoKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRlbXBsYXRlcyBsb2FkZWQsIGRvIG5vdGhpbmdcbiAgICBsZXQgbm9kZSA9IERPTS5xdWVyeSgnI3lleHQtYW5zd2Vycy10ZW1wbGF0ZXMnKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhIHNjcmlwdCB0byBmZXRjaCB0aGUgY29tcGlsZWQgdGVtcGxhdGVzLFxuICAgIC8vIHdyYXBwaW5nIGl0IGEgUHJvbWlzZSBmb3IgY2xlYW5saW5lc3NcbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc2NyaXB0ID0gRE9NLmNyZWF0ZUVsKCdzY3JpcHQnLCB7XG4gICAgICAgIGlkOiAneWV4dC1hbnN3ZXJzLXRlbXBsYXRlcycsXG4gICAgICAgIG9ubG9hZDogcmVzb2x2ZSxcbiAgICAgICAgb25lcnJvcjogcmVqZWN0LFxuICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgc3JjOiB0aGlzLl90ZW1wbGF0ZVVybFxuICAgICAgfSk7XG5cbiAgICAgIERPTS5hcHBlbmQoJ2JvZHknLCBzY3JpcHQpO1xuICAgIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIC8vIFRPRE8oYmlsbHkpIEltcGxtZW5ldCBlcnJvciBoYW5kbGluZyBoZXJlIChlLmcuIHJlcXVlc3QgY291bGQgZmFpbClcbiAgICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IScpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogcmVnaXN0ZXIgdGhlIHRlbXBsYXRlcyBpbnRlcm5hbGx5IHNvIHRoYXQgdGhleSBjYW4gYmUgbGF0ZXIgY29uc3VtZWRcbiAgICogKGUuZy4gYnkgY29tcG9uZW50cyBhbmQgcmVuZGVyZXJzKSB3aXRoIGNvbnZpZW5pZW5jZS5cbiAgICpcbiAgICogYGZldGNoVGVtcGxhdGVzYCB3aWxsIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGlzLCBwcm92aWRpbmcgdGhlIGNvbXBpbGVkIHRlbXBsYXRlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICByZWdpc3RlciAodGVtcGxhdGVzKSB7XG4gICAgdGhpcy5fdGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuXG4gICAgLy8gTm90aWZ5IG91ciBjb25zdW1lcnMgdGhhdCB0aGUgdGVtcGxhdGVzIGFyZSBoZXJlIDopXG4gICAgdGhpcy5fb25Mb2FkZWQodGhpcy5fdGVtcGxhdGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uTG9hZGVkIChjYikge1xuICAgIHRoaXMuX29uTG9hZGVkID0gY2I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgKHRlbXBsYXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFRoZSBpbnRlcm5hbCB0ZW1wbGF0ZSBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXRUZW1wbGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZXM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRE9NIH0gZnJvbSAnLi9kb20vZG9tJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi9kb20vc2VhcmNocGFyYW1zJztcblxuZXhwb3J0IHsgUmVuZGVyZXJzIH0gZnJvbSAnLi9yZW5kZXJpbmcvY29uc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZW1wbGF0ZUxvYWRlciB9IGZyb20gJy4vcmVuZGVyaW5nL3RlbXBsYXRlbG9hZGVyJztcbiIsIi8qKiBAbW9kdWxlIEV2ZW50RW1pdHRlciAqL1xuXG4vKipcbiAqIEV2ZW50RW1pdHRlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGFueSBvYmplY3QgdGhhdCB3YW50cyB0byBleHBvc2VcbiAqIGEgcHViL3N1YiBpbnRlcmZhY2UsIGZvciBlbWl0dGluZyBtZXNzYWdlcyBhbmQgcHJvdmlkaW5nIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJzY3JpYmVycyBvZiBtZXNzYWdlc1xuICAgICAqIEB0eXBlIHtvYmplY3RbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIG9uIGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciBzdWJzY3JpYmluZyBldmVudHMgdGhhdCBhcmUgZW1pdHRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCB0aGUgZXZlbnQgbmFtZSB0byBsaXN0ZW4gdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSB7ZXZ0fSBpcyBlbWl0dGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSBPcHRpb25hbCB2YWx1ZSB3aGljaCB3aWxsIG9ubHkgaGFuZGxlIHRoZSBtZXNzYWdlIG9uY2VcbiAgICovXG4gIG9uIChldnQsIGNiLCBvbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBoYW5kbGVyIHNob3VsZCBiZSBvZiB0eXBlIHtmdW5jdGlvbn0nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldnQsXG4gICAgICBjYjogY2IsXG4gICAgICBvbmNlOiBvbmNlIHx8IGZhbHNlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBvbmNlIGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciBzdWJzY3JpYmluZyBldmVudHMgdGhhdCBhcmUgZW1pdHRlZC5cbiAgICogVGhlIGhhbmRsZXIgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBvbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IHRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIHtldnR9IGlzIGVtaXR0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIE9wdGlvbmFsIHZhbHVlIHdoaWNoIHdpbGwgb25seSBoYW5kbGUgdGhlIG1lc3NhZ2Ugb25jZVxuICAgKi9cbiAgb25jZSAoZXZ0LCBjYikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2dCwgY2IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9mZiBpcyB0aGUgcHVibGljIGludGVyZmFjZSBmb3IgdW5zdWJzY3JpYmluZyBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICAgKi9cbiAgb2ZmIChldnQpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogZW1pdCBpcyB0aGUgcHVibGljIGludGVyZmFjZSBmb3IgYnJvYWRjYXN0aW5nIG1lc3NhZ2VzL2V2ZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IHRoZSBldmVudCBuYW1lIHRvIHB1Ymxpc2ggZnJvbVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBzZW5kIGFsb25nIHRvIHRoZSBzdWJzY3JpYmVyc1xuICAgKi9cbiAgZW1pdCAoZXZ0LCBkYXRhKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEludm9rZSBlYWNoIG9mIGFsbCB0aGUgbGlzdGVuZXIgaGFuZGxlcnMgYW5kIHJlbW92ZSB0aGUgb25lcyB0aGF0IHNob3VsZCBmaXJlIG9ubHkgb25jZS5cbiAgICBsZXQga2VlcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uY2IoZGF0YSk7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEluc3RlYWQgb2YgaGF2aW5nIGEgJ2RpcnR5JyBhcnJheSB3aXRoIGRlbGV0ZWQgb3IgJ3VuZGVmaW5lZCcgZW50cmllcyxcbiAgICAgIC8vIHdlIGp1c3QgY3JlYXRlIGEgYnJhbmQgbmV3IGFycmF5IHdpdGhvdXQgdGhlIGxpc3RlbmVycyB0aGF0IHdlcmUgcmVtb3ZlZFxuICAgICAga2VlcC5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG91ciBvbGQgbGlzdCBvZiBsaXN0ZW5lcnMgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXlcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IGtlZXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFN0YXRlICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vY29yZS9ldmVudGVtaXR0ZXIvZXZlbnRlbWl0dGVyJztcblxuLyoqXG4gKiBTdGF0ZSBjb250YWlucyB0aGUgZGF0YSBmb3IgdGhlIGNvbXBvbmVudFxuICogYW5kIGV4cG9zZXMgYW4ge0V2ZW50RW1pdHRlcn0gaW50ZXJmYWNlIHNvIHRoYXQgZXh0ZXJuYWxcbiAqIGRlcGVuZGVuY2llcyBjYW4gbGlzdGVuL2hvb2sgc3Vic2NyaWJlIHRvIG1lc3NhZ2VzL3VwZGF0ZXMuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXRlID0gZGF0YSB8fCB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogTk9URShiaWxseSk6IERvZXMgbm90IGZpcmUgYW4gdXBkYXRlIG1lc3NhZ2VcbiAgICovXG4gIGluaXQgKHByb3AsIG9wdFZhbCkge1xuICAgIHRoaXMuX3NldChwcm9wLCBvcHRWYWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldHRlciBmb3IgdGhlIHN0YXRlXG4gICAqIEBwYXJhbSBwcm9wIHtzdHJpbmd8T2JqZWN0fSBUaGUgcHJvcGVydHkgdG8gc2V0XG4gICAqIEBwYXJhbSBvcHRWYWwgT3B0aW9uYWwsIGlmIHByb3AgaXMgYSB7c3RyaW5nfSwgaXQgd2lsbCBhc3NpZ24gdGhlIHZhbHVlIHRvIHRoYXQgcHJvcGVydHlcbiAgICovXG4gIHNldCAocHJvcCwgb3B0VmFsKSB7XG4gICAgdGhpcy5fc2V0KHByb3AsIG9wdFZhbCk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXR0ZXIgZm9yIHRoZSBzdGF0ZSBlbmFibGVzIHlvdSB0byB1cGRhdGUgYSBzaW5nbGUgcHJvcGVydHksIG9yIGNvbXBsZXRlIHN0YXRlXG4gICAqIGRlcGVuZGluZyBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gcHJvcCB7c3RyaW5nfE9iamVjdH0gVGhlIHByb3BlcnR5IHRvIHNldFxuICAgKiBAcGFyYW0gb3B0VmFsIElmIHByb3AgaXMgYSB7c3RyaW5nfSwgcHJvdmlkZSBpdHMgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXQgKHByb3AsIG9wdFZhbCkge1xuICAgIGlmIChvcHRWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBwcm9wO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZVtwcm9wXSA9IG9wdFZhbDtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUgKGRhdGEpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IGRhdGE7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHByb3BlcnRpZXMgdmFsdWUgZnJvbSB0aGUgc3RhdGVcbiAgICogSWYgbm8gcHJvcGVydHkgcHJvdmlkZWQsIHJldHVybiB0aGUgZnVsbCBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0UHJvcCBvcHRpb25hbCBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKi9cbiAgZ2V0IChvcHRQcm9wKSB7XG4gICAgaWYgKG9wdFByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGVbb3B0UHJvcF07XG4gIH1cblxuICBoYXMgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVbcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFzSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIdHRwUmVxdWVzdGVyICovXG5cbi8qIGdsb2JhbCBmZXRjaCAqL1xuXG4vKipcbiAqIFR5cGVzIG9mIEhUVFAgcmVxdWVzdHNcbiAqL1xuY29uc3QgTWV0aG9kcyA9IHtcbiAgR0VUOiAnZ2V0JyxcbiAgUE9TVDogJ3Bvc3QnLFxuICBQVVQ6ICdwdXQnLFxuICBERUxFVEU6ICdkZWxldGUnXG59O1xuXG4vKipcbiAqIEh0dHBSZXF1ZXN0ZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEFKQVhcbiAqIHJlbGF0ZWQgbWF0dGVycy4gSXQncyB1c2VkIHRvIG1ha2UgYWxsIHR5cGVzIG9mIG5ldHdvcmsgcmVxdWVzdHNcbiAqIGFuZCBleHBvc2VzIGEgcHJvbWlzZSBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEh0dHBSZXF1ZXN0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgR0VUIEhUVFAgcmVxdWVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gcHJvdmlkZSAoZ2V0cyBlbmNvZGVkIGludG8gdGhlIFVSTClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICovXG4gIGdldCAodXJsLCBkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChNZXRob2RzLkdFVCwgdGhpcy5lbmNvZGVQYXJhbXModXJsLCBkYXRhKSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgUE9TVCBIVFRQIHJlcXVlc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cmxQYXJhbXMgVGhlIHBhcmFtcyB0byBlbmNvZGUgaW50byB0aGUgVVJMXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uQm9keSBUaGUgcmVxdWVzdCBib2R5IChqc29uKSB0byBwcm92aWRlIHdpdGggdGhlIFBPU1QgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdENvbmZpZyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgKi9cbiAgcG9zdCAodXJsLCB1cmxQYXJhbXMsIGpzb25Cb2R5LCByZXF1ZXN0Q29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIE1ldGhvZHMuUE9TVCxcbiAgICAgIHRoaXMuZW5jb2RlUGFyYW1zKHVybCwgdXJsUGFyYW1zKSxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkJvZHkpLFxuICAgICAgICBjcmVkZW50aWFsczogdW5kZWZpbmVkXG4gICAgICB9LCByZXF1ZXN0Q29uZmlnKVxuICAgICk7XG4gIH1cblxuICByZXF1ZXN0IChtZXRob2QsIHVybCwgb3B0cykge1xuICAgIGNvbnN0IHJlcUFyZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAnbWV0aG9kJzogbWV0aG9kLFxuICAgICAgJ2NyZWRlbnRpYWxzJzogJ2luY2x1ZGUnXG4gICAgfSwgb3B0cyk7XG5cbiAgICByZXR1cm4gZmV0Y2godXJsLCByZXFBcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgYmVhY29uIHRvIHRoZSBwcm92aWRlZCB1cmwgd2hpY2ggd2lsbCBzZW5kIGEgbm9uLWJsb2NraW5nIHJlcXVlc3RcbiAgICogdG8gdGhlIHNlcnZlciB0aGF0IGlzIGd1YXJhbnRlZWQgdG8gc2VuZCBiZWZvcmUgcGFnZSBsb2FkLiBObyByZXNwb25zZSBpcyByZXR1cm5lZCxcbiAgICogc28gYmVhY29ucyBhcmUgcHJpbWFyaWx5IHVzZWQgZm9yIGFuYWx5dGljcyByZXBvcnRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0byBzZW5kIHRoZSBiZWFjb24gdG9cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIGRhdGEgcGF5bG9hZCB0byBzZW5kIGluIHRoZSBiZWFjb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsbHkgcXVldWVkXG4gICAqL1xuICBiZWFjb24gKHVybCwgZGF0YSkge1xuICAgIHJldHVybiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih1cmwsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgfVxuXG4gIGVuY29kZVBhcmFtcyAodXJsLCBwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaGFzUGFyYW0gPSB1cmwuaW5kZXhPZignPycpID4gLTE7XG5cbiAgICBsZXQgc2VhcmNoUXVlcnkgPSAnJztcbiAgICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAoIWhhc1BhcmFtKSB7XG4gICAgICAgIGhhc1BhcmFtID0gdHJ1ZTtcbiAgICAgICAgc2VhcmNoUXVlcnkgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoUXVlcnkgKz0gJyYnO1xuICAgICAgfVxuXG4gICAgICBzZWFyY2hRdWVyeSArPSBrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdXJsICsgc2VhcmNoUXVlcnk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFBST0RVQ1RJT04sIFNBTkRCT1ggfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdXJsIGZvciB0aGUgbGl2ZSBhcGkgYmFja2VuZCBpbiB0aGUgZGVzaXJlZCBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnYgVGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXZlQXBpVXJsIChlbnYgPSBQUk9EVUNUSU9OKSB7XG4gIHJldHVybiBlbnYgPT09IFNBTkRCT1ggPyAnaHR0cHM6Ly9saXZlYXBpLXNhbmRib3gueWV4dC5jb20nIDogJ2h0dHBzOi8vbGl2ZWFwaS55ZXh0LmNvbSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSB1cmwgZm9yIHRoZSBrbm93bGVkZ2UgYXBpIGJhY2tlbmQgaW4gdGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52IFRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S25vd2xlZGdlQXBpVXJsIChlbnYgPSBQUk9EVUNUSU9OKSB7XG4gIHJldHVybiBlbnYgPT09IFNBTkRCT1ggPyAnaHR0cHM6Ly9hcGktc2FuZGJveC55ZXh0LmNvbScgOiAnaHR0cHM6Ly9hcGkueWV4dC5jb20nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdXJsIGZvciB0aGUgYW5hbHl0aWNzIGJhY2tlbmQgaW4gdGhlIGRlc2lyZWQgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52IFRoZSBkZXNpcmVkIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtib29sZWFufSBjb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIElmIGNvbnZlcnNpb24gdHJhY2tpbmcgaGFzIGJlZW4gb3B0ZWQgaW50by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFuYWx5dGljc1VybCAoZW52ID0gUFJPRFVDVElPTiwgY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCA9IGZhbHNlKSB7XG4gIGlmIChjb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkKSB7XG4gICAgcmV0dXJuIGVudiA9PT0gU0FOREJPWFxuICAgICAgPyAnaHR0cHM6Ly9zYW5kYm94LXJlYWx0aW1lYW5hbHl0aWNzLnlleHQuY29tJ1xuICAgICAgOiAnaHR0cHM6Ly9yZWFsdGltZWFuYWx5dGljcy55ZXh0LmNvbSc7XG4gIH1cbiAgcmV0dXJuIGVudiA9PT0gU0FOREJPWFxuICAgID8gJ2h0dHBzOi8vc2FuZGJveC1hbnN3ZXJzLnlleHQtcGl4ZWwuY29tJ1xuICAgIDogJ2h0dHBzOi8vYW5zd2Vycy55ZXh0LXBpeGVsLmNvbSc7XG59XG4iLCIvKiogQG1vZHVsZSBBcGlSZXF1ZXN0ICovXG5cbmltcG9ydCBIdHRwUmVxdWVzdGVyIGZyb20gJy4vaHR0cHJlcXVlc3Rlcic7XG5pbXBvcnQgeyBMSUJfVkVSU0lPTiwgUFJPRFVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL3VpL2RvbS9zZWFyY2hwYXJhbXMnOyAvLyBUT0RPIGlkZWFsbHkgdGhpcyB3b3VsZCBiZSBwYXNzZWQgaW4gYXMgYSBwYXJhbVxuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCB7IGdldExpdmVBcGlVcmwgfSBmcm9tICcuLi91dGlscy91cmx1dGlscyc7XG5cbi8qKlxuICogQXBpUmVxdWVzdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEFQSSByZXF1ZXN0cy5cbiAqIEl0IGRlZmluZXMgYWxsIG9mIHRoZSBjb3JlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gbWFrZSBhIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBpUmVxdWVzdCB7XG4gIC8vIFRPRE8gKHRtZXllcik6IENyZWF0ZSBhbiBBcGlTZXJ2aWNlIGludGVyZmFjZSBhbmQgcGFzcyBhbiBpbXBsZW1lbnRhdGlvbiB0byB0aGUgY3VycmVudFxuICAvLyBjb25zdW1lcnMgb2YgQXBpUmVxdWVzdCBhcyBhIGRlcGVuZGVuY3kuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiB1c2VkIGZvciBtYWtpbmcgbmV0d29yayByZXF1ZXN0IGFuZCBoYW5kbGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7SHR0cFJlcXVlc3Rlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlcXVlc3RlciA9IG5ldyBIdHRwUmVxdWVzdGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIG1hZGUgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW52aXJvbm1lbnQgPSBvcHRzLmVudmlyb25tZW50IHx8IFBST0RVQ1RJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZVVybCB0byB1c2UgZm9yIG1ha2luZyBhIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IG9wdHMuYmFzZVVybCB8fCBnZXRMaXZlQXBpVXJsKHRoaXMuX2Vudmlyb25tZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmRwb2ludCB0byB1c2UgaW4gdGhlIHVybCAoYXBwZW5kZWQgdG8gdGhlIHtiYXNlVXJsfSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW5kcG9pbnQgPSBvcHRzLmVuZHBvaW50IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IG9wdHMuYXBpS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgQVBJIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSBvcHRzLnZlcnNpb24gfHwgMjAxOTAxMDE7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGRhdGEgcGFyYW1zIHRoYXQgYXJlIHNlbnQgYWxvbmcgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBvcHRzLnBhcmFtcyB8fCB7fTtcblxuICAgIGlmICghZ2xvYmFsU3RvcmFnZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdNdXN0IGluY2x1ZGUgZ2xvYmFsIHN0b3JhZ2UnLCAnQXBpUmVxdWVzdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R2xvYmFsU3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBjcmVhdGVzIGEgbmV3IGBHRVRgIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcmVxdWVzdCBjbGFzc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAqL1xuICBnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0ZXIuZ2V0KFxuICAgICAgdGhpcy5fYmFzZVVybCArIHRoaXMuX2VuZHBvaW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUGFyYW1zKCksIHRoaXMuc2FuaXRpemVQYXJhbXModGhpcy5fcGFyYW1zKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICovXG4gIHBvc3QgKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdGVyLnBvc3QoXG4gICAgICB0aGlzLl9iYXNlVXJsICsgdGhpcy5fZW5kcG9pbnQsXG4gICAgICB0aGlzLmJhc2VQYXJhbXMoKSAvKiB1cmxQYXJhbXMgKi8sXG4gICAgICB0aGlzLnNhbml0aXplUGFyYW1zKHRoaXMuX3BhcmFtcykgLyoganNvbkJvZHkgKi8sXG4gICAgICBvcHRzIC8qIHJlcXVlc3RDb25maWcgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiYXNlUGFyYW1zICgpIHtcbiAgICBsZXQgYmFzZVBhcmFtcyA9IHtcbiAgICAgICd2JzogdGhpcy5fdmVyc2lvbixcbiAgICAgICdhcGlfa2V5JzogdGhpcy5fYXBpS2V5LFxuICAgICAgJ2pzTGliVmVyc2lvbic6IExJQl9WRVJTSU9OLFxuICAgICAgJ3Nlc3Npb25UcmFja2luZ0VuYWJsZWQnOiB0aGlzLl9nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTilcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKHVybFBhcmFtcy5oYXMoJ2JldGEnKSkge1xuICAgICAgYmFzZVBhcmFtc1snYmV0YSddID0gdXJsUGFyYW1zLmdldCgnYmV0YScpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlUGFyYW1zO1xuICB9XG5cbiAgc2FuaXRpemVQYXJhbXMgKHBhcmFtcyA9IHt9KSB7XG4gICAgLy8gUmVtb3ZlIGFueSBwYXJhbWF0ZXJzIHdob3MgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAgLy9cbiAgICAvLyBOT1RFKGJpbGx5KSBQcm9iYWJseSBiZXR0ZXIgdG8gYmUgZXhwbGljaXQgYWJvdXQgaG93IHRvIGhhbmRsZSB0aGlzIGF0IHRoZSByZXF1ZXN0IGJ1aWxkaW5nIGxldmVsLFxuICAgIC8vIGJ1dCBJIGNhbid0IHNlZSBhbnkgY2FzZXMgd2hlcmUgd2UnZCBldmVyIHdhbnQgdG8gc2VuZCAndW5kZWZpbmVkJyBhcyBhIHZhbHVlIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gU28gaXQncyBwcm9iYWJseSBmaW5lIHRvICdjbGVhbicgdGhlIHBhcmFtcyBvYmplY3QgaGVyZVxuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHBhcmFtc1trZXldID09PSB1bmRlZmluZWQgfHwgcGFyYW1zW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHBhcmFtc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VhcmNoQXBpICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlYXJjaHNlcnZpY2UnKS5kZWZhdWx0fSBTZWFyY2hTZXJ2aWNlICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBBbnN3ZXJzQmFzaWNFcnJvciwgQW5zd2Vyc0NvcmVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKipcbiAqIFNlYXJjaEFwaSBpcyB0aGUgQVBJIGZvciBkb2luZyB2YXJpb3VzIHR5cGVzIG9mIHNlYXJjaFxuICogb3ZlciB0aGUgbmV0d29yayAoZS5nLiB2ZXJ0aWNhbCBvciB1bml2ZXJzYWwpXG4gKlxuICogQGltcGxlbWVudHMge1NlYXJjaFNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEFwaSB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBBUEkgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0FwaSBLZXkgaXMgcmVxdWlyZWQnLCAnU2VhcmNoJyk7XG4gICAgfVxuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgQW5zd2VycyBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5leHBlcmllbmNlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0Fuc3dlcnMgS2V5IGlzIHJlcXVpcmVkJywgJ1NlYXJjaCcpO1xuICAgIH1cbiAgICB0aGlzLl9leHBlcmllbmNlS2V5ID0gY29uZmlnLmV4cGVyaWVuY2VLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBBUEkgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uIHx8IDIwMTkwMTAxIHx8IDIwMTkwMzAxO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGxvY2FsZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmxvY2FsZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdMb2NhbGUgaXMgcmVxdWlyZWQnLCAnU2VhcmNoJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIEFuc3dlcnMgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2ZXJ0aWNhbFNlYXJjaCAodmVydGljYWxLZXksIHsgaW5wdXQsIGZpbHRlciwgZmFjZXRGaWx0ZXIsIGxpbWl0LCBvZmZzZXQsIGlkLCBnZW9sb2NhdGlvbiwgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQsIHNraXBTcGVsbENoZWNrLCBxdWVyeVRyaWdnZXIsIHNlc3Npb25UcmFja2luZ0VuYWJsZWQsIHNvcnRCeXMgfSkge1xuICAgIGlmIChsaW1pdCA+IDUwKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignUHJvdmlkZWQgc2VhcmNoIGxpbWl0IHVuc3VwcG9ydGVkJywgJ1NlYXJjaEFwaScpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9xdWVyeScsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBlbnZpcm9ubWVudDogdGhpcy5fZW52aXJvbm1lbnQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogaW5wdXQsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2ZpbHRlcnMnOiBmaWx0ZXIsXG4gICAgICAgICdmYWNldEZpbHRlcnMnOiBmYWNldEZpbHRlcixcbiAgICAgICAgJ3ZlcnRpY2FsS2V5JzogdmVydGljYWxLZXksXG4gICAgICAgICdsaW1pdCc6IGxpbWl0LFxuICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0LFxuICAgICAgICAnbG9jYXRpb24nOiBnZW9sb2NhdGlvbiA/IGAke2dlb2xvY2F0aW9uLmxhdH0sJHtnZW9sb2NhdGlvbi5sbmd9YCA6IG51bGwsXG4gICAgICAgICdyYWRpdXMnOiBnZW9sb2NhdGlvbiA/IGdlb2xvY2F0aW9uLnJhZGl1cyA6IG51bGwsXG4gICAgICAgICdxdWVyeUlkJzogaWQsXG4gICAgICAgICdyZXRyaWV2ZUZhY2V0cyc6IGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkLFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2tpcFNwZWxsQ2hlY2snOiBza2lwU3BlbGxDaGVjayxcbiAgICAgICAgJ3F1ZXJ5VHJpZ2dlcic6IHF1ZXJ5VHJpZ2dlcixcbiAgICAgICAgJ3Nlc3Npb25UcmFja2luZ0VuYWJsZWQnOiBzZXNzaW9uVHJhY2tpbmdFbmFibGVkLFxuICAgICAgICAnc29ydEJ5cyc6IHNvcnRCeXNcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgeyBnZXRTdGF0ZTogKCkgPT4gc2Vzc2lvblRyYWNraW5nRW5hYmxlZCB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHVuaXZlcnNhbFNlYXJjaCAocXVlcnlTdHJpbmcsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB7XG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9hbnN3ZXJzL3F1ZXJ5JyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBxdWVyeVN0cmluZyxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAnbG9jYXRpb24nOiBwYXJhbXMuZ2VvbG9jYXRpb24gPyBgJHtwYXJhbXMuZ2VvbG9jYXRpb24ubGF0fSwke3BhcmFtcy5nZW9sb2NhdGlvbi5sbmd9YCA6IG51bGwsXG4gICAgICAgICdyYWRpdXMnOiBwYXJhbXMuZ2VvbG9jYXRpb24gPyBwYXJhbXMuZ2VvbG9jYXRpb24ucmFkaXVzIDogbnVsbCxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2xvY2FsZSc6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgJ3NraXBTcGVsbENoZWNrJzogcGFyYW1zLnNraXBTcGVsbENoZWNrLFxuICAgICAgICAncXVlcnlUcmlnZ2VyJzogcGFyYW1zLnF1ZXJ5VHJpZ2dlclxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB7IGdldFN0YXRlOiAoKSA9PiBwYXJhbXMuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIE1vZGVsIGZvciB0aGUgYW5hbHl0aWNzIGV2ZW50IHR5cGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5hbHl0aWNzRXZlbnQge1xuICBjb25zdHJ1Y3RvciAodHlwZSwgbGFiZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBldmVudCB0byByZXBvcnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRUeXBlID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gYmUgcHJvdmlkZWQgZm9yIHRoZSBldmVudFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHByb3ZpZGVkIG9wdGlvbnMgdG8gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGV2ZW50XG4gICAqL1xuICBhZGRPcHRpb25zIChvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGV2ZW50IGluIHRoZSBhcGkgZm9ybWF0LCB0eXBpY2FsbHkgZm9yIHJlcG9ydGluZyB0byB0aGUgYXBpXG4gICAqL1xuICB0b0FwaUV2ZW50ICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEFuYWx5dGljc1JlcG9ydGVyICovXG5cbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCB7IEFuc3dlcnNBbmFseXRpY3NFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IHsgUFJPRFVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgSHR0cFJlcXVlc3RlciBmcm9tICcuLi9odHRwL2h0dHByZXF1ZXN0ZXInO1xuaW1wb3J0IHsgZ2V0QW5hbHl0aWNzVXJsIH0gZnJvbSAnLi4vdXRpbHMvdXJsdXRpbHMnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvYW5hbHl0aWNzcmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gQW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcG9ydGluZyBhbmFseXRpY3MgZXZlbnRzIHRvIHRoZSBzZXJ2ZXIgdmlhIEhUVFBcbiAqXG4gKiBAaW1wbGVtZW50cyB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmFseXRpY3NSZXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBjb3JlLFxuICAgIGV4cGVyaWVuY2VLZXksXG4gICAgZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgYnVzaW5lc3NJZCxcbiAgICBnbG9iYWxPcHRpb25zID0ge30sXG4gICAgZW52aXJvbm1lbnQgPSBQUk9EVUNUSU9OKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGJ1c2luZXNzIGlkZW50aWZpZXIgdXNlZCBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9idXNpbmVzc0lkID0gYnVzaW5lc3NJZDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IGFuYWx5dGljIGV2ZW50IHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGdsb2JhbE9wdGlvbnMsIHsgZXhwZXJpZW5jZUtleSB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgQW5zd2VycyBleHBlcmllbmNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Vudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIFVSTCBmb3IgdGhlIGFuYWx5dGljcyBBUElcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IGdldEFuYWx5dGljc1VybCh0aGlzLl9lbnZpcm9ubWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBCb29sZWFuIGluZGljYXRpbmcgaWYgb3B0ZWQgaW4gb3Igb3V0IG9mIGNvbnZlcnNpb24gdHJhY2tpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChleHBlcmllbmNlVmVyc2lvbikge1xuICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5leHBlcmllbmNlVmVyc2lvbiA9IGV4cGVyaWVuY2VWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbiB0byBxdWVyeSBpZCB1cGRhdGVzXG4gICAgY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5RVUVSWV9JRCwgaWQgPT4gdGhpcy5zZXRRdWVyeUlkKGlkKSk7XG4gIH1cblxuICBzZXRRdWVyeUlkIChxdWVyeUlkKSB7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5xdWVyeUlkID0gcXVlcnlJZDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGV2ZW50KSB7XG4gICAgbGV0IGNvb2tpZURhdGEgPSB7fTtcbiAgICBpZiAodGhpcy5fY29udmVyc2lvblRyYWNraW5nRW5hYmxlZCAmJiB0eXBlb2YgeXRhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgeXRhZygnb3B0aW4nLCB0cnVlKTtcbiAgICAgIGNvb2tpZURhdGEgPSB5dGFnKCd5ZnBjJywgbnVsbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0FuYWx5dGljc0Vycm9yKCdUcmllZCB0byBlbmFibGUgY29udmVyc2lvbiB0cmFja2luZyB3aXRob3V0IGluY2x1ZGluZyB5dGFnJyk7XG4gICAgfVxuXG4gICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBBbmFseXRpY3NFdmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IoJ1RyaWVkIHRvIHNlbmQgaW52YWxpZCBhbmFseXRpY3MgZXZlbnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgZXZlbnQuYWRkT3B0aW9ucyh0aGlzLl9nbG9iYWxPcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgSHR0cFJlcXVlc3RlcigpLmJlYWNvbihcbiAgICAgIGAke3RoaXMuX2Jhc2VVcmx9L3JlYWx0aW1lYW5hbHl0aWNzL2RhdGEvYW5zd2Vycy8ke3RoaXMuX2J1c2luZXNzSWR9YCxcbiAgICAgIHsgZGF0YTogZXZlbnQudG9BcGlFdmVudCgpLCAuLi5jb29raWVEYXRhIH1cbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgKGlzRW5hYmxlZCkge1xuICAgIHRoaXMuX2NvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgdGhpcy5fYmFzZVVybCA9IGdldEFuYWx5dGljc1VybCh0aGlzLl9lbnZpcm9ubWVudCwgaXNFbmFibGVkKTtcbiAgfVxufVxuIiwiLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2FuYWx5dGljc3JlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEFuYWx5dGljc1JlcG9ydGVyU2VydmljZSAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtBbmFseXRpY3NSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vb3BBbmFseXRpY3NSZXBvcnRlciB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc2V0Q29udmVyc2lvblRyYWNraW5nRW5hYmxlZCAoaXNFbmFibGVkKSB7fVxufVxuIiwiLyoqIEBtb2R1bGUgTW9kdWxlRGF0YSAqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2V2ZW50ZW1pdHRlci9ldmVudGVtaXR0ZXInO1xuXG4vKipcbiAqIE1vZHVsZURhdGEgaXMgdXNlZCBhcyBhIGdlbmVyaWMgbW9kZWwgZm9yIFN0b3JhZ2UuXG4gKiBUeXBpY2FsbHkgYW4gaW5zdGFuY2Ugb2YgTW9kdWxlRGF0YSBwb3dlcnMgYSBzaW5nbGUgY29tcG9uZW50LlxuXG4gKiBBIGRhdGEgbW9kZWwgdGhhdCBleHBvc2VzIGFuIGV2ZW50IGVtaXR0ZXIgaW50ZXJmYWNlLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZHVsZURhdGEgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaWQsIGRhdGEgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9pZCA9IGlkO1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBsYWNlcyB0aGUgY3VycmVudGx5IGhlbGQgZGF0YSB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSB0aGUgZGF0YSB0byByZXBsYWNlIHRoZSBjdXJyZW50IGRhdGFcbiAgICovXG4gIHNldCAoZGF0YSkge1xuICAgIHRoaXMuY2FwdHVyZVByZXZpb3VzKCk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl9kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3Igc2hhbGxvdyBlcXVhbGl0eVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YVtrZXldICE9PSBkYXRhW2tleV0pIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5fZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYXB0dXJlUHJldmlvdXMgKCkge1xuICAgIGlmICh0aGlzLl9oaXN0b3J5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faGlzdG9yeS5sZW5ndGggKyAxID4gNSkge1xuICAgICAgdGhpcy5faGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIElmIGRhdGEgaXMgZXZlciB1bmRlZmluZWQsIHdlIGRlZmF1bHQgdG8gZW1wdHkgb2JqZWN0XG4gICAgdGhpcy5faGlzdG9yeS5wdXNoKEpTT04uc3RyaW5naWZ5KHRoaXMuX2RhdGEgfHwge30pKTtcbiAgfVxuXG4gIHVuZG8gKCkge1xuICAgIGxldCBwcmV2aW91cyA9IHt9O1xuICAgIGlmICh0aGlzLl9wcmV2aW91cy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmV2aW91cyA9IEpTT04ucGFyc2UodGhpcy5fcHJldmlvdXMucG9wKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEuc2V0KHByZXZpb3VzKTtcbiAgfVxuXG4gIHJhdyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdsb2JhbFN0b3JhZ2UgKi9cblxuaW1wb3J0IE1vZHVsZURhdGEgZnJvbSAnLi9tb2R1bGVkYXRhJztcbmltcG9ydCB7IEFuc3dlcnNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuL3N0b3JhZ2VrZXlzJztcblxuLyoqXG4gKiBTdG9yYWdlIGlzIGEgY29udGFpbmVyIGFyb3VuZCBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAqIEl0IGV4cG9zZXMgYW4gaW50ZXJmYWNlIGZvciBDUlVEIG9wZXJhdGlvbnMgYXMgd2VsbCBhcyBsaXN0ZW5pbmdcbiAqIGZvciBzdGF0ZWZ1bCBjaGFuZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbG9iYWxTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXIgPSB7fTtcbiAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRhdGEgaW4gc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBrZXkgdG8gdGhlIHByb3ZpZGVkIGRhdGEsXG4gICAqIGNvbXBsZXRlbHkgb3ZlcndyaXRpbmcgYW55IGV4aXN0aW5nIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHN0b3JhZ2Uga2V5IHRvIHNldFxuICAgKiBAcGFyYW0geyp9IGRhdGEgdGhlIGRhdGEgdG8gc2V0XG4gICAqL1xuICBzZXQgKGtleSwgZGF0YSkge1xuICAgIHRoaXMuX2luaXREYXRhQ29udGFpbmVyKGtleSwgZGF0YSk7XG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldLnNldChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgcHJvdmlkZWQgbWFwIHRvIHRoZSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUga2V5L3ZhbHVlIHBhaXJzIHRvIHNldCBpbiB0aGUgc3RvcmFnZVxuICAgKi9cbiAgc2V0QWxsIChkYXRhKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICBpZiAoa2V5ID09PSBTdG9yYWdlS2V5cy5RVUVSWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgcXVlcnkgbGFzdCBzaW5jZSBpdCB0cmlnZ2VycyBhIHNlYXJjaFxuICAgIC8vIFRPRE86IG1vdmUgbGlzdGVuZXJzIHVwIHNvIGFsbCBvZiBzdG9yYWdlIGNhbiBiZSB1cGRhdGVkIGF0IHRoZSBzYW1lIHRpbWVcbiAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5RVUVSWV0pIHtcbiAgICAgIHRoaXMuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCBkYXRhW1N0b3JhZ2VLZXlzLlFVRVJZXSk7XG4gICAgfVxuICB9XG5cbiAgX2luaXREYXRhQ29udGFpbmVyIChrZXksIGRhdGEpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignSW52YWxpZCBzdG9yYWdlIGtleSBwcm92aWRlZCcsIGtleSwgZGF0YSk7XG4gICAgfVxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNTdG9yYWdlRXJyb3IoJ05vIGRhdGEgcHJvdmlkZWQnLCBrZXksIGRhdGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldID0gbmV3IE1vZHVsZURhdGEoa2V5KTtcbiAgICAgIHRoaXMuX2FwcGx5RnV0dXJlTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdGUgKG1vZHVsZUlkKSB7XG4gICAgaWYgKHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0ucmF3KCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0QWxsIChrZXkpIHtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChjb25zdCBkYXRhS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX21vZHVsZURhdGFDb250YWluZXIpKSB7XG4gICAgICBpZiAoZGF0YUtleS5zdGFydHNXaXRoKGtleSkgJiYgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltkYXRhS2V5XS5yYXcoKSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLnB1c2godGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltkYXRhS2V5XS5yYXcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGF0YSBpbiBzdG9yYWdlIHdpdGggdGhlIGdpdmVuIGtleSB0byB0aGUgcHJvdmlkZWQgZGF0YSxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgc3RvcmFnZSBrZXkgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUgKGtleSkge1xuICAgIC8vIE5vdGU6IERvIHdlIG5lZWQgdG8gY2xlYW4gdXAgbGlzdGVuZXJzIGhlcmU/XG4gICAgZGVsZXRlIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJba2V5XTtcbiAgfVxuXG4gIG9uIChldnQsIG1vZHVsZUlkLCBjYikge1xuICAgIGxldCBtb2R1bGVEYXRhID0gdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF07XG4gICAgaWYgKG1vZHVsZURhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0ucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldnQsXG4gICAgICAgIGNiOiBjYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXS5vbihldnQsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZiAoZXZ0LCBtb2R1bGVJZCwgY2IpIHtcbiAgICBsZXQgbW9kdWxlRGF0YSA9IHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdO1xuICAgIGlmIChtb2R1bGVEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0ub2ZmKGV2dCwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2FwcGx5RnV0dXJlTGlzdGVuZXJzIChtb2R1bGVJZCkge1xuICAgIGxldCBmdXR1cmVzID0gdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXTtcbiAgICBpZiAoIWZ1dHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBmdXR1cmUgPSBmdXR1cmVzW2ldO1xuICAgICAgdGhpcy5vbihmdXR1cmUuZXZlbnQsIG1vZHVsZUlkLCBmdXR1cmUuY2IpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2hBcGkgfSBmcm9tICcuL3NlYXJjaC9zZWFyY2hhcGknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBbmFseXRpY3NSZXBvcnRlciB9IGZyb20gJy4vYW5hbHl0aWNzL2FuYWx5dGljc3JlcG9ydGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9vcEFuYWx5dGljc1JlcG9ydGVyIH0gZnJvbSAnLi9hbmFseXRpY3Mvbm9vcGFuYWx5dGljc3JlcG9ydGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9kdWxlRGF0YSB9IGZyb20gJy4vc3RvcmFnZS9tb2R1bGVkYXRhJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RvcmFnZSB9IGZyb20gJy4vc3RvcmFnZS9nbG9iYWxzdG9yYWdlJztcbiIsIi8qKiBAbW9kdWxlIENvbXBvbmVudCAqL1xuXG5pbXBvcnQgeyBSZW5kZXJlcnMgfSBmcm9tICcuLi9yZW5kZXJpbmcvY29uc3QnO1xuXG5pbXBvcnQgRE9NIGZyb20gJy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0YXRlIGZyb20gJy4vc3RhdGUnO1xuaW1wb3J0IHsgQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuLi8uLi9jb3JlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5cbi8qKlxuICogQ29tcG9uZW50IGlzIGFuIGFic3RyYWN0aW9uIHRoYXQgZW5jYXBzdWxhdGVzIHN0YXRlLCBiZWhhdmlvcixcbiAqIGFuZCB2aWV3IGZvciBhIHBhcnRpY3VsYXIgY2h1bmsgb2YgZnVuY3Rpb25hbGl0eSBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgQVBJIGV4cG9zZXMgZXZlbnQgbGlmZSBjeWNsZSBob29rcyBmb3Igd2hlbiB0aGluZ3MgYXJlIHJlbmRlcmVkLFxuICogbW91bnRlZCwgY3JlYXRlZCwgZXRjLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5tb2R1bGVJZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAqIFVzZWQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBvdGhlciBjb21wb25lbnRzIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IudHlwZTtcblxuICAgIC8qKlxuICAgICAqIENhY2hlIHRoZSBvcHRpb25zIHNvIHRoYXQgd2UgY2FuIHByb3BvZ2F0ZSBwcm9wZXJseSB0byBjaGlsZCBjb21wb25lbnRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyIHVzZWQgdG8gY2xhc3NpZnkgdGhlIHR5cGUgb2YgY29tcG9uZW50LlxuICAgICAqIFRoZSBjb21wb25lbnQgbWFuYWdlciB1c2VzIHRoaXMgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gcGVyc2lzdCBhbmQgb3JnYW5pemUgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtzdHJpbmd8Q29tcG9uZW50VHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLl90eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb21wb25lbnQsIGlmIGV4aXN0c1xuICAgICAqIEB0eXBlIHtDb21wb25lbnR9XG4gICAgICovXG4gICAgdGhpcy5fcGFyZW50Q29udGFpbmVyID0gY29uZmlnLnBhcmVudENvbnRhaW5lciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBjb250YWluZXIgZm9yIGFsbCB0aGUgY2hpbGQgY29tcG9uZW50c1xuICAgICAqIEB0eXBlIHtDb21wb25lbnRbXX1cbiAgICAgKi9cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXRlIChkYXRhKSBvZiB0aGUgY29tcG9uZW50IHRvIGJlIHByb3ZpZGVkIHRvIHRoZSB0ZW1wbGF0ZSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTdGF0ZShjb25maWcuc3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETyhiaWxseSkgVGhpcyBzaG91bGQgYmUgJ3NlcnZpY2VzJ1xuICAgICAqL1xuICAgIHRoaXMuY29yZSA9IHN5c3RlbUNvbmZpZy5jb3JlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50IG1hbmFnZXIsIHdoaWNoIGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tcG9uZW50IGNsYXNzZXNcbiAgICAgKiBlbGlnaWJsZSB0byBiZSBjcmVhdGVkXG4gICAgICogQHR5cGUge0NvbXBvbmVudE1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyID0gc3lzdGVtQ29uZmlnLmNvbXBvbmVudE1hbmFnZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBhbmFseXRpY3MgcmVwb3J0ZXIsIHVzZWQgdG8gcmVwb3J0IGV2ZW50cyBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7QW5hbHl0aWNzUmVwb3J0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlciA9IHN5c3RlbUNvbmZpZy5hbmFseXRpY3NSZXBvcnRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyB0byBpbmNsdWRlIHdpdGggYWxsIGFuYWx5dGljIGV2ZW50cyBzZW50IGJ5IHRoaXMgY29tcG9uZW50XG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FuYWx5dGljc09wdGlvbnMgPSBjb25maWcuYW5hbHl0aWNzT3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBET00gbm9kZSB0aGF0IHRoZSBjb21wb25lbnQgd2lsbCBiZSBhcHBlbmRlZCB0byB3aGVuIG1vdW50ZWQvcmVuZGVyZWQuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGlmICh0aGlzLl9wYXJlbnRDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLnF1ZXJ5KGNvbmZpZy5jb250YWluZXIpIHx8IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNvbnRhaW5lciBET00gbm9kZTogJyArIGNvbmZpZy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIGNvbmZpZy5jb250YWluZXIpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGFyZW50LCBhbmQgdGhlIGNvbnRhaW5lciBpcyBtaXNzaW5nIGZyb20gdGhlIERPTSxcbiAgICAgIC8vIHdlIGNvbnN0cnVjdCB0aGUgY29udGFpbmVyIGFuZCBhcHBlbmQgaXQgdG8gdGhlIHBhcmVudFxuICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogY29uZmlnLmNvbnRhaW5lci5zdWJzdHJpbmcoMSwgY29uZmlnLmNvbnRhaW5lci5sZW5ndGgpXG4gICAgICAgIH0pO1xuICAgICAgICBET00uYXBwZW5kKHRoaXMuX3BhcmVudENvbnRhaW5lciwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGN1c3RvbSBjbGFzcyB0byBiZSBhcHBsaWVkIHRvIHt0aGlzLl9jb250YWluZXJ9IG5vZGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2NsYXNzTmFtZSA9IGNvbmZpZy5jbGFzcyB8fCAnY29tcG9uZW50JztcblxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyID0gY29uZmlnLnJlbmRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQge1JlbmRlcmVyfSB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJlciA9IHN5c3RlbUNvbmZpZy5yZW5kZXJlciB8fCBSZW5kZXJlcnMuSGFuZGxlYmFycztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBzdHJpbmcgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudFxuICAgICAqIElmIHRoaXMgaXMgbGVmdCBlbXB0eSwgd2UgbG9va3VwIHRoZSB0ZW1wbGF0ZSB0aGUgYmFzZSB0ZW1wbGF0ZXMgdXNpbmcgdGhlIHRlbXBsYXRlTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGUgPSBjb25maWcudGVtcGxhdGUgPyB0aGlzLl9yZW5kZXJlci5jb21waWxlKGNvbmZpZy50ZW1wbGF0ZSkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlTmFtZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIFRoaXMgaXMgb25seSB1c2VkIGlmIF90ZW1wbGF0ZSBpcyBlbXB0eS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGNvbmZpZy50ZW1wbGF0ZU5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0VGVtcGxhdGVOYW1lKGNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBzdGF0ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2ssIHRoYXRzIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBpbnRlcm5hbCBkYXRhXG4gICAgICogbW9kZWxzIG9mIHRoZSBjb21wb25lbnRzLCBiZWZvcmUgaXQgZ2V0cyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQgc3RhdGUuXG4gICAgICogQnkgZGVmYXVsdCwgbm8gdHJhbnNmb3JtYXRpb24gaGFwcGVucy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1EYXRhID0gY29uZmlnLnRyYW5zZm9ybURhdGEgfHwgdGhpcy50cmFuc2Zvcm1EYXRhIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIGNyZWF0ZWQuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25DcmVhdGUgPSBjb25maWcub25DcmVhdGVPdmVycmlkZSB8fCB0aGlzLm9uQ3JlYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMub25DcmVhdGUgPSB0aGlzLm9uQ3JlYXRlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgTW91bnRlZC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbk1vdW50ID0gY29uZmlnLm9uTW91bnRPdmVycmlkZSB8fCB0aGlzLm9uTW91bnQgfHwgZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5vbk1vdW50ID0gdGhpcy5vbk1vdW50LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBjb21wb25lbnRzIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBjb25maWcub25VcGRhdGVPdmVycmlkZSB8fCB0aGlzLm9uVXBkYXRlIHx8IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB0aGlzLm9uVXBkYXRlID0gdGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uQ3JlYXRlIGNhbGxiYWNrXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXNlck9uQ3JlYXRlID0gY29uZmlnLm9uQ3JlYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uTW91bnQgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy51c2VyT25Nb3VudCA9IGNvbmZpZy5vbk1vdW50IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQSB1c2VyIHByb3ZpZGVkIG9uVXBkYXRlIGNhbGxiYWNrXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXNlck9uVXBkYXRlID0gY29uZmlnLm9uVXBkYXRlIHx8IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0JztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdDb21wb25lbnQnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaW5pdCAob3B0cykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnNldFN0YXRlKG9wdHMuZGF0YSB8fCBvcHRzLnN0YXRlIHx8IHt9KTtcbiAgICAgIHRoaXMub25DcmVhdGUoKTtcbiAgICAgIHRoaXMudXNlck9uQ3JlYXRlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ0Vycm9yIGluaXRpYWxpemluZyBjb21wb25lbnQnLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnR5cGUsXG4gICAgICAgIGUpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlLm9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgICAgIHRoaXMudXNlck9uVXBkYXRlKCk7XG4gICAgICAgIHRoaXMudW5Nb3VudCgpO1xuICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIHVwZGF0aW5nIGNvbXBvbmVudCcsXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci50eXBlLFxuICAgICAgICAgIGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgRE9NLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB7IF9jb25maWc6IHRoaXMuX2NvbmZpZyB9LCBkYXRhKTtcbiAgICB0aGlzLl9zdGF0ZS5zZXQobmV3U3RhdGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0U3RhdGUgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0KHByb3ApO1xuICB9XG5cbiAgaGFzU3RhdGUgKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaGFzKHByb3ApO1xuICB9XG5cbiAgdHJhbnNmb3JtRGF0YSAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgYWRkQ2hpbGQgKGRhdGEsIHR5cGUsIG9wdHMpIHtcbiAgICBsZXQgY2hpbGRDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKFxuICAgICAgdHlwZSxcbiAgICAgIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHBhcmVudENvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCBvcHRzIHx8IHt9LCB7XG4gICAgICAgIF9wYXJlbnRPcHRzOiB0aGlzLl9jb25maWdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGRDb21wb25lbnQpO1xuICAgIHJldHVybiBjaGlsZENvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50IGFuZCByZW1vdmUgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbiBmcm9tIHRoZSBsaXN0XG4gICAqIG9mIGFjdGl2ZSBjb21wb25lbnRzXG4gICAqL1xuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goYyA9PiBjLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVtb3ZlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyIG1ldGhvZCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW5kZXJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc2V0UmVuZGVyIChyZW5kZXIpIHtcbiAgICB0aGlzLl9yZW5kZXIgPSByZW5kZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZW5kZXJlciBmb3IgdGhlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1JlbmRlcmVyVHlwZX0gcmVuZGVyZXJcbiAgICovXG4gIHNldFJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gUmVuZGVyZXJzW3JlbmRlcmVyXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGNvbXBvbmVudCB0byB1c2Ugd2hlbiByZW5kZXJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXRUZW1wbGF0ZSAodGVtcGxhdGUpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRoaXMuX3JlbmRlcmVyLmNvbXBpbGUodGVtcGxhdGUpO1xuICB9XG5cbiAgdW5Nb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQudW5Nb3VudCgpO1xuICAgIH0pO1xuXG4gICAgRE9NLmVtcHR5KHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5vblVuTW91bnQoKTtcbiAgfVxuXG4gIG1vdW50IChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJlZm9yZU1vdW50KCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBET00uYXBwZW5kKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5yZW5kZXIodGhpcy5fc3RhdGUuYXNKU09OKCkpKTtcblxuICAgIC8vIFByb2Nlc3MgdGhlIERPTSB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGNyZWF0ZVxuICAgIC8vIGluLW1lbW9yeSBzdWItY29tcG9uZW50cyBmb3IgcmVuZGVyaW5nXG4gICAgY29uc3QgZG9tQ29tcG9uZW50cyA9IERPTS5xdWVyeUFsbCh0aGlzLl9jb250YWluZXIsICdbZGF0YS1jb21wb25lbnRdOm5vdChbZGF0YS1pcy1jb21wb25lbnQtbW91bnRlZF0pJyk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudHJhbnNmb3JtRGF0YShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX3N0YXRlLmdldCgpKSkpO1xuICAgIGRvbUNvbXBvbmVudHMuZm9yRWFjaChjID0+IHRoaXMuX2NyZWF0ZVN1YmNvbXBvbmVudChjLCBkYXRhKSk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICAvLyBBdHRhY2ggYW5hbHl0aWNzIGhvb2tzIGFzIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLmFuYWx5dGljc1JlcG9ydGVyKSB7XG4gICAgICBsZXQgZG9tSG9va3MgPSBET00ucXVlcnlBbGwodGhpcy5fY29udGFpbmVyLCAnW2RhdGEtZXZlbnR0eXBlXTpub3QoW2RhdGEtaXMtYW5hbHl0aWNzLWF0dGFjaGVkXSknKTtcbiAgICAgIGRvbUhvb2tzLmZvckVhY2godGhpcy5fY3JlYXRlQW5hbHl0aWNzSG9vay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIHRoaXMub25Nb3VudCh0aGlzKTtcbiAgICB0aGlzLnVzZXJPbk1vdW50KHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogcmVuZGVyIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUge1JlbmRlcmVyfSB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0ZW1wbGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICByZW5kZXIgKGRhdGEgPSB0aGlzLl9zdGF0ZS5nZXQoKSkge1xuICAgIHRoaXMuYmVmb3JlUmVuZGVyKCk7XG4gICAgLy8gVGVtcG9yYXJ5IGZpeCBmb3IgcGFzc2luZyBpbW11dGFibGUgZGF0YSB0byB0cmFuc2Zvcm1EYXRhKCkuXG4gICAgZGF0YSA9IHRoaXMudHJhbnNmb3JtRGF0YShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG5cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIC8vIFVzZSBlaXRoZXIgdGhlIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gb3IgdGhlIGludGVybmFsIHJlbmRlcmVyXG4gICAgLy8gZGVwZW5kYW50IG9uIHRoZSBjb21wb25lbnQgY29uZmlndXJhdGlvblxuICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBodG1sID0gdGhpcy5fcmVuZGVyKGRhdGEpO1xuICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlciBtZXRob2QgbXVzdCByZXR1cm4gSFRNTCBhcyB0eXBlIHtzdHJpbmd9Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlciB0aGUgZXhpc3RpbmcgdGVtcGxhdGVzIGFzIGEgc3RyaW5nXG4gICAgICBodG1sID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyKHtcbiAgICAgICAgdGVtcGxhdGU6IHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICB0ZW1wbGF0ZU5hbWU6IHRoaXMuX3RlbXBsYXRlTmFtZVxuICAgICAgfSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gV2UgY3JlYXRlIGFuIEhUTUwgRG9jdW1lbnQgZnJhZ21lbnQgd2l0aCB0aGUgcmVuZGVyZWQgc3RyaW5nXG4gICAgLy8gU28gdGhhdCB3ZSBjYW4gcXVlcnkgaXQgZm9yIHByb2Nlc3Npbmcgb2Ygc3ViIGNvbXBvbmVudHNcbiAgICBsZXQgZWwgPSBET00uY3JlYXRlKGh0bWwpO1xuXG4gICAgdGhpcy5hZnRlclJlbmRlcigpO1xuICAgIHJldHVybiBlbC5pbm5lckhUTUw7XG4gIH1cblxuICBfY3JlYXRlU3ViY29tcG9uZW50IChkb21Db21wb25lbnQsIGRhdGEpIHtcbiAgICBkb21Db21wb25lbnQuZGF0YXNldC5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBkb21Db21wb25lbnQuZGF0YXNldDtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC5jb21wb25lbnQ7XG4gICAgY29uc3QgcHJvcCA9IGRhdGFzZXQucHJvcDtcbiAgICBsZXQgb3B0cyA9IGRhdGFzZXQub3B0cyA/IEpTT04ucGFyc2UoZGF0YXNldC5vcHRzKSA6IHt9O1xuXG4gICAgbGV0IGNoaWxkRGF0YSA9IGRhdGFbcHJvcF0gfHwge307XG5cbiAgICBvcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbnRhaW5lcjogZG9tQ29tcG9uZW50XG4gICAgfTtcblxuICAgIC8vIFRPRE8oYmlsbHkpIFJpZ2h0IG5vdywgaWYgd2UgcHJvdmlkZSBhbiBhcnJheSBhcyB0aGUgZGF0YSBwcm9wLFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBjcmVhdGUgbWFueSBjb21wb25lbnRzIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgIC8vIFRIQVQgaW50ZXJmYWNlIFNIT1VMRCBjaGFuZ2UgdG8gdXNlIGEgZGlmZmVyZW50IHByb3BlcnR5IHRoYXQgZGVmaW5lc1xuICAgIC8vIHdoZXRoZXIgdG8gYXJyYXkgZGF0YSBzaG91bGQgYmUgdXNlZCBmb3IgYSBzaW5nbGUgY29tcG9uZW50IG9yXG4gICAgLy8gdG8gY3JlYXRlIG1hbnkgY29tcG9uZW50cyBmb3IgZWFjaCBpdGVtLlxuICAgIC8vIE92ZXJsb2FkaW5nIGFuZCBoYXZpbmcgdGhpcyBzaWRlIGVmZmVjdCBpcyB1bmludHVpdGl2ZSBhbmQgV1JPTkdcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGREYXRhKSkge1xuICAgICAgLy8gUmVuZGVyaW5nIGEgc3ViIGNvbXBvbmVudCBzaG91bGQgYmUgd2l0aGluIHRoZSBjb250ZXh0LFxuICAgICAgLy8gb2YgdGhlIG5vZGUgdGhhdCB3ZSBwcm9jZXNzZWQgaXQgZnJvbVxuICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZERhdGEsIHR5cGUsIG9wdHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNoaWxkRGF0YS5yZXZlcnNlKCk7XG4gICAgY2hpbGREYXRhLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICB0aGlzLmFkZENoaWxkKGRhdGEsIHR5cGUsIG9wdHMpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUFuYWx5dGljc0hvb2sgKGRvbUNvbXBvbmVudCkge1xuICAgIGRvbUNvbXBvbmVudC5kYXRhc2V0LmlzQW5hbHl0aWNzQXR0YWNoZWQgPSB0cnVlO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBkb21Db21wb25lbnQuZGF0YXNldDtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC5ldmVudHR5cGU7XG4gICAgY29uc3QgbGFiZWwgPSBkYXRhc2V0LmV2ZW50bGFiZWw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRhdGFzZXQuZXZlbnRvcHRpb25zID8gSlNPTi5wYXJzZShkYXRhc2V0LmV2ZW50b3B0aW9ucykgOiB7fTtcblxuICAgIERPTS5vbihkb21Db21wb25lbnQsICdjbGljaycsIGUgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQW5hbHl0aWNzRXZlbnQodHlwZSwgbGFiZWwpO1xuICAgICAgZXZlbnQuYWRkT3B0aW9ucyh0aGlzLl9hbmFseXRpY3NPcHRpb25zKTtcbiAgICAgIGV2ZW50LmFkZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogb25DcmVhdGUgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjb25zdHJ1Y3RlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25DcmVhdGUgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvblVwZGF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvblVwZGF0ZSAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGJlZm9yZVJlbmRlciBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIGJlZm9yZVJlbmRlciAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGFmdGVyUmVuZGVyIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBhZnRlclJlbmRlciAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIG9uTW91bnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhcHBlbmRlZCB0byB0aGUgRE9NXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvbk1vdW50IChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25Vbk1vdW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uVW5Nb3VudCAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIGJlZm9yZU1vdW50IGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHRvIHRoZSBET01cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIGJlZm9yZU1vdW50IChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25EZXN0cm95IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvbkRlc3Ryb3kgKGNiKSB7XG5cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRXJyb3JSZXBvcnRlciAqL1xuXG5pbXBvcnQgeyBBbnN3ZXJzQmFzZUVycm9yLCBBbnN3ZXJzQmFzaWNFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuaW1wb3J0IEFwaVJlcXVlc3QgZnJvbSAnLi4vaHR0cC9hcGlyZXF1ZXN0JztcbmltcG9ydCB7IExJQl9WRVJTSU9OIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBFcnJvclJlcG9ydGVyIGlzIHVzZWQgZm9yIHJlcG9ydGluZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUgYW5kIEFQSVxuICpcbiAqIEBpbXBsZW1lbnRzIHtFcnJvclJlcG9ydGVyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JSZXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcsIGdsb2JhbFN0b3JhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXBpS2V5IHRvIHVzZSBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXhwZXJpZW5jZUtleSB0byB1c2Ugd2hlbiByZXBvcnRpbmdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuc3dlcnMgY29uZmlnIHZlcnNpb24gdXNlZCBmb3IgYXBpIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbiB8fCAnY29uZmlnMS4wJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHByaW50IGVudGlyZSBlcnJvciBvYmplY3RzIHRvIHRoZSBjb25zb2xlIGZvciBpbnNwZWN0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wcmludFZlcmJvc2UgPSBjb25maWcucHJpbnRWZXJib3NlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmVwb3J0IHRoZSBlcnJvciB0aGUgc2VydmVyIGZvciBsb2dnaW5nIGFuZCBtb25pdG9yaW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZW5kVG9TZXJ2ZXIgPSBjb25maWcuc2VuZFRvU2VydmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzdG9yYWdlIGluc3RhbmNlIG9mIHRoZSBleHBlcmllbmNlXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICovXG4gICAgaWYgKHRoaXMuc2VuZFRvU2VydmVyICYmICFnbG9iYWxTdG9yYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoXG4gICAgICAgICdNdXN0IGluY2x1ZGUgZ2xvYmFsU3RvcmFnZSB0byBzZW5kIGVycm9ycyB0byBzZXJ2ZXInLFxuICAgICAgICAnRXJyb3JSZXBvcnRlcicpO1xuICAgIH1cbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBBbnN3ZXJzIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbnZpcm9ubWVudCA9IGNvbmZpZy5lbnZpcm9ubWVudDtcblxuICAgIC8vIEF0dGFjaCByZXBvcnRpbmcgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGUgPT4gdGhpcy5yZXBvcnQoZS5lcnJvcikpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBlID0+IHRoaXMucmVwb3J0KGUuZXJyb3IpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBvcnQgcHJldHR5IHByaW50cyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG9wdGlvbmFsbHlcbiAgICogcHJpbnRzIHRoZSBlbnRpcmUgZXJyb3IgaWYgYHByaW50VmVyYm9zZWAgaXMgdHJ1ZSwgYW5kIHNlbmRzIHRoZVxuICAgKiBlcnJvciB0byB0aGUgc2VydmVyIHRvIGJlIGxvZ2dlZCBpZiBgc2VuZFRvU2VydmVyYCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSByZXBvcnRlZFxuICAgKiBAcmV0dXJucyB7QW5zd2Vyc0Jhc2VFcnJvcn0gVGhlIHJlcG9ydGVkIGVycm9yXG4gICAqL1xuICByZXBvcnQgKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3IpIHx8IGVyci5yZXBvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVyci5yZXBvcnRlZCA9IHRydWU7XG5cbiAgICB0aGlzLnByaW50RXJyb3IoZXJyKTtcblxuICAgIGlmICh0aGlzLnNlbmRUb1NlcnZlcikge1xuICAgICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9lcnJvcnMnLFxuICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICB2ZXJzaW9uOiAyMDE5MDMwMSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICdsaWJWZXJzaW9uJzogTElCX1ZFUlNJT04sXG4gICAgICAgICAgJ2V4cGVyaWVuY2VWZXJzaW9uJzogdGhpcy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuZXhwZXJpZW5jZUtleSxcbiAgICAgICAgICAnZXJyb3InOiBlcnIudG9Kc29uKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLmdsb2JhbFN0b3JhZ2UpO1xuXG4gICAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IFdlIHNob3VsZCBwcm9iYWJseSBjaGFuZ2UgdGhpcyBlbmRwb2ludCB0byBQT1NULFxuICAgICAgLy8gaWRlYWxseSB1c2luZyB0aGUgYmVhY29uIEFQSS4gU3RhY2sgdHJhY2VzIHdpbGwgbGlrZWx5IGVhc2lseSBoaXQgVVJMXG4gICAgICAvLyBsZW5ndGggbGltaXRzLlxuICAgICAgcmVxdWVzdC5nZXQoKVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnI7XG4gIH1cblxuICAvKipcbiAgICogcHJpbnRzIHRoZSBnaXZlbiBlcnJvciB0byB0aGUgYnJvd3NlciBjb25zb2xlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSBwcmludGVkXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICBpZiAodGhpcy5wcmludFZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYGVycm9yOiAke2Vyci5lcnJvck1lc3NhZ2V9XG5jb2RlOiAke2Vyci5lcnJvckNvZGV9XG5ib3VuZGFyeTogJHtlcnIuYm91bmRhcnl9XG5zdGFjazogJHtlcnIuc3RhY2t9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RXJyb3JSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnNvbGVFcnJvclJlcG9ydGVyIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlcG9ydCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgeyBBbnN3ZXJzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcblxuLyoqIEBtb2R1bGUgUGVyc2lzdGVudFN0b3JhZ2UgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc2lzdGVudFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwYXJhbXMgbW9kZWxcbiAgICAgKiBAdHlwZSB7U2VhcmNoUGFyYW1zfVxuICAgICAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgaGlzdG9yeSBlZGl0IHRpbWVyLCBpZiBhbnlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2hpc3RvcnlUaW1lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBsaXN0ZW5lcnMgdG8gZXZlcnkgc3RvcmFnZSB1cGRhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVMaXN0ZW5lciA9IGNvbmZpZy51cGRhdGVMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGxpc3RlbmVycyB0byBzdG9yYWdlIHJlc2V0c1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbltdfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc2V0TGlzdGVuZXIgPSBjb25maWcucmVzZXRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICB0aGlzLl9jYWxsTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgdGhpcy5fY2FsbExpc3RlbmVyKHRoaXMuX3Jlc2V0TGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBnaXZlbiBrZXkvdmFsdWUgcGFpciBpbnRvIHN0b3JhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGluc2VydCB0aGUgZGF0YSBpblxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSBoaXN0b3J5IGluc3RlYWQgb2YgcHVzaGluZyBuZXcgc3RhdGVcbiAgICovXG4gIHNldCAoa2V5LCBkYXRhLCByZXBsYWNlSGlzdG9yeSA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignU3RvcmFnZSBkYXRhIGtleSBtdXN0IGJlIGEgc3RyaW5nJywga2V5LCBkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3RGF0YSA9IGRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgbmV3RGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9wYXJhbXMuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBnaXZlbiBrZXkgZnJvbSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBkZWxldGVcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIGhpc3RvcnkgaW5zdGVhZCBvZiBwdXNoaW5nIG5ldyBzdGF0ZVxuICAgKi9cbiAgZGVsZXRlIChrZXksIHJlcGxhY2VIaXN0b3J5ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICBfdXBkYXRlSGlzdG9yeSAocmVwbGFjZUhpc3RvcnkgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9oaXN0b3J5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaXN0b3J5VGltZXIpO1xuICAgIH1cblxuICAgIC8vIGJhdGNoIHVwZGF0ZSBjYWxscyBhY3Jvc3MgY29tcG9uZW50cyB0byBhdm9pZCB1cGRhdGluZyB0aGUgdXJsIHRvbyBtdWNoXG4gICAgdGhpcy5faGlzdG9yeVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcGxhY2VIaXN0b3J5KSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIGA/JHt0aGlzLl9wYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgYD8ke3RoaXMuX3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGxpc3Qgb2YgY2FsbGJhY2tzIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBkYXRhXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gbGlzdGVuZXJzIFRoZSBjYWxsYmFja3MgdG8gaW52b2tlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsbExpc3RlbmVyIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKHRoaXMuZ2V0QWxsKCksIHRoaXMuX3BhcmFtcy50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBrZXkvdmFsdWUgcGFpcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgZ2V0QWxsICgpIHtcbiAgICBjb25zdCBhbGxQYXJhbXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fcGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgYWxsUGFyYW1zW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBhbGxQYXJhbXM7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFuc3dlcnNDb25maWdFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKiogQG1vZHVsZSBTZWFyY2hDb25maWcgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heCByZXN1bHRzIHBlciBzZWFyY2guXG4gICAgICogQWxzbyBkZWZpbmVzIHRoZSBudW1iZXIgb2YgcmVzdWx0cyBwZXIgcGFnZSwgaWYgcGFnaW5hdGlvbiBpcyBlbmFibGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbWl0ID0gY29uZmlnLmxpbWl0IHx8IDIwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2UgZm9yIGFsbCBzZWFyY2hlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHNlYXJjaCB0byB1c2Ugb24gaW5pdGlhbGl6YXRpb24gZm9yIHZlcnRpY2FsIHNlYXJjaGVycywgd2hlbiB0aGUgdXNlciBoYXMndCBwcm92aWRlZCBhIHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRJbml0aWFsU2VhcmNoID0gY29uZmlnLmRlZmF1bHRJbml0aWFsU2VhcmNoO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpbWl0ICE9PSAnbnVtYmVyJyB8fCB0aGlzLmxpbWl0IDwgMSB8fCB0aGlzLmxpbWl0ID4gNTApIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IoJ1NlYXJjaCBMaW1pdCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAnLCAnU2VhcmNoQ29uZmlnJyk7XG4gICAgfVxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVEYXRhICovXG5cbmltcG9ydCBIaWdobGlnaHRlZFZhbHVlIGZyb20gJy4vaGlnaGxpZ2h0ZWR2YWx1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZURhdGEge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgdGhpcy5xdWVyeUlkID0gZGF0YS5xdWVyeUlkIHx8ICcnO1xuICAgIHRoaXMuaW5wdXRJbnRlbnRzID0gZGF0YS5pbnB1dEludGVudHMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSkge1xuICAgIGxldCBzZWN0aW9ucztcbiAgICBpZiAocmVzcG9uc2Uuc2VjdGlvbnMpIHtcbiAgICAgIHNlY3Rpb25zID0gcmVzcG9uc2Uuc2VjdGlvbnMubWFwKHMgPT4gKHtcbiAgICAgICAgbGFiZWw6IHMubGFiZWwsXG4gICAgICAgIHJlc3VsdHM6IHMucmVzdWx0cy5tYXAociA9PiBuZXcgQXV0b0NvbXBsZXRlUmVzdWx0KHIpKVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWN0aW9ucyA9IFt7IHJlc3VsdHM6IHJlc3BvbnNlLnJlc3VsdHMubWFwKHIgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdChyKSkgfV07XG4gICAgfVxuICAgIGxldCBpbnB1dEludGVudHMgPSByZXNwb25zZS5pbnB1dCA/IHJlc3BvbnNlLmlucHV0LnF1ZXJ5SW50ZW50cyA6IFtdO1xuICAgIHJldHVybiBuZXcgQXV0b0NvbXBsZXRlRGF0YSh7XG4gICAgICBzZWN0aW9ucyxcbiAgICAgIHF1ZXJ5SWQ6IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBpbnB1dEludGVudHMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF1dG9Db21wbGV0ZVJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICB0aGlzLmZpbHRlciA9IGRhdGEuZmlsdGVyIHx8IHt9O1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWRWYWx1ZSA9IG5ldyBIaWdobGlnaHRlZFZhbHVlKGRhdGEpLmdldEludmVydGVkKCk7XG4gICAgdGhpcy5rZXkgPSBkYXRhLmtleSB8fCAnJztcbiAgICB0aGlzLm1hdGNoZWRTdWJzdHJpbmdzID0gZGF0YS5tYXRjaGVkU3Vic3RyaW5ncyB8fCBbXTtcbiAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZSB8fCAnJztcbiAgICB0aGlzLnNob3J0VmFsdWUgPSBkYXRhLnNob3J0VmFsdWUgfHwgdGhpcy52YWx1ZTtcbiAgICB0aGlzLmludGVudHMgPSBkYXRhLnF1ZXJ5SW50ZW50cyB8fCBbXTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIgKi9cblxuaW1wb3J0IEF1dG9Db21wbGV0ZURhdGEgZnJvbSAnLi4vbW9kZWxzL2F1dG9jb21wbGV0ZWRhdGEnO1xuXG4vKipcbiAqIEEgRGF0YSBUcmFuc2Zvcm1lciB0aGF0IHRha2VzIHRoZSByZXNwb25zZSBvYmplY3QgZnJvbSBhIEF1dG9Db21wbGV0ZSByZXF1ZXN0XG4gKiBBbmQgdHJhbnNmb3JtcyBpbiB0byBhIGZyb250LWVuZCBvcmllbnRlZCBkYXRhIHN0cnVjdHVyZSB0aGF0IG91clxuICogY29tcG9uZW50IGxpYnJhcnkgYW5kIGNvcmUgc3RvcmFnZSB1bmRlcnN0YW5kLlxuICpcbiAqIFRPRE8oYmlsbHkpIENyZWF0ZSBvdXIgb3duIGZyb250LWVuZCBkYXRhIG1vZGVsc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIge1xuICBzdGF0aWMgY2xlYW4gKG1vZHVsZUlkLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuc2VjdGlvbnMgJiYgZGF0YS5zZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBkYXRhLnNlY3Rpb25zO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnNlY3Rpb25zICYmIGRhdGEuc2VjdGlvbnMubGVuZ3RoID09PSAxICYmIGRhdGEuc2VjdGlvbnNbMF0ucmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBkYXRhLnNlY3Rpb25zO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBbbW9kdWxlSWRdOiBkYXRhXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB1bml2ZXJzYWwgKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEF1dG9Db21wbGV0ZURhdGEuZnJvbShyZXNwb25zZSk7XG4gIH1cblxuICBzdGF0aWMgZmlsdGVyIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBdXRvQ29tcGxldGVEYXRhLmZyb20ocmVzcG9uc2UpO1xuICB9XG5cbiAgc3RhdGljIHZlcnRpY2FsIChyZXNwb25zZSkge1xuICAgIHJldHVybiBBdXRvQ29tcGxldGVEYXRhLmZyb20ocmVzcG9uc2UpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVBcGkgKi9cblxuaW1wb3J0IEFwaVJlcXVlc3QgZnJvbSAnLi4vaHR0cC9hcGlyZXF1ZXN0JztcbmltcG9ydCBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIgZnJvbSAnLi9hdXRvY29tcGxldGVkYXRhdHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IsIEFuc3dlcnNFbmRwb2ludEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2F1dG9jb21wbGV0ZXNlcnZpY2UnKS5kZWZhdWx0fSBBdXRvQ29tcGxldGVTZXJ2aWNlICovXG5cbi8qKlxuICogQXV0b0NvbXBsZXRlQXBpIGV4cG9zZXMgYW4gaW50ZXJmYWNlIGZvciBuZXR3b3JrIHJlbGF0ZWQgbWF0dGVyc1xuICogZm9yIGFsbCB0aGUgYXV0b2NvbXBsZXRlIGVuZHBvaW50cy5cbiAqXG4gKiBAaW1wbGVtZW50cyB7QXV0b0NvbXBsZXRlU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0NvbXBsZXRlQXBpIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBnbG9iYWxTdG9yYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIEFQSSBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignQXBpIEtleSBpcyByZXF1aXJlZCcsICdBdXRvQ29tcGxldGUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBBbnN3ZXJzIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmV4cGVyaWVuY2VLZXkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignQW5zd2VycyBLZXkgaXMgcmVxdWlyZWQnLCAnQXV0b0NvbXBsZXRlJyk7XG4gICAgfVxuICAgIHRoaXMuX2V4cGVyaWVuY2VLZXkgPSBjb25maWcuZXhwZXJpZW5jZUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBBUEkgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uIHx8IDIwMTkwMTAxIHx8IDIwMTkwMzAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuc3dlcnMgY29uZmlnIHZlcnNpb24gdG8gdXNlIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24gPSBjb25maWcuZXhwZXJpZW5jZVZlcnNpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcubG9jYWxlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0xvY2FsZSBpcyByZXF1aXJlZCcsICdBdXRvQ29tcGxldGUnKTtcbiAgICB9XG4gICAgdGhpcy5fbG9jYWxlID0gY29uZmlnLmxvY2FsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgc3RvcmFnZSBpbnN0YW5jZSBvZiB0aGUgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtHbG9iYWxTdG9yYWdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFnbG9iYWxTdG9yYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0dsb2JhbCBzdG9yYWdlIGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9nbG9iYWxTdG9yYWdlID0gZ2xvYmFsU3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgQW5zd2VycyBleHBlcmllbmNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Vudmlyb25tZW50ID0gY29uZmlnLmVudmlyb25tZW50O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5RmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgY29uc3QgcmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvZmlsdGVyc2VhcmNoJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLl9lbnZpcm9ubWVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAnaW5wdXQnOiBpbnB1dCxcbiAgICAgICAgJ2V4cGVyaWVuY2VLZXknOiB0aGlzLl9leHBlcmllbmNlS2V5LFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAndmVydGljYWxLZXknOiBjb25maWcudmVydGljYWxLZXksXG4gICAgICAgICdsb2NhbGUnOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICdzZWFyY2hfcGFyYW1ldGVycyc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdChyZXF1ZXN0Q29uZmlnLCB0aGlzLl9nbG9iYWxTdG9yYWdlKTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIuZmlsdGVyKHJlc3BvbnNlLnJlc3BvbnNlKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcignRmlsdGVyIHNlYXJjaCByZXF1ZXN0IGZhaWxlZCcsICdBdXRvQ29tcGxldGUnLCBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVZlcnRpY2FsIChpbnB1dCwgdmVydGljYWxLZXkpIHtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9hdXRvY29tcGxldGUnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuX2Vudmlyb25tZW50LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IGlucHV0LFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICd2ZXJ0aWNhbEtleSc6IHZlcnRpY2FsS2V5LFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlXG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHJlcXVlc3RDb25maWcsIHRoaXMuX2dsb2JhbFN0b3JhZ2UpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QuZ2V0KClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lci52ZXJ0aWNhbChyZXNwb25zZS5yZXNwb25zZSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQW5zd2Vyc0VuZHBvaW50RXJyb3IoJ1ZlcnRpY2FsIHNlYXJjaCByZXF1ZXN0IGZhaWxlZCcsICdBdXRvQ29tcGxldGUnLCBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVVuaXZlcnNhbCAocXVlcnlTdHJpbmcpIHtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9hdXRvY29tcGxldGUnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuX2Vudmlyb25tZW50LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IHF1ZXJ5U3RyaW5nLFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICdsb2NhbGUnOiB0aGlzLl9sb2NhbGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5fZ2xvYmFsU3RvcmFnZSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQocXVlcnlTdHJpbmcpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIudW5pdmVyc2FsKHJlc3BvbnNlLnJlc3BvbnNlKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcignVW5pdmVyc2FsIHNlYXJjaCByZXF1ZXN0IGZhaWxlZCcsICdBdXRvQ29tcGxldGUnLCBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IEF1dG9Db21wbGV0ZURhdGEsIHsgQXV0b0NvbXBsZXRlUmVzdWx0IH0gZnJvbSAnLi4vbW9kZWxzL2F1dG9jb21wbGV0ZWRhdGEnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvYXV0b2NvbXBsZXRlc2VydmljZScpLmRlZmF1bHR9IEF1dG9Db21wbGV0ZVNlcnZpY2UgKi9cblxuY29uc3QgdW5pdmVyc2FsT3B0aW9ucyA9IFtcbiAgJ3doYXQgaXMgeWV4dCcsXG4gICd3aG8gaXMgdGhlIGNlbyBvZiB5ZXh0J1xuXTtcblxuY29uc3QgdmVydGljYWxPcHRpb25zID0gW1xuICAnbmVhciBtZScsXG4gICdpbiBuZXcgeW9yaycsXG4gICdhdmFpbGFibGUgbm93J1xuXTtcblxuLyoqXG4gKiBNb2NrQXV0b0NvbXBsZXRlU2VydmljZSBzZXJ2ZXMgYXV0b2NvbXBsZXRlIHF1ZXJpZXMgd2l0aCBtb2NrIGRhdGFcbiAqXG4gKiBAaW1wbGVtZW50cyB7QXV0b0NvbXBsZXRlU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2Uge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlGaWx0ZXIgKGlucHV0LCBjb25maWcpIHtcbiAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IFNpbXVsYXRlIGZpbHRlciBzZWFyY2gsIHdpdGggc2VjdGlvbnNcbiAgICByZXR1cm4gZW1wdHlSZXN1bHRzKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcXVlcnlWZXJ0aWNhbCAoaW5wdXQsIHZlcnRpY2FsS2V5KSB7XG4gICAgcmV0dXJuIGZpbHRlck9wdGlvbnMoaW5wdXQsIHZlcnRpY2FsT3B0aW9uc1xuICAgICAgLm1hcChvcHQgPT4gYCR7dmVydGljYWxLZXl9ICR7b3B0fWApXG4gICAgICAuY29uY2F0KHVuaXZlcnNhbE9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVVuaXZlcnNhbCAoaW5wdXQpIHtcbiAgICByZXR1cm4gZmlsdGVyT3B0aW9ucyhpbnB1dCwgdW5pdmVyc2FsT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgUXVlcnkgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zIEhhcmRjb2RlZCBhdXRvY29tcGxldGUgb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8QXV0b0NvbXBsZXRlRGF0YT59XG4gKi9cbmZ1bmN0aW9uIGZpbHRlck9wdGlvbnMgKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZW1wdHlSZXN1bHRzKCk7XG4gIH1cblxuICBjb25zdCBsb3dlcmNhc2UgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCByZXN1bHRzID0gb3B0aW9uc1xuICAgIC5maWx0ZXIob3B0ID0+IG9wdC5pbmNsdWRlcyhsb3dlcmNhc2UpKVxuICAgIC5tYXAob3B0ID0+IG5ldyBBdXRvQ29tcGxldGVSZXN1bHQoe1xuICAgICAgdmFsdWU6IG9wdCxcbiAgICAgIG1hdGNoZWRTdWJzdHJpbmdzOiBbe1xuICAgICAgICBvZmZzZXQ6IG9wdC5pbmRleE9mKGxvd2VyY2FzZSksXG4gICAgICAgIGxlbmd0aDogbG93ZXJjYXNlLmxlbmd0aFxuICAgICAgfV1cbiAgICB9KSk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dG9Db21wbGV0ZURhdGEoe1xuICAgIHNlY3Rpb25zOiBbeyByZXN1bHRzIH1dLFxuICAgIHF1ZXJ5SWQ6IHJhbmRvbVN0cmluZygpXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRvQ29tcGxldGVEYXRhPn1cbiAqL1xuZnVuY3Rpb24gZW1wdHlSZXN1bHRzICgpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXV0b0NvbXBsZXRlRGF0YSh7XG4gICAgc2VjdGlvbnM6IFt7fV0sXG4gICAgcXVlcnlJZDogcmFuZG9tU3RyaW5nKClcbiAgfSkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZyAoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG4iLCIvKiogQG1vZHVsZSBRdWVzdGlvbkFuc3dlckFwaSAqL1xuXG5pbXBvcnQgQXBpUmVxdWVzdCBmcm9tICcuLi9odHRwL2FwaXJlcXVlc3QnO1xuaW1wb3J0IHsgUFJPRFVDVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBbnN3ZXJzQmFzaWNFcnJvciwgQW5zd2Vyc0VuZHBvaW50RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCB7IGdldEtub3dsZWRnZUFwaVVybCB9IGZyb20gJy4uL3V0aWxzL3VybHV0aWxzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJykuZGVmYXVsdH0gUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogUXVlc3Rpb25BbnN3ZXJBcGkgc3VibWl0cyBxdWVzdGlvbnMgdmlhIHRoZSBRJkEgUkVTVCBBUElcbiAqXG4gKiBAaW1wbGVtZW50cyB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVzdGlvbkFuc3dlckFwaSB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgZ2xvYmFsU3RvcmFnZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBBUEkgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0FwaSBLZXkgaXMgcmVxdWlyZWQnLCAnUXVlc3Rpb25BbnN3ZXJBcGknKTtcbiAgICB9XG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgc3RvcmFnZSBpbnN0YW5jZSBvZiB0aGUgZXhwZXJpZW5jZVxuICAgICAqIEB0eXBlIHtHbG9iYWxTdG9yYWdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFnbG9iYWxTdG9yYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0dsb2JhbCBzdG9yYWdlIGlzIHJlcXVpcmVkJywgJ1F1ZXN0aW9uQW5zd2VyQXBpJyk7XG4gICAgfVxuICAgIHRoaXMuX2dsb2JhbFN0b3JhZ2UgPSBnbG9iYWxTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVudmlyb25tZW50IG9mIHRoZSBBbnN3ZXJzIGV4cGVyaWVuY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW52aXJvbm1lbnQgPSBjb25maWcuZW52aXJvbm1lbnQgfHwgUFJPRFVDVElPTjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBzdWJtaXRRdWVzdGlvbiAocXVlc3Rpb24pIHtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgYmFzZVVybDogZ2V0S25vd2xlZGdlQXBpVXJsKHRoaXMuX2Vudmlyb25tZW50KSxcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2NyZWF0ZVF1ZXN0aW9uJyxcbiAgICAgIGFwaUtleTogdGhpcy5fYXBpS2V5LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdlbnRpdHlJZCc6IHF1ZXN0aW9uLmVudGl0eUlkLFxuICAgICAgICAnc2l0ZSc6IHF1ZXN0aW9uLnNpdGUsXG4gICAgICAgICduYW1lJzogcXVlc3Rpb24ubmFtZSxcbiAgICAgICAgJ2VtYWlsJzogcXVlc3Rpb24uZW1haWwsXG4gICAgICAgICdxdWVzdGlvblRleHQnOiBxdWVzdGlvbi5xdWVzdGlvblRleHQsXG4gICAgICAgICdxdWVzdGlvbkRlc2NyaXB0aW9uJzogcXVlc3Rpb24ucXVlc3Rpb25EZXNjcmlwdGlvbixcbiAgICAgICAgJ3F1ZXN0aW9uTGFuZ3VhZ2UnOiBxdWVzdGlvbi5xdWVzdGlvbkxhbmd1YWdlXG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHJlcXVlc3RDb25maWcsIHRoaXMuX2dsb2JhbFN0b3JhZ2UpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QucG9zdCh7XG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNFbmRwb2ludEVycm9yKFxuICAgICAgICAgICdRdWVzdGlvbiBzdWJtaXQgZmFpbGVkJyxcbiAgICAgICAgICAnUXVlc3Rpb25BbnN3ZXJBcGknLFxuICAgICAgICAgIGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHN1Ym1pdFF1ZXN0aW9uIChxdWVzdGlvbikge1xuICAgIC8vIFRPRE8oYW11bGxpbmdzKTogTWFrZSBhY3R1YWwgcmVzcG9uc2Ugb2JqZWN0IG9uY2Ugd2UncmUgdXNpbmcgaXQgZm9yXG4gICAgLy8gc29tZXRoaW5nXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBmZXRjaCAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vbW9kZWxzL3NlY3Rpb24nKS5kZWZhdWx0fSBTZWN0aW9uICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvc2VhcmNoc2VydmljZScpLmRlZmF1bHR9IFNlYXJjaFNlcnZpY2UgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXN1bHREYXRhXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YVxuICogQHByb3BlcnR5IHtzdHJpbmcgfSBodG1sVGl0bGVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBSZXN1bHRzTW9kaWZpZXJcbiAqIEBwYXJhbSB7UmVzdWx0RGF0YVtdfSByZXN1bHRzXG4gKiBAcmV0dXJucyB7UmVzdWx0RGF0YVtdfVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIE1vY2tEYXRhQ29uc3VtZXJcbiAqIEBwYXJhbSB7U2VjdGlvbltdfSBzZWN0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuXG5jb25zdCBBUkJJVFJBUllfQlVTSU5FU1NfSUQgPSA5MTk4NzE7XG5cbi8qKlxuICogQGltcGxlbWVudHMge1NlYXJjaFNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vY2tTZWFyY2hTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9nZXRNb2NrRGF0YUpzb24gPSBmZXRjaCgnaHR0cHM6Ly9hc3NldHMuc2l0ZXNjZG4ubmV0L2Fuc3dlcnMvdGVzdGRhdGEvc2VhcmNoL21vY2tkYXRhX3YxLmpzb24nKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLnRleHQoKSlcbiAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2ZXJ0aWNhbFNlYXJjaCAodmVydGljYWxLZXksIHsgaW5wdXQsIGZpbHRlciwgZmFjZXRGaWx0ZXIsIGxpbWl0LCBvZmZzZXQsIGlkLCBnZW9sb2NhdGlvbiwgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQsIHNraXBTcGVsbENoZWNrLCBxdWVyeVRyaWdnZXIgfSkge1xuICAgIHJldHVybiB0aGlzLnVzZU1vY2tEYXRhKHNlY3Rpb25zID0+IHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRSZXNwb25zZShjb25zdHJ1Y3RWZXJ0aWNhbFJlc3BvbnNlKHtcbiAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICBhcHBsaWVkUXVlcnlGaWx0ZXJzOiBbXVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVpdGhlciBmaW5kIGEgc2VjdGlvbiB3aXRoIG1hdGNoaW5nIElELCBvciBwaWNrIG9uZSBhdCByYW5kb21cbiAgICAgIGxldCBzZWN0aW9uID0gc2VjdGlvbnMuZmluZChcbiAgICAgICAgdmVydGljYWxNb2R1bGUgPT4gdmVydGljYWxLZXkgPT09IHZlcnRpY2FsTW9kdWxlWyd2ZXJ0aWNhbENvbmZpZ0lkJ11cbiAgICAgICk7XG4gICAgICBpZiAoc2VjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzZWN0aW9ucy5sZW5ndGgpXTtcbiAgICAgIH1cblxuICAgICAgbW9kaWZ5UmVzdWx0cyhzZWN0aW9uLCBnZXRSZXN1bHRzRmlsdGVyZXIoaW5wdXQpKTtcbiAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCAmJiBsaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIG1vZGlmeVJlc3VsdHMoc2VjdGlvbiwgZnVuY3Rpb24gbGltaXQgKHJlc3VsdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBjb25zdHJ1Y3RWZXJ0aWNhbFJlc3BvbnNlKHNlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRlbGF5ZWRSZXNwb25zZShyZXNwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB1bml2ZXJzYWxTZWFyY2ggKHF1ZXJ5U3RyaW5nLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy51c2VNb2NrRGF0YShzZWN0aW9ucyA9PiB7XG4gICAgICBpZiAocXVlcnlTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkZWxheWVkUmVzcG9uc2UoY29uc3RydWN0VW5pdmVyc2FsUmVzcG9uc2UoW10pKTtcbiAgICAgIH1cblxuICAgICAgc2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgbW9kaWZ5UmVzdWx0cyhzZWN0aW9uLCBnZXRSZXN1bHRzRmlsdGVyZXIocXVlcnlTdHJpbmcpKTtcbiAgICAgIH0pO1xuXG4gICAgICBzZWN0aW9ucyA9IHNlY3Rpb25zLmZpbHRlcihzZWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24ucmVzdWx0cy5sZW5ndGggPiAwO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBjb25zdHJ1Y3RVbml2ZXJzYWxSZXNwb25zZShzZWN0aW9ucyk7XG4gICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKHJlc3ApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9ja0RhdGFDb25zdW1lcn0gY29uc3VtZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVzZU1vY2tEYXRhIChjb25zdW1lcikge1xuICAgIHJldHVybiB0aGlzLl9nZXRNb2NrRGF0YUpzb24udGhlbihKU09OLnBhcnNlKS50aGVuKGNvbnN1bWVyKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVN0cmluZ1xuICogQHJldHVybiB7UmVzdWx0c01vZGlmaWVyfVxuICovXG5mdW5jdGlvbiBnZXRSZXN1bHRzRmlsdGVyZXIgKHF1ZXJ5U3RyaW5nKSB7XG4gIHJldHVybiByZXN1bHRzID0+IHJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiB7XG4gICAgaWYgKHJlc3VsdC5odG1sVGl0bGUgJiYgcmVzdWx0Lmh0bWxUaXRsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5U3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBpbiByZXN1bHQuZGF0YSkge1xuICAgICAgY29uc3QgdmFsID0gcmVzdWx0LmRhdGFbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnlTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VjdGlvbn0gc2VjdGlvblxuICogQHBhcmFtIHtSZXN1bHRzTW9kaWZpZXJ9IG1vZGlmeUZuXG4gKi9cbmZ1bmN0aW9uIG1vZGlmeVJlc3VsdHMgKHNlY3Rpb24sIG1vZGlmeUZuKSB7XG4gIHNlY3Rpb24ucmVzdWx0cyA9IG1vZGlmeUZuKHNlY3Rpb24ucmVzdWx0cyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWN0aW9uW119IHNlY3Rpb25zIEEgbGlzdCBvZiBtb2NrIHNlY3Rpb24gZGF0YVxuICogQHJldHVybnMge09iamVjdH0gQSBtb2NrIEFuc3dlcnNBcGkgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0VW5pdmVyc2FsUmVzcG9uc2UgKHNlY3Rpb25zKSB7XG4gIC8vIFRPRE8oYW11bGxpbmdzKTogc3BlbGxjaGVjaywgZ2VvLCBmaWx0ZXJzXG4gIC8vIFRPRE8oYW11bGxpbmdzKTogRmFrZSBlbmNvZGVkU3RhdGUgb25jZSB0aGUgU0RLIHVzZXMgaXRcbiAgc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZmlsbFNlY3Rpb25GaWVsZHMpO1xuICByZXR1cm4ge1xuICAgIG1ldGE6IHtcbiAgICAgIHV1aWQ6IHV1aWRWNCgpLFxuICAgICAgZXJyb3JzOiBbXVxuICAgIH0sXG4gICAgcmVzcG9uc2U6IHtcbiAgICAgIGJ1c2luZXNzSWQ6IEFSQklUUkFSWV9CVVNJTkVTU19JRCxcbiAgICAgIG1vZHVsZXM6IHNlY3Rpb25zLFxuICAgICAgZmFpbGVkVmVydGljYWxzOiBbXSxcbiAgICAgIHF1ZXJ5SWQ6IHV1aWRWNCgpLFxuICAgICAgc2VhcmNoSW50ZW50czogW11cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWN0aW9ufSBzZWN0aW9uIEEgbW9jayBzZWN0aW9uIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgbW9jayBBbnN3ZXJzQXBpIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2UgKHNlY3Rpb24pIHtcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBzcGVsbGNoZWNrLCBnZW8sIGZpbHRlcnNcbiAgLy8gVE9ETyhhbXVsbGluZ3MpOiBGYWtlIGVuY29kZWRTdGF0ZSBvbmNlIHRoZSBTREsgdXNlcyBpdFxuICBzZWN0aW9uID0gZmlsbFNlY3Rpb25GaWVsZHMoc2VjdGlvbik7XG4gIHJldHVybiB7XG4gICAgbWV0YToge1xuICAgICAgdXVpZDogdXVpZFY0KCksXG4gICAgICBlcnJvcnM6IFtdXG4gICAgfSxcbiAgICByZXNwb25zZTogT2JqZWN0LmFzc2lnbihzZWN0aW9uLCB7XG4gICAgICBidXNpbmVzc0lkOiBBUkJJVFJBUllfQlVTSU5FU1NfSUQsXG4gICAgICBxdWVyeUlkOiB1dWlkVjQoKSxcbiAgICAgIHNlYXJjaEludGVudHM6IFtdXG4gICAgfSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb259XG4gKiBAcmV0dXJucyB7U2VjdGlvbn1cbiAqL1xuZnVuY3Rpb24gZmlsbFNlY3Rpb25GaWVsZHMgKHNlY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbENvbmZpZ0lkOiBzZWN0aW9uLnZlcnRpY2FsQ29uZmlnSWQsXG4gICAgcmVzdWx0c0NvdW50OiBzZWN0aW9uLnJlc3VsdHMubGVuZ3RoLFxuICAgIGVuY29kZWRTdGF0ZTogJycsXG4gICAgcmVzdWx0czogc2VjdGlvbi5yZXN1bHRzLFxuICAgIGFwcGxpZWRRdWVyeUZpbHRlcnM6IHNlY3Rpb24uYXBwbGllZFF1ZXJ5RmlsdGVycyxcbiAgICBxdWVyeUR1cmF0aW9uTWlsbGlzOiByYW5kb21JbnQoNTAsIDEwMDApLFxuICAgIGZhY2V0czogc2VjdGlvbi5mYWNldHMsXG4gICAgc291cmNlOiBzZWN0aW9uLnNvdXJjZVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5mdW5jdGlvbiBkZWxheWVkUmVzcG9uc2UgKHJlc3ApIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICB9LCByYW5kb21JbnQoMjUwLCAxMDAwKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvZGUtZ29sZi15IGJ1dCBsZWdpdCBiYXNpYyBVVUlEIHY0IGltcGxlbWVudGF0aW9uLiBOb3QgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlLlxuICogRnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHY0LWNvbXBsaWFudCBVVUlEXG4gKi9cbmZ1bmN0aW9uIHV1aWRWNCAoKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gYiAoYSkgeyByZXR1cm4gYSA/IChhIF4gTWF0aC5yYW5kb20oKSAqIDE2ID4+IGEgLyA0KS50b1N0cmluZygxNikgOiAoWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYik7IH0pKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggZXhjbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2VcbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50IChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xufVxuIiwiLyoqIEBtb2R1bGUgTmF2aWdhdGlvbkNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL2RvbS9zZWFyY2hwYXJhbXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBUaGUgZGVib3VuY2UgZHVyYXRpb24gZm9yIHJlc2l6ZSBldmVudHNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFJFU0laRV9ERUJPVU5DRSA9IDEwMDtcblxuLyoqXG4gKiBUaGUgYnJlYWtwb2ludCBmb3IgbW9iaWxlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNT0JJTEVfQlJFQUtQT0lOVCA9IDc2NztcblxuLyoqXG4gKiBFbnVtIG9wdGlvbnMgZm9yIG1vYmlsZSBvdmVyZmxvdyBiZWFodmlvclxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OID0ge1xuICBDT0xMQVBTRTogJ0NPTExBUFNFJyxcbiAgSU5ORVJTQ1JPTEw6ICdJTk5FUlNDUk9MTCdcbn07XG5cbi8qKlxuICogVGhlIFRhYiBpcyBhIG1vZGVsIHRoYXQgaXMgdXNlZCB0byBwb3dlciB0aGUgTmF2aWdhdGlvbiB0YWJzIGluIHRoZSB2aWV3LlxuICogSXQncyBpbml0aWFsaXplZCB0aHJvdWdoIHRoZSBjb25maWd1cmF0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHRhYiB0aGF0IGlzIGV4cG9zZWQgZm9yIHRoZSBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gY29uZmlnLmxhYmVsO1xuICAgIGlmICh0eXBlb2YgdGhpcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoJ2xhYmVsIGlzIGEgcmVxdWlyZWQgY29uZmlndXJhdGlvbiBvcHRpb24gZm9yIHRhYi4nLCAnTmF2aWdhdGlvbkNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZSBVUkwsIGluY2x1ZGluZyB0aGUgcGFyYW1zXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IGNvbmZpZy51cmw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoJ3VybCBpcyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciB0YWIuJywgJ05hdmlnYXRpb25Db21wb25lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyc2lkZSB2ZXJ0aWNhbCBjb25maWcgaWQgdGhhdCB0aGlzIGlzIHJlZmVyZW5jZWQgdG8uXG4gICAgICogQnkgcHJvdmlkaW5nIHRoaXMsIGVuYWJsZXMgZHluYW1pYyBzb3J0aW5nIGJhc2VkIG9uIHJlc3VsdHMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ0lkID0gY29uZmlnLmNvbmZpZ0lkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBVUkwgdXNlZCBmb3IgY29uc3RydWN0aW5nIHRoZSBVUkwgd2l0aCBwYXJhbXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy51cmw7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gc2hvdyB0aGlzIHRhYiBmaXJzdCBpbiB0aGUgb3JkZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRmlyc3QgPSBjb25maWcuaXNGaXJzdCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gYXBwbHkgYSBzcGVjaWFsIGNsYXNzIHRvIHRoZVxuICAgICAqIG1hcmt1cCB0byBkZXRlcm1pbmUgaWYgaXQncyBhbiBhY3RpdmUgdGFiXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGNvbmZpZy5pc0FjdGl2ZSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmcm9tIHdpbGwgY29uc3RydWN0IGEgbWFwIG9mIGNvbmZpZ0lkIHRvIHtUYWJ9IGZyb21cbiAgICogYSBjb25maWd1cmF0aW9uIGZpbGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHRhYnNDb25maWcgdGhlIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAodGFic0NvbmZpZykge1xuICAgIGxldCB0YWJzID0ge307XG4gICAgLy8gUGFyc2UgdGhlIG9wdGlvbnMgYW5kIGJ1aWxkIG91dCBvdXIgdGFicyBhbmRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnNDb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0YWIgPSB0YWJzQ29uZmlnW2ldO1xuICAgICAgLy8gRm9yIHRhYnMgd2l0aG91dCBjb25maWcgaWRzLCBtYXAgdGhlaXIgVVJMIHRvIHRoZSBjb25maWdJRFxuICAgICAgLy8gdG8gYXZvaWQgZHVwbGljYXRpb24gb2YgcmVuZGVyc1xuICAgICAgaWYgKHRhYi5jb25maWdJZCA9PT0gbnVsbCAmJiB0YWJzW3RhYi5jb25maWdJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YWIuY29uZmlnSWQgPSB0YWIudXJsO1xuICAgICAgfVxuXG4gICAgICB0YWJzW3RhYi5jb25maWdJZF0gPSBuZXcgVGFiKHRhYik7XG4gICAgfVxuICAgIHJldHVybiB0YWJzO1xuICB9XG59XG5cbi8qKlxuICogTmF2aWdhdGlvbkNvbXBvbmVudCBleHBvc2VzIGFuIGludGVyZmFjZSBmb3IgYnVpbGRpbmcgYSBkeW5hbWljXG4gKiBuYXZpZ2F0aW9uIHRoYXQgaXMgcG93ZXJlZCBieSB1bml2ZXJzYWwgc2VhcmNoIHVwZGF0ZXMuXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBvbiB0aGUgZHJvcGRvd24gbWVudSBidXR0b24gd2hlbiBvdmVyZmxvd1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd0xhYmVsID0gY29uZmlnLm92ZXJmbG93TGFiZWwgfHwgJ01vcmUnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGljb24gdG8gc2hvdyBvbiB0aGUgZHJvcGRvd24gbWVudSBidXR0b24gd2hlbiBvdmVyZmxvd1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd0ljb24gPSBjb25maWcub3ZlcmZsb3dJY29uIHx8ICdrYWJvYic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBzdG9yYWdlIGtleVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLk5BVklHQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUYWJzIGNvbmZpZyBmcm9tIGdsb2JhbCBuYXZpZ2F0aW9uIGNvbmZpZ1xuICAgICAqIEB0eXBlIHtBcnJheS48b2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RhYnNDb25maWcgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5OQVZJR0FUSU9OX0NPTkZJRykudGFic0NvbmZpZztcblxuICAgIC8qKlxuICAgICAqIFVub3JkZXJlZCBtYXAgb2YgZWFjaCB0YWIsIGtleWVkIGJ5IFZTIGNvbmZpZ0lkXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBPYmplY3Q+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGFicyA9IFRhYi5mcm9tKHRoaXMuX3RhYnNDb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSB0YWJzLCBwYXJzZWQgZnJvbSBjb25maWd1cmF0aW9uIG9yIFVSTC5cbiAgICAgKiBUaGlzIGdldHMgdXBkYXRlZCBiYXNlZCBvbiB0aGUgc2VydmVyIHJlc3VsdHNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59IFRoZSBsaXN0IG9mIFZTIGNvbmZpZ0lkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGFiT3JkZXIgPSB0aGlzLmdldERlZmF1bHRUYWJPcmRlcih0aGlzLl90YWJzQ29uZmlnLCB0aGlzLmdldFVybFBhcmFtcygpKTtcblxuICAgIC8qKlxuICAgICAqIEJyZWFrcG9pbnRzIGF0IHdoaWNoIG5hdmlnYXRpb24gaXRlbXMgbW92ZSB0byB0aGUgXCJtb3JlXCIgZHJvcGRvd25cbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9uYXZCcmVha3BvaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBtb2JpbGUgb3ZlcmZsb3cgYmVoYXZpb3IgY29uZmlnXG4gICAgICogIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fbW9iaWxlT3ZlcmZsb3dCZWhhdmlvciA9IGNvbmZpZy5tb2JpbGVPdmVyZmxvd0JlaGF2aW9yIHx8IE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04uQ09MTEFQU0U7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIEFSSUEgbGFiZWxcbiAgICAgKiAgQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9hcmlhTGFiZWwgPSBjb25maWcuYXJpYUxhYmVsIHx8ICdTZWFyY2ggUGFnZSBOYXZpZ2F0aW9uJztcblxuICAgIHRoaXMuY2hlY2tPdXRzaWRlQ2xpY2sgPSB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IgPSB0aGlzLmNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ05hdmlnYXRpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICduYXZpZ2F0aW9uL25hdmlnYXRpb24nO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIC8vIFRPRE86IFJlLXJlbmRlcmluZyBhbmQgcmUtbW91bnRpbmcgdGhlIGNvbXBvbmVudCBldmVyeSB0aW0gZSB0aGUgd2luZG93IGNoYW5nZXMgc2l6ZVxuICAgIC8vIGlzIG5vdCBncmVhdC5cbiAgICBET00ub24od2luZG93LCAncmVzaXplJywgdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IpO1xuICB9XG5cbiAgb25EZXN0cm95ICgpIHtcbiAgICBET00ub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLnNob3VsZENvbGxhcHNlKCkpIHtcbiAgICAgIHRoaXMuX25hdkJyZWFrcG9pbnRzID0gW107XG4gICAgICB0aGlzLmJpbmRPdmVyZmxvd0hhbmRsZXJzKCk7XG4gICAgICB0aGlzLnJlZml0TmF2KCk7XG4gICAgICBET00ub24oRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKSwgJ2NsaWNrJywgdGhpcy50b2dnbGVNb3JlRHJvcGRvd24uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgb25Vbk1vdW50ICgpIHtcbiAgICB0aGlzLnVuYmluZE92ZXJmbG93SGFuZGxlcnMoKTtcbiAgfVxuXG4gIGJpbmRPdmVyZmxvd0hhbmRsZXJzICgpIHtcbiAgICBET00ub24od2luZG93LCAnY2xpY2snLCB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrKTtcbiAgfVxuXG4gIHVuYmluZE92ZXJmbG93SGFuZGxlcnMgKCkge1xuICAgIERPTS5vZmYod2luZG93LCAnY2xpY2snLCB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrKTtcbiAgfVxuXG4gIHJlZml0TmF2ICgpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtY29udGFpbmVyJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgY29uc3QgbWFpbkxpbmtzID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LWV4cGFuZGVkJyk7XG4gICAgY29uc3QgY29sbGFwc2VkTGlua3MgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcblxuICAgIGNvbnN0IG5hdldpZHRoID0gbW9yZUJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3l4dC1OYXYtaXRlbS0tbW9yZScpXG4gICAgICA/IGNvbnRhaW5lci5vZmZzZXRXaWR0aFxuICAgICAgOiBjb250YWluZXIub2Zmc2V0V2lkdGggLSBtb3JlQnV0dG9uLm9mZnNldFdpZHRoO1xuICAgIGxldCBudW1CcmVha3BvaW50cyA9IHRoaXMuX25hdkJyZWFrcG9pbnRzLmxlbmd0aDtcblxuICAgIC8vIHN1bSBjaGlsZCB3aWR0aHMgaW5zdGVhZCBvZiB1c2luZyBwYXJlbnQncyB3aWR0aCB0byBhdm9pZFxuICAgIC8vIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAgbGV0IG1haW5MaW5rc1dpZHRoID0gMDtcbiAgICBmb3IgKGxldCBlbCBvZiBtYWluTGlua3MuY2hpbGRyZW4pIHtcbiAgICAgIG1haW5MaW5rc1dpZHRoICs9IGVsLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChtYWluTGlua3NXaWR0aCA+IG5hdldpZHRoKSB7XG4gICAgICB0aGlzLl9uYXZCcmVha3BvaW50cy5wdXNoKG1haW5MaW5rc1dpZHRoKTtcbiAgICAgIGNvbnN0IGxhc3RMaW5rID0gbWFpbkxpbmtzLmNoaWxkcmVuLml0ZW0obWFpbkxpbmtzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGxhc3RMaW5rID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbGxhcHNlZExpbmtzLnByZXBlbmQobGFzdExpbmspO1xuXG4gICAgICBpZiAobW9yZUJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ3l4dC1OYXYtaXRlbS0tbW9yZScpKSB7XG4gICAgICAgIG1vcmVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgneXh0LU5hdi1pdGVtLS1tb3JlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChudW1CcmVha3BvaW50cyAmJiBuYXZXaWR0aCA+IHRoaXMuX25hdkJyZWFrcG9pbnRzW251bUJyZWFrcG9pbnRzIC0gMV0pIHtcbiAgICAgICAgY29uc3QgZmlyc3RMaW5rID0gY29sbGFwc2VkTGlua3MuY2hpbGRyZW4uaXRlbSgwKTtcbiAgICAgICAgaWYgKGZpcnN0TGluayA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYWluTGlua3MuYXBwZW5kKGZpcnN0TGluayk7XG4gICAgICAgIHRoaXMuX25hdkJyZWFrcG9pbnRzLnBvcCgpO1xuICAgICAgICBudW1CcmVha3BvaW50cy0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sbGFwc2VkTGlua3MuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1vcmVCdXR0b24uY2xhc3NMaXN0LmFkZCgneXh0LU5hdi1pdGVtLS1tb3JlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZU1vcmVEcm9wZG93bigpO1xuICAgIGlmIChtYWluTGlua3NXaWR0aCA+IG5hdldpZHRoIHx8XG4gICAgICAobnVtQnJlYWtwb2ludHMgPiAwICYmIG5hdldpZHRoID4gdGhpcy5fbmF2QnJlYWtwb2ludHNbbnVtQnJlYWtwb2ludHMgLSAxXSkpIHtcbiAgICAgIHRoaXMucmVmaXROYXYoKTtcbiAgICB9XG4gIH1cblxuICBjbG9zZU1vcmVEcm9wZG93biAoKSB7XG4gICAgY29uc3QgY29sbGFwc2VkID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vZGFsJyk7XG4gICAgY29sbGFwc2VkLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIGNvbnN0IG1vcmVCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9yZScpO1xuICAgIG1vcmVCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgb3Blbk1vcmVEcm9wZG93biAoKSB7XG4gICAgY29uc3QgY29sbGFwc2VkID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vZGFsJyk7XG4gICAgY29sbGFwc2VkLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgIGNvbnN0IG1vcmVCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9yZScpO1xuICAgIG1vcmVCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gIH1cblxuICB0b2dnbGVNb3JlRHJvcGRvd24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuICAgIGNvbGxhcHNlZC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBtb3JlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGNvbGxhcHNlZC5jbGFzc0xpc3QuY29udGFpbnMoJ2lzLWFjdGl2ZScpKTtcbiAgfVxuXG4gIGNoZWNrT3V0c2lkZUNsaWNrIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoJy55eHQtTmF2LWNvbnRhaW5lcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZU1vcmVEcm9wZG93bigpO1xuICB9XG5cbiAgY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yICgpIHtcbiAgICBpZiAodGhpcy5fY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3JUaW1lcik7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc2V0U3RhdGUuYmluZCh0aGlzKSwgUkVTSVpFX0RFQk9VTkNFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5jZSB0aGUgc2VydmVyIGRhdGEgb25seSBwcm92aWRlcyBhIGxpc3Qgb2ZcbiAgICogVlMgY29uZmlnSWRzLCB3ZSBuZWVkIHRvIGNvbXB1dGUgYW5kIHRyYW5zZm9ybVxuICAgKiB0aGUgZGF0YSBpbnRvIHRoZSBwcm9wZXIgZm9ybWF0IGZvciByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0U3RhdGUgKGRhdGEgPSB7fSkge1xuICAgIGlmIChkYXRhLnRhYk9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3RhYk9yZGVyID0gdGhpcy5tZXJnZVRhYk9yZGVyKGRhdGEudGFiT3JkZXIsIHRoaXMuX3RhYk9yZGVyKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB0aGUgdGFiIG9yZGVyaW5nIGNhbiBjaGFuZ2UgYmFzZWQgb24gdGhlIHNlcnZlciBkYXRhXG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgZWFjaCB0YWJzIFVSTCB0byBpbmNsdWRlIHRoZSBvcmRlciBhcyBwYXJ0IG9mIHRoZWlyIHBhcmFtcy5cbiAgICAvLyBUaGlzIGhlbHBzIHdpdGggcGVyc2lzdGluZyBzdGF0ZSBhY3Jvc3MgdmVydGljYWxzLlxuICAgIGxldCB0YWJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YWJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRhYiA9IHRoaXMuX3RhYnNbdGhpcy5fdGFiT3JkZXJbaV1dO1xuICAgICAgaWYgKHRhYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhYi51cmwgPSB0aGlzLmdlbmVyYXRlVGFiVXJsKHRhYi5iYXNlVXJsLCB0aGlzLmdldFVybFBhcmFtcygpKTtcbiAgICAgICAgdGFicy5wdXNoKHRhYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKHtcbiAgICAgIHRhYnM6IHRhYnMsXG4gICAgICBvdmVyZmxvd0xhYmVsOiB0aGlzLm92ZXJmbG93TGFiZWwsXG4gICAgICBvdmVyZmxvd0ljb246IHRoaXMub3ZlcmZsb3dJY29uLFxuICAgICAgc2hvd0NvbGxhcHNlOiB0aGlzLnNob3VsZENvbGxhcHNlKCksXG4gICAgICBhcmlhTGFiZWw6IHRoaXMuX2FyaWFMYWJlbFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VXJsUGFyYW1zICgpIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gIH1cblxuICBzaG91bGRDb2xsYXBzZSAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9tb2JpbGVPdmVyZmxvd0JlaGF2aW9yKSB7XG4gICAgICBjYXNlIE1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04uQ09MTEFQU0U6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OLklOTkVSU0NST0xMOlxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtY29udGFpbmVyJykgfHwgdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb25zdCBuYXZXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgcmV0dXJuIG5hdldpZHRoID4gTU9CSUxFX0JSRUFLUE9JTlQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldERlZmF1bHRUYWJPcmRlciB3aWxsIGNvbXB1dGUgdGhlIGluaXRpYWwgdGFiIG9yZGVyaW5nIGJhc2VkXG4gICAqIG9uIGEgY29tYmluYXRpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgZGlyZWN0bHkgdG8gdGhlIGNvbXBvbmVudFxuICAgKiBhbmQgdGhlIHVybCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IHRhYnNDb25maWdcbiAgICogQHBhcmFtIHtTZWFyY2hQYXJhbXN9XG4gICAqL1xuICBnZXREZWZhdWx0VGFiT3JkZXIgKHRhYnNDb25maWcsIHVybFBhcmFtcykge1xuICAgIGxldCB0YWJPcmRlciA9IFtdO1xuXG4gICAgLy8gVXNlIHRoZSBvcmRlcmluZyBmcm9tIHRoZSBVUkwgYXMgdGhlIHByaW1hcnkgY29uZmlndXJhdGlvblxuICAgIC8vIEFuZCB0aGVuIG1lcmdlIGl0IHdpdGggdGhlIGxvY2FsIGNvbmZpZ3VyYXRpb24sIGlmIHByb3ZpZGVkLlxuICAgIGlmICh1cmxQYXJhbXMgJiYgdXJsUGFyYW1zLmhhcygndGFiT3JkZXInKSkge1xuICAgICAgdGFiT3JkZXIgPSB1cmxQYXJhbXMuZ2V0KCd0YWJPcmRlcicpLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzQ29uZmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0YWIgPSB0YWJzQ29uZmlnW2ldO1xuICAgICAgLy8gU29tZSB0YWJzIGRvbid0IGhhdmUgY29uZmlnSWQsIHNvIHdlIG1hcCBpdCBmcm9tIFVSTFxuICAgICAgaWYgKHRhYi5jb25maWdJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhYi5jb25maWdJZCA9IHRhYi51cmw7XG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIGR1cGxpY2F0ZXMgaWYgY29uZmlnIHdhcyBwcm92aWRlZCBmcm9tIFVSTFxuICAgICAgaWYgKHRhYk9yZGVyLmluY2x1ZGVzKHRhYi5jb25maWdJZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlzRmlyc3Qgc2hvdWxkIGFsd2F5cyBiZSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGlzdFxuICAgICAgaWYgKHRhYi5pc0ZpcnN0KSB7XG4gICAgICAgIHRhYk9yZGVyLnVuc2hpZnQodGFiLmNvbmZpZ0lkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYk9yZGVyLnB1c2godGFiLmNvbmZpZ0lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFiT3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogbWVyZ2VUYWJPcmRlciBtZXJnZXMgdHdvIGFycmF5cyBpbnRvIG9uZVxuICAgKiBieSBhcHBlbmRpbmcgYWRkaXRpb25hbCB0YWJzIHRvIHRoZSBlbmQgb2YgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHRhYk9yZGVyIFRhYiBvcmRlciBwcm92aWRlZCBieSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG90aGVyVGFiT3JkZXIgVGFiIG9yZGVyIHByb3ZpZGVkIGJ5IGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW119XG4gICAqL1xuICBtZXJnZVRhYk9yZGVyICh0YWJPcmRlciwgb3RoZXJUYWJPcmRlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3RoZXJUYWJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFiQ29uZmlnID0gb3RoZXJUYWJPcmRlcltpXTtcbiAgICAgIGlmICh0YWJPcmRlci5pbmNsdWRlcyh0YWJDb25maWcpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpc0ZpcnN0IHNob3VsZCBiZSBhbiBvdmVycmlkZSB0byBkeW5hbWljIHRhYiBvcmRlcmluZy5cbiAgICAgIGlmICh0aGlzLl90YWJzW3RhYkNvbmZpZ10gJiYgdGhpcy5fdGFic1t0YWJDb25maWddLmlzRmlyc3QpIHtcbiAgICAgICAgdGFiT3JkZXIudW5zaGlmdCh0YWJDb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFiT3JkZXIucHVzaCh0YWJDb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWJPcmRlcjtcbiAgfVxuXG4gIGdlbmVyYXRlVGFiVXJsIChiYXNlVXJsLCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCkpIHtcbiAgICAvLyBXZSB3YW50IHRvIHBlcnNpc3QgdGhlIHBhcmFtcyBmcm9tIHRoZSBleGlzdGluZyBVUkwgdG8gdGhlIG5ld1xuICAgIC8vIFVSTFMgd2UgY3JlYXRlLlxuICAgIHBhcmFtcy5zZXQoJ3RhYk9yZGVyJywgdGhpcy5fdGFiT3JkZXIpO1xuICAgIHJldHVybiBiYXNlVXJsICsgJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uL2RvbS9zZWFyY2hwYXJhbXMnO1xuXG4vKipcbiAqIFNlYXJjaENvbXBvbmVudCBleHBvc2VzIGFuIGludGVyZmFjZSBpbiBvcmRlciB0byBjcmVhdGVcbiAqIGEgVUkgU2VhcmNoIGV4cGVyaWVuY2UgZm9yIHZlcnRpY2FsIGFuZCB1bml2ZXJzYWwgc2VhcmNoLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIHZlcnRpY2FsIGtleSBmb3IgdmVydGljYWwgc2VhcmNoIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIGF1dG8tY29tcGxldGUgYW5kIHNlYXJjaCB3aWxsIGJlIGJhc2VkIG9uIHVuaXZlcnNhbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHN1Ym1pc3Npb24gaXMgYmFzZWQgb24gYSBmb3JtIGFzIGNvbnRleHQuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZCwgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIG5hdGl2ZSBmb3JtIG5vZGUgd2l0aGluIGNvbnRhaW5lclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgICAqL1xuICAgIHRoaXMuX2Zvcm1FbCA9IGNvbmZpZy5mb3JtU2VsZWN0b3IgfHwgJ2Zvcm0nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGlucHV0IGVsZW1lbnQgdXNlZCBmb3Igc2VhcmNoaW5nIGFuZCB3aXJlcyB1cCB0aGUga2V5Ym9hcmQgaW50ZXJhY3Rpb25cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgICAqL1xuICAgIHRoaXMuX2lucHV0RWwgPSBjb25maWcuaW5wdXRFbCB8fCAnLmpzLXlleHQtcXVlcnknO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHVzZWQsIHByb3ZpZGVkIHRvIHRoZSB0ZW1wbGF0ZSBhcyBhIGRhdGEgcG9pbnRcbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLiBJZiBub3QgcHJvdmlkZWQsIG5vIHRpdGxlIHdpbGwgYmUgaW5jbHVkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gY29uZmlnLnRpdGxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRleHQgaXMgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGlucHV0IGJveCwgYWxzbyBwcm92aWRlZCB0byB0ZW1wbGF0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsVGV4dCA9IGNvbmZpZy5sYWJlbFRleHQgfHwgJ0NvbmR1Y3QgYSBzZWFyY2gnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN1Ym1pdCB0ZXh0IGlzIHVzZWQgZm9yIGxhYmVsaW5nIHRoZSBzdWJtaXQgYnV0dG9uLCBhbHNvIHByb3ZpZGVkIHRvIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3VibWl0VGV4dCA9IGNvbmZpZy5zdWJtaXRUZXh0IHx8ICdTdWJtaXQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsZWFyIHRleHQgaXMgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGNsZWFyIGJ1dHRvbiwgYWxzbyBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyVGV4dCA9IGNvbmZpZy5jbGVhclRleHQgfHwgJ0NsZWFyJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdWJtaXQgaWNvbiBpcyBhbiBpY29uIGZvciB0aGUgc3VibWl0IGJ1dHRvbiwgaWYgcHJvdmlkZWQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQgYW5kIHRoZVxuICAgICAqIHN1Ym1pdCB0ZXh0IHdpbGwgYmUgdXNlZCBmb3Igc2NyZWVuIHJlYWRlcnMuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3VibWl0SWNvbiA9IGNvbmZpZy5zdWJtaXRJY29uIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgdGV4dCB0byBzaG93IGFzIHRoZSBmaXJzdCBpdGVtIGZvciBhdXRvIGNvbXBsZXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvbXB0SGVhZGVyID0gY29uZmlnLnByb21wdEhlYWRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXV0byBmb2N1c2VzIHRoZSBpbnB1dCBib3ggaWYgc2V0IHRvIHRydWUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZCwgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdXRvRm9jdXMgPSBjb25maWcuYXV0b0ZvY3VzID09PSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhbiBcInhcIiB0aGF0IGFsbG93cyB0aGUgdXNlciB0byBjbGVhciB0aGUgY3VycmVudFxuICAgICAqIHF1ZXJ5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jbGVhckJ1dHRvbiA9IGNvbmZpZy5jbGVhckJ1dHRvbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHRydWVcbiAgICAgIDogY29uZmlnLmNsZWFyQnV0dG9uO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBhdXRvZm9jdXNpbmcgb24gbG9hZCwgb3B0aW9uYWxseSBvcGVuIHRoZSBhdXRvY29tcGxldGVcbiAgICAgKiAocHJlc2V0IHByb21wdHMpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdXRvY29tcGxldGVPbkxvYWQgPSBjb25maWcuYXV0b2NvbXBsZXRlT25Mb2FkIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogc3VibWl0VVJMIHdpbGwgZm9yY2UgdGhlIHNlYXJjaCBxdWVyeSBzdWJtaXNzaW9uIHRvIGdldFxuICAgICAqIHJlZGlyZWN0ZWQgdG8gdGhlIFVSTCBwcm92aWRlZC5cbiAgICAgKiBPcHRpb25hbCwgZGVmYXVsdHMgdG8gbnVsbC5cbiAgICAgKlxuICAgICAqIElmIG5vIHJlZGlyZWN0VXJsIHByb3ZpZGVkLCB3ZSBrZWVwIHRoZSBwYWdlIGFzIGEgc2luZ2xlIHBhZ2UgYXBwLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZWRpcmVjdFVybCA9IGNvbmZpZy5yZWRpcmVjdFVybCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGVyZSBpcyBhbm90aGVyIHNlYXJjaCBiYXIgcHJlc2VudCBvbiB0aGUgcGFnZS5cbiAgICAgKiBUd2lucyBvbmx5IHVwZGF0ZSB0aGUgcXVlcnksIGFuZCBkbyBub3Qgc2VhcmNoXG4gICAgICovXG4gICAgdGhpcy5faXNUd2luID0gY29uZmlnLmlzVHdpbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgdG8gdXNlIGZvciB0aGUgaW5wdXQgYm94LCBwcm92aWRlZCB0byB0ZW1wbGF0ZSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IGNvbmZpZy5xdWVyeSB8fCB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlFVRVJZLCBxID0+IHtcbiAgICAgIHRoaXMucXVlcnkgPSBxO1xuICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5kZWJvdW5jZWRTZWFyY2gocSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSB0aW1lIGFsbG93ZWQgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gc2VhcmNoZXMgdG8gcHJldmVudFxuICAgICAqIG1hbnkgZHVwbGljYXRlIHNlYXJjaGVzIGJhY2stdG8tYmFja1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hDb29sZG93biA9IGNvbmZpZy5zZWFyY2hDb29sZG93biB8fCAzMDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgYW5kIFwibmVhciBtZVwiIGludGVudCBpcyBleHByZXNzZWQsIHByb21wdCB0aGUgdXNlciBmb3IgdGhlaXIgZ2VvbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Byb21wdEZvckxvY2F0aW9uID0gY29uZmlnLnByb21wdEZvckxvY2F0aW9uID09PSB1bmRlZmluZWRcbiAgICAgID8gdHJ1ZVxuICAgICAgOiBCb29sZWFuKGNvbmZpZy5wcm9tcHRGb3JMb2NhdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHNlYXJjaCBjbGVhciBidXR0b25cbiAgICAgKi9cbiAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSB0aGlzLmNsZWFyQnV0dG9uICYmIHRoaXMucXVlcnk7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdmVydGljYWwgc2VhcmNoIGJhcnMsIHdoZXRoZXIgb3Igbm90IHRvIGFsbG93IGVtcHR5IHNlYXJjaGVzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYWxsb3dFbXB0eVNlYXJjaCA9ICEhY29uZmlnLmFsbG93RW1wdHlTZWFyY2g7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgQXV0b0NvbXBsZXRlIGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYXV0b0NvbXBsZXRlTmFtZSA9IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdTZWFyY2hCYXInO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvc2VhcmNoJztcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBpZiAodGhpcy5xdWVyeSAhPSBudWxsICYmICF0aGlzLnJlZGlyZWN0VXJsKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0UXVlcnkodGhpcy5xdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gTk9URShhbXVsbGluZ3MpOiBJZiBhdXRvY29tcGxldGVPbkxvYWQgaXMgZmFsc2UsIHdlIGZvY3VzIHRoZSBpbnB1dFxuICAgIC8vIGVsZW1lbnQgYmVmb3JlIGxvYWRpbmcgdGhlIGF1dG9jb21wbGV0ZSBjb21wb25lbnQgc28gdGhhdCBpdHMgZm9jdXNcbiAgICAvLyBoYW5kbGVyIHdvbid0IGJlIHRyaWdnZXJlZFxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyA9PT0gdHJ1ZSAmJiAhdGhpcy5xdWVyeSAmJiAhdGhpcy5hdXRvY29tcGxldGVPbkxvYWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyBXaXJlIHVwIG91ciBzZWFyY2ggaGFuZGxpbmcgYW5kIGF1dG8gY29tcGxldGVcbiAgICB0aGlzLmluaXRTZWFyY2godGhpcy5fZm9ybUVsKTtcbiAgICB0aGlzLmluaXRBdXRvQ29tcGxldGUodGhpcy5faW5wdXRFbCk7XG5cbiAgICBpZiAodGhpcy5jbGVhckJ1dHRvbikge1xuICAgICAgdGhpcy5pbml0Q2xlYXJCdXR0b24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMgPT09IHRydWUgJiYgIXRoaXMucXVlcnkgJiYgdGhpcy5hdXRvY29tcGxldGVPbkxvYWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIGluaXRDbGVhckJ1dHRvbiAoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtU2VhcmNoQmFyLWNsZWFyJyk7XG4gICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdGhpcy5fc2hvd0NsZWFyQnV0dG9uIHx8IHRoaXMucXVlcnk7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicsICF0aGlzLl9zaG93Q2xlYXJCdXR0b24pO1xuXG4gICAgRE9NLm9uKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gZmFsc2U7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci0taGlkZGVuJyk7XG4gICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUlksIHRoaXMucXVlcnkpO1xuICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5zZXRRdWVyeSh0aGlzLnF1ZXJ5KTtcblxuICAgICAgLy8gRm9jdXMgdGhlIGlucHV0IGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgdGhlIHF1ZXJ5LCByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICAgIC8vIG9yIG5vdCB0aGUgYXV0b0ZvY3VzIG9wdGlvbiBpcyBlbmFibGVkLlxuICAgICAgLy8gTk9URShhbXVsbGluZ3MpOiBUaGlzIGRlcGVuZHMgaGVhdmlseSBvbiB0aGUgZmFjdCB0aGF0IHRoZSByZS1yZW5kZXJzXG4gICAgICAvLyB0cmlnZ2VyZWQgYnkgc2V0U3RhdGUgYW5kIGNvcmUuc2V0UXVlcnkgaGFwcGVuIHN5bmNocm9ub3VzbHk7IGlmIHRoaXNcbiAgICAgIC8vIHN0b3BzIGJlaW5nIHRoZSBjYXNlIGF0IHNvbWUgcG9pbnQsIHdlJ2xsIG5lZWQgYW4gYWx0ZXJuYXRpdmUgc29sdXRpb25cbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0ID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCk7XG4gICAgRE9NLm9uKGlucHV0LCAnaW5wdXQnLCBlID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX3Nob3dDbGVhckJ1dHRvbiAmJiBpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3Nob3dDbGVhckJ1dHRvbiA9IHRydWU7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hvd0NsZWFyQnV0dG9uICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB1c2UgZm9yIHdpcmluZyB1cCBzZWFyY2hpbmcgb24gZm9ybSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtU2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIHN1Ym1pdCBoYW5kbGluZyB0b1xuICAgKi9cbiAgaW5pdFNlYXJjaCAoZm9ybVNlbGVjdG9yKSB7XG4gICAgdGhpcy5fZm9ybUVsID0gZm9ybVNlbGVjdG9yO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItd3JhcHBlcicpO1xuXG4gICAgbGV0IGZvcm0gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBmb3JtU2VsZWN0b3IpO1xuICAgIGlmICghZm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBTZWFyY2hCYXI7IENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9mb3JtRWwsICdgLicpO1xuICAgIH1cblxuICAgIERPTS5vbihmb3JtLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbGV0IGlucHV0RWwgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IodGhpcy5faW5wdXRFbCk7XG5cbiAgICAgIGxldCBxdWVyeSA9IGlucHV0RWwudmFsdWU7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlZGlyZWN0VXJsLCB3ZSB3YW50IHRoZSBmb3JtIHRvIGJlXG4gICAgICAvLyBzZXJpYWxpemVkIGFuZCBzdWJtaXR0ZWQuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucmVkaXJlY3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5yZWRpcmVjdFVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlucHV0RWwuYmx1cigpO1xuXG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCBxdWVyeSk7XG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIHRoaXMuZGVib3VuY2VkU2VhcmNoKHF1ZXJ5KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdG8gd2lyZSB1cCBvdXIgYXV0byBjb21wbGV0ZSBvbiBhbiBpbnB1dCBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRTZWxlY3RvciBDU1Mgc2VsZWN0b3IgdG8gYmluZCBvdXIgYXV0byBjb21wbGV0ZSBjb21wb25lbnQgdG9cbiAgICovXG4gIGluaXRBdXRvQ29tcGxldGUgKGlucHV0U2VsZWN0b3IpIHtcbiAgICB0aGlzLl9pbnB1dEVsID0gaW5wdXRTZWxlY3RvcjtcblxuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdXRvY29tcGxldGUgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IHRoaXMuX2F1dG9Db21wbGV0ZU5hbWUsXG4gICAgICBjb250YWluZXI6ICcueXh0LVNlYXJjaEJhci1hdXRvY29tcGxldGUnLFxuICAgICAgYXV0b0ZvY3VzOiB0aGlzLmF1dG9Gb2N1cyAmJiAhdGhpcy5hdXRvY29tcGxldGVPbkxvYWQsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBwcm9tcHRIZWFkZXI6IHRoaXMucHJvbXB0SGVhZGVyLFxuICAgICAgb3JpZ2luYWxRdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIGlucHV0RWw6IGlucHV0U2VsZWN0b3IsXG4gICAgICBvblN1Ym1pdDogKCkgPT4ge1xuICAgICAgICBET00udHJpZ2dlcihET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCB0aGlzLl9mb3JtRWwpLCAnc3VibWl0Jyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgRE9NLnRyaWdnZXIoRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgaW5wdXRTZWxlY3RvciksICdpbnB1dCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgZGVib3VuY2VkIHF1ZXJ5IHVzaW5nIHRoZSBwcm92aWRlZCBzdHJpbmcgaW5wdXQuIFNwZWNpZmljYWxseSwgYSBuZXcgc2VhcmNoIGlzIG5vdFxuICAgKiBwZXJmb3JtZWQgaWYgd2UgcmVjZW50bHkgc2VhcmNoZWQsIGlmIHRoZXJlJ3Mgbm8gcXVlcnkgZm9yIHVuaXZlcnNhbCBzZWFyY2gsIG9yIGlmIHRoaXNcbiAgICogaXMgYSB0d2luIHNlYXJjaGJhci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IFRoZSBzdHJpbmcgdG8gcXVlcnkgYWdhaW5zdC5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgcGVyZm9ybSB0aGUgcXVlcnkgYW5kIHVwZGF0ZSBnbG9iYWxTdG9yYWdlIGFjY29yZGluZ2x5LlxuICAgKi9cbiAgZGVib3VuY2VkU2VhcmNoIChxdWVyeSkge1xuICAgIGlmICh0aGlzLl90aHJvdHRsZWQgfHxcbiAgICAgICghcXVlcnkgJiYgIXRoaXMuX3ZlcnRpY2FsS2V5KSB8fFxuICAgICAgKCFxdWVyeSAmJiB0aGlzLl92ZXJ0aWNhbEtleSAmJiAhdGhpcy5fYWxsb3dFbXB0eVNlYXJjaCkgfHxcbiAgICAgIHRoaXMuX2lzVHdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Rocm90dGxlZCA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuX3Rocm90dGxlZCA9IGZhbHNlOyB9LCB0aGlzLl9zZWFyY2hDb29sZG93bik7XG5cbiAgICAvLyBJZiBfcHJvbXB0Rm9yTG9jYXRpb24gaXMgZW5hYmxlZCwgd2Ugd2lsbCBjb21wdXRlIHRoZSBxdWVyeSdzIGludGVudCBhbmQsIGZyb20gdGhlcmUsXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGl0J3MgbmVjZXNzYXJ5IHRvIHByb21wdCB0aGUgdXNlciBmb3IgdGhlaXIgbG9jYXRpb24gaW5mb3JtYXRpb24uIEl0IHdpbGxcbiAgICAvLyBiZSB1bm5lY2Vzc2FyeSBpZiB0aGUgcXVlcnkgZG9lcyBub3QgaGF2ZSBuZWFyIG1lIGludGVudCBvciB3ZSBhbHJlYWR5IGhhdmUgdGhlaXIgbG9jYXRpb25cbiAgICAvLyBzdG9yZWQuXG4gICAgaWYgKHRoaXMuX3Byb21wdEZvckxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmZldGNoUXVlcnlJbnRlbnRzKHF1ZXJ5KVxuICAgICAgICAudGhlbihxdWVyeUludGVudHMgPT4gcXVlcnlJbnRlbnRzLmluY2x1ZGVzKCdORUFSX01FJykpXG4gICAgICAgIC50aGVuKHF1ZXJ5SGFzTmVhck1lSW50ZW50ID0+IHtcbiAgICAgICAgICBpZiAocXVlcnlIYXNOZWFyTWVJbnRlbnQgJiYgIXRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zZWFyY2gocXVlcnkpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICgpID0+IHJlc29sdmUodGhpcy5zZWFyY2gocXVlcnkpKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaChxdWVyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBxdWVyeSB1c2luZyB0aGUgcHJvdmlkZWQgc3RyaW5nIGlucHV0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHN0cmluZyB0byBxdWVyeSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBwZXJmb3JtIHRoZSBxdWVyeSBhbmQgdXBkYXRlIGdsb2JhbFN0b3JhZ2UgYWNjb3JkaW5nbHkuXG4gICAqL1xuICBzZWFyY2ggKHF1ZXJ5KSB7XG4gICAgaWYgKHRoaXMuX3ZlcnRpY2FsS2V5KSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgICAgOiBhbGxGaWx0ZXJzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl92ZXJ0aWNhbEtleSwge1xuICAgICAgICBpbnB1dDogcXVlcnksXG4gICAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgICBvZmZzZXQ6IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOT1RFKGJpbGx5KSBUZW1wb3JhcnkgaGFjayBmb3IgREVNT1xuICAgICAgLy8gUmVtb3ZlIG1lIGFmdGVyIHRoZSBkZW1vXG4gICAgICBsZXQgbmF2ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyXG4gICAgICAgIC5nZXRBY3RpdmVDb21wb25lbnQoJ05hdmlnYXRpb24nKTtcblxuICAgICAgaWYgKG5hdikge1xuICAgICAgICBsZXQgdGFicyA9IG5hdi5nZXRTdGF0ZSgndGFicycpO1xuICAgICAgICBsZXQgdXJscyA9IHt9O1xuXG4gICAgICAgIGlmICh0YWJzICYmIEFycmF5LmlzQXJyYXkodGFicykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHRhYnNbaV0udXJsLnNwbGl0KCc/JylbMV0pO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgncXVlcnknLCBxdWVyeSk7XG5cbiAgICAgICAgICAgIGxldCB1cmwgPSB0YWJzW2ldLmJhc2VVcmw7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnRvU3RyaW5nKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmxzW3RhYnNbaV0uY29uZmlnSWRdID0gdXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3JlLnNlYXJjaChxdWVyeSwgdXJscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvcmUuc2VhcmNoKHF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgY29tcHV0ZXMgdGhlIGludGVudHMgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2FzIGVudGVyZWRcbiAgICogbWFudWFsbHkgaW50byB0aGUgc2VhcmNoIGJhciBvciBzZWxlY3RlZCB2aWEgYXV0b2NvbXBsZXRlLCBpdHMgaW50ZW50cyB3aWxsIGhhdmUgYmVlbiBzdG9yZWRcbiAgICogYWxyZWFkeSBpbiBnbG9iYWxTdG9yYWdlLiBPdGhlcndpc2UsIGEgbmV3IEFQSSBjYWxsIHdpbGwgaGF2ZSB0byBiZSBpc3N1ZWQgdG8gZGV0ZXJtaW5lXG4gICAqIGludGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSBpbnRlbnQgaXMgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGludGVudHMgb2YgdGhlIHF1ZXJ5LlxuICAgKi9cbiAgZmV0Y2hRdWVyeUludGVudHMgKHF1ZXJ5KSB7XG4gICAgY29uc3QgYXV0b2NvbXBsZXRlRGF0YSA9XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7dGhpcy5fYXV0b0NvbXBsZXRlTmFtZX1gKTtcbiAgICBpZiAoIWF1dG9jb21wbGV0ZURhdGEpIHtcbiAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZVJlcXVlc3QgPSB0aGlzLl92ZXJ0aWNhbEtleVxuICAgICAgICA/IHRoaXMuY29yZS5hdXRvQ29tcGxldGVWZXJ0aWNhbChcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB0aGlzLl9hdXRvQ29tcGxldGVOYW1lLFxuICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsS2V5KVxuICAgICAgICA6IHRoaXMuY29yZS5hdXRvQ29tcGxldGVVbml2ZXJzYWwocXVlcnksIHRoaXMuX2F1dG9Db21wbGV0ZU5hbWUpO1xuICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVJlcXVlc3QudGhlbihkYXRhID0+IGRhdGEuaW5wdXRJbnRlbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHR3byBhbHRlcm5hdGl2ZXMgdG8gY29uc2lkZXIgaGVyZS4gVGhlIHVzZXIgY291bGQgaGF2ZSBzZWxlY3RlZCB0aGUgcXVlcnlcbiAgICAgIC8vIGFzIGFuIGF1dG9jb21wbGV0ZSBvcHRpb24gb3IgbWFudWFsbHkgaW5wdXQgaXQgdGhlbXNlbHZlcy4gSWYgdGhlIGZvcm1lciwgdXNlIHRoZSBpbnRlbnRzXG4gICAgICAvLyBvZiB0aGUgY29ycmVzcG9uZGluZyBhdXRvY29tcGxldGUgb3B0aW9uLiBJZiB0aGUgbGF0dGVyLCB1c2UgdGhlIGlucHV0SW50ZW50cyBvZiB0aGVcbiAgICAgIC8vIGF1dG9jb21wbGV0ZURhdGEuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXV0b2NvbXBsZXRlRGF0YS5zZWN0aW9ucy5mbGF0TWFwKHNlY3Rpb24gPT4gc2VjdGlvbi5yZXN1bHRzKTtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUmVzdWx0ID0gcmVzdWx0cy5maW5kKHJlc3VsdCA9PiByZXN1bHQudmFsdWUgPT09IHF1ZXJ5KTtcbiAgICAgIGNvbnN0IHF1ZXJ5SW50ZW50cyA9IG1hdGNoaW5nUmVzdWx0ID8gbWF0Y2hpbmdSZXN1bHQuaW50ZW50cyA6IGF1dG9jb21wbGV0ZURhdGEuaW5wdXRJbnRlbnRzO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShxdWVyeUludGVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBjb25zdHJ1Y3RzIHRoZSBtZXRhIGluZm9ybWF0aW9uIG5lZWRlZCBieSB0aGUgU0VBUkNIX0NMRUFSX0JVVFRPTlxuICAgKiBhbmFseXRpY3MgZXZlbnQuXG4gICAqL1xuICBldmVudE9wdGlvbnMgKCkge1xuICAgIGNvbnN0IHF1ZXJ5SWQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWV9JRCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHF1ZXJ5SWQgJiYgeyBxdWVyeUlkIH0sXG4gICAgICB0aGlzLl92ZXJ0aWNhbEtleSAmJiB7IHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSB9XG4gICAgKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgICAgbGFiZWxUZXh0OiB0aGlzLmxhYmVsVGV4dCxcbiAgICAgIHN1Ym1pdEljb246IHRoaXMuc3VibWl0SWNvbixcbiAgICAgIHN1Ym1pdFRleHQ6IHRoaXMuc3VibWl0VGV4dCxcbiAgICAgIGNsZWFyVGV4dDogdGhpcy5jbGVhclRleHQsXG4gICAgICBzaG93Q2xlYXJCdXR0b246IHRoaXMuX3Nob3dDbGVhckJ1dHRvbixcbiAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5IHx8ICcnLFxuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucygpXG4gICAgfSwgZGF0YSkpO1xuICB9XG5cbiAgZm9jdXNJbnB1dEVsZW1lbnQgKCkge1xuICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2lucHV0RWwpLmZvY3VzKCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaFBhcmFtc1BhcnNlciAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFNlYXJjaFBhcmFtZXRlcnMgKHNlYXJjaFBhcmFtZXRlckNvbmZpZ3MpIHtcbiAgbGV0IHNlYXJjaFBhcmFtZXRlcnMgPSB7XG4gICAgc2VjdGlvbmVkOiBmYWxzZSxcbiAgICBmaWVsZHM6IFtdXG4gIH07XG4gIGlmIChzZWFyY2hQYXJhbWV0ZXJDb25maWdzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2VhcmNoUGFyYW1ldGVycztcbiAgfVxuICBpZiAoc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5zZWN0aW9uZWQpIHtcbiAgICBzZWFyY2hQYXJhbWV0ZXJzLnNlY3Rpb25lZCA9IHNlYXJjaFBhcmFtZXRlckNvbmZpZ3Muc2VjdGlvbmVkO1xuICB9XG4gIHNlYXJjaFBhcmFtZXRlcnMuZmllbGRzID0gYnVpbGRGaWVsZHMoc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5maWVsZHMpO1xuICByZXR1cm4gc2VhcmNoUGFyYW1ldGVycztcbn1cblxuZnVuY3Rpb24gYnVpbGRGaWVsZHMgKGZpZWxkQ29uZmlncykge1xuICBpZiAoZmllbGRDb25maWdzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gZmllbGRDb25maWdzLm1hcChmYyA9PiAoeyBmZXRjaEVudGl0aWVzOiBmYWxzZSwgLi4uZmMgfSkpO1xufVxuIiwiLyoqIEBtb2R1bGUgRmlsdGVyU2VhcmNoQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgYnVpbGRTZWFyY2hQYXJhbWV0ZXJzIGZyb20gJy4uLy4uL3Rvb2xzL3NlYXJjaHBhcmFtc3BhcnNlcic7XG5cbi8qKlxuICogRmlsdGVyU2VhcmNoQ29tcG9uZW50IGlzIHVzZWQgZm9yIGF1dG9jb21wbGV0ZSB1c2luZyB0aGUgRmlsdGVyU2VhcmNoIGJhY2tlbmQuXG4gKiBJdCdsbCBhbGxvdyB5b3UgdG8gcGljayBwcmUtc2V0IGZpbHRlcnMgdGhhdCBhcmUgc2V0dXAgb24gdGhlIGJhY2tlbmQgd2l0aGluXG4gKiBhIHZlcnRpY2FsIHNlYXJjaCBjb250ZXh0LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJTZWFyY2hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSBmb3IgdmVydGljYWwgc2VhcmNoIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZSB0aGUgZmlsdGVyIHZhbHVlIGJ1dCBkbyBub3Qgc2VhcmNoIG9uIGNoYW5nZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUXVlcnkgc3VibWlzc2lvbiBpcyBiYXNlZCBvbiBhIGZvcm0gYXMgY29udGV4dC5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gbmF0aXZlIGZvcm0gbm9kZSB3aXRoaW4gY29udGFpbmVyXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1TZWxlY3RvciB8fCAnZm9ybSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgZWxlbWVudCB1c2VkIGZvciBzZWFyY2hpbmcgYW5kIHdpcmVzIHVwIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvblxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5faW5wdXRFbCA9IGNvbmZpZy5pbnB1dEVsIHx8ICcuanMteWV4dC1xdWVyeSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdXNlZCwgcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlIGFzIGEgZGF0YSBwb2ludFxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gY29uZmlnLnRpdGxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlYXJjaCB0ZXh0IHVzZWQgZm9yIGxhYmVsaW5nIHRoZSBpbnB1dCBib3gsIGFsc28gcHJvdmlkZWQgdG8gdGVtcGxhdGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hUZXh0ID0gY29uZmlnLnNlYXJjaFRleHQgfHwgJ1doYXQgYXJlIHlvdSBpbnRlcmVzdGVkIGluPyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgdGV4dCB0byBzaG93IGFzIHRoZSBmaXJzdCBpdGVtIGZvciBhdXRvIGNvbXBsZXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvbXB0SGVhZGVyID0gY29uZmlnLnByb21wdEhlYWRlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXV0byBmb2N1c2VzIHRoZSBpbnB1dCBib3ggaWYgc2V0IHRvIHRydWUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZCwgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdXRvRm9jdXMgPSBjb25maWcuYXV0b0ZvY3VzID09PSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogc3VibWl0VVJMIHdpbGwgZm9yY2UgdGhlIHNlYXJjaCBxdWVyeSBzdWJtaXNzaW9uIHRvIGdldFxuICAgICAqIHJlZGlyZWN0ZWQgdG8gdGhlIFVSTCBwcm92aWRlZC5cbiAgICAgKiBPcHRpb25hbCwgZGVmYXVsdHMgdG8gbnVsbC5cbiAgICAgKlxuICAgICAqIElmIG5vIHJlZGlyZWN0VXJsIHByb3ZpZGVkLCB3ZSBrZWVwIHRoZSBwYWdlIGFzIGEgc2luZ2xlIHBhZ2UgYXBwLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZWRpcmVjdFVybCA9IGNvbmZpZy5yZWRpcmVjdFVybCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHN0cmluZyB0byB1c2UgZm9yIHRoZSBpbnB1dCBib3gsIHByb3ZpZGVkIHRvIHRlbXBsYXRlIGZvciByZW5kZXJpbmcuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IGNvbmZpZy5xdWVyeSB8fCB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCkgfHwgJyc7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gLCBxID0+IHtcbiAgICAgIHRoaXMucXVlcnkgPSBxO1xuICAgICAgdGhpcy5zZWFyY2goKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIHByb3ZpZGVkIHF1ZXJ5XG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXIgPSBjb25maWcuZmlsdGVyIHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCkgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gSlNPTi5wYXJzZSh0aGlzLmZpbHRlcik7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoUGFyYW1ldGVycyA9IGJ1aWxkU2VhcmNoUGFyYW1ldGVycyhjb25maWcuc2VhcmNoUGFyYW1ldGVycyk7XG5cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gLCBmID0+IHsgdGhpcy5maWx0ZXIgPSBmOyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdGaWx0ZXJTZWFyY2gnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvZmlsdGVyc2VhcmNoJztcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBpZiAodGhpcy5xdWVyeSAmJiB0aGlzLmZpbHRlcikge1xuICAgICAgdGhpcy5zZWFyY2goKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBXaXJlIHVwIG91ciBzZWFyY2ggaGFuZGxpbmcgYW5kIGF1dG8gY29tcGxldGVcbiAgICB0aGlzLmluaXRBdXRvQ29tcGxldGUodGhpcy5faW5wdXRFbCk7XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMgPT09IHRydWUgJiYgdGhpcy5xdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2lucHV0RWwpLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB3aXJlIHVwIG91ciBhdXRvIGNvbXBsZXRlIG9uIGFuIGlucHV0IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFNlbGVjdG9yIENTUyBzZWxlY3RvciB0byBiaW5kIG91ciBhdXRvIGNvbXBsZXRlIGNvbXBvbmVudCB0b1xuICAgKi9cbiAgaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIHRoaXMuX2lucHV0RWwgPSBpbnB1dFNlbGVjdG9yO1xuXG4gICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZSgnQXV0b0NvbXBsZXRlJywge1xuICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICBuYW1lOiBgJHt0aGlzLm5hbWV9LmF1dG9jb21wbGV0ZWAsXG4gICAgICBpc0ZpbHRlclNlYXJjaDogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogJy55eHQtU2VhcmNoQmFyLWF1dG9jb21wbGV0ZScsXG4gICAgICBwcm9tcHRIZWFkZXI6IHRoaXMucHJvbXB0SGVhZGVyLFxuICAgICAgb3JpZ2luYWxRdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIG9yaWdpbmFsRmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgIGlucHV0RWw6IGlucHV0U2VsZWN0b3IsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBzZWFyY2hQYXJhbWV0ZXJzOiB0aGlzLnNlYXJjaFBhcmFtZXRlcnMsXG4gICAgICBvblN1Ym1pdDogKHF1ZXJ5LCBmaWx0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIHBhcmFtcy5zZXQoYCR7dGhpcy5uYW1lfS5xdWVyeWAsIHF1ZXJ5KTtcbiAgICAgICAgcGFyYW1zLnNldChgJHt0aGlzLm5hbWV9LmZpbHRlcmAsIGZpbHRlcik7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlZGlyZWN0VXJsLCB3ZSB3YW50IHRoZSBwYXJhbXMgdG8gYmVcbiAgICAgICAgLy8gc2VyaWFsaXplZCBhbmQgc3VibWl0dGVkLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVkaXJlY3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnJlZGlyZWN0VXJsICsgJz8nICsgcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgZmlsdGVyIHRvIHN0b3JhZ2UgZm9yIHRoZSBuZXh0IHNlYXJjaFxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gRmlsdGVyLmZyb21SZXNwb25zZShmaWx0ZXIpO1xuICAgICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gLCB0aGlzLnF1ZXJ5KTtcbiAgICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5zZWFyY2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSB2ZXJ0aWNhbCBzZWFyY2ggd2l0aCBhbGwgc2F2ZWQgZmlsdGVycyBhbmQgcXVlcnksXG4gICAqIG9wdGlvbmFsbHkgcmVkaXJlY3RpbmcgYmFzZWQgb24gY29uZmlnXG4gICAqL1xuICBzZWFyY2ggKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGxldCB0b3RhbEZpbHRlciA9IGZpbHRlcnNbMF07XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgdG90YWxGaWx0ZXIgPSBGaWx0ZXIuYW5kKC4uLmZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBzZWFyY2hRdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSB8fCAnJztcbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuXG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICBpbnB1dDogc2VhcmNoUXVlcnksXG4gICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBzZWFyY2hUZXh0OiB0aGlzLnNlYXJjaFRleHQsXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICB9LCBkYXRhKSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEF1dG9Db21wbGV0ZUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmNvbnN0IEtleXMgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQ0FQRTogMjcsXG5cbiAgTEVGVDogMzcsXG4gIFJJR0hUOiAzOSxcbiAgVVA6IDM4LFxuXG4gIERFTEVURTogNDYsXG4gIERPV046IDQwLFxuICBMRUZUX09TX0tFWTogOTEsXG4gIFJJR0hUX09TX0tFWTogOTIsXG4gIFNFTEVDVF9LRVk6IDkzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1PcHRzID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1PcHRzKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXV0b2NvbXBsZXRlIGlzIHNpbXBsZSBvciBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRmlsdGVyU2VhcmNoID0gb3B0cy5pc0ZpbHRlclNlYXJjaCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdmVydGljYWxLZXlgIG9mIHRoZSB2ZXJ0aWNhbCBzZWFyY2ggdG8gdXNlIGZvciBhdXRvLWNvbXBsZXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IG9wdHMudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dCBlbCBzZWxlY3RvciBmb3IgYXV0byBjb21wbGV0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5faW5wdXRFbCA9IG9wdHMuaW5wdXRFbCB8fCAnLmpzLXlleHQtcXVlcnknO1xuXG4gICAgLyoqXG4gICAgICogQSBzZWxlY3RvciBmb3IgdGhlIGF1dG9jb21wbGV0ZSBlbGVtZW50ZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9jb21wbGV0ZUVscyA9IG9wdHMuYXV0b0NvbXBsZXRlRWxzIHx8ICcuanMteWV4dC1hdXRvY29tcGxldGUtb3B0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSBmb3IgdGhlIGRhdGEtc3RvcmFnZSB0byBsaXN0ZW4gZm9yIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gYCR7U3RvcmFnZUtleXMuQVVUT0NPTVBMRVRFfS4ke3RoaXMubmFtZX1gO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHR5cGluZy5cbiAgICAgKiBXZSB1c2UgdGhpcyBmb3IgcmVzZXR0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgdmFsdWUgd2hlbiBvdGhlciBpbnRlcmFjdGlvbnMgKGUuZy4gcmVzdWx0IG5hdmlnYXRpb24pXG4gICAgICogY2hhbmdlIGJhc2VkIG9uIGludGVyYWN0aW9ucy4gRm9yIGluc3RhbmNlLCBoaXR0aW5nIGVzY2FwZSBzaG91bGQgcmVzZXQgdGhlIHZhbHVlIHRvIHRoZSBvcmlnaW5hbCB0eXBlZCBxdWVyeS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSBvcHRzLm9yaWdpbmFsUXVlcnkgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIHRocm91Z2ggcmVzdWx0cy5cbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgc2VjdGlvbiB3ZSdyZSBuYXZpZ2F0aW5nIGluLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24gdGhyb3VnaCByZXN1bHRzLlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZXN1bHQgaW5kZXggd2UncmUgbmF2aWdhdGluZyBvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgdGV4dCB0byBzaG93IGFzIHRoZSBmaXJzdCBpdGVtIGZvciBhdXRvIGNvbXBsZXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvbXB0SGVhZGVyID0gb3B0cy5wcm9tcHRIZWFkZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGF1dG9jb21hdGljYWxseSBmb2N1c2VkIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IG9wdHMuYXV0b0ZvY3VzIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSBgRW50ZXJgIGtleSBpcyBwcmVzc2VkIG9uIGF1dG8gY29tcGxldGUuXG4gICAgICovXG4gICAgdGhpcy5fb25TdWJtaXQgPSBvcHRzLm9uU3VibWl0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgYXV0byBjb21wbGV0ZS4gTm90ZSB0aGF0IHRoaXMgaXNcbiAgICAgKiBub3QgY2FsbGVkIHdoZW4gZWl0aGVyIHRoZSBgRW50ZXJgIGtleSBpcyBwcmVzc2VkIG9yIHRoZSBtb3VzZSBpcyB1c2VkIHRvIHNlbGVjdCBhblxuICAgICAqIGF1dG9jb21wbGV0ZSBvcHRpb24uXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBvcHRzLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5fc2VhcmNoUGFyYW1ldGVycyA9IG9wdHMuc2VhcmNoUGFyYW1ldGVycyB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhbGlhc2VkIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBtYW5hZ2VyIGZvciBjcmVhdGlvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdBdXRvQ29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvYXV0b2NvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZSBpcyBvdmVycmlkZGVuIHNvIHRoYXQgd2UgY2FuIHByb3ZpZGUgYWRkaXRpb25hbCBtZXRhIGRhdGFcbiAgICogdG8gdGhlIHRlbXBsYXRlIChlLmcuIHRoZSBzZWN0aW9uSW5kZXggYW5kIHJlc3VsdEluZGV4KSwgc2luY2VcbiAgICogdGhvc2UgYXJlIGNsaWVudC1pbnRlcmFjdGlvbiBzcGVjaWZpYyB2YWx1ZXMgYW5kIGFyZW4ndCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGlmICghdGhpcy5pc1F1ZXJ5SW5wdXRGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IDA7XG4gICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IC0xO1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBoYXNSZXN1bHRzOiB0aGlzLmhhc1Jlc3VsdHMoZGF0YSksXG4gICAgICBzZWN0aW9uSW5kZXg6IHRoaXMuX3NlY3Rpb25JbmRleCxcbiAgICAgIHJlc3VsdEluZGV4OiB0aGlzLl9yZXN1bHRJbmRleCxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5fb3JpZ2luYWxRdWVyeS5sZW5ndGggPT09IDAgPyB0aGlzLnByb21wdEhlYWRlciA6IG51bGxcbiAgICB9KSk7XG4gIH1cblxuICBpc1F1ZXJ5SW5wdXRGb2N1c2VkICgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc05hbWUuaW5jbHVkZXModGhpcy5faW5wdXRFbC5zdWJzdHJpbmcoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGlzIGEgaGVscGVyIHRvIGFwcGx5IHRoZSBjdXJyZW50IHN0YXRlIHdpdGggbmV3IGNsaWVudC1zdGF0ZS5cbiAgICovXG4gIHVwZGF0ZVN0YXRlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuX3N0YXRlLmdldCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbkNyZWF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIGZyYW1ld29yay5cbiAgICogT25jZSB3ZSdyZSBpbml0YWxpemVkLCB3ZSB3aXJlIHVwIGFsbCBvZiBvdXIgdXNlciBpbnRlcmFjdGlvbnNcbiAgICovXG4gIG9uQ3JlYXRlICgpIHtcbiAgICAvLyBVc2UgdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gZmluZCB0aGUgaW5wdXQgbm9kZS5cbiAgICBsZXQgcXVlcnlJbnB1dCA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIGlmICghcXVlcnlJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBBdXRvQ29tcGxldGUuIENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9pbnB1dEVsLCAnYC4nKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIHRoZSBuYXRpdmUgYXV0b2NvbXBsZXRlLCBhdXRvY29ycmVjdCAmIHNwZWxsY2hlY2tcbiAgICBET00uYXR0cmlidXRlcyhxdWVyeUlucHV0LCB7XG4gICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJ1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHVzZXIgZXhpdHMgdGhlIGlucHV0LCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzdGF0ZSBhbmQgY2xvc2VcbiAgICAvLyB0aGUgYXV0byBjb21wbGV0ZVxuICAgIC8vIFRPRE8oamRlbGVybWUpOiBDbG9zZSBsb2dpYyB0byBiZSBtb3ZlZCB0byBwYXJlbnRcbiAgICBET00ub24oZG9jdW1lbnQsICdjbGljaycsIGUgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0Lm1hdGNoZXMoJy5qcy15eHQtQXV0b0NvbXBsZXRlLXdyYXBwZXIgKicpIHx8IGUudGFyZ2V0Lm1hdGNoZXModGhpcy5faW5wdXRFbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gV2hlbiBhIHVzZXIgZm9jdXNlcyB0aGUgaW5wdXQsIHdlIHNob3VsZCBwb3B1bGF0ZSB0aGUgYXV0b2NvbXBsZXRlIGJhc2VkXG4gICAgLy8gb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICBET00ub24ocXVlcnlJbnB1dCwgJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hdXRvQ29tcGxldGUocXVlcnlJbnB1dC52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHRoZSByZXN1bHRzIHVzaW5nIHRoZSBrZXlib2FyZFxuICAgIERPTS5vbihxdWVyeUlucHV0LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU5hdmlnYXRlUmVzdWx0cyhlLmtleUNvZGUsIGUpO1xuICAgICAgdGhpcy5oYW5kbGVTdWJtaXRSZXN1bHQoZS5rZXlDb2RlLCBxdWVyeUlucHV0LnZhbHVlLCBlKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9hdXRvRm9jdXMpIHtcbiAgICAgIERPTS5vbmNlKHF1ZXJ5SW5wdXQsICdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGUocXVlcnlJbnB1dC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBzZWxlY3QgYSByZXN1bHQgd2l0aCB0aGUgbW91c2VcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtYXV0b2NvbXBsZXRlLW9wdGlvbicsICdjbGljaycsIChldnQsIHRhcmdldCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZGF0YXNldDtcbiAgICAgIGxldCB2YWwgPSBkYXRhLnNob3J0O1xuXG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHZhbCk7XG4gICAgICB0aGlzLl9vblN1Ym1pdCh2YWwsIGRhdGEuZmlsdGVyKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIHVzZXIgaXMgdHlwaW5nIGluIHRoZSBpbnB1dCwgcHJvY2VzcyB0aGUgYXV0byBjb21wbGV0ZS5cbiAgICBET00ub24ocXVlcnlJbnB1dCwgJ2tleXVwJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVHlwaW5nKGUua2V5Q29kZSwgcXVlcnlJbnB1dC52YWx1ZSwgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogY2xvc2Ugd2lsbCBoaWRlIHRoZSBhdXRvIGNvbXBsZXRlIHJlc3VsdHMgYW5kIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogcmVzZXRzIHRoZSBjbGllbnQgc3RhdGUgdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWVzIGFuZCB0cmlnZ2Vyc1xuICAgKiBhIHRlbXBsYXRlLXJlcmVuZGVyIHZpYSB1cGRhdGVTdGF0ZVxuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IDA7XG4gICAgdGhpcy5fcmVzdWx0SW5kZXggPSAtMTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdFZhbHVlIE9wdGlvbiB2YWx1ZSBwcm92aWRlZC5cbiAgICogSWYgbm8gdmFsdWUgcHJvdmlkZWQsIHdlJ2xsIHRyeSB0byBmaW5kIGl0IGJhc2VkIG9uIHRoZSBzZWxlY3Rpb24gaW5kZXhlcy5cbiAgICovXG4gIHVwZGF0ZVF1ZXJ5IChvcHRWYWx1ZSkge1xuICAgIC8vIE9ubHkgd2FudCB0byB1cGRhdGUgdGhlIHF1ZXJ5IHN0cmluZyBpZiB0aGVyZXMgYSB2YWx1ZS5cbiAgICAvLyBJZiBvbmUgaXMgcHJvdmlkZWQsIGdyZWF0LlxuICAgIC8vIE90aGVyd2lzZSwgbGV0cyB0cnkgdG8gZmluZCBpdCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgcmVzdWx0cy5cbiAgICBpZiAob3B0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5fc3RhdGUuZ2V0KCdzZWN0aW9ucycpO1xuXG4gICAgICBsZXQgcmVzdWx0cyA9IHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0cztcbiAgICAgIG9wdFZhbHVlID0gcmVzdWx0c1t0aGlzLl9yZXN1bHRJbmRleF0uc2hvcnRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlFbCA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIHF1ZXJ5RWwudmFsdWUgPSBvcHRWYWx1ZTtcbiAgfVxuXG4gIGhhbmRsZVR5cGluZyAoa2V5LCB2YWx1ZSwgZSkge1xuICAgIGxldCBpZ25vcmVkS2V5cyA9IFtcbiAgICAgIEtleXMuRE9XTixcbiAgICAgIEtleXMuVVAsXG4gICAgICBLZXlzLkNUUkwsXG4gICAgICBLZXlzLkFMVCxcbiAgICAgIEtleXMuU0hJRlQsXG4gICAgICBLZXlzLkxFRlQsXG4gICAgICBLZXlzLlJJR0hULFxuICAgICAgS2V5cy5MRUZUX09TX0tFWSxcbiAgICAgIEtleXMuUklHSFRfT1NfS0VZLFxuICAgICAgS2V5cy5FTlRFUixcbiAgICAgIEtleXMuVEFCLFxuICAgICAgS2V5cy5TRUxFQ1RfS0VZXG4gICAgXTtcblxuICAgIGlmIChpZ25vcmVkS2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVzZXIgZXNjYXBlcyBvdXQgb2YgYXV0byBjb21wbGV0ZSwgc28gd2UgcmVzZXQgaXQgdG8gdGhlIG9yaWdpbmFsIGlucHV0XG4gICAgaWYgKGtleSA9PT0gS2V5cy5FU0NBUEUpIHtcbiAgICAgIHRoaXMudXBkYXRlUXVlcnkodGhpcy5fb3JpZ2luYWxRdWVyeSk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBvcmlnaW5hbCB2YWx1ZSBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dFxuICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSB2YWx1ZTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmF1dG9Db21wbGV0ZSh2YWx1ZSk7XG4gIH1cblxuICBhdXRvQ29tcGxldGUgKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuaXNGaWx0ZXJTZWFyY2gpIHtcbiAgICAgIHRoaXMuY29yZS5hdXRvQ29tcGxldGVGaWx0ZXIoaW5wdXQsIHtcbiAgICAgICAgbmFtZXNwYWNlOiB0aGlzLm5hbWUsXG4gICAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgICAgc2VhcmNoUGFyYW1ldGVyczogdGhpcy5fc2VhcmNoUGFyYW1ldGVyc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl92ZXJ0aWNhbEtleSkge1xuICAgICAgdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVZlcnRpY2FsKGlucHV0LCB0aGlzLm5hbWUsIHRoaXMuX3ZlcnRpY2FsS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3JlLmF1dG9Db21wbGV0ZVVuaXZlcnNhbChpbnB1dCwgdGhpcy5uYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0cnVlIGlmIHdlIGhhdmUgcmVzdWx0cyBpbiBhbnkgc2VjdGlvblxuICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAqL1xuICBoYXNSZXN1bHRzIChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBzZWN0aW9ucyA9IGRhdGFbJ3NlY3Rpb25zJ107XG4gICAgaWYgKCFzZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzZWN0aW9uc1tpXTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBkYXRhLnJlc3VsdHM7XG4gICAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlTmF2aWdhdGVSZXN1bHRzIChrZXksIGUpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLl9zdGF0ZS5nZXQoJ3NlY3Rpb25zJyk7XG4gICAgaWYgKHNlY3Rpb25zID09PSB1bmRlZmluZWQgfHwgc2VjdGlvbnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUYWJiaW5nIG91dCBvciBlbnRlciBzaG91bGQgY2xvc2UgdGhlIGF1dG8gY29tcGxldGUuXG4gICAgaWYgKGtleSA9PT0gS2V5cy5UQUIpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0cztcbiAgICBpZiAoa2V5ID09PSBLZXlzLlVQKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5fcmVzdWx0SW5kZXggPD0gMCkge1xuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbkluZGV4ID4gMCkge1xuICAgICAgICAgIHRoaXMuX3NlY3Rpb25JbmRleC0tO1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gc2VjdGlvbnNbdGhpcy5fc2VjdGlvbkluZGV4XS5yZXN1bHRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVRdWVyeSh0aGlzLl9vcmlnaW5hbFF1ZXJ5KTtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUXVlcnkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jlc3VsdEluZGV4LS07XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gS2V5cy5ET1dOKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5fcmVzdWx0SW5kZXggPj0gcmVzdWx0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWN0aW9uSW5kZXggPCBzZWN0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhpcy5fc2VjdGlvbkluZGV4Kys7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUXVlcnkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jlc3VsdEluZGV4Kys7XG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU3VibWl0UmVzdWx0IChrZXksIHZhbHVlLCBlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gdGhpcy5fc3RhdGUuZ2V0KCdzZWN0aW9ucycpO1xuICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHNlY3Rpb25zLmxlbmd0aCA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpbHRlclNlYXJjaCkge1xuICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3VibWl0IHRoZSBzZWFyY2ggb24gZW50ZXJcbiAgICBpZiAoa2V5ID09PSBLZXlzLkVOVEVSKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmICh0aGlzLmlzRmlsdGVyU2VhcmNoICYmIHRoaXMuX3Jlc3VsdEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBmaWx0ZXIgPSAnJztcbiAgICAgIGlmICh0aGlzLl9zZWN0aW9uSW5kZXggPj0gMCAmJiB0aGlzLl9yZXN1bHRJbmRleCA+PSAwKSB7XG4gICAgICAgIGZpbHRlciA9IEpTT04uc3RyaW5naWZ5KHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0c1t0aGlzLl9yZXN1bHRJbmRleF0uZmlsdGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVRdWVyeSh2YWx1ZSk7XG4gICAgICB0aGlzLl9vcmlnaW5hbFF1ZXJ5ID0gdmFsdWU7XG4gICAgICB0aGlzLl9vblN1Ym1pdCh2YWx1ZSwgZmlsdGVyKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNwZWxsQ2hlY2tDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG4vKipcbiAqIFNwZWxsQ2hlY2tDb21wb25lbnQgd2lsbCBzdXBwb3J0IGRpc3BsYXlpbmcgc3VnZ2VzdGlvbiwgYXV0b2NvcnJlY3QgYW5kIGNvbWJpbmVkKG1heWJlIGluIHRoZSBmdXR1cmUpXG4gKiBwcm92aWRlZCBmcm9tIHNwZWxsaW5nIGNvcnJlY3Rpb24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWxsQ2hlY2tDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1NwZWxsQ2hlY2snO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnc2VhcmNoL3NwZWxsY2hlY2snO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoJ3NraXBTcGVsbENoZWNrJywgdHJ1ZSk7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZSgncXVlcnlUcmlnZ2VyJywgdHJ1ZSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSwgdmFsKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIHNob3VsZFNob3c6IGRhdGEuY29ycmVjdGVkUXVlcnkgIT09IHVuZGVmaW5lZCxcbiAgICAgIGNvcnJlY3RlZFF1ZXJ5VXJsOiB0aGlzLl9idWlsZFJlZGlyZWN0UXVlcnlVcmwoZGF0YS5jb3JyZWN0ZWRRdWVyeSwgZGF0YS50eXBlKSxcbiAgICAgIGhlbHBUZXh0OiB0aGlzLl9nZXRIZWxwVGV4dChkYXRhLnR5cGUpXG4gICAgfSwgdmFsKSk7XG4gIH1cblxuICBfYnVpbGRSZWRpcmVjdFF1ZXJ5VXJsIChxdWVyeSwgdHlwZSkge1xuICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGxldCBwYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5LnZhbHVlKTtcbiAgICBwYXJhbXMuc2V0KCdza2lwU3BlbGxDaGVjaycsIHRydWUpO1xuICAgIHBhcmFtcy5zZXQoJ3F1ZXJ5VHJpZ2dlcicsIHR5cGUudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICB9XG5cbiAgX2dldEhlbHBUZXh0ICh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdTVUdHRVNUJzpcbiAgICAgICAgcmV0dXJuICdEaWQgeW91IG1lYW46JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBMb2NhdGlvbkJpYXNDb21wb25lbnQgd2lsbCBzaG93IHRoZSB1c2VyIHdoZXJlIGlzIHVzZWQgZm9yIGxvY2F0aW9uIGJpYXMgYW5kIGFsbG93IHVzZXIgdG9cbiAqIGltcHJvdmUgYWNjdXJhY3kgd2l0aCBIVE1MNSBnZW9sb2NhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25CaWFzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFJlY2lldmUgdXBkYXRlcyBmcm9tIHN0b3JhZ2UgYmFzZWQgb24gdGhpcyBpbmRleFxuICAgICAqIEB0eXBlIHtTdG9yYWdlS2V5fVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIHZlcnRpY2FsIGtleSBmb3IgdmVydGljYWwgc2VhcmNoIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHdoZW4gbG9jYXRpb24gdXBkYXRlZCxcbiAgICAgKiBhIHVuaXZlcnNhbCBzZWFyY2ggd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBSZW1vdmUgY29uZmlnLnZlcnRpY2FsS2V5XG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHVzZWQgZm9yIHVwZGF0aW5nIGxvY2F0aW9uXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVMb2NhdGlvbkVsID0gY29uZmlnLnVwZGF0ZUxvY2F0aW9uRWwgfHwgJy5qcy1sb2NhdGlvbkJpYXMtdXBkYXRlLWxvY2F0aW9uJztcblxuICAgIHRoaXMuX2xvY2F0aW9uRGlzcGxheU5hbWUgPSAnJztcblxuICAgIHRoaXMuX2FjY3VyYWN5ID0gJyc7XG5cbiAgICB0aGlzLl9hbGxvd1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnTG9jYXRpb25CaWFzJztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9sb2NhdGlvbmJpYXMnO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLl9hbGxvd1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXNhYmxlTG9jYXRpb25VcGRhdGVJZkdlb2xvY2F0aW9uRGVuaWVkKCk7XG4gICAgRE9NLm9uKHRoaXMuX3VwZGF0ZUxvY2F0aW9uRWwsICdjbGljaycsIChlKSA9PiB7XG4gICAgICBpZiAoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigocG9zaXRpb24pID0+IHtcbiAgICAgICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04sIHtcbiAgICAgICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLFxuICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3lcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9kb1NlYXJjaCgpO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlTG9jYXRpb25VcGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHRocm93IGVycm9yIG9yIHdhcm5pbmcgaGVyZSBpZiBubyBnZW9sb2NhdGlvbj9cbiAgICB9KTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICB0aGlzLl9sb2NhdGlvbkRpc3BsYXlOYW1lID0gZGF0YS5sb2NhdGlvbkRpc3BsYXlOYW1lO1xuICAgIHRoaXMuX2FjY3VyYWN5ID0gZGF0YS5hY2N1cmFjeTtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwge1xuICAgICAgbG9jYXRpb25EaXNwbGF5TmFtZTogdGhpcy5fZ2V0TG9jYXRpb25EaXNwbGF5TmFtZShkYXRhKSxcbiAgICAgIGFjY3VyYWN5VGV4dDogdGhpcy5fZ2V0QWNjdXJhY3lIZWxwVGV4dChkYXRhLmFjY3VyYWN5KSxcbiAgICAgIGlzUHJlY2lzZUxvY2F0aW9uOiBkYXRhLmFjY3VyYWN5ID09PSAnREVWSUNFJyAmJiB0aGlzLl9hbGxvd1VwZGF0ZSxcbiAgICAgIGlzVW5rbm93bkxvY2F0aW9uOiBkYXRhLmFjY3VyYWN5ID09PSAnVU5LTk9XTicsXG4gICAgICBzaG91bGRTaG93OiBkYXRhLmFjY3VyYWN5ICE9PSB1bmRlZmluZWQsXG4gICAgICBhbGxvd1VwZGF0ZTogdGhpcy5fYWxsb3dVcGRhdGVcbiAgICB9LCB2YWwpKTtcbiAgfVxuXG4gIF9nZXRMb2NhdGlvbkRpc3BsYXlOYW1lIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuYWNjdXJhY3kgPT09ICdVTktOT1dOJykge1xuICAgICAgcmV0dXJuICdVbmtub3duIExvY2F0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEubG9jYXRpb25EaXNwbGF5TmFtZTtcbiAgfVxuXG4gIF9nZXRBY2N1cmFjeUhlbHBUZXh0IChhY2N1cmFjeSkge1xuICAgIHN3aXRjaCAoYWNjdXJhY3kpIHtcbiAgICAgIGNhc2UgJ0lQJzpcbiAgICAgICAgcmV0dXJuICdiYXNlZCBvbiB5b3VyIGludGVybmV0IGFkZHJlc3MnO1xuICAgICAgY2FzZSAnREVWSUNFJzpcbiAgICAgICAgcmV0dXJuICdiYXNlZCBvbiB5b3VyIGRldmljZSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgX2RvU2VhcmNoICgpIHtcbiAgICBsZXQgcXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG4gICAgaWYgKHRoaXMuX3ZlcnRpY2FsS2V5KSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgICAgOiBhbGxGaWx0ZXJzWzBdO1xuICAgICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcbiAgICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl92ZXJ0aWNhbEtleSwge1xuICAgICAgICBpbnB1dDogcXVlcnksXG4gICAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgICBvZmZzZXQ6IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDAsXG4gICAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvcmUuc2VhcmNoKHF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICBfZGlzYWJsZUxvY2F0aW9uVXBkYXRlSWZHZW9sb2NhdGlvbkRlbmllZCAoKSB7XG4gICAgaWYgKCdwZXJtaXNzaW9ucycgaW4gbmF2aWdhdG9yKSB7XG4gICAgICBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoeyBuYW1lOiAnZ2VvbG9jYXRpb24nIH0pXG4gICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUxvY2F0aW9uVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZGlzYWJsZUxvY2F0aW9uVXBkYXRlICgpIHtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04pO1xuICAgIHRoaXMuX2FsbG93VXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBsb2NhdGlvbkRpc3BsYXlOYW1lOiB0aGlzLl9sb2NhdGlvbkRpc3BsYXlOYW1lLFxuICAgICAgYWNjdXJhY3k6IHRoaXMuX2FjY3VyYWN5XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZhY2V0ICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgZmFjZXQgZmlsdGVyIHdpdGggdGhlIGZvcm1hdCBvZlxuICoge1xuICogICBcImZpZWxkX25hbWVcIjogWyBGaWx0ZXJzLi4uIF0sXG4gKiAgIC4uLlxuICogfVxuICpcbiAqIEBzZWUge0BsaW5rIEZpbHRlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjZXQge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkYXRhKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZhY2V0IGZpbHRlciBmcm9tIGEgbGlzdCBvZiBGaWx0ZXJzXG4gICAqIEBwYXJhbSAgey4uLkZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVycyB0byB1c2UgaW4gdGhpcyBmYWNldFxuICAgKiBAcmV0dXJucyB7RmFjZXR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZpbHRlcnMgKGF2YWlsYWJsZUZpZWxkSWRzLCAuLi5maWx0ZXJzKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgYXZhaWxhYmxlRmllbGRJZHMuZm9yRWFjaChmaWVsZElkID0+IHtcbiAgICAgIGdyb3Vwc1tmaWVsZElkXSA9IFtdO1xuICAgIH0pO1xuICAgIGNvbnN0IGZsYXRGaWx0ZXJzID0gZmlsdGVycy5mbGF0TWFwKGYgPT4gZi4kb3IgfHwgZik7XG4gICAgZmxhdEZpbHRlcnMuZm9yRWFjaChmID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKGYpWzBdO1xuICAgICAgaWYgKCFncm91cHNba2V5XSkge1xuICAgICAgICBncm91cHNba2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JvdXBzW2tleV0ucHVzaChmKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgRmFjZXQoZ3JvdXBzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRmlsdGVyQm94Q29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgRmFjZXQgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmFjZXQnO1xuXG5jbGFzcyBGaWx0ZXJCb3hDb25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgYWJvdmUgdGhlIGNvbnRyb2xzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gY29uZmlnLnRpdGxlIHx8ICdGaWx0ZXJzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiByZXN1bHRzIG5leHQgdG8gZWFjaCBmYWNldFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0NvdW50ID0gY29uZmlnLnNob3dDb3VudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93Q291bnQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0cmlnZ2VyIGEgc2VhcmNoIG9uIGVhY2ggY2hhbmdlIHRvIGEgZmlsdGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hPbkNoYW5nZSA9IGNvbmZpZy5zZWFyY2hPbkNoYW5nZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBidXR0b24gdG8gcmVzZXQgZm9yIGVhY2ggZmFjZXQgZ3JvdXBcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmlsdGVyID0gY29uZmlnLnJlc2V0RmFjZXQgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlckxhYmVsID0gY29uZmlnLnJlc2V0RmFjZXRMYWJlbCB8fCAncmVzZXQnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIFwicmVzZXQgYWxsXCIgYnV0dG9uIHRvIHJlc2V0IGFsbCBmYWNldHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmlsdGVycyA9IGNvbmZpZy5yZXNldEZhY2V0cyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5yZXNldEZhY2V0cztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciB0aGUgXCJyZXNldCBhbGxcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXJzTGFiZWwgPSBjb25maWcucmVzZXRGYWNldHNMYWJlbCB8fCAncmVzZXQgYWxsJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGZhY2V0cyB0byBzaG93IGJlZm9yZSBkaXNwbGF5aW5nIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnc2hvdyBtb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3MgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnc2hvdyBsZXNzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGVuYWJsZSBoaWRpbmcgZXhjZXNzIGZhY2V0cyBpbiBlYWNoIGdyb3VwIHdpdGggYSBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCIgYnV0dG9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZSA9IGNvbmZpZy5zaG93TW9yZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TW9yZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFsbG93IGV4cGFuZGluZyBhbmQgY29sbGFwc2luZyBlYWNoIGdyb3VwIG9mIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXhwYW5kID0gY29uZmlnLmV4cGFuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5leHBhbmQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFwcGxpZWQgZmlsdGVycyB3aGVuIGNvbGxhcHNlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd051bWJlckFwcGxpZWQgPSBjb25maWcuc2hvd051bWJlckFwcGxpZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd051bWJlckFwcGxpZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHRvIGRpc3BsYXkgb24gdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcHBseUxhYmVsID0gY29uZmlnLmFwcGx5TGFiZWwgfHwgJ2FwcGx5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RvciBvZiB0aGUgYXBwbHkgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5QnV0dG9uU2VsZWN0b3IgPSBjb25maWcuYXBwbHlCdXR0b25TZWxlY3RvciB8fCAnLmpzLXlleHQtZmlsdGVyYm94LWFwcGx5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGZpbHRlcnMgdG8gZGlzcGxheSBhbmQgY29udHJvbCwgaWdub3JpbmcgZW1wdHkgc2VjdGlvbnNcbiAgICAgKiBAdHlwZSB7b2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJDb25maWdzID0gY29uZmlnLmZpbHRlcnMuZmlsdGVyKGYgPT4gZi5vcHRpb25zLmxlbmd0aCAhPT0gMCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGZpbHRlcmJveCBjb250YWlucyBmYWNldHMuIFRoaXMgYWZmZWN0cyB0aGVcbiAgICAgKiB0aGUgd2F5IHRoZSBmaWx0ZXJzIGFyZSB1c2VkIGluIHRoZSBzZWFyY2hcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRHluYW1pYyA9IGNvbmZpZy5pc0R5bmFtaWMgfHwgZmFsc2U7XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIGEgc2V0IG9mIGZpbHRlcnMsIGFuZCBzZWFyY2hlcyB3aXRoIHRoZW0gd2hlbiBhcHBsaWVkLlxuICogTXVsdGlwbGUgRmlsdGVyQm94IGNvbXBvbmVudHMgd2lsbCBBTkQgdG9nZXRoZXIgYnV0IHdpbGwgbm90IHNoYXJlIHN0YXRlLlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlckJveENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBGaWx0ZXJCb3hDb25maWcoY29uZmlnKTtcblxuICAgIGlmICghY29uZmlnLmZpbHRlcnMgfHwgIShjb25maWcuZmlsdGVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ0ZpbHRlckJveCByZXF1aXJlcyBmaWx0ZXJzIHRvIGJlIHByb3ZpZGVkIGFzIGFuIGFycmF5JyxcbiAgICAgICAgJ0ZpbHRlckJveCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0aWNhbCBrZXkgZm9yIHRoZSBzZWFyY2hcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnRzIGNyZWF0ZWQgZm9yIGVhY2ggZmlsdGVyIGNvbmZpZ1xuICAgICAqIEB0eXBlIHtDb21wb25lbnRbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmaWx0ZXIgY29tcG9uZW50cyBpbiB0aGUgYm94XG4gICAgICogQHR5cGUge0ZpbHRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBbXTtcblxuICAgIGlmICghdGhpcy5jb25maWcuc2hvd0NvdW50KSB7XG4gICAgICB0aGlzLmNvbmZpZy5maWx0ZXJDb25maWdzLmZvckVhY2goY29uZmlnID0+IHtcbiAgICAgICAgY29uZmlnLm9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICAgIG9wdGlvbi5jb3VudExhYmVsID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRmlsdGVyQm94JztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ2ZpbHRlcnMvZmlsdGVyYm94JztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwgdGhpcy5jb25maWcsIHtcbiAgICAgIHNob3dSZXNldDogdGhpcy5jb25maWcucmVzZXRGaWx0ZXJzLFxuICAgICAgcmVzZXRMYWJlbDogdGhpcy5jb25maWcucmVzZXRGaWx0ZXJzTGFiZWwsXG4gICAgICBzaG93QXBwbHlCdXR0b246ICF0aGlzLmNvbmZpZy5zZWFyY2hPbkNoYW5nZVxuICAgIH0pKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLl9maWx0ZXJDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cy5mb3JFYWNoKGMgPT4gYy5yZW1vdmUoKSk7XG4gICAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzID0gW107XG4gICAgICB0aGlzLl9maWx0ZXJzID0gW107XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBmaWx0ZXJzIGZyb20gY29uZmlnc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZmlsdGVyQ29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcuZmlsdGVyQ29uZmlnc1tpXTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoY29uZmlnLnR5cGUsIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdGhpcy5jb25maWcsXG4gICAgICAgIHtcbiAgICAgICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgICBuYW1lOiBgJHt0aGlzLm5hbWV9LmZpbHRlciR7aX1gLFxuICAgICAgICAgIHN0b3JlT25DaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgIGNvbnRhaW5lcjogYC5qcy15ZXh0LWZpbHRlcmJveC1maWx0ZXIke2l9YCxcbiAgICAgICAgICBzaG93UmVzZXQ6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVyLFxuICAgICAgICAgIHJlc2V0TGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVyTGFiZWwsXG4gICAgICAgICAgc2hvd0V4cGFuZDogdGhpcy5jb25maWcuZXhwYW5kLFxuICAgICAgICAgIG9uQ2hhbmdlOiAoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRmlsdGVyQ2hhbmdlKGksIGZpbHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICBjb21wb25lbnQubW91bnQoKTtcbiAgICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgdGhpcy5fZmlsdGVyc1tpXSA9IGNvbXBvbmVudC5nZXRGaWx0ZXIoKTtcbiAgICAgIHRoaXMuX3NhdmVGaWx0ZXJzVG9TdG9yYWdlKCk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBhcHBseSBidXR0b25cbiAgICBpZiAoIXRoaXMuY29uZmlnLnNlYXJjaE9uQ2hhbmdlKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCB0aGlzLmNvbmZpZy5hcHBseUJ1dHRvblNlbGVjdG9yKTtcblxuICAgICAgaWYgKGJ1dHRvbikge1xuICAgICAgICBET00ub24oYnV0dG9uLCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2F2ZUZpbHRlcnNUb1N0b3JhZ2UoKTtcbiAgICAgICAgICB0aGlzLl9zZWFyY2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSByZXNldCBidXR0b25cbiAgICBpZiAodGhpcy5jb25maWcucmVzZXRGaWx0ZXJzKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LUZpbHRlckJveC1yZXNldCcpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICB0aGlzLnJlc2V0RmlsdGVycy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICByZXNldEZpbHRlcnMgKCkge1xuICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMuZm9yRWFjaChmaWx0ZXIgPT4gZmlsdGVyLmNsZWFyT3B0aW9ucygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyB0byBjaGlsZCBmaWx0ZXIgY29tcG9uZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjaGFuZ2VkIGZpbHRlclxuICAgKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyIFRoZSBuZXcgZmlsdGVyXG4gICAqL1xuICBvbkZpbHRlckNoYW5nZSAoaW5kZXgsIGZpbHRlcikge1xuICAgIHRoaXMuX2ZpbHRlcnNbaW5kZXhdID0gZmlsdGVyO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgdGhpcy5fc2F2ZUZpbHRlcnNUb1N0b3JhZ2UoKTtcbiAgICAgIHRoaXMuX3NlYXJjaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGZpbHRlciBjb21wb25lbnRzIGFsb25nIHdpdGggdGhpcyBjb21wb25lbnRcbiAgICovXG4gIHJlbW92ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cy5mb3JFYWNoKGMgPT4gYy5yZW1vdmUoKSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IGZpbHRlcnMgdG8gc3RvcmFnZSB0byBiZSB1c2VkIGluIHRoZSBuZXh0IHNlYXJjaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NhdmVGaWx0ZXJzVG9TdG9yYWdlICgpIHtcbiAgICBjb25zdCB2YWxpZEZpbHRlcnMgPSB0aGlzLl9maWx0ZXJzLmZpbHRlcihmID0+XG4gICAgICBmICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGYgIT09IG51bGwgJiZcbiAgICAgIE9iamVjdC5rZXlzKGYpLmxlbmd0aCA+IDApO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmlzRHluYW1pYykge1xuICAgICAgY29uc3QgYXZhaWxhYmxlRmllbGRJZHMgPSB0aGlzLmNvbmZpZy5maWx0ZXJDb25maWdzLm1hcChjb25maWcgPT4gY29uZmlnLmZpZWxkSWQpO1xuICAgICAgY29uc3QgY29tYmluZWRGaWx0ZXIgPSBGYWNldC5mcm9tRmlsdGVycyhhdmFpbGFibGVGaWVsZElkcywgLi4udmFsaWRGaWx0ZXJzKTtcbiAgICAgIHRoaXMuY29yZS5zZXRGYWNldEZpbHRlcih0aGlzLm5hbWUsIGNvbWJpbmVkRmlsdGVyIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tYmluZWRGaWx0ZXIgPSB2YWxpZEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgICA/IEZpbHRlci5hbmQoLi4udmFsaWRGaWx0ZXJzKVxuICAgICAgICA6IHZhbGlkRmlsdGVyc1swXTtcbiAgICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCBjb21iaW5lZEZpbHRlciB8fCB7fSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzZWFyY2ggd2l0aCBhbGwgZmlsdGVycyBpbiBzdG9yYWdlXG4gICAqL1xuICBfc2VhcmNoICgpIHtcbiAgICBjb25zdCBhbGxGaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgY29uc3QgdG90YWxGaWx0ZXIgPSBhbGxGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgOiBhbGxGaWx0ZXJzWzBdO1xuXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSk7XG5cbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuXG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICBpbnB1dDogcXVlcnksXG4gICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRmlsdGVyT3B0aW9uc0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IHN1cHBvcnRlZCBjb250cm9sc1xuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBTVVBQT1JURURfQ09OVFJPTFMgPSBbXG4gICdzaW5nbGVvcHRpb24nLFxuICAnbXVsdGlvcHRpb24nXG5dO1xuXG5jbGFzcyBGaWx0ZXJPcHRpb25zQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGNvbnRyb2wgdG8gZGlzcGxheVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb250cm9sID0gY29uZmlnLmNvbnRyb2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBmaWx0ZXIgb3B0aW9ucyB0byBkaXNwbGF5IHdpdGggY2hlY2tlZCBzdGF0dXNcbiAgICAgKiBAdHlwZSB7b2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gYmUgdXNlZCBpbiB0aGUgbGVnZW5kXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gY29uZmlnLmxhYmVsIHx8ICdGaWx0ZXJzJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gY2hhbmdlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uQ2hhbmdlID0gY29uZmlnLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc3RvcmVzIHRoZSBmaWx0ZXIgdG8gc3RvcmFnZSBvbiBlYWNoIGNoYW5nZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIGJ1dHRvbiB0byByZXNldCB0aGUgY3VycmVudCBmaWx0ZXIgc2VsZWN0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93UmVzZXQgPSBjb25maWcuc2hvd1Jlc2V0ICYmIHRoaXMub3B0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSByZXNldCBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRMYWJlbCA9IGNvbmZpZy5yZXNldExhYmVsIHx8ICdyZXNldCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG51bWJlciBvZiBmYWNldHMgdG8gc2hvdyBiZWZvcmUgZGlzcGxheWluZyBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IGNvbmZpZy5zaG93TW9yZUxpbWl0IHx8IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ3Nob3cgbW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBsZXNzIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TGVzc0xhYmVsID0gY29uZmlnLnNob3dMZXNzTGFiZWwgfHwgJ3Nob3cgbGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBlbmFibGUgaGlkaW5nIGV4Y2VzcyBmYWNldHMgd2l0aCBhIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIiBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlID0gY29uZmlnLnNob3dNb3JlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dNb3JlO1xuICAgIHRoaXMuc2hvd01vcmUgPSB0aGlzLnNob3dNb3JlICYmIHRoaXMub3B0aW9ucy5sZW5ndGggPiB0aGlzLnNob3dNb3JlTGltaXQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvdyBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmcgdGhlIGdyb3VwIG9mIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd0V4cGFuZCA9IGNvbmZpZy5zaG93RXhwYW5kID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dFeHBhbmQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFwcGxpZWQgZmlsdGVycyB3aGVuIGNvbGxhcHNlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd051bWJlckFwcGxpZWQgPSBjb25maWcuc2hvd051bWJlckFwcGxpZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd051bWJlckFwcGxpZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3IgdXNlZCBmb3Igb3B0aW9ucyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uU2VsZWN0b3IgPSBjb25maWcub3B0aW9uU2VsZWN0b3IgfHwgJy5qcy15ZXh0LWZpbHRlci1vcHRpb24nO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBjb25maWcucHJldmlvdXNPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnLnByZXZpb3VzT3B0aW9ucyA9IEpTT04ucGFyc2UoY29uZmlnLnByZXZpb3VzT3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbmZpZy5wcmV2aW91c09wdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbGVjdGVkT3B0aW9ucyA9IGNvbmZpZy5wcmV2aW91c09wdGlvbnMgfHwgW107XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5zZXREZWZhdWx0U2VsZWN0ZWRWYWx1ZXModGhpcy5vcHRpb25zLCBzZWxlY3RlZE9wdGlvbnMpO1xuICB9XG5cbiAgc2V0RGVmYXVsdFNlbGVjdGVkVmFsdWVzIChvcHRpb25zLCBzZWxlY3RlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5tYXAobyA9PiAoe1xuICAgICAgLi4ubyxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoXG4gICAgICAgID8gc2VsZWN0ZWRPcHRpb25zLmluY2x1ZGVzKG8ubGFiZWwpXG4gICAgICAgIDogby5zZWxlY3RlZFxuICAgIH0pKTtcbiAgfVxuXG4gIGdldFNlbGVjdGVkQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVkdWNlKFxuICAgICAgKG51bVNlbGVjdGVkLCBvcHRpb24pID0+IG9wdGlvbi5zZWxlY3RlZCA/IG51bVNlbGVjdGVkICsgMSA6IG51bVNlbGVjdGVkLFxuICAgICAgMCk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wgfHwgIVNVUFBPUlRFRF9DT05UUk9MUy5pbmNsdWRlcyh0aGlzLmNvbnRyb2wpKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRmlsdGVyT3B0aW9ucyByZXF1aXJlcyBhIHZhbGlkIFwiY29udHJvbFwiIHRvIGJlIHByb3ZpZGVkJyxcbiAgICAgICAgJ0ZpbHRlck9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgJ0ZpbHRlck9wdGlvbnMgY29tcG9uZW50IHJlcXVpcmVzIG9wdGlvbnMgdG8gYmUgcHJvdmlkZWQnLFxuICAgICAgICAnRmlsdGVyT3B0aW9ucycpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBzZXQgb2Ygb3B0aW9ucywgZWFjaCBvbmUgcmVwcmVzZW50aW5nIGEgZmlsdGVyIGluIGEgc2VhcmNoLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJPcHRpb25zQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIGxldCBwcmV2aW91c09wdGlvbnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSh0aGlzLm5hbWUpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZSh0aGlzLm5hbWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCBjb25maWdcbiAgICAgKiBAdHlwZSB7RmlsdGVyT3B0aW9uc0NvbmZpZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBGaWx0ZXJPcHRpb25zQ29uZmlnKHtcbiAgICAgIHByZXZpb3VzT3B0aW9ucyxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IHRoaXMuY29uZmlnLmdldFNlbGVjdGVkQ291bnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIG9wdGlvbiBsaXN0IGlzIGV4cGFuZGVkIGFuZCB2aXNpYmxlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHBhbmRlZCA9IHRoaXMuY29uZmlnLnNob3dFeHBhbmQgPyBzZWxlY3RlZENvdW50ID4gMCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGFsbCBvcHRpb25zIGFyZSBzaG93biwgZmFsc2UgaWYgc29tZSBhcmUgaGlkZGVuIGJhc2VkIG9uIGNvbmZpZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWxsU2hvd24gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdGaWx0ZXJPcHRpb25zJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyLCBiYXNlZCBvbiB0aGUgY29udHJvbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gYGNvbnRyb2xzL2ZpbHRlcm9wdGlvbnNgO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dNb3JlICYmICF0aGlzLmFsbFNob3duKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucy5zbGljZSgwLCB0aGlzLmNvbmZpZy5zaG93TW9yZUxpbWl0KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IHRoaXMuY29uZmlnLmdldFNlbGVjdGVkQ291bnQoKTtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgc2hvd1Jlc2V0OiB0aGlzLmNvbmZpZy5zaG93UmVzZXQgJiYgc2VsZWN0ZWRDb3VudCA+IDAsXG4gICAgICBleHBhbmRlZDogdGhpcy5leHBhbmRlZCxcbiAgICAgIGFsbFNob3duOiB0aGlzLmFsbFNob3duLFxuICAgICAgc2VsZWN0ZWRDb3VudCxcbiAgICAgIGlzU2luZ2xlT3B0aW9uOiB0aGlzLmNvbmZpZy5jb250cm9sID09PSAnc2luZ2xlb3B0aW9uJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBET00uZGVsZWdhdGUoXG4gICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBgLnl4dC1GaWx0ZXJPcHRpb25zLW9wdGlvbnNgKSxcbiAgICAgIHRoaXMuY29uZmlnLm9wdGlvblNlbGVjdG9yLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3B0aW9uKHBhcnNlSW50KGV2ZW50LnRhcmdldC5kYXRhc2V0LmluZGV4KSwgZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuXG4gICAgLy8gcmVzZXQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dSZXNldCAmJiBzZWxlY3RlZENvdW50ID4gMCkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLXJlc2V0JyksXG4gICAgICAgICdjbGljaycsXG4gICAgICAgIHRoaXMuY2xlYXJPcHRpb25zLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIHNob3cgbW9yZS9sZXNzIGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zaG93TW9yZSkge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLXNob3dUb2dnbGUnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWxsU2hvd24gPSAhdGhpcy5hbGxTaG93bjtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBidXR0b25cbiAgICBpZiAodGhpcy5jb25maWcuc2hvd0V4cGFuZCkge1xuICAgICAgY29uc3QgbGVnZW5kID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtRmlsdGVyT3B0aW9ucy1jbGlja2FibGVMZWdlbmQnKTtcbiAgICAgIERPTS5vbihcbiAgICAgICAgbGVnZW5kLFxuICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgY2xpY2sgPT4ge1xuICAgICAgICAgIGlmIChjbGljay5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICBET00ub24oXG4gICAgICAgIGxlZ2VuZCxcbiAgICAgICAgJ2tleWRvd24nLFxuICAgICAgICBrZXkgPT4ge1xuICAgICAgICAgIGlmIChrZXkua2V5ID09PSAnICcgfHwga2V5LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAga2V5LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjbGVhck9wdGlvbnMgKCkge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zLm1hcChvID0+IE9iamVjdC5hc3NpZ24oe30sIG8sIHsgc2VsZWN0ZWQ6IGZhbHNlIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZUxpc3RlbmVycyAoKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5fYnVpbGRGaWx0ZXIoKTtcbiAgICBpZiAodGhpcy5jb25maWcuc3RvcmVPbkNoYW5nZSkge1xuICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIGZpbHRlcik7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcub25DaGFuZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIF91cGRhdGVPcHRpb24gKGluZGV4LCBzZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5jb250cm9sID09PSAnc2luZ2xlb3B0aW9uJykge1xuICAgICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnMubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnLm9wdGlvbnNbaW5kZXhdID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcub3B0aW9uc1tpbmRleF0sIHsgc2VsZWN0ZWQgfSk7XG4gICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBvcHRpb25zXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBET00ucXVlcnlBbGwodGhpcy5fY29udGFpbmVyLCB0aGlzLmNvbmZpZy5vcHRpb25TZWxlY3Rvcik7XG4gICAgZWxlbWVudHMuZm9yRWFjaChlID0+IGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2ZhbHNlJykpO1xuICAgIHRoaXMuX2FwcGx5RmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW5kIHJldHVybiB0aGUgRmlsdGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyICgpIHtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5jb25maWcub3B0aW9uc1xuICAgICAgLmZpbHRlcihvID0+IG8uc2VsZWN0ZWQpXG4gICAgICAubWFwKG8gPT4gby5maWx0ZXJcbiAgICAgICAgPyBvLmZpbHRlclxuICAgICAgICA6IEZpbHRlci5lcXVhbChvLmZpZWxkLCBvLnZhbHVlKSk7XG5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KHRoaXMubmFtZSwgdGhpcy5jb25maWcub3B0aW9ucy5maWx0ZXIobyA9PiBvLnNlbGVjdGVkKS5tYXAobyA9PiBvLmxhYmVsKSk7XG4gICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMFxuICAgICAgPyBGaWx0ZXIuZ3JvdXAoLi4uZmlsdGVycylcbiAgICAgIDoge307XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJhbmdlRmlsdGVyQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0byBmaWx0ZXIgb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGQgPSBjb25maWcuZmllbGQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmaWx0ZXIgdmFsdWUgY2hhbmdlc1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uQ2hhbmdlID0gY29uZmlnLm9uQ2hhbmdlIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc3RvcmVzIHRoZSBmaWx0ZXIgdG8gc3RvcmFnZSBvbiBlYWNoIGNoYW5nZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnN0b3JlT25DaGFuZ2U7XG5cbiAgICBsZXQgbWluVmFsID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5taW5gKTtcbiAgICBpZiAodHlwZW9mIG1pblZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pblZhbCA9IE51bWJlci5wYXJzZUludChtaW5WYWwpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgbGV0IG1heFZhbCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke3RoaXMubmFtZX0ubWF4YCk7XG4gICAgaWYgKHR5cGVvZiBtaW5WYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIucGFyc2VJbnQobWF4VmFsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmFuZ2UgcmVwcmVzZW50ZWRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmFuZ2UgPSB7XG4gICAgICBtaW46IG1pblZhbCB8fCBjb25maWcuaW5pdGlhbE1pbiB8fCAwLFxuICAgICAgbWF4OiBtYXhWYWwgfHwgY29uZmlnLmluaXRpYWxNYXggfHwgMTBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgZm9yIHRoZSByYW5nZSBjb250cm9sXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RpdGxlID0gY29uZmlnLnRpdGxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGxhYmVsIHRvIGRpc3BsYXkgZm9yIHRoZSBtaW4gaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWluTGFiZWwgPSBjb25maWcubWluTGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBsYWJlbCB0byBkaXNwbGF5IGZvciB0aGUgbWF4IGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGBjb250cm9scy9yYW5nZWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUmFuZ2VGaWx0ZXInO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB0aXRsZTogdGhpcy5fdGl0bGUsXG4gICAgICBtaW5MYWJlbDogdGhpcy5fbWluTGFiZWwsXG4gICAgICBtYXhMYWJlbDogdGhpcy5fbWF4TGFiZWwsXG4gICAgICBtaW5WYWx1ZTogdGhpcy5fcmFuZ2UubWluLFxuICAgICAgbWF4VmFsdWU6IHRoaXMuX3JhbmdlLm1heFxuICAgIH0pKTtcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtcmFuZ2UnLCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVSYW5nZShldmVudC50YXJnZXQuZGF0YXNldC5rZXksIE51bWJlci5wYXJzZUludChldmVudC50YXJnZXQudmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldE1pbiAodmFsdWUpIHtcbiAgICB0aGlzLl91cGRhdGVSYW5nZSgnbWluJywgdmFsdWUpO1xuICB9XG5cbiAgc2V0TWF4ICh2YWx1ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtYXgnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCByYW5nZSBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByYW5nZSBrZXkgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUga2V5XG4gICAqL1xuICBfdXBkYXRlUmFuZ2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9yYW5nZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JhbmdlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1pbmAsIHRoaXMuX3JhbmdlLm1pbik7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1heGAsIHRoaXMuX3JhbmdlLm1heCk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBmaWx0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIF9idWlsZEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIEZpbHRlci5pbmNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fcmFuZ2UubWluLCB0aGlzLl9yYW5nZS5tYXgpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBEYXRlRmlsdGVyQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogQSBmaWx0ZXIgZm9yIGEgcmFuZ2Ugb2YgZGF0ZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcGkgZmllbGQgdGhpcyBmaWx0ZXIgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGQgPSBjb25maWcuZmllbGQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBmb3IgdGhlIGRhdGUgcmFuZ2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1pbiBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21pbkxhYmVsID0gY29uZmlnLm1pbkxhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1heCBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgdXNlZCB3aGVuIGEgZGF0ZSBpcyBjaGFuZ2VkXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc3RvcmVPbkNoYW5nZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgZmlsdGVyIHJlcHJlc2VudHMgYW4gZXhjbHVzaXZlIHJhbmdlLCByYXRoZXIgdGhhbiBhbiBpbmNsdXNpdmUgb25lXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0V4Y2x1c2l2ZSA9IGNvbmZpZy5pc0V4Y2x1c2l2ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGBjb250cm9scy9kYXRlYDtcblxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0b2RheVN0cmluZyA9IGAke3RvZGF5LmdldEZ1bGxZZWFyKCl9LSR7YCR7dG9kYXkuZ2V0TW9udGgoKSArIDF9YC5wYWRTdGFydCgyLCAnMCcpfS0ke2Ake3RvZGF5LmdldERhdGUoKX1gLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICBjb25zdCBtaW5EYXRlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5taW5gKTtcbiAgICBjb25zdCBtYXhEYXRlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5tYXhgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGRhdGUgcmFuZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RhdGUgPSB7XG4gICAgICBtaW46IG1pbkRhdGUgfHwgY29uZmlnLmluaXRpYWxNaW4gfHwgdG9kYXlTdHJpbmcsXG4gICAgICBtYXg6IG1heERhdGUgfHwgY29uZmlnLmluaXRpYWxNYXggfHwgdG9kYXlTdHJpbmdcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0RhdGVSYW5nZUZpbHRlcic7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHRpdGxlOiB0aGlzLl90aXRsZSxcbiAgICAgIG1pbkxhYmVsOiB0aGlzLl9taW5MYWJlbCxcbiAgICAgIG1heExhYmVsOiB0aGlzLl9tYXhMYWJlbCxcbiAgICAgIGRhdGVNaW46IHRoaXMuX2RhdGUubWluLFxuICAgICAgZGF0ZU1heDogdGhpcy5fZGF0ZS5tYXhcbiAgICB9KSk7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgRE9NLmRlbGVnYXRlKHRoaXMuX2NvbnRhaW5lciwgJy5qcy15ZXh0LWRhdGUnLCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVSYW5nZShldmVudC50YXJnZXQuZGF0YXNldC5rZXksIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW4gZGF0ZSB0byB0aGUgb25lIHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIERhdGUgdG8gc2V0IGluIHl5eXktbW0tZGQgc3RyaW5nIGZvcm1hdFxuICAgKi9cbiAgc2V0TWluIChkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlUmFuZ2UoJ21pbicsIGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4IGRhdGUgdG8gdGhlIG9uZSBwcm92aWRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSBEYXRlIHRvIHNldCBpbiB5eXl5LW1tLWRkIHN0cmluZyBmb3JtYXRcbiAgICovXG4gIHNldE1heCAoZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtYXgnLCBkYXRlKTtcbiAgfVxuXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSByYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgZm9yIHRoZSBkYXRlIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3RyaW5nIGRhdGUgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVSYW5nZSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX2RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kYXRlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1pbmAsIHRoaXMuX2RhdGUubWluKTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke3RoaXMubmFtZX0ubWF4YCwgdGhpcy5fZGF0ZS5tYXgpO1xuXG4gICAgdGhpcy5fb25DaGFuZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gYXBpIGZpbHRlciB3aXRoIHRoZSBjdXJyZW50IGRhdGUgc3RhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZEZpbHRlciAoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGUubWluID09PSAnJyB8fCB0aGlzLl9kYXRlLm1heCA9PT0gJycpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzRXhjbHVzaXZlXG4gICAgICA/IEZpbHRlci5leGNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fZGF0ZS5taW4sIHRoaXMuX2RhdGUubWF4KVxuICAgICAgOiBGaWx0ZXIuaW5jbHVzaXZlUmFuZ2UodGhpcy5fZmllbGQsIHRoaXMuX2RhdGUubWluLCB0aGlzLl9kYXRlLm1heCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZhY2V0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuY2xhc3MgRmFjZXRzQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGFib3ZlIHRoZSBjb250cm9sc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IGNvbmZpZy50aXRsZSB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgcmVzdWx0cyBuZXh0IHRvIGVhY2ggZmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dDb3VudCA9IGNvbmZpZy5zaG93Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0NvdW50O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdHJpZ2dlciBhIHNlYXJjaCBvbiBlYWNoIGNoYW5nZSB0byBhIGZpbHRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoT25DaGFuZ2UgPSBjb25maWcuc2VhcmNoT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgYnV0dG9uIHRvIHJlc2V0IGZvciBlYWNoIGZhY2V0IGdyb3VwXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0ID0gY29uZmlnLnJlc2V0RmFjZXQgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0TGFiZWwgPSBjb25maWcucmVzZXRGYWNldExhYmVsIHx8ICdyZXNldCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgXCJyZXNldCBhbGxcIiBidXR0b24gdG8gcmVzZXQgYWxsIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGYWNldHMgPSBjb25maWcucmVzZXRGYWNldHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucmVzZXRGYWNldHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIFwicmVzZXQgYWxsXCIgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmFjZXRzTGFiZWwgPSBjb25maWcucmVzZXRGYWNldHNMYWJlbCB8fCAncmVzZXQgYWxsJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGZhY2V0cyB0byBzaG93IGJlZm9yZSBkaXNwbGF5aW5nIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnc2hvdyBtb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3MgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnc2hvdyBsZXNzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGVuYWJsZSBoaWRpbmcgZXhjZXNzIGZhY2V0cyBpbiBlYWNoIGdyb3VwIHdpdGggYSBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCIgYnV0dG9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZSA9IGNvbmZpZy5zaG93TW9yZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TW9yZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFsbG93IGV4cGFuZGluZyBhbmQgY29sbGFwc2luZyBlYWNoIGdyb3VwIG9mIGZhY2V0c1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXhwYW5kID0gY29uZmlnLmV4cGFuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5leHBhbmQ7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgY3VycmVudGx5IGFwcGxpZWQgZmlsdGVycyB3aGVuIGNvbGxhcHNlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd051bWJlckFwcGxpZWQgPSBjb25maWcuc2hvd051bWJlckFwcGxpZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd051bWJlckFwcGxpZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHRvIGRpc3BsYXkgb24gdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcHBseUxhYmVsID0gY29uZmlnLmFwcGx5TGFiZWwgfHwgJ2FwcGx5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9scyB0byB1c2UgZm9yIGVhY2ggZmllbGQuIEVhY2ggdHlwZSBvZiBmaWx0ZXIgaGFzIGEgZGVmYXVsdFxuICAgICAqICRlcSA6IG11bHRpb3B0aW9uIChjaGVja2JveClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRDb250cm9scyA9IGNvbmZpZy5maWVsZENvbnRyb2xzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdG9yIG9mIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hcHBseUJ1dHRvblNlbGVjdG9yID0gY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IgfHwgbnVsbDtcblxuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BsYXlzIGEgc2V0IG9mIGR5bmFtaWMgZmlsdGVycyByZXR1cm5lZCBmcm9tIHRoZSBiYWNrZW5kXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjZXRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIHRoaXMuY29uZmlnID0gbmV3IEZhY2V0c0NvbmZpZyhjb25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSBmb3IgdGhlIHNlYXJjaFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleTtcblxuICAgIC8vIGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdG9yIG9mIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYXBwbHlCdXR0b25TZWxlY3RvciA9IGNvbmZpZy5hcHBseUJ1dHRvblNlbGVjdG9yIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgZm9yIHRoZSBkYXRhIHN0b3JhZ2UgdG8gbGlzdGVuIGZvciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkRZTkFNSUNfRklMVEVSUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWx0ZXIgYm94IHRoYXQgZGlzcGxheXMgdGhlIGR5bmFtaWMgZmlsdGVyc1xuICAgICAqIEB0eXBlIHtGaWx0ZXJCb3hDb21wb25lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJib3ggPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZhY2V0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ2ZpbHRlcnMvZmFjZXRzJztcbiAgfVxuXG4gIHJlbW92ZSAoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcmJveCkge1xuICAgICAgdGhpcy5fZmlsdGVyYm94LnJlbW92ZSgpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIHRoaXMuY29yZS5lbmFibGVEeW5hbWljRmlsdGVycygpO1xuXG4gICAgaWYgKHRoaXMuX2ZpbHRlcmJveCkge1xuICAgICAgdGhpcy5fZmlsdGVyYm94LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGxldCB7IGZpbHRlcnMgfSA9IHRoaXMuX3N0YXRlLmdldCgpO1xuXG4gICAgaWYgKCFmaWx0ZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmlsdGVycyA9IGZpbHRlcnMubWFwKGYgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGYsIHtcbiAgICAgICAgdHlwZTogJ0ZpbHRlck9wdGlvbnMnLFxuICAgICAgICBjb250cm9sOiB0aGlzLmNvbmZpZy5maWVsZENvbnRyb2xzW2YuZmllbGRJZF0gfHwgJ211bHRpb3B0aW9uJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9maWx0ZXJib3ggPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKFxuICAgICAgJ0ZpbHRlckJveCcsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZywge1xuICAgICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgbmFtZTogYCR7dGhpcy5uYW1lfS5maWx0ZXJib3hgLFxuICAgICAgICBjb250YWluZXI6ICcuanMteXh0LUZhY2V0cycsXG4gICAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgICAgcmVzZXRGaWx0ZXI6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXQsXG4gICAgICAgIHJlc2V0RmlsdGVyczogdGhpcy5jb25maWcucmVzZXRGYWNldHMsXG4gICAgICAgIHJlc2V0RmlsdGVyTGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXRMYWJlbCxcbiAgICAgICAgcmVzZXRGaWx0ZXJzTGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXRzTGFiZWwsXG4gICAgICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAgICAgZmlsdGVyc1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fZmlsdGVyYm94Lm1vdW50KCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEdlb0xvY2F0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBidWlsZFNlYXJjaFBhcmFtZXRlcnMgZnJvbSAnLi4vLi4vdG9vbHMvc2VhcmNocGFyYW1zcGFyc2VyJztcblxuY29uc3QgTUVURVJTX1BFUl9NSUxFID0gMTYwOS4zNDQ7XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICAvKipcbiAgICogVGhlIHJhZGl1cywgaW4gbWlsZXMsIGFyb3VuZCB0aGUgdXNlcidzIGxvY2F0aW9uIHRvIGZpbmQgcmVzdWx0cy5cbiAgICogSWYgbG9jYXRpb24gYWNjdXJhY3kgaXMgbG93LCBhIGxhcmdlciByYWRpdXMgbWF5IGJlIHVzZWQgYXV0b21hdGljYWxseVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgcmFkaXVzOiA1MCxcblxuICAvKipcbiAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2VcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHZlcnRpY2FsS2V5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBzdWJtaXRzIGEgc2VhcmNoIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzZWFyY2hPbkNoYW5nZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aXRsZTogJ0xvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGxhYmVsOiAnTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB1cmwgdG8gc2hvdyBpbiB0aGUgZ2VvIGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2VvQnV0dG9uSWNvbjogJycsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIHNob3cgaW4gdGhlIGdlbyBidXR0b25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdlb0J1dHRvblRleHQ6ICdVc2UgTXkgTG9jYXRpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBzaG93IHdoZW4gZ2VvbG9jYXRpb24gaXMgZW5hYmxlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZW5hYmxlZFRleHQ6ICdDdXJyZW50IExvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyB3aGVuIGxvYWRpbmcgdGhlIHVzZXIncyBsb2NhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgbG9hZGluZ1RleHQ6ICdGaW5kaW5nIFlvdXIgTG9jYXRpb24uLi4nLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBzaG93IGlmIHRoZSB1c2VyJ3MgbG9jYXRpb24gY2Fubm90IGJlIGZvdW5kXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBlcnJvclRleHQ6ICdDb3VsZCBOb3QgRmluZCBZb3VyIExvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIENTUyBzZWxlY3RvciBvZiB0aGUgdG9nZ2xlIGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYnV0dG9uU2VsZWN0b3I6ICcuanMteXh0LUdlb0xvY2F0aW9uRmlsdGVyLWJ1dHRvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBDU1Mgc2VsZWN0b3Igb2YgdGhlIHF1ZXJ5IGlucHV0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBpbnB1dFNlbGVjdG9yOiAnLmpzLXl4dC1HZW9Mb2NhdGlvbkZpbHRlci1pbnB1dCdcbn07XG5cbi8qKlxuICogUmVuZGVycyBhIGJ1dHRvbiB0aGF0IHdoZW4gY2xpY2tlZCBhZGRzIGEgc3RhdGljIGZpbHRlciByZXByZXNlbnRpbmcgdGhlIHVzZXIncyBsb2NhdGlvblxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlb0xvY2F0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9LCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHN0cmluZyB0byB1c2UgZm9yIHRoZSBpbnB1dCBib3gsIHByb3ZpZGVkIHRvIHRlbXBsYXRlIGZvciByZW5kZXJpbmcuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWApIHx8ICcnO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCwgcSA9PiB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWx0ZXIgdG8gdXNlIGZvciB0aGUgY3VycmVudCBxdWVyeVxuICAgICAqIEB0eXBlIHtGaWx0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWApIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgdGhpcy5maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmZpbHRlciA9IEpTT04ucGFyc2UodGhpcy5maWx0ZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gLCBmID0+IHsgdGhpcy5maWx0ZXIgPSBmOyB9KTtcblxuICAgIHRoaXMuc2VhcmNoUGFyYW1ldGVycyA9IGJ1aWxkU2VhcmNoUGFyYW1ldGVycyhjb25maWcuc2VhcmNoUGFyYW1ldGVycyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnR2VvTG9jYXRpb25GaWx0ZXInO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnY29udHJvbHMvZ2VvbG9jYXRpb24nO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAnJztcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLl9jb25maWcuZW5hYmxlZFRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLmdlb0xvYWRpbmcpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5fY29uZmlnLmxvYWRpbmdUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5nZW9FcnJvcikge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLl9jb25maWcuZXJyb3JUZXh0O1xuICAgIH1cbiAgICBzdXBlci5zZXRTdGF0ZSh7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdGl0bGU6IHRoaXMuX2NvbmZpZy50aXRsZSxcbiAgICAgIGdlb0VuYWJsZWQ6IHRoaXMuX2VuYWJsZWQsXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIGxhYmVsVGV4dDogdGhpcy5fY29uZmlnLmxhYmVsLFxuICAgICAgZW5hYmxlZFRleHQ6IHRoaXMuX2NvbmZpZy5lbmFibGVkVGV4dCxcbiAgICAgIGxvYWRpbmdUZXh0OiB0aGlzLl9jb25maWcubG9hZGluZ1RleHQsXG4gICAgICBlcnJvclRleHQ6IHRoaXMuX2NvbmZpZy5lcnJvclRleHQsXG4gICAgICBnZW9CdXR0b25JY29uOiB0aGlzLl9jb25maWcuZ2VvQnV0dG9uSWNvbixcbiAgICAgIGdlb1ZhbHVlOiB0aGlzLl9lbmFibGVkIHx8IGRhdGEuZ2VvTG9hZGluZyB8fCBkYXRhLmdlb0Vycm9yID8gJycgOiB0aGlzLnF1ZXJ5LFxuICAgICAgZ2VvUGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgZ2VvQnV0dG9uVGV4dDogdGhpcy5fY29uZmlnLmdlb0J1dHRvblRleHRcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0QXV0b0NvbXBsZXRlKHRoaXMuX2NvbmZpZy5pbnB1dFNlbGVjdG9yKTtcbiAgICBET00ub24odGhpcy5fY29uZmlnLmJ1dHRvblNlbGVjdG9yLCAnY2xpY2snLCAoKSA9PiB0aGlzLl90b2dnbGVHZW9GaWx0ZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIHdpcmUgdXAgb3VyIGF1dG8gY29tcGxldGUgb24gYW4gaW5wdXQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIGF1dG8gY29tcGxldGUgY29tcG9uZW50IHRvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdXRvY29tcGxldGUgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYCxcbiAgICAgIGlzRmlsdGVyU2VhcmNoOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiAnLmpzLXl4dC1HZW9Mb2NhdGlvbkZpbHRlci1hdXRvY29tcGxldGUnLFxuICAgICAgb3JpZ2luYWxRdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIG9yaWdpbmFsRmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgIGlucHV0RWw6IGlucHV0U2VsZWN0b3IsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fY29uZmlnLnZlcnRpY2FsS2V5LFxuICAgICAgc2VhcmNoUGFyYW1ldGVyczogdGhpcy5zZWFyY2hQYXJhbWV0ZXJzLFxuICAgICAgb25TdWJtaXQ6IChxdWVyeSwgZmlsdGVyKSA9PiB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBGaWx0ZXIuZnJvbVJlc3BvbnNlKGZpbHRlcik7XG4gICAgICAgIHRoaXMuX3NhdmVEYXRhVG9TdG9yYWdlKHF1ZXJ5LCB0aGlzLmZpbHRlcik7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzdGF0aWMgZmlsdGVyIHJlcHJlc2VudGluZyB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdG9nZ2xlR2VvRmlsdGVyICgpIHtcbiAgICBpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGdlb0Vycm9yOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGdlb0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxuICAgICAgICBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5fYnVpbGRGaWx0ZXIocG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX3NhdmVEYXRhVG9TdG9yYWdlKCcnLCBmaWx0ZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKTtcbiAgICAgICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHRoaXMuc2V0U3RhdGUoeyBnZW9FcnJvcjogdHJ1ZSB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIHByb3ZpZGVkIGZpbHRlciB1bmRlciB0aGlzIGNvbXBvbmVudCdzIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSB0byBzYXZlXG4gICAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXIgVGhlIGZpbHRlciB0byBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gc2F2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NhdmVEYXRhVG9TdG9yYWdlIChxdWVyeSwgZmlsdGVyLCBwb3NpdGlvbikge1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHF1ZXJ5KTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCwgZmlsdGVyKTtcbiAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OLCB7XG4gICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnNlYXJjaE9uQ2hhbmdlKSB7XG4gICAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZJTFRFUik7XG4gICAgICBsZXQgdG90YWxGaWx0ZXIgPSBmaWx0ZXJzWzBdO1xuICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICB0b3RhbEZpbHRlciA9IEZpbHRlci5hbmQoLi4uZmlsdGVycyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWFyY2hRdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSB8fCAnJztcbiAgICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG5cbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgICB0aGlzLmNvcmUudmVydGljYWxTZWFyY2godGhpcy5fY29uZmlnLnZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGlucHV0OiBzZWFyY2hRdWVyeSxcbiAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICAgIGZhY2V0RmlsdGVyOiBKU09OLnN0cmluZ2lmeShmYWNldEZpbHRlcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHBvc2l0aW9uLCBjb25zdHJ1Y3QgYSBGaWx0ZXIgb2JqZWN0XG4gICAqIEBwYXJhbSB7UG9zdGl0aW9ufSBwb3NpdGlvbiBUaGUgcG9zaXRpb25cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZEZpbHRlciAocG9zaXRpb24pIHtcbiAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGFjY3VyYWN5IH0gPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoYWNjdXJhY3ksIHRoaXMuX2NvbmZpZy5yYWRpdXMgKiBNRVRFUlNfUEVSX01JTEUpO1xuICAgIHJldHVybiBGaWx0ZXIucG9zaXRpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSwgcmFkaXVzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU29ydE9wdGlvbnNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuXG4vKipcbiAqIFJlbmRlcnMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nIFZlcnRpY2FsIFJlc3VsdHMuXG4gKiBUT0RPOiBob3cgdG8gZGVhbCB3aXRoIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNvbXBvbmVudCAoYW5kIGZpbHRlcnMgaW4gZ2VuZXJhbCksXG4gKiBpZGVhbGx5IFwiaWRlbnRpY2FsXCIgZmlsdGVycy9zb3J0cyB3b3VsZCBiZSBzeW5jZWQgdXAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvcnRPcHRpb25zQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGFzc2lnbkRlZmF1bHRzKGNvbmZpZyksIHN5c3RlbUNvbmZpZyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4ID0gcGFyc2VJbnQodGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUodGhpcy5uYW1lKSkgfHwgMDtcbiAgICB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4XS5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLmhpZGVFeGNlc3NPcHRpb25zID0gdGhpcy5fY29uZmlnLnNob3dNb3JlICYmIHRoaXMuc2VsZWN0ZWRPcHRpb25JbmRleCA8PSB0aGlzLl9jb25maWcuc2hvd01vcmVMaW1pdDtcbiAgICB0aGlzLnNob3dSZXNldCA9IHRoaXMuX2NvbmZpZy5zaG93UmVzZXQgJiYgdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4ICE9PSAwO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5oaWRlRXhjZXNzT3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zbGljZSgwLCB0aGlzLl9jb25maWcuc2hvd01vcmVMaW1pdCk7XG4gICAgfVxuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBoaWRlRXhjZXNzT3B0aW9uczogdGhpcy5oaWRlRXhjZXNzT3B0aW9ucyxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHNob3dSZXNldDogdGhpcy5zaG93UmVzZXRcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICAvLyBIYW5kbGUgcmFkaW8gYnV0dG9uIHNlbGVjdGlvbnNcbiAgICBET00ub24oXG4gICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1Tb3J0T3B0aW9ucy1maWVsZFNldCcpLFxuICAgICAgJ2NoYW5nZScsXG4gICAgICBldnQgPT4gdGhpcy5oYW5kbGVPcHRpb25TZWxlY3Rpb24ocGFyc2VJbnQoZXZ0LnRhcmdldC52YWx1ZSkpXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIG1vcmUvbGVzcyBidXR0b25cbiAgICBpZiAodGhpcy5fY29uZmlnLnNob3dNb3JlKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LVNvcnRPcHRpb25zLXNob3dUb2dnbGUnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZUV4Y2Vzc09wdGlvbnMgPSAhdGhpcy5oaWRlRXhjZXNzT3B0aW9ucztcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgc2hvdyByZXNldCBidXR0b25cbiAgICBpZiAodGhpcy5zaG93UmVzZXQpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtU29ydE9wdGlvbnMtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVPcHRpb25TZWxlY3Rpb24oMClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXIgYXBwbHkgYnV0dG9uXG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIERPTS5vbihcbiAgICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtU29ydE9wdGlvbnMtYXBwbHknKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgKCkgPT4gdGhpcy5fc29ydFJlc3VsdHMoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVPcHRpb25TZWxlY3Rpb24gKG9wdGlvbkluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWRPcHRpb24ob3B0aW9uSW5kZXgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3NvcnRSZXN1bHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVNlbGVjdGVkT3B0aW9uIChvcHRpb25JbmRleCkge1xuICAgIHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkT3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnNbb3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25JbmRleCA9IG9wdGlvbkluZGV4O1xuICAgIHRoaXMuc2hvd1Jlc2V0ID0gdGhpcy5fY29uZmlnLnNob3dSZXNldCAmJiBvcHRpb25JbmRleCAhPT0gMDtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG4gIH1cblxuICBfc29ydFJlc3VsdHMgKCkge1xuICAgIGNvbnN0IG9wdGlvbkluZGV4ID0gdGhpcy5zZWxlY3RlZE9wdGlvbkluZGV4O1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc1tvcHRpb25JbmRleF07XG5cbiAgICAvLyBzZWFyY2hPbkNoYW5nZSByZWFsbHkgbWVhbnMgc29ydCBvbiBjaGFuZ2UgaGVyZSwganVzdCB0aGF0IHRoZSBzb3J0IGlzIGRvbmUgdGhyb3VnaCBhIHNlYXJjaCxcbiAgICAvLyBUaGlzIHdhcyBkb25lIHRvIGhhdmUgYSBjb25zaXN0ZW50IG9wdGlvbiBuYW1lIGJldHdlZW4gZmlsdGVycy5cbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KHRoaXMubmFtZSwgb3B0aW9uSW5kZXgpO1xuICAgIGlmICh0aGlzLl9jb25maWcuc3RvcmVPbkNoYW5nZSAmJiBvcHRpb25JbmRleCA9PT0gMCkge1xuICAgICAgdGhpcy5jb3JlLmNsZWFyU29ydEJ5cygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY29uZmlnLnN0b3JlT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuY29yZS5zZXRTb3J0QnlzKG9wdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX3NlYXJjaCgpO1xuICAgIHRoaXMuX2NvbmZpZy5vbkNoYW5nZShvcHRpb24pO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2VhcmNoIHdpdGggYWxsIGZpbHRlcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgX3NlYXJjaCAoKSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgIDogYWxsRmlsdGVyc1swXTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKSB8fCAnJztcbiAgICBjb25zdCBmYWNldEZpbHRlciA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVIpWzBdO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl9jb25maWcudmVydGljYWxLZXksIHtcbiAgICAgIGlucHV0LFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU29ydE9wdGlvbnMnO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnY29udHJvbHMvc29ydG9wdGlvbnMnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzIChjb25maWcpIHtcbiAgY29uc3QgdXBkYXRlZENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG5cbiAgLy8gT3B0aW9uYWwsIFRoZSBsYWJlbCB1c2VkIGZvciB0aGUg4oCcZGVmYXVsdOKAnSBzb3J0IChha2EgdGhlIHNvcnQgc3BlY2lmaWVkIGJ5IHRoZSBleHBlcmllbmNlIGNvbmZpZ1wiKS5cbiAgdXBkYXRlZENvbmZpZy5kZWZhdWx0U29ydExhYmVsID0gY29uZmlnLmRlZmF1bHRTb3J0TGFiZWwgfHwgJ0Jlc3QgTWF0Y2gnO1xuXG4gIC8vIEFycmF5IG9mIHNlYXJjaCBvcHRpb25zLCB3aGVyZSBhbiBvcHRpb24gaGFzIHR5cGUsIGxhYmVsLCBhbmQgaWYgaXMgdHlwZSBGSUVMRCBhbHNvIGEgbGFiZWwgYW5kIGRpcmVjdGlvblxuICBpZiAoIWNvbmZpZy5vcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdjb25maWcub3B0aW9ucyBhcmUgcmVxdWlyZWQnLCAnU29ydE9wdGlvbnMnKTtcbiAgfVxuICBjb25zdCBPUFRJT05fVFlQRVMgPSBbJ0ZJRUxEJywgJ1JFTEVWQU5DRScsICdFTlRJVFlfRElTVEFOQ0UnXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5vcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMnLCAnU29ydE9wdGlvbnMnKTtcbiAgfVxuICB1cGRhdGVkQ29uZmlnLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICBpZiAoIW9wdGlvbi5sYWJlbCB8fCAhb3B0aW9uLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcihgb3B0aW9uLmxhYmVsIGFuZCBvcHRpb24udHlwZSBhcmUgcmVxdWlyZWQgb3B0aW9uICR7b3B0aW9ufWAsICdTb3J0T3B0aW9ucycpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPcHRpb24gPSB7IGlzU2VsZWN0ZWQ6IGZhbHNlIH07XG4gICAgbmV3T3B0aW9uLmxhYmVsID0gb3B0aW9uLmxhYmVsO1xuICAgIG5ld09wdGlvbi50eXBlID0gb3B0aW9uLnR5cGU7XG4gICAgY29uc3QgaXNGaWVsZCA9IE9QVElPTl9UWVBFUy5pbmRleE9mKG5ld09wdGlvbi50eXBlKSA9PT0gMDtcbiAgICBpZiAoaXNGaWVsZCAmJiBvcHRpb24uZmllbGQgJiYgb3B0aW9uLmRpcmVjdGlvbikge1xuICAgICAgbmV3T3B0aW9uLmZpZWxkID0gb3B0aW9uLmZpZWxkO1xuICAgICAgbmV3T3B0aW9uLmRpcmVjdGlvbiA9IG9wdGlvbi5kaXJlY3Rpb247XG4gICAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoYG9wdGlvbi5maWVsZCBhbmQgb3B0aW9uLmRpcmVjdGlvbiBhcmUgcmVxdWlyZWQgZm9yIG9wdGlvbjogJHtvcHRpb259YCwgJ1NvcnRPcHRpb25zJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdPcHRpb247XG4gIH0pO1xuICAvLyBBZGQgZGVmYXVsdCBvcHRpb24gdG8gdGhlIGZyb250IG9mIHRoZSBvcHRpb25zIGFycmF5XG4gIHVwZGF0ZWRDb25maWcub3B0aW9ucy51bnNoaWZ0KHtcbiAgICBsYWJlbDogdXBkYXRlZENvbmZpZy5kZWZhdWx0U29ydExhYmVsLFxuICAgIGlzU2VsZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgc2VsZWN0b3IgdXNlZCBmb3Igb3B0aW9ucyBpbiB0aGUgdGVtcGxhdGVcbiAgdXBkYXRlZENvbmZpZy5vcHRpb25TZWxlY3RvciA9IGNvbmZpZy5vcHRpb25TZWxlY3RvciB8fCAneXh0LVNvcnRPcHRpb25zLW9wdGlvblNlbGVjdG9yJztcblxuICAvLyBPcHRpb25hbCwgaWYgdHJ1ZSwgdHJpZ2dlcnMgYSBzZWFyY2ggb24gZWFjaCBjaGFuZ2UgdG8gYSBmaWx0ZXIsXG4gIC8vIGlmIGZhbHNlIHRoZSBjb21wb25lbnQgYWxzbyByZW5kZXJzIGFuIGFwcGx5IGJ1dHRvbiwgZGVmYXVsdHMgdG8gZmFsc2VcbiAgdXBkYXRlZENvbmZpZy5zZWFyY2hPbkNoYW5nZSA9IGNvbmZpZy5zZWFyY2hPbkNoYW5nZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zZWFyY2hPbkNoYW5nZTtcblxuICAvLyBPcHRpb25hbCwgc2hvdyBhIHJlc2V0IGJ1dHRvbi4gQ2xpY2tpbmcgaXQgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSB1c2VyIHRvIHRoZSBkZWZhdWx0IHNvcnRpbmcgb3B0aW9uLlxuICB1cGRhdGVkQ29uZmlnLnNob3dSZXNldCA9IGNvbmZpZy5zaG93UmVzZXQgfHwgZmFsc2U7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSByZXNldCBidXR0b25cbiAgdXBkYXRlZENvbmZpZy5yZXNldExhYmVsID0gY29uZmlnLnJlc2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAvLyBPcHRpb25hbCwgdGhlIG1heCBudW1iZXIgb2YgZmlsdGVyIG9wdGlvbnMgdG8gc2hvdyBiZWZvcmUgY29sbGFwc2luZyBleHRyYXNcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAvLyBPcHRpb25hbCwgYWxsb3cgY29sbGFwc2luZyBleGNlc3Mgc29ydCBvcHRpb25zIGFmdGVyIGEgbGltaXRcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZSA9IGNvbmZpZy5zaG93TW9yZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TW9yZTtcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZSA9IHVwZGF0ZWRDb25maWcuc2hvd01vcmUgJiYgKHVwZGF0ZWRDb25maWcub3B0aW9ucy5sZW5ndGggPiB1cGRhdGVkQ29uZmlnLnNob3dNb3JlTGltaXQpO1xuXG4gIC8vIE9wdGlvbmFsLCB0aGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIG9wdGlvbnNcbiAgdXBkYXRlZENvbmZpZy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ1Nob3cgbW9yZSc7XG5cbiAgLy8gT3B0aW9uYWwsIHRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3Mgb3B0aW9uc1xuICB1cGRhdGVkQ29uZmlnLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnU2hvdyBsZXNzJztcblxuICAvLyBPcHRpb25hbCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBjaGFuZ2VkXG4gIHVwZGF0ZWRDb25maWcub25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgLy8gT3B0aW9uYWwsIFRvcCB0aXRsZSBmb3IgdGhlIHNvcnRpbmcgY29tcG9uZW50XG4gIHVwZGF0ZWRDb25maWcubGFiZWwgPSBjb25maWcubGFiZWwgfHwgJ1NvcnRpbmcnO1xuXG4gIC8vIE9wdGlvbmFsLCB3aGVuIHRydWUgY29tcG9uZW50IGRvZXMgbm90IHVwZGF0ZSBnbG9iYWxTdG9yYWdlXG4gIC8vIHBvc3NpYmx5IGRlbGVnYXRpbmcgdGhhdCB0byBhIGhpZ2hlci1vcmRlci9jb21wb3NpdGUgY29tcG9uZW50XG4gIHVwZGF0ZWRDb25maWcuc3RvcmVPbkNoYW5nZSA9IGNvbmZpZy5zdG9yZU9uQ2hhbmdlID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnN0b3JlT25DaGFuZ2U7XG5cbiAgdXBkYXRlZENvbmZpZy5hcHBseUxhYmVsID0gY29uZmlnLmFwcGx5TGFiZWwgfHwgJ0FwcGx5JztcblxuICB1cGRhdGVkQ29uZmlnLnZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLnZlcnRpY2FsS2V5O1xuICBpZiAoIXVwZGF0ZWRDb25maWcudmVydGljYWxLZXkpIHtcbiAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ3ZlcnRpY2FsIGtleSBpcyByZXF1aXJlZCcsICdTb3J0T3B0aW9ucycpO1xuICB9XG5cbiAgLy8gbm90ZTogc2hvd0V4cGFuZCBhbmQgc2hvd051bWJlckFwcGxpZWQgZXhwbGljaXRseSBub3QgaW5jbHVkZWQsIG9uIHRoZSBncm91bmRzIHRoYXRcbiAgLy8gc29ydGluZyBzaG91bGQgYWx3YXlzIGJlIGV4cG9zZWQgdG8gdGhlIHVzZXIgaWYgYWRkZWQuXG5cbiAgcmV0dXJuIHVwZGF0ZWRDb25maWc7XG59XG4iLCIvKiogQG1vZHVsZSBEaXJlY3RBbnN3ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBFdmVudFR5cGVzIGFyZSBleHBsaWNpdCBzdHJpbmdzIGRlZmluZWRcbiAqIGZvciB3aGF0IHRoZSBzZXJ2ZXIgZXhwZWN0cyBmb3IgYW5hbHl0aWNzLlxuICpcbiAqIEBlbnVtXG4gKi9cbmNvbnN0IEV2ZW50VHlwZXMgPSB7XG4gIFRIVU1CU19VUDogJ1RIVU1CU19VUCcsXG4gIFRIVU1CU19ET1dOOiAnVEhVTUJTX0RPV04nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RBbnN3ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjaWV2ZSB1cGRhdGVzIGZyb20gc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGluZGV4XG4gICAgICogQHR5cGUge1N0b3JhZ2VLZXl9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB1c2VkIGZvciBzdWJtaXR0aW5nIHRoZSBmZWVkYmFja1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1FbCB8fCAnLmpzLWRpcmVjdEFuc3dlci1mZWVkYmFjay1mb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdGh1bWJzIHVwYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNVcFNlbGVjdG9yID0gY29uZmlnLnRodW1ic1VwU2VsZWN0b3IgfHwgJy5qcy1kaXJlY3RBbnN3ZXItdGh1bWJVcCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYHRodW1icyBkb3duYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IgPSBjb25maWcudGh1bWJzRG93blNlbGVjdG9yIHx8ICcuanMtZGlyZWN0QW5zd2VyLXRodW1iRG93bic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzcGxheSB0ZXh0IGZvciB0aGUgVmlldyBEZXRhaWxzIGNsaWNrIHRvIGFjdGlvbiBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92aWV3RGV0YWlsc1RleHQgPSBjb25maWcudmlld0RldGFpbHNUZXh0IHx8ICdWaWV3IERldGFpbHMnO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0RpcmVjdEFuc3dlcic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvZGlyZWN0YW5zd2VyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBiZWZvcmVNb3VudCwgb25seSBkaXNwbGF5IHRoZSBkaXJlY3QgYW5zd2VyIGNvbXBvbmVudCBpZiBpdCBoYXMgZGF0YVxuICAgKi9cbiAgYmVmb3JlTW91bnQgKCkge1xuICAgIGlmICghdGhpcy5oYXNTdGF0ZSgnYW5zd2VyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBET00gaXMgY29uc3RydWN0ZWQsXG4gICAqIHdlIHdhbnQgdG8gd2lyZSB1cCB0aGUgYmVoYXZpb3IgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIHF1YWxpdHkgZmVlZGJhY2sgcmVwb3J0aW5nICh0aHVtYnN1cC9kb3duKVxuICAgKi9cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gQXZvaWQgYmluZGluZ3MgaWYgdGhlIGZlZWRiYWNrIGhhcyBwcmV2aW91c2x5IGJlZW4gc3VibWl0dGVkXG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoJ2ZlZWRiYWNrU3VibWl0dGVkJykgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZvciBXQ0FHIGNvbXBsaWFuY2UsIHRoZSBmZWVkYmFjayBzaG91bGQgYmUgYSBzdWJtaXR0YWJsZSBmb3JtXG4gICAgRE9NLm9uKHRoaXMuX2Zvcm1FbCwgJ3N1Ym1pdCcsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsID0gZS50YXJnZXQ7XG4gICAgICBsZXQgY2hlY2tlZFZhbHVlID0gRE9NLnF1ZXJ5KGZvcm1FbCwgJ2lucHV0OmNoZWNrZWQnKS52YWx1ZSA9PT0gJ3RydWUnO1xuXG4gICAgICB0aGlzLnJlcG9ydFF1YWxpdHkoY2hlY2tlZFZhbHVlKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAnZmVlZGJhY2tTdWJtaXR0ZWQnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIElzIHRoaXMgYWN0dWFsbHkgbmVjZXNzYXJ5PyBJIGd1ZXNzIGl0J3Mgb25seSBuZWNlc3NhcnkgaWYgdGhlXG4gICAgLy8gc3VibWl0IGJ1dHRvbiBpcyBoaWRkZW4uXG4gICAgRE9NLm9uKHRoaXMuX3RodW1ic1VwU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICAgIERPTS5vbih0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGVuYWJsZXMgZm9yIHBhcnRpYWwgdXBkYXRlcyAodGhlIGRlbHRhIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3KVxuICAgKiBAdHlwZSB7b2JqZWN0fSBUaGUgbmV3IHN0YXRlIHRvIGFwcGx5IHRvIHRoZSBvbGRcbiAgICovXG4gIHVwZGF0ZVN0YXRlIChzdGF0ZSA9IHt9KSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCksIHN0YXRlKTtcbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5ldmVudE9wdGlvbnMoZGF0YSksXG4gICAgICB2aWV3RGV0YWlsc1RleHQ6IHRoaXMuX3ZpZXdEZXRhaWxzVGV4dFxuICAgIH0pKTtcbiAgfVxuXG4gIGV2ZW50T3B0aW9ucyAoZGF0YSkge1xuICAgIGlmICghZGF0YSB8fCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogZGF0YS5yZWxhdGVkSXRlbS52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgc2VhcmNoZXI6ICdVTklWRVJTQUwnLFxuICAgICAgZW50aXR5SWQ6IGRhdGEucmVsYXRlZEl0ZW0uZGF0YS5pZCxcbiAgICAgIGN0YUxhYmVsOiB0aGlzLl92aWV3RGV0YWlsc1RleHQudG9VcHBlckNhc2UoKS5yZXBsYWNlKCcgJywgJ18nKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlcG9ydFF1YWxpdHkgd2lsbCBzZW5kIHRoZSBxdWFsaXR5IGZlZWRiYWNrIHRvIGFuYWx5dGljc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzR29vZCB0cnVlIGlmIHRoZSBhbnN3ZXIgaXMgd2hhdCB5b3Ugd2VyZSBsb29raW5nIGZvclxuICAgKi9cbiAgcmVwb3J0UXVhbGl0eSAoaXNHb29kKSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gaXNHb29kID09PSB0cnVlID8gRXZlbnRUeXBlcy5USFVNQlNfVVAgOiBFdmVudFR5cGVzLlRIVU1CU19ET1dOO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KGV2ZW50VHlwZSlcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgJ2RpcmVjdEFuc3dlcic6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBSZXN1bHRzSXRlbUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogdmVydGljYWxDb25maWdJZCB1c2VkIGZvciBhbmFseXRpY3MgYW5kIHBhc3NlZCB0byBjaGlsZHJlblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbENvbmZpZ0lkID0gb3B0cy52ZXJ0aWNhbENvbmZpZ0lkO1xuXG4gICAgLyoqXG4gICAgICogaXNVbml2ZXJzYWwgaXMgdXNlZCBmb3IgYW5hbHl0aWNzIGFuZCBwYXNzZWQgdG8gY2hpbGRyZW4gYW5kIGlzIHNldCB0b1xuICAgICAqIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQgYnkgdGhlIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzVW5pdmVyc2FsID0gb3B0cy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdSZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2l0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIHRvIGNvbnN0cnVjdCB0aGUgZXZlbnRPcHRpb25zIG9iamVjdCBmb3IgdGhlIHRpdGxlIGxpbmtcbiAgICogQHBhcmFtIGVudGl0eUlkIFRoZSBJRCBvZiB0aGUgcmVzdWx0IGl0ZW0sIGlmIHByZXNlbnRcbiAgICogQHBhcmFtIHVybCBUaGUgdXJsIG9mIHRoZSByZXN1bHQgaXRlbSwgaWYgcHJlc2VudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZXZlbnRPcHRpb25zIChlbnRpdHlJZCwgdXJsKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICBzZWFyY2hlcjogdGhpcy5faXNVbml2ZXJzYWwgPyAnVU5JVkVSU0FMJyA6ICdWRVJUSUNBTCdcbiAgICB9O1xuXG4gICAgaWYgKGVudGl0eUlkKSB7XG4gICAgICBvcHRpb25zLmVudGl0eUlkID0gZW50aXR5SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXNzZXMgZXZlbnRPcHRpb25zIHRvIHRoZSB2aWV3TW9kZWxcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHRzSXRlbUNvbXBvbmVudH1cbiAgICovXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucyhkYXRhLmlkLCBkYXRhLmxpbmspXG4gICAgfSkpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50ICovXG5cbmltcG9ydCBSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHNpdGVtY29tcG9uZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBleHRlbmRzIFJlc3VsdHNJdGVtQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1Db25maWcpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0xvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL2xvY2F0aW9ucmVzdWx0c2l0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgKi9cblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgUmVzdWx0c0l0ZW1Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbUNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvZXZlbnRyZXN1bHRzaXRlbSc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQgKi9cblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBleHRlbmRzIFJlc3VsdHNJdGVtQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3Blb3BsZXJlc3VsdHNpdGVtJztcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBQcm92aWRlciAqL1xuXG4vKipcbiAqIEEgTWFwUHJvdmlkZXIgaXMgYW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGF0IHNob3VsZCBiZSBpbXBsZW1lbnRlZFxuICogaW4gb3JkZXIgdG8gaW50ZWdyYXRlIHdpdGggYSBUaGlyZCBQYXJ0eSBNYXAgcHJvdmlkZXIgZm9yXG4gKiBpbnRlcmFjdGl2ZSBtYXBzLiBNYXBQcm92aWRlcnMgYXJlIHVzZWQgYnkgdGhlIE1hcENvbXBvbmVudC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGV4dGVuZCB0aGlzIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwUHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB1c2VkIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBtYXAgcHJvdmlkZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLCBkZWZhdWx0cyB0byAxNFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fem9vbSA9IGNvbmZpZy56b29tIHx8IDE0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29vcmRpbmF0ZXMgdG8gZGlzcGxheSBpZiB0aGVyZSBhcmUgbm8gcmVzdWx0cyByZXR1cm5lZFxuICAgICAqIE9ubHkgdXNlZCBpZiBzaG93RW1wdHlNYXAgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RlZmF1bHRQb3NpdGlvbiA9IGNvbmZpZy5kZWZhdWx0UG9zaXRpb24gfHwgeyBsYXQ6IDM3LjA5MDIsIGxuZzogLTk1LjcxMjkgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gZW1wdHkgbWFwIHNob3VsZCBiZSBzaG93biB3aGVuIHRoZXJlIGFyZSBubyByZXN1bHRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fc2hvd0VtcHR5TWFwID0gY29uZmlnLnNob3dFbXB0eU1hcCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIG1hcCBpbnN0YW5jZSwgY3JlYXRlZCBieSB0aGUgZXh0ZXJuYWwgbGliLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbWFwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSBib29sZWFuIHRyYWNraW5nIHdoZXRoZXIgb3Igbm90IHRoZSBleHRlcm5hbCBKUyBsaWJyYXJ5IGlzIGxvYWRlZCAoc2VlIFRPRE8gYmVsb3cpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGEgcGluIGlzIGNsaWNrZWQuIFRoZSBjbGlja2VkIGl0ZW0ocykgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fb25QaW5DbGljayA9IGNvbmZpZy5vblBpbkNsaWNrIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgSmF2YXNjcmlwdCBpcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fb25Mb2FkZWQgPSBjb25maWcub25Mb2FkZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VzdG9tIGNvbmZpZ3VyYXRpb24gb3ZlcnJpZGUgdG8gdXNlIGZvciB0aGUgbWFwIG1hcmtlcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX3BpbkNvbmZpZyA9IHR5cGVvZiBjb25maWcucGluID09PSAnZnVuY3Rpb24nID8gY29uZmlnLnBpbiA6IE9iamVjdC5hc3NpZ24oTWFwUHJvdmlkZXIuREVGQVVMVF9QSU5fQ09ORklHLCBjb25maWcucGluKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gY29sbGFwc2UgcGlucyBhdCB0aGUgc2FtZSBsYXQvbG5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fY29sbGFwc2VQaW5zID0gY29uZmlnLmNvbGxhcHNlUGlucyB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHRvIHVzZSBmb3IgdGhlIG1hcCBtYXJrZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIFRPRE8oYmlsbHkpIENyZWF0ZSBhIGNvbmZpZ3VyYXRpb24gbW9kZWxcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QSU5fQ09ORklHICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjoge1xuICAgICAgICBhbmNob3I6IG51bGwsIC8vIGUuZy4geyB4OiAxLCB5OiAxIH1cbiAgICAgICAgc3ZnOiBudWxsLFxuICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgIHNjYWxlZFNpemU6IG51bGwgLy8gZS5nLiB7IHc6IDIwLCBoOiAyMCB9XG4gICAgICB9LFxuICAgICAgbGFiZWxUeXBlOiAnbnVtZXJpYydcbiAgICB9O1xuICB9XG5cbiAgb25Mb2FkZWQgKGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX29uTG9hZGVkID0gY2I7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICB9XG4gIH1cblxuICBpc0xvYWRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICB9XG5cbiAgbG9hZEpTICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgTWV0aG9kOiBsb2FkSlMnKTtcbiAgfVxuXG4gIGluaXQgKG1hcERhdGEpIHtcbiAgICAvLyBUT0RPKGJpbGx5KSBUaGlzIHNob3VsZCBiZSBiYXNlZCBvZmYgYSBwcm9taXNlIHRoYXQgZ2V0cyBjcmVhdGVkIGZyb20gbG9hZEpTXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIE1ldGhvZDogaW5pdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbGlzdCBvZiBtYXJrZXJzLCBjb21iaW5lIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBsYXQvbG5nIGludG8gYSBzaW5nbGUgbWFya2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IG1hcmtlcnMgVGhlIG1hcmtlcnMgdG8gY29sbGFwc2VcbiAgICovXG4gIF9jb2xsYXBzZU1hcmtlcnMgKG1hcmtlcnMpIHtcbiAgICBjb25zdCBsb2NhdGlvblRvSXRlbSA9IHt9O1xuICAgIG1hcmtlcnMuZm9yRWFjaChtID0+IHtcbiAgICAgIGxvY2F0aW9uVG9JdGVtW2Ake20ubGF0aXR1ZGV9JHttLmxvbmdpdHVkZX1gXVxuICAgICAgICA/IGxvY2F0aW9uVG9JdGVtW2Ake20ubGF0aXR1ZGV9JHttLmxvbmdpdHVkZX1gXS5wdXNoKG0pXG4gICAgICAgIDogbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdID0gW21dO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY29sbGFwc2VkTWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IFssIG1hcmtlcnNdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2F0aW9uVG9JdGVtKSkge1xuICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXIgPSB7XG4gICAgICAgICAgaXRlbTogbWFya2Vycy5tYXAobSA9PiBtLml0ZW0pLFxuICAgICAgICAgIGxhYmVsOiBtYXJrZXJzLmxlbmd0aCxcbiAgICAgICAgICBsYXRpdHVkZTogbWFya2Vyc1swXS5sYXRpdHVkZSxcbiAgICAgICAgICBsb25naXR1ZGU6IG1hcmtlcnNbMF0ubG9uZ2l0dWRlXG4gICAgICAgIH07XG4gICAgICAgIGNvbGxhcHNlZE1hcmtlcnMucHVzaChjb2xsYXBzZWRNYXJrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sbGFwc2VkTWFya2Vycy5wdXNoKG1hcmtlcnNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xsYXBzZWRNYXJrZXJzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBHb29nbGVNYXBQcm92aWRlciAqL1xuXG5pbXBvcnQgTWFwUHJvdmlkZXIgZnJvbSAnLi9tYXBwcm92aWRlcic7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uLy4uL2RvbS9kb20nO1xuXG4vKiBnbG9iYWwgZ29vZ2xlICovXG5cbi8qKlxuICogR29vZ2xlTWFwUHJvdmlkZXIgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYSBNYXBQcm92aWRlclxuICogdGhhdCBoYW5kbGVzIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSB0aGlyZCBwYXJ0eSBBUEkgdG8gZXhwb3NlIG1hcHMuXG4gKiBAZXh0ZW5kcyBNYXBQcm92aWRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb29nbGVNYXBQcm92aWRlciBleHRlbmRzIE1hcFByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIC8vIG5vcm1hbGl6ZSBiZWNhdXNlIGdvb2dsZSdzIHpvb20gaXMgZWZmZWN0aXZlbHkgMSB1bml0IG9mIGRpZmZlcmVuY2UgYXdheSBmcm9tIG1hcGJveCB6b29tXG4gICAgdGhpcy5fem9vbU9mZnNldCA9IDE7XG4gICAgdGhpcy5fem9vbSArPSB0aGlzLl96b29tT2Zmc2V0O1xuICAgIHRoaXMuX2NsaWVudElkID0gb3B0cy5jbGllbnRJZDtcbiAgICB0aGlzLl9zaWduYXR1cmUgPSBvcHRzLnNpZ25hdHVyZTtcblxuICAgIGlmICghdGhpcy5oYXNWYWxpZENsaWVudENyZWRlbnRpYWxzKCkgJiYgIXRoaXMuX2FwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGVNYXBzUHJvdmlkZXI6IE1pc3NpbmcgYGFwaUtleWAgb3Ige2BjbGllbnRJZGAsIGBzaWduYXR1cmVgfScpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRKUyAob25Mb2FkKSB7XG4gICAgaWYgKERPTS5xdWVyeSgnI3lleHQtbWFwLWpzJykpIHtcbiAgICAgIHRoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uTG9hZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzY3JpcHQgPSBET00uY3JlYXRlRWwoJ3NjcmlwdCcsIHtcbiAgICAgIGlkOiAneWV4dC1tYXAtanMnLFxuICAgICAgb25sb2FkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIHNyYzogYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz8ke3RoaXMuZ2VuZXJhdGVDcmVkZW50aWFscygpfWBcbiAgICB9KTtcblxuICAgIERPTS5hcHBlbmQoJ2JvZHknLCBzY3JpcHQpO1xuICB9XG5cbiAgZ2VuZXJhdGVDcmVkZW50aWFscyAoKSB7XG4gICAgaWYgKHRoaXMuaGFzVmFsaWRDbGllbnRDcmVkZW50aWFscygpKSB7XG4gICAgICByZXR1cm4gYGNsaWVudD0ke3RoaXMuX2NsaWVudElkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBga2V5PSR7dGhpcy5fYXBpS2V5fWA7XG4gICAgfVxuICB9XG5cbiAgaGFzVmFsaWRDbGllbnRDcmVkZW50aWFscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudElkO1xuICB9XG5cbiAgaW5pdCAoZWwsIG1hcERhdGEpIHtcbiAgICBpZiAoKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwTWFya2Vycy5sZW5ndGggPD0gMCkgJiYgIXRoaXMuX3Nob3dFbXB0eU1hcCkge1xuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE5PVEUoYmlsbHkpIFRoaXMgdGltZW91dCBpcyBhIGhhY2sgZm9yIGRlYWxpbmcgd2l0aCBhc3luYyBuYXR1cmUuXG4gICAgLy8gT25seSBoZXJlIGZvciBkZW1vIHB1cnBvc2VzLCBzbyB3ZSdsbCBmaXggbGF0ZXIuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgY29udGFpbmVyID0gRE9NLnF1ZXJ5KGVsKTtcbiAgICAgIHRoaXMubWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChjb250YWluZXIsIHtcbiAgICAgICAgem9vbTogdGhpcy5fem9vbSxcbiAgICAgICAgY2VudGVyOiB0aGlzLmdldENlbnRlck1hcmtlcihtYXBEYXRhKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFwcGx5IG91ciBzZWFyY2ggZGF0YSB0byBvdXIgR29vZ2xlTWFwXG4gICAgICBpZiAobWFwRGF0YSAmJiBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZE1hcmtlcnMgPSB0aGlzLl9jb2xsYXBzZVBpbnNcbiAgICAgICAgICA/IHRoaXMuX2NvbGxhcHNlTWFya2VycyhtYXBEYXRhLm1hcE1hcmtlcnMpXG4gICAgICAgICAgOiBtYXBEYXRhLm1hcE1hcmtlcnM7XG4gICAgICAgIGxldCBnb29nbGVNYXBNYXJrZXJDb25maWdzID0gR29vZ2xlTWFwTWFya2VyQ29uZmlnLmZyb20oXG4gICAgICAgICAgY29sbGFwc2VkTWFya2VycyxcbiAgICAgICAgICB0aGlzLl9waW5Db25maWcsXG4gICAgICAgICAgdGhpcy5tYXApO1xuXG4gICAgICAgIGxldCBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKGdvb2dsZU1hcE1hcmtlckNvbmZpZ3NbaV0pO1xuICAgICAgICAgIGlmICh0aGlzLl9vblBpbkNsaWNrKSB7XG4gICAgICAgICAgICBtYXJrZXIuYWRkTGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5fb25QaW5DbGljayhjb2xsYXBzZWRNYXJrZXJzW2ldLml0ZW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm91bmRzLmV4dGVuZChtYXJrZXIucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB0aGlzLm1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH1cblxuICBnZXRDZW50ZXJNYXJrZXIgKG1hcERhdGEpIHtcbiAgICByZXR1cm4gbWFwRGF0YSAmJiBtYXBEYXRhLm1hcENlbnRlciAmJiBtYXBEYXRhLm1hcENlbnRlci5sb25naXR1ZGUgJiYgbWFwRGF0YS5tYXBDZW50ZXIubGF0aXR1ZGVcbiAgICAgID8geyBsbmc6IG1hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSwgbGF0OiBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZSB9XG4gICAgICA6IHsgbG5nOiB0aGlzLl9kZWZhdWx0UG9zaXRpb24ubG5nLCBsYXQ6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sYXQgfTtcbiAgfVxufVxuXG4vLyBUT0RPKGJpbGx5KSBNb3ZlIHRvIG93biBjbGFzc1xuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcE1hcmtlckNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGdvb2dsZSBtYXAsIHRoYXQgdGhlIG1hcmtlciBpcyBhcHBlbmRlZCB0b1xuICAgICAqIEB0eXBlIHtHb29nbGVNYXB9XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBvcHRzLm1hcCB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1hcmtlciAobGF0L2xuZylcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBvcHRzLnBvc2l0aW9uIHx8IHtcbiAgICAgIGxhdDogdW5kZWZpbmVkLFxuICAgICAgbG5nOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnRpZXMvc2V0dGluZ3Mgb2YgdGhlIGljb24gdXNlZCBmb3IgdGhlIG1hcmtlclxuICAgICAqIGUuZy4ge1xuICAgICAqICAgICAgICBhbmNob3I6IHsgeDogMCwgeTogMCB9XG4gICAgICogICAgICAgIHVybDogJ3BhdGgvdG8vdXJsLmpwZydcbiAgICAgKiAgICAgICAgc2NhbGVkU2l6ZTogeyB3OiAwLCBoOiAwIH1cbiAgICAgKiAgICAgICB9XG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaWNvbiA9IG9wdHMuaWNvbiB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgb2YgdGhlIG1hcmtlciB0byB1c2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBvcHRzLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGFuIGFycmF5IG9mIG1hcmtlciBjb25maWdzXG4gICAqIEBwYXJhbSB7R29vZ2xlTWFwTWFya2VyQ29uZmlnW119IGdvb2dsZU1hcE1hcmtlckNvbmZpZ3NcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZSAoZ29vZ2xlTWFwTWFya2VyQ29uZmlncykge1xuICAgIGxldCBzZXJpYWxpemVkTWFya2VycyA9IFtdO1xuICAgIGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICBzZXJpYWxpemVkTWFya2Vycy5wdXNoKGBtYXJrZXJzPWxhYmVsOiR7bWFya2VyLmxhYmVsfXwke21hcmtlci5wb3NpdGlvbi5sYXR9LCR7bWFya2VyLnBvc2l0aW9uLmxuZ31gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1hcmtlcnMuam9pbignJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzdG9yYWdlIGRhdGEgbW9kZWwgb2YgbWFya2VycyBpbnRvIEdvb2dsZUFQSU1hcmtlclxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBtYXJrZXJzIFRoZSBkYXRhIG9mIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gcGluQ29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHtHb29nbGVNYXB9IG1hcCByZWZlcmVuY2UgdG8gdGhlIGdvb2dsZSBtYXAgdG8gYXBwbHkgdGhlIG1hcmtlciB0b1xuICAgKiBAcmV0dXJucyB7R29vZ2xlTWFwTWFya2VyQ29uZmlnW119XG4gICAqL1xuICBzdGF0aWMgZnJvbSAobWFya2VycywgcGluQ29uZmlnLCBtYXApIHtcbiAgICBsZXQgZ29vZ2xlTWFwTWFya2VyQ29uZmlncyA9IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXJrZXJzKSkge1xuICAgICAgbWFya2VycyA9IFttYXJrZXJzXTtcbiAgICB9XG5cbiAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgLy8gU3VwcG9ydCBjb25maWd1cmF0aW9uIGFzIGEgZnVuY3Rpb25cbiAgICAgIGxldCBwaW5Db25maWdPYmogPSBwaW5Db25maWc7XG4gICAgICBpZiAodHlwZW9mIHBpbkNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwaW5Db25maWdPYmogPSBwaW5Db25maWcoXG4gICAgICAgICAgbWFya2VyLml0ZW0sXG4gICAgICAgICAgTWFwUHJvdmlkZXIuREVGQVVMVF9QSU5fQ09ORklHLFxuICAgICAgICAgIG1hcmtlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBvdXIgQ29uZmlndXJhdGlvbiBPYmplY3QgaW50byB0aGUgZXhwZWN0ZWRcbiAgICAgIC8vIEdvb2dsZSBBUEkgZm9ybWF0LlxuICAgICAgbGV0IGljb24gPSB7fTtcbiAgICAgIGlmIChwaW5Db25maWdPYmouYW5jaG9yKSB7XG4gICAgICAgIGljb24uYW5jaG9yID0gZ29vZ2xlLm1hcHMuUG9pbnQocGluQ29uZmlnT2JqLmFuY2hvci54LCBwaW5Db25maWdPYmouYW5jaG9yLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluQ29uZmlnT2JqLnNjYWxlZFNpemUpIHtcbiAgICAgICAgaWNvbi5zY2FsZWRTaXplID0gbmV3IGdvb2dsZS5tYXBzLlNpemUocGluQ29uZmlnT2JqLnNjYWxlZFNpemUudywgcGluQ29uZmlnT2JqLnNjYWxlZFNpemUuaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5Db25maWdPYmoudXJsKSB7XG4gICAgICAgIGljb24udXJsID0gcGluQ29uZmlnT2JqLnVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbkNvbmZpZ09iai5zdmcpIHtcbiAgICAgICAgaWNvbi51cmwgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsICR7ZW5jb2RlVVJJQ29tcG9uZW50KHBpbkNvbmZpZ09iai5zdmcpfWA7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYWJlbDtcbiAgICAgIGlmIChwaW5Db25maWdPYmoubGFiZWwpIHtcbiAgICAgICAgbGFiZWwgPSBwaW5Db25maWdPYmoubGFiZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IG1hcmtlci5sYWJlbC50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGJpbGx5KSBHb29nbGUgbWFwcyBkb2Vzbid0IGhhbmRsZSBlbXB0eSBpY29uIG9iamVjdHMgbmljZWx5XG4gICAgICAvLyBNYWtlIGdvb2dsZSBtYXBzIGhhcHB5IGlmIG5vIHNldHRpbmdzIGZvciBpY29uIGFyZSBwcm92aWRlZDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhpY29uKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWNvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5wdXNoKFxuICAgICAgICBuZXcgR29vZ2xlTWFwTWFya2VyQ29uZmlnKHtcbiAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbGF0OiBtYXJrZXIubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IG1hcmtlci5sb25naXR1ZGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGljb246IGljb24sXG4gICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdvb2dsZU1hcE1hcmtlckNvbmZpZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1hcEJveE1hcFByb3ZpZGVyICovXG5cbmltcG9ydCBNYXBQcm92aWRlciBmcm9tICcuL21hcHByb3ZpZGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vLi4vZG9tL2RvbSc7XG5cbi8qIGdsb2JhbCBtYXBib3hnbCAqL1xuXG4vKipcbiAqIE1hcEJveE1hcFByb3ZpZGVyIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGEgTWFwUHJvdmlkZXJcbiAqIHRoYXQgaGFuZGxlcyB0aGUgaW50ZWdyYXRpb24gd2l0aCB0aGUgdGhpcmQgcGFydHkgQVBJIHRvIGV4cG9zZSBtYXBzLlxuICogQGV4dGVuZHMgTWFwUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwQm94TWFwUHJvdmlkZXIgZXh0ZW5kcyBNYXBQcm92aWRlciB7XG4gIC8qKlxuICAgKiBMb2FkIHRoZSBleHRlcm5hbCBKUyBMaWJyYXJ5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uTG9hZCBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgSlMgaXMgbG9hZGVkLlxuICAgKi9cbiAgbG9hZEpTIChvbkxvYWQpIHtcbiAgICBsZXQgc2NyaXB0ID0gRE9NLmNyZWF0ZUVsKCdzY3JpcHQnLCB7XG4gICAgICBpZDogJ3lleHQtbWFwLWpzJyxcbiAgICAgIG9ubG9hZDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gdGhpcy5fYXBpS2V5O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uTG9hZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgc3JjOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDQuMS9tYXBib3gtZ2wuanMnXG4gICAgfSk7XG5cbiAgICBsZXQgY3NzID0gRE9NLmNyZWF0ZUVsKCdsaW5rJywge1xuICAgICAgaWQ6ICd5ZXh0LW1hcC1jc3MnLFxuICAgICAgcmVsOiAnc3R5bGVzaGVldCcsXG4gICAgICBocmVmOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDQuMS9tYXBib3gtZ2wuY3NzJ1xuICAgIH0pO1xuXG4gICAgRE9NLmFwcGVuZCgnYm9keScsIGNzcyk7XG4gICAgRE9NLmFwcGVuZCgnYm9keScsIHNjcmlwdCk7XG4gIH1cblxuICBpbml0IChlbCwgbWFwRGF0YSkge1xuICAgIGlmICgoIW1hcERhdGEgfHwgbWFwRGF0YS5tYXBNYXJrZXJzLmxlbmd0aCA8PSAwKSAmJiAhdGhpcy5fc2hvd0VtcHR5TWFwKSB7XG4gICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRhaW5lciA9IERPTS5xdWVyeShlbCk7XG4gICAgdGhpcy5fbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHpvb206IHRoaXMuX3pvb20sXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12OScsXG4gICAgICBjZW50ZXI6IHRoaXMuZ2V0Q2VudGVyTWFya2VyKG1hcERhdGEpXG4gICAgfSk7XG5cbiAgICBpZiAobWFwRGF0YSAmJiBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXJzID0gdGhpcy5fY29sbGFwc2VQaW5zXG4gICAgICAgID8gdGhpcy5fY29sbGFwc2VNYXJrZXJzKG1hcERhdGEubWFwTWFya2VycylcbiAgICAgICAgOiBtYXBEYXRhLm1hcE1hcmtlcnM7XG4gICAgICBjb25zdCBtYXBib3hNYXBNYXJrZXJDb25maWdzID0gTWFwQm94TWFya2VyQ29uZmlnLmZyb20oXG4gICAgICAgIGNvbGxhcHNlZE1hcmtlcnMsXG4gICAgICAgIHRoaXMuX3BpbkNvbmZpZyxcbiAgICAgICAgdGhpcy5fbWFwKTtcblxuICAgICAgY29uc3QgYm91bmRzID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBib3hNYXBNYXJrZXJDb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB3cmFwcGVyID0gbWFwYm94TWFwTWFya2VyQ29uZmlnc1tpXS53cmFwcGVyO1xuICAgICAgICBsZXQgY29vcmRzID0gbmV3IG1hcGJveGdsLkxuZ0xhdChcbiAgICAgICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzW2ldLnBvc2l0aW9uLmxvbmdpdHVkZSxcbiAgICAgICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzW2ldLnBvc2l0aW9uLmxhdGl0dWRlKTtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBtYXBib3hnbC5NYXJrZXIod3JhcHBlcikuc2V0TG5nTGF0KGNvb3Jkcyk7XG4gICAgICAgIGJvdW5kcy5leHRlbmQobWFya2VyLmdldExuZ0xhdCgpKTtcbiAgICAgICAgbWFya2VyLmFkZFRvKHRoaXMuX21hcCk7XG4gICAgICAgIGlmICh0aGlzLl9vblBpbkNsaWNrKSB7XG4gICAgICAgICAgbWFya2VyLmdldEVsZW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuX29uUGluQ2xpY2soY29sbGFwc2VkTWFya2Vyc1tpXS5pdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXBib3hNYXBNYXJrZXJDb25maWdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHRoaXMuX21hcC5maXRCb3VuZHMoYm91bmRzLCB7IHBhZGRpbmc6IDUwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldENlbnRlck1hcmtlciAobWFwRGF0YSkge1xuICAgIHJldHVybiBtYXBEYXRhICYmIG1hcERhdGEubWFwQ2VudGVyICYmIG1hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSAmJiBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZVxuICAgICAgPyBbbWFwRGF0YS5tYXBDZW50ZXIubG9uZ2l0dWRlLCBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZV1cbiAgICAgIDogeyBsbmc6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sbmcsIGxhdDogdGhpcy5fZGVmYXVsdFBvc2l0aW9uLmxhdCB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXBCb3hNYXJrZXJDb25maWcge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBtYXBib3ggbWFwLCB0aGF0IHRoZSBtYXJrZXIgaXMgYXBwZW5kZWQgdG9cbiAgICAgKiBAdHlwZSB7TWFwQm94fVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gb3B0cy5tYXAgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXJrZXIgKGxhdC9sbmcpXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbiB8fCB7XG4gICAgICBsYXRpdHVkZTogdW5kZWZpbmVkLFxuICAgICAgbG9uZ2l0dWRlOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGh0bWwgZWxlbWVudCB0byBiZSB1c2VkIGFzIHRoZSBtYXAgbWFya2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZXIgPSBvcHRzLndyYXBwZXIgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIG9mIHRoZSBtYXJrZXIgdG8gdXNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gb3B0cy5sYWJlbCB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBwaW4gZm9yIHRoZSBzdGF0aWMgbWFwXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRpY01hcFBpbiA9IG9wdHMuc3RhdGljTWFwUGluIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGFuIGFycmF5IG9mIG1hcmtlciBjb25maWdzXG4gICAqIEBwYXJhbSB7TWFwQm94TWFya2VyQ29uZmlnW119IG1hcGJveE1hcE1hcmtlckNvbmZpZ3NcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZSAobWFwYm94TWFwTWFya2VyQ29uZmlncykge1xuICAgIGxldCBzZXJpYWxpemVkTWFya2VycyA9IFtdO1xuICAgIG1hcGJveE1hcE1hcmtlckNvbmZpZ3MuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICBpZiAobWFya2VyLnN0YXRpY01hcFBpbikge1xuICAgICAgICBzZXJpYWxpemVkTWFya2Vycy5wdXNoKGB1cmwtJHttYXJrZXIuc3RhdGljTWFwUGlufSgke21hcmtlci5wb3NpdGlvbi5sb25naXR1ZGV9LCR7bWFya2VyLnBvc2l0aW9uLmxhdGl0dWRlfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRNYXJrZXJzLnB1c2goYHBpbi1zLSR7bWFya2VyLmxhYmVsfSgke21hcmtlci5wb3NpdGlvbi5sb25naXR1ZGV9LCR7bWFya2VyLnBvc2l0aW9uLmxhdGl0dWRlfSlgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1hcmtlcnMuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzdG9yYWdlIGRhdGEgbW9kZWwgb2YgbWFya2VycyBpbnRvIE1hcEJveE1hcmtlckNvbmZpZ1xuICAgKiBAcGFyYW0ge01hcEJveH0gQSByZWZlcmVuY2UgdG8gdGhlIG1hcGJveCBtYXAgdG8gYXBwbHkgdGhlIG1hcmtlciB0b1xuICAgKiBAcGFyYW0ge29iamVjdFtdfSBtYXJrZXJzIFRoZSBkYXRhIG9mIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBpbkNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgbWFya2VyXG4gICAqIEByZXR1cm5zIHtNYXBCb3hNYXJrZXJDb25maWdbXX1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChtYXJrZXJzLCBwaW5Db25maWcsIG1hcCkge1xuICAgIGxldCBtYXBib3hNYXBNYXJrZXJDb25maWdzID0gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hcmtlcnMpKSB7XG4gICAgICBtYXJrZXJzID0gW21hcmtlcnNdO1xuICAgIH1cblxuICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAvLyBTdXBwb3J0IGNvbmZpZ3VyYXRpb24gYXMgYSBmdW5jdGlvblxuICAgICAgbGV0IHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZztcbiAgICAgIGlmICh0eXBlb2YgcGluQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZyhcbiAgICAgICAgICBtYXJrZXIuaXRlbSxcbiAgICAgICAgICBNYXBQcm92aWRlci5ERUZBVUxUX1BJTl9DT05GSUcsXG4gICAgICAgICAgbWFya2VyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlciA9IHBpbkNvbmZpZ09iai53cmFwcGVyID8gcGluQ29uZmlnT2JqLndyYXBwZXIgOiBudWxsO1xuICAgICAgY29uc3Qgc3RhdGljTWFwUGluID0gcGluQ29uZmlnT2JqLnN0YXRpY01hcFBpbiA/IHBpbkNvbmZpZ09iai5zdGF0aWNNYXBQaW4gOiBudWxsO1xuXG4gICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzLnB1c2goXG4gICAgICAgIG5ldyBNYXBCb3hNYXJrZXJDb25maWcoe1xuICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBsYXRpdHVkZTogbWFya2VyLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBtYXJrZXIubG9uZ2l0dWRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICAgIGxhYmVsOiBtYXJrZXIubGFiZWwsXG4gICAgICAgICAgc3RhdGljTWFwUGluOiBzdGF0aWNNYXBQaW5cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFwYm94TWFwTWFya2VyQ29uZmlncztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTWFwQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcblxuaW1wb3J0IEdvb2dsZU1hcFByb3ZpZGVyIGZyb20gJy4vcHJvdmlkZXJzL2dvb2dsZW1hcHByb3ZpZGVyJztcbmltcG9ydCBNYXBCb3hNYXBQcm92aWRlciBmcm9tICcuL3Byb3ZpZGVycy9tYXBib3htYXBwcm92aWRlcic7XG5cbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG5jb25zdCBQcm92aWRlclR5cGVzID0ge1xuICAnZ29vZ2xlJzogR29vZ2xlTWFwUHJvdmlkZXIsXG4gICdtYXBib3gnOiBNYXBCb3hNYXBQcm92aWRlclxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIHRoaXMgY29tcG9uZW50IHRvIGxpc3RlbiB0byB0aGUgc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGtleVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXNlZCB1c2VkIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBtYXAgcHJvdmlkZXIgdG8gdXNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9tYXBQcm92aWRlciA9IG9wdHMubWFwUHJvdmlkZXI7XG4gICAgaWYgKCF0aGlzLl9tYXBQcm92aWRlciB8fCAhKHRoaXMuX21hcFByb3ZpZGVyLnRvTG93ZXJDYXNlKCkgaW4gUHJvdmlkZXJUeXBlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFwQ29tcG9uZW50OiBJbnZhbGlkIE1hcCBQcm92aWRlcjsgbXVzdCBiZSBgZ29vZ2xlYCBvciBgbWFwQm94YCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIGFuIGluc3RhbmNlIG9mIHRoZSB7TWFwUHJvdmlkZXJ9IHRoYXQncyBjb25zdHJ1Y3RlZFxuICAgICAqIEB0eXBlIHtNYXBQcm92aWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ01hcCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvbWFwJztcbiAgfVxuXG4gIC8vIFRPRE8oYmlsbHkpIE1ha2UgUHJvdmlkZXJUeXBlcyBhIGZhY3RvcnkgY2xhc3NcbiAgZ2V0UHJvdmlkZXJJbnN0YW5jZSAodHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvdmlkZXJUeXBlc1t0eXBlLnRvTG93ZXJDYXNlKCldKHRoaXMuX2NvbmZpZyk7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgdGhpcy5fbWFwID0gdGhpcy5nZXRQcm92aWRlckluc3RhbmNlKHRoaXMuX21hcFByb3ZpZGVyKTtcbiAgICB0aGlzLl9tYXAubG9hZEpTKCk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICB0aGlzLl9tYXAub25Mb2FkZWQoKCkgPT4ge1xuICAgICAgdGhpcy5fbWFwLmluaXQodGhpcy5fY29udGFpbmVyLCB0aGlzLmdldFN0YXRlKCdtYXAnKSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSwgdmFsKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKGRhdGEsIHZhbCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdHNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuXG5pbXBvcnQgUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL2xvY2F0aW9ucmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9ldmVudHJlc3VsdHNpdGVtY29tcG9uZW50JztcbmltcG9ydCBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Blb3BsZXJlc3VsdHNpdGVtY29tcG9uZW50JztcbmltcG9ydCBNYXBDb21wb25lbnQgZnJvbSAnLi4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmNvbnN0IFJlc3VsdFR5cGUgPSB7XG4gIEVWRU5UOiAnZXZlbnQnLFxuICBMT0NBVElPTjogJ2xvY2F0aW9uJyxcbiAgUEVPUExFOiAncGVvcGxlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdWx0c0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiB2ZXJ0aWNhbENvbmZpZ0lkIHVzZWQgZm9yIGFuYWx5dGljcyBhbmQgcGFzc2VkIHRvIGNoaWxkcmVuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQgPSBjb25maWcudmVydGljYWxDb25maWdJZDtcblxuICAgIC8qKlxuICAgICAqIGlzVW5pdmVyc2FsIGlzIHNldCB0byB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIGJ5IHRoZSBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc1VuaXZlcnNhbCA9IGNvbmZpZy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcblxuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTO1xuICAgIHRoaXMuX2l0ZW1Db25maWcgPSB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICB0ZW1wbGF0ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIFtFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50LnR5cGVdOiB7XG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgdGVtcGxhdGU6IG51bGxcbiAgICAgIH0sXG4gICAgICBbTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudC50eXBlXToge1xuICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgIHRlbXBsYXRlOiBudWxsXG4gICAgICB9LFxuICAgICAgW1Blb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50LnR5cGVdOiB7XG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgdGVtcGxhdGU6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJJdGVtID09PSB1bmRlZmluZWQgJiYgY29uZmlnLl9wYXJlbnRPcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5yZW5kZXJJdGVtID0gY29uZmlnLl9wYXJlbnRPcHRzLnJlbmRlckl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5pdGVtVGVtcGxhdGUgPT09IHVuZGVmaW5lZCAmJiBjb25maWcuX3BhcmVudE9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZmlnLml0ZW1UZW1wbGF0ZSA9IGNvbmZpZy5fcGFyZW50T3B0cy5pdGVtVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWd1cmVJdGVtKHtcbiAgICAgIHJlbmRlcjogY29uZmlnLnJlbmRlckl0ZW0sXG4gICAgICB0ZW1wbGF0ZTogY29uZmlnLml0ZW1UZW1wbGF0ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCB0byB0aGUgdW5pdmVyc2FsIHBhZ2UgZm9yIHRoZSBubyByZXN1bHRzIHBhZ2UgdG8gbGluayBiYWNrIHRvIHdpdGggY3VycmVudCBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl91bml2ZXJzYWxVcmwgPSBjb25maWcudW5pdmVyc2FsVXJsO1xuICB9XG5cbiAgbW91bnQgKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmdldFN0YXRlKCkpLmxlbmd0aCA+IDApIHtcbiAgICAgIHN1cGVyLm1vdW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGR1cGxpY2F0ZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBjb25zdCByZXN1bHRzID0gZGF0YS5yZXN1bHRzIHx8IFtdO1xuICAgIGNvbnN0IHNlYXJjaFN0YXRlID0gZGF0YS5zZWFyY2hTdGF0ZSB8fCBTZWFyY2hTdGF0ZXMuUFJFX1NFQVJDSDtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHJlc3VsdHM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIGluY2x1ZGVNYXA6IHRoaXMuX2NvbmZpZy5pbmNsdWRlTWFwLFxuICAgICAgbWFwQ29uZmlnOiB0aGlzLl9jb25maWcubWFwQ29uZmlnLFxuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucygpLFxuICAgICAgdW5pdmVyc2FsVXJsOiB0aGlzLl91bml2ZXJzYWxVcmwgPyB0aGlzLl91bml2ZXJzYWxVcmwgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoIDogJycsXG4gICAgICBzaG93Tm9SZXN1bHRzOiByZXN1bHRzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSlcbiAgICB9KSwgdmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgdG8gY29uc3RydWN0IHRoZSBldmVudE9wdGlvbnMgb2JqZWN0IGZvciB0aGUgdmlldyBhbGwgbGlua1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZXZlbnRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxDb25maWdJZFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1ZlcnRpY2FsUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0cyc7XG4gIH1cblxuICBjb25maWd1cmVJdGVtIChjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2l0ZW1Db25maWcuZ2xvYmFsLnJlbmRlciA9IGNvbmZpZy5yZW5kZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcucmVuZGVyKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVJlbmRlcihrZXksIGNvbmZpZy5yZW5kZXJba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9pdGVtQ29uZmlnLmdsb2JhbC50ZW1wbGF0ZSA9IGNvbmZpZy50ZW1wbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZy50ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnNldEl0ZW1UZW1wbGF0ZShrZXksIGNvbmZpZy50ZW1wbGF0ZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRJdGVtVGVtcGxhdGUgKHR5cGUsIHRlbXBsYXRlKSB7XG4gICAgbGV0IGNsYXp6ID0gdGhpcy5nZXRJdGVtQ29tcG9uZW50KHR5cGUpO1xuICAgIHRoaXMuX2l0ZW1Db25maWdbY2xhenoudHlwZV0udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgfVxuXG4gIHNldEl0ZW1SZW5kZXIgKHR5cGUsIHJlbmRlcikge1xuICAgIGxldCBjbGF6eiA9IHRoaXMuZ2V0SXRlbUNvbXBvbmVudCh0eXBlKTtcbiAgICB0aGlzLl9pdGVtQ29uZmlnW2NsYXp6LnR5cGVdLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuXG4gIGdldEl0ZW1Db21wb25lbnQgKHR5cGUpIHtcbiAgICBsZXQgY29tcCA9IFJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSZXN1bHRUeXBlLkVWRU5UOlxuICAgICAgICBjb21wID0gRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJlc3VsdFR5cGUuTE9DQVRJT046XG4gICAgICAgIGNvbXAgPSBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVzdWx0VHlwZS5QRU9QTEU6XG4gICAgICAgIGNvbXAgPSBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cblxuICBhZGRDaGlsZCAoZGF0YSwgdHlwZSwgb3B0cykge1xuICAgIC8vIFRPRE8oYmlsbHkpIFJlZmFjdG9yIHRoZSB3YXkgY29uZmlndXJhdGlvbiBhbmQgZGF0YSBmbG93c1xuICAgIC8vIHRocm91Z2ggdG9wIGxldmVsIGNvbXBvbmVudHMgdG8gY2hpbGQgY29tcG9uZW50cy5cbiAgICBpZiAodHlwZSA9PT0gUmVzdWx0c0l0ZW1Db21wb25lbnQudHlwZSkge1xuICAgICAgbGV0IGNsYXp6ID0gdGhpcy5nZXRJdGVtQ29tcG9uZW50KGRhdGEudHlwZSk7XG4gICAgICBpZiAoY2xhenopIHtcbiAgICAgICAgdHlwZSA9IGNsYXp6LnR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBNYXBDb21wb25lbnQudHlwZSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgbWFwOiBkYXRhXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2NvbmZpZy5tYXBDb25maWcsIG9wdHMpO1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG5ld09wdHMpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSBwcm9wZXIgaXRlbSByZW5kZXJzIHRvIHRoZSB0aGUgY29tcG9uZW50c1xuICAgIC8vIGhhdmUganVzdCBiZWVuIGNvbnN0cnVjdGVkLiBQcmlvcml0aXplIGdsb2JhbCBvdmVyIGluZGl2aWR1YWwgaXRlbXMuXG4gICAgbGV0IGNvbXAgPSBzdXBlci5hZGRDaGlsZChkYXRhLCB0eXBlLCBPYmplY3QuYXNzaWduKG9wdHMsIHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICBpc1VuaXZlcnNhbDogdGhpcy5faXNVbml2ZXJzYWxcbiAgICB9KSk7XG4gICAgbGV0IGdsb2JhbENvbmZpZyA9IHRoaXMuX2l0ZW1Db25maWcuZ2xvYmFsO1xuICAgIGxldCBpdGVtQ29uZmlnID0gdGhpcy5faXRlbUNvbmZpZ1tjb21wLnR5cGVdO1xuICAgIGxldCBoYXNHbG9iYWxSZW5kZXIgPSB0eXBlb2YgZ2xvYmFsQ29uZmlnLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICBsZXQgaGFzR2xvYmFsVGVtcGxhdGUgPSB0eXBlb2YgZ2xvYmFsQ29uZmlnLnRlbXBsYXRlID09PSAnc3RyaW5nJztcblxuICAgIGlmIChoYXNHbG9iYWxSZW5kZXIpIHtcbiAgICAgIGNvbXAuc2V0UmVuZGVyKGdsb2JhbENvbmZpZy5yZW5kZXIpO1xuICAgIH1cblxuICAgIGlmIChoYXNHbG9iYWxUZW1wbGF0ZSkge1xuICAgICAgY29tcC5zZXRUZW1wbGF0ZShnbG9iYWxDb25maWcudGVtcGxhdGUpO1xuICAgIH1cblxuICAgIGlmICghaXRlbUNvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNHbG9iYWxSZW5kZXIgJiYgaXRlbUNvbmZpZy5yZW5kZXIpIHtcbiAgICAgIGNvbXAuc2V0UmVuZGVyKGl0ZW1Db25maWcucmVuZGVyKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB0ZW1wbGF0ZSBzcGVjaWZpYyBzaXR1YXRpb25cbiAgICBpZiAoIWhhc0dsb2JhbFRlbXBsYXRlICYmIGl0ZW1Db25maWcudGVtcGxhdGUpIHtcbiAgICAgIGNvbXAuc2V0VGVtcGxhdGUoaXRlbUNvbmZpZy50ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50ICovXG5pbXBvcnQgUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHNjb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuLi8uLi8uLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY29yZGlvblJlc3VsdHNDb21wb25lbnQgZXh0ZW5kcyBSZXN1bHRzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIGJhc2Ugc2VsZWN0b3IgdG8gdXNlIHdoZW4gZmluZGluZyBET00gdGFyZ2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fc2VsZWN0b3JCYXNlID0gY29uZmlnLnNlbGVjdG9yQmFzZSB8fCAnLmpzLXl4dC1BY2NvcmRpb25SZXN1bHQnO1xuXG4gICAgLyoqXG4gICAgICogY29sbGFwc2VkIHN0YXRlIGNsYXNzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZENsYXNzID0gY29uZmlnLmNvbGxhcHNlZENsYXNzIHx8ICdpcy1jb2xsYXBzZWQnO1xuXG4gICAgLyoqXG4gICAgICogdmVydGljYWwgY29uZmlnIGlkIGlzIHJlcXVpcmVkIGZvciBhbmFseXRpY3NcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbENvbmZpZ0lkID0gY29uZmlnLnZlcnRpY2FsQ29uZmlnSWQgfHwgY29uZmlnLl9wYXJlbnRPcHRzLnZlcnRpY2FsQ29uZmlnSWQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgY29tcG9uZW50IHR5cGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnQWNjb3JkaW9uUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2FjY29yZGlvbic7XG4gIH1cblxuICAvKipcbiAgICogb3ZlcnJpZGVzIG9uTW91bnQgdG8gYWRkIGJpbmRpbmdzIHRvIGNoYW5nZSB0aGUgaGVpZ2h0IG9uIGNsaWNrXG4gICAqIEByZXR1cm5zIHtBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uTW91bnQgKCkge1xuICAgIHN1cGVyLm9uTW91bnQoKTtcblxuICAgIC8vIE5PVEUoYW11bGxpbmdzKTogVGhpcyBpcyBhIGhhY2ssIHNpbmNlIGN1cnJlbnRseSBjb21wb25lbnRzIHdpdGggc2libGluZ3NcbiAgICAvLyBoYXZlIG5vIHdheSBvZiByZWZlcnJpbmcgdG8gdGhlaXIgb3duIGVsZW1lbnQuIFdlIGhhdmUgdG8gZ3JhYiB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IHNpbmNlIHNlY3Rpb25zIGdldCBhZGRlZCBpbiByZXZlcnNlLlxuICAgIGNvbnN0IHNlbGZFbCA9IHRoaXMuX2NvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZDtcblxuICAgIGNvbnN0IGFjY29yZGlvbkVscyA9IERPTS5xdWVyeUFsbChzZWxmRWwsIHRoaXMuX3NlbGVjdG9yQmFzZSk7XG4gICAgYWNjb3JkaW9uRWxzLmZvckVhY2goKGFjY29yZGlvbkVsKSA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy50b2dnbGVTZWxlY3RvcigpKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy5ib2R5U2VsZWN0b3IoKSk7XG4gICAgICB0aGlzLmNoYW5nZUhlaWdodChjb250ZW50RWwsIGFjY29yZGlvbkVsKTtcbiAgICAgIHRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGFjY29yZGlvbkVsLCB0b2dnbGVFbCwgY29udGVudEVsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBtb2RpZmllcjogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRoZSBhY2NvcmRpb24gdG9nZ2xlIGJ1dHRvblxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHBhcmFtIHRvZ2dsZUVsIHtIVE1MRWxlbWVudH0gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0gY29udGVudEVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSB0YXJnZXRcbiAgICovXG4gIGhhbmRsZUNsaWNrICh3cmFwcGVyRWwsIHRvZ2dsZUVsLCBjb250ZW50RWwpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBBbmFseXRpY3NFdmVudCh0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAnUk9XX0VYUEFORCcgOiAnUk9XX0NPTExBUFNFJylcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgICBlbnRpdHlJZDogdG9nZ2xlRWwuZGF0YXNldC5lbnRpdHlJZFxuICAgICAgfSk7XG4gICAgd3JhcHBlckVsLmNsYXNzTGlzdC50b2dnbGUodGhpcy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgdGhpcy5jaGFuZ2VIZWlnaHQoY29udGVudEVsLCB3cmFwcGVyRWwpO1xuICAgIHRvZ2dsZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRoaXMuaXNDb2xsYXBzZWQod3JhcHBlckVsKSA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGNvbGxhcHNlZFxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvbGxhcHNlZCAod3JhcHBlckVsKSB7XG4gICAgaWYgKCF3cmFwcGVyRWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlckVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbGxhcHNlZENsYXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b2dnbGVzIHRoZSBoZWlnaHQgYmV0d2VlbiAwIGFuZCB0aGUgY29udGVudCBoZWlnaHQgZm9yIHNtb290aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHRhcmdldEVsIHtIVE1MRWxlbWVudH1cbiAgICogQHBhcmFtIHdyYXBwZXJFbCB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjaGFuZ2VIZWlnaHQgKHRhcmdldEVsLCB3cmFwcGVyRWwpIHtcbiAgICB0YXJnZXRFbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAwIDogdGFyZ2V0RWwuc2Nyb2xsSGVpZ2h0fXB4YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIGNvbXBvc2luZyBjaGlsZCBlbGVtZW50IHNlbGVjdG9yc1xuICAgKiBAcGFyYW0gY2hpbGQge3N0cmluZ31cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJ1aWxkU2VsZWN0b3IgKGNoaWxkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3NlbGVjdG9yQmFzZX0ke2NoaWxkfWA7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9nZ2xlU2VsZWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkU2VsZWN0b3IoJy10b2dnbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIHRoZSBjb250ZW50IGVsZW1lbnQgc2VsZWN0b3JcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJvZHlTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRTZWxlY3RvcignLWJvZHknKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5pbXBvcnQgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL2FjY29yZGlvbnJlc3VsdHNjb21wb25lbnQuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFM7XG4gICAgdGhpcy5fbGltaXQgPSBvcHRzLmxpbWl0IHx8IDEwO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1VuaXZlcnNhbFJlc3VsdHMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3VuaXZlcnNhbHJlc3VsdHMnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbml0IChvcHRzKSB7XG4gICAgc3VwZXIuaW5pdChvcHRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgY29uc3Qgc2VhcmNoU3RhdGUgPSBkYXRhLnNlYXJjaFN0YXRlIHx8IFNlYXJjaFN0YXRlcy5QUkVfU0VBUkNIO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2VjdGlvbnM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIHNob3dOb1Jlc3VsdHM6IHNlY3Rpb25zLmxlbmd0aCA9PT0gMCxcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSlcbiAgICB9KSwgdmFsKTtcbiAgfVxuXG4gIGFkZENoaWxkIChkYXRhID0ge30sIHR5cGUsIG9wdHMpIHtcbiAgICBjb25zdCBjaGlsZE9wdHMgPSB7IC4uLm9wdHMsIC4uLnRoaXMuZ2V0Q2hpbGRDb25maWcoW2RhdGFbJ3ZlcnRpY2FsQ29uZmlnSWQnXV0pIH07XG4gICAgaWYgKGNoaWxkT3B0cy51c2VBY2NvcmRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50LnR5cGUsIGNoaWxkT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCB0eXBlLCBjaGlsZE9wdHMpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb25maWcgKGNvbmZpZ0lkKSB7XG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IGNvbmZpZ0lkLFxuICAgICAgaXNVbml2ZXJzYWw6IHRydWVcbiAgICB9O1xuICAgIGxldCBjb25maWcgPSB0aGlzLl9jb25maWcuY29uZmlnO1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRDb25maWcsIHRoaXMuX2NvbmZpZ1snY29uZmlnJ11bY29uZmlnSWRdIHx8IHRoaXMuX2NvbmZpZ1snY29uZmlnJ10pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBQYWdpbmF0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdpbmF0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0aWNhbCBrZXkgdG8gdXNlIGZvciBzZWFyY2hlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLnZlcnRpY2FsS2V5O1xuICAgIGlmICh0eXBlb2YgdGhpcy5fdmVydGljYWxLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAndmVydGljYWxLZXkgbm90IHByb3ZpZGVkLCBidXQgbmVjZXNzYXJ5IGZvciBwYWdpbmF0aW9uJyxcbiAgICAgICAgJ1BhZ2luYXRpb25Db21wb25lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5cyB0aGUgZmlyc3QgcGFnZSBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQgPSBjb25maWcuc2hvd0ZpcnN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dGaXJzdDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXlzIHRoZSBsYXN0IHBhZ2UgYnV0dG9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQgPSBjb25maWcuc2hvd0xhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0xhc3Q7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRvIGluY2x1ZGUgd2l0aCBhbGwgYW5hbHl0aWMgZXZlbnRzIHNlbnQgYnkgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzT3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBmb3IgYSBwYWdlIG9mIHJlc3VsdHMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3BhZ2VMYWJlbCA9IGNvbmZpZy5wYWdlTGFiZWwgfHwgJ1BhZ2UnO1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMDtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgTnVtYmVyKG9mZnNldCkpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBvZmZzZXQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBOdW1iZXIob2Zmc2V0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgcmVzdWx0cyA9PiB7XG4gICAgICBpZiAocmVzdWx0cy5zZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUGFnaW5hdGlvbic7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3BhZ2luYXRpb24nO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMpIHx8IHt9O1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQ7XG4gICAgY29uc3Qgc2hvd0NvbnRyb2xzID0gcmVzdWx0cy5zZWFyY2hTdGF0ZSA9PT0gJ3NlYXJjaC1jb21wbGV0ZScgJiYgcmVzdWx0cy5yZXN1bHRzQ291bnQgPiBsaW1pdDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwO1xuICAgIGlmICghc2hvd0NvbnRyb2xzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlvdXNQYWdlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtUGFnaW5hdGlvbi1wcmV2aW91cycpO1xuICAgIGNvbnN0IG5leHRQYWdlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtUGFnaW5hdGlvbi1uZXh0Jyk7XG4gICAgY29uc3QgbWF4UGFnZSA9IE1hdGgudHJ1bmMoKHJlc3VsdHMucmVzdWx0c0NvdW50IC0gMSkgLyBsaW1pdCk7XG5cbiAgICBET00ub24ocHJldmlvdXNQYWdlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZVBhZ2Uob2Zmc2V0IC0gbGltaXQpKTtcbiAgICBET00ub24obmV4dFBhZ2VCdXR0b24sICdjbGljaycsICgpID0+IHRoaXMudXBkYXRlUGFnZShvZmZzZXQgKyBsaW1pdCkpO1xuXG4gICAgaWYgKHRoaXMuX2ZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGZpcnN0UGFnZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LVBhZ2luYXRpb24tZmlyc3QnKTtcbiAgICAgIERPTS5vbihmaXJzdFBhZ2VCdXR0b24sICdjbGljaycsICgpID0+IHRoaXMudXBkYXRlUGFnZSgwKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCkge1xuICAgICAgY29uc3QgbGFzdFBhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLWxhc3QnKTtcbiAgICAgIERPTS5vbihsYXN0UGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKG1heFBhZ2UgKiBsaW1pdCkpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVBhZ2UgKG9mZnNldCkge1xuICAgIHRoaXMuc2Nyb2xsVG9Ub3AoKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgb2Zmc2V0KTtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIG9mZnNldCk7XG4gICAgdGhpcy5jb3JlLnZlcnRpY2FsUGFnZSh0aGlzLl92ZXJ0aWNhbEtleSwgb2Zmc2V0KTtcbiAgfVxuXG4gIHNjcm9sbFRvVG9wICgpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAvLyBTYWZhcmlcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IDA7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTKSB8fCB7fTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMDtcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLmxpbWl0O1xuICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSBvZmZzZXQgLyBsaW1pdDtcbiAgICBjb25zdCBzaG93Q29udHJvbHMgPSByZXN1bHRzLnNlYXJjaFN0YXRlID09PSAnc2VhcmNoLWNvbXBsZXRlJyAmJiByZXN1bHRzLnJlc3VsdHNDb3VudCA+IGxpbWl0O1xuICAgIGNvbnN0IGlzTW9yZVJlc3VsdHMgPSByZXN1bHRzLnJlc3VsdHNDb3VudCA+IG9mZnNldCArIGxpbWl0O1xuICAgIGNvbnN0IG1heFBhZ2UgPSBNYXRoLnRydW5jKChyZXN1bHRzLnJlc3VsdHNDb3VudCAtIDEpIC8gbGltaXQpO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZSh7XG4gICAgICBzaG93Q29udHJvbHM6IHNob3dDb250cm9scyxcbiAgICAgIGZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQ6IHRoaXMuX2ZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQsXG4gICAgICBsYXN0UGFnZUJ1dHRvbkVuYWJsZWQ6IHRoaXMuX2xhc3RQYWdlQnV0dG9uRW5hYmxlZCxcbiAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIgKyAxLFxuICAgICAgcGFnZUxhYmVsOiB0aGlzLl9wYWdlTGFiZWwsXG4gICAgICBzaG93Rmlyc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyID4gMSxcbiAgICAgIHNob3dQcmV2aW91c1BhZ2VCdXR0b246IHBhZ2VOdW1iZXIgPiAwLFxuICAgICAgc2hvd05leHRQYWdlQnV0dG9uOiBpc01vcmVSZXN1bHRzLFxuICAgICAgc2hvd0xhc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyIDwgbWF4UGFnZSAtIDEsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL3F1ZXN0aW9uc3VibWlzc2lvbic7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbi8qKlxuICogQ29uZmlndXJhYmxlIG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnRcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICAvKipcbiAgICogVGhlIGVudGl0eSBpZGVudGlmaWVyIHRoYXQgdGhlIHF1ZXN0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogVGhpcyBpcyB0eXBpY2FsbHkgYW4gb3JnYW5pemF0aW9uIG9iamVjdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgJ2VudGl0eUlkJzogbnVsbCxcblxuICAvKipcbiAgICogVGhlIG1haW4gQ1NTIHNlbGVjdG9yIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBmb3JtIGZvciB0aGUgY29tcG9uZW50LlxuICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICovXG4gICdmb3JtU2VsZWN0b3InOiAnZm9ybScsXG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZSBmb3IgdGhlIGUtbWFpbCBhZGRyZXNzIGlucHV0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnZW1haWxMYWJlbCc6ICdFbWFpbCcsXG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZSBmb3IgdGhlIG5hbWUgaW5wdXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICduYW1lTGFiZWwnOiAnTmFtZScsXG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZSBmb3IgdGhlIHF1ZXN0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncXVlc3Rpb25MYWJlbCc6ICdRdWVzdGlvbicsXG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZSBmb3IgdGhlIFByaXZhY3kgUG9saWN5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncHJpdmFjeVBvbGljeVRleHQnOiAnQnkgc3VibWl0dGluZyBteSBlbWFpbCBhZGRyZXNzLCBJIGNvbnNlbnQgdG8gYmVpbmcgY29udGFjdGVkIHZpYSBlbWFpbCBhdCB0aGUgYWRkcmVzcyBwcm92aWRlZC4nLFxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgdG8gdXNlIGZvciB0aGUgU3VibWl0IGJ1dHRvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ2J1dHRvbkxhYmVsJzogJ1N1Ym1pdCcsXG5cbiAgLyoqXG4gICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGluIHRoZSB0aXRsZSBiYXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdzZWN0aW9uVGl0bGUnOiAnQXNrIGEgUXVlc3Rpb24nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gdG8gZGlzcGxheSBpbiB0aGUgdGl0bGUgYmFyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndGVhc2VyJzogJ0NhbuKAmXQgZmluZCB3aGF0IHlvdVxcJ3JlIGxvb2tpbmcgZm9yPyBBc2sgYSBxdWVzdGlvbiBiZWxvdy4nLFxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbiB0byB1c2UgaW4gdGhlIHRpdGxlIGJhclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3NlY3Rpb25UaXRsZUljb25OYW1lJzogJ3N1cHBvcnQnLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBkaXNwbGF5IGluIHRoZSBmZWVkYmFjayBmb3JtIGFoZWFkIG9mIHRoZSBRdWVzdGlvbiBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ2Rlc2NyaXB0aW9uJzogJ0VudGVyIHlvdXIgcXVlc3Rpb24gYW5kIGNvbnRhY3QgaW5mb3JtYXRpb24sIGFuZCB3ZVxcJ2xsIGdldCBiYWNrIHRvIHlvdSB3aXRoIGEgcmVzcG9uc2Ugc2hvcnRseS4nLFxuXG4gIC8qKlxuICAgKiBUaGUgcGxhY2Vob2xkZXIgdGV4dCBmb3IgcmVxdWlyZWQgaW5wdXRzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncmVxdWlyZWRJbnB1dFBsYWNlaG9sZGVyJzogJyhyZXF1aXJlZCknLFxuXG4gIC8qKlxuICAgKiBUaGUgcGxhY2Vob2xkZXIgdGV4dCBmb3IgdGhlIHF1ZXN0aW9uIHRleHQgYXJlYVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3F1ZXN0aW9uSW5wdXRQbGFjZWhvbGRlcic6ICdFbnRlciB5b3VyIHF1ZXN0aW9uIGhlcmUnLFxuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlybWF0aW9uIHRleHQgdG8gZGlzcGxheSBhZnRlciBzdWNjZXNzZnVsbHkgc3VibWl0dGluZyBmZWVkYmFja1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3F1ZXN0aW9uU3VibWlzc2lvbkNvbmZpcm1hdGlvblRleHQnOiAnVGhhbmsgeW91IGZvciB5b3VyIHF1ZXN0aW9uIScsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaXZhY3kgcG9saWN5IHVybCBsYWJlbFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqL1xuICAncHJpdmFjeVBvbGljeVVybExhYmVsJzogJ0xlYXJuIG1vcmUgaGVyZS4nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwcml2YWN5IHBvbGljeSB1cmxcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdwcml2YWN5UG9saWN5VXJsJzogJycsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaXZhY3kgcG9saWN5IGVycm9yIHRleHQsIHNob3duIHdoZW4gdGhlIHVzZXIgZG9lcyBub3QgYWdyZWVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdwcml2YWN5UG9saWN5RXJyb3JUZXh0JzogJyogWW91IG11c3QgYWdyZWUgdG8gdGhlIHByaXZhY3kgcG9saWN5IHRvIHN1Ym1pdCBhIHF1ZXN0aW9uLicsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVtYWlsIGZvcm1hdCBlcnJvciB0ZXh0LCBzaG93biB3aGVuIHRoZSB1c2VyIHN1Ym1pdHMgYW4gaW52YWxpZCBlbWFpbFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ2VtYWlsRm9ybWF0RXJyb3JUZXh0JzogJyogUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcy4nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBuZXR3b3JrIGVycm9yIHRleHQsIHNob3duIHdoZW4gdGhlcmUgaXMgYW4gaXNzdWUgd2l0aCB0aGUgUUEgU3VibWlzc2lvblxuICAgKiByZXF1ZXN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ25ldHdvcmtFcnJvclRleHQnOiAnV2VcXCdyZSBzb3JyeSwgYW4gZXJyb3Igb2NjdXJyZWQuJyxcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgaXMgZXhwYW5kZWQgYnkgZGVmYXVsdC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICAnZXhwYW5kZWQnOiB0cnVlXG59O1xuXG4vKipcbiAqIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCBpcyBhIGNvbXBvbmVudCB0aGF0IGNyZWF0ZXMgYSBmb3JtXG4gKiB0aGF0cyBkaXNwbGF5ZWQgd2hlbmV2ZXIgYSBxdWVyeSBpcyBydW4uIEl0IGVuYWJsZXMgdGhlIHVzZXJcbiAqIHRvIHN1Ym1pdCBxdWVzdGlvbnMgdGhhdCB0aGV5IGNhbnQgZmluZCB0aGUgYW5zd2VyIGZvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHLCBjb25maWcpLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBzdG9yYWdlIG1vZGVsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuUVVFU1RJT05fU1VCTUlTU0lPTjtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbG9jYWxlIGFzIHNldCBpbiB0aGUgZ2xvYmFsIGNvbmZpZ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbGUgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5MT0NBTEUpO1xuXG4gICAgLyoqXG4gICAgICogTk9URShiaWxseSkgaWYgdGhpcyBpcyBhIHBhdHRlcm4gd2Ugd2FudCB0byBmb2xsb3cgZm9yIGNvbmZpZ3VyYXRpb25cbiAgICAgKiB3ZSBzaG91bGQgYmFrZSBpdCBpbnRvIHRoZSBjb3JlIGNsYXNzLlxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdGVDb25maWcoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBRdWVzdGlvblN1Ym1pc3Npb24gY29tcG9uZW50IHNob3VsZCBiZSByZW5kZXJlZCBvbmx5IG9uY2UgYSBzZWFyY2ggaGFzIGNvbXBsZXRlZC4gSWYgdGhlXG4gICAgICogc2VhcmNoIHJlc3VsdHMgYXJlIHN0aWxsIGxvYWRpbmcsIHRoZSBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgY29uc3Qgb25SZXN1bHRzVXBkYXRlID0gcmVzdWx0cyA9PiB7XG4gICAgICBpZiAocmVzdWx0cy5zZWFyY2hTdGF0ZSAhPT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9MT0FESU5HKSB7XG4gICAgICAgIGNvbnN0IHF1ZXN0aW9uVGV4dCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXcgUXVlc3Rpb25TdWJtaXNzaW9uKHtcbiAgICAgICAgICBxdWVzdGlvblRleHQ6IHF1ZXN0aW9uVGV4dCxcbiAgICAgICAgICBleHBhbmRlZDogdGhpcy5fY29uZmlnLmV4cGFuZGVkXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5Nb3VudCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgb25SZXN1bHRzVXBkYXRlKTtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFMsIG9uUmVzdWx0c1VwZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3F1ZXN0aW9ucy9xdWVzdGlvbnN1Ym1pc3Npb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMgaW50ZXJmYWNlIGFsaWFzIGZvciB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1FBU3VibWlzc2lvbic7XG4gIH1cblxuICAvKipcbiAgICogdmFsaWRhdGlvbkNvbmZpZyBjb250YWlucyBhIGJ1bmNoIG9mIHJ1bGVzXG4gICAqIHRoYXQgYXJlIHVzZWQgdG8gdmFsaWRhdGUgYWdpbnN0IGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICovXG4gIHZhbGlkYXRlQ29uZmlnICgpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLmVudGl0eUlkID09PSBudWxsIHx8IHRoaXMuX2NvbmZpZy5lbnRpdHlJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnYGVudGl0eUlkYCBpcyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciBRdWVzdGlvbiBTdWJtaXNzaW9uJyxcbiAgICAgICAgJ1F1ZXN0aW9uU3VibWlzc2lvbicpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZU1vdW50ICgpIHtcbiAgICAvLyBBdm9pZCBtb3VudGluZyB0aGUgY29tcG9uZW50IGlmIHRoZXJlcyBubyBkYXRhXG4gICAgLy8gTm90ZSwgMSBiZWNhdXNlIGBjb25maWdgIGlzIGFsd2F5cyBwYXJ0IG9mIHRoZSBzdGF0ZS5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRTdGF0ZSgpKS5sZW5ndGggPiAxO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgbGV0IHRyaWdnZXJFbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMtY29udGVudC12aXNpYmlsaXR5LXRvZ2dsZScpO1xuICAgIGlmICh0cmlnZ2VyRWwgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYmluZEZvcm1Ub2dnbGUodHJpZ2dlckVsKTtcbiAgICB9XG5cbiAgICBsZXQgZm9ybUVsID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY29uZmlnLmZvcm1TZWxlY3Rvcik7XG4gICAgaWYgKGZvcm1FbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEZvcm1Gb2N1cyhmb3JtRWwpO1xuICAgIHRoaXMuYmluZEZvcm1TdWJtaXQoZm9ybUVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybUZvY3VzIHdpbGwgd2lyZSB1cCB0aGUgRE9NIGZvY3VzIGV2ZW50IHRvIHNlcnZlcnNpZGUgcmVwb3J0aW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm1FbFxuICAgKi9cbiAgYmluZEZvcm1Gb2N1cyAoZm9ybUVsKSB7XG4gICAgaWYgKHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVzdGlvblRleHQgPSBET00ucXVlcnkoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLXRleHQnKTtcbiAgICBET00ub24ocXVlc3Rpb25UZXh0LCAnZm9jdXMnLCAoKSA9PiB7XG4gICAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyLnJlcG9ydCh0aGlzLmdldEFuYWx5dGljc0V2ZW50KCdRVUVTVElPTl9GT0NVUycpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybVN1Ym1pdCBoYW5kbGVzIHN1Ym1pdHRpbmcgdGhlIHF1ZXN0aW9uIHRvIHRoZSBzZXJ2ZXIsXG4gICAqIGFuZCBzdWJtaXRzIGFuIGV2ZW50IHRvIHNlcnZlcnNpZGUgcmVwb3J0aW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm1FbFxuICAgKi9cbiAgYmluZEZvcm1TdWJtaXQgKGZvcm1FbCkge1xuICAgIERPTS5vbihmb3JtRWwsICdzdWJtaXQnLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQodGhpcy5nZXRBbmFseXRpY3NFdmVudCgnUVVFU1RJT05fU1VCTUlUJykpO1xuXG4gICAgICAvLyBUT0RPKGJpbGx5KSB3ZSBwcm9iYWJseSB3YW50IHRvIGRpc2FibGUgdGhlIGZvcm0gZnJvbSBiZWluZyBzdWJtaXR0ZWQgdHdpY2VcbiAgICAgIGNvbnN0IGVycm9ycyA9IHRoaXMudmFsaWRhdGUoZm9ybUVsKTtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gdGhpcy5wYXJzZShmb3JtRWwpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oZm9ybURhdGEsIGVycm9ycykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvcmUuc3VibWl0UXVlc3Rpb24oe1xuICAgICAgICAnZW50aXR5SWQnOiB0aGlzLl9jb25maWcuZW50aXR5SWQsXG4gICAgICAgICdxdWVzdGlvbkxhbmd1YWdlJzogdGhpcy5sb2NhbGUsXG4gICAgICAgICdzaXRlJzogJ0ZJUlNUUEFSVFknLFxuICAgICAgICAnbmFtZSc6IGZvcm1EYXRhLm5hbWUsXG4gICAgICAgICdlbWFpbCc6IGZvcm1EYXRhLmVtYWlsLFxuICAgICAgICAncXVlc3Rpb25UZXh0JzogZm9ybURhdGEucXVlc3Rpb25UZXh0LFxuICAgICAgICAncXVlc3Rpb25EZXNjcmlwdGlvbic6IGZvcm1EYXRhLnF1ZXN0aW9uRGVzY3JpcHRpb25cbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oZm9ybURhdGEsIHtcbiAgICAgICAgICAgICAgJ25ldHdvcmsnOiAnV2VcXCdyZSBzb3JyeSwgYW4gZXJyb3Igb2NjdXJyZWQuJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybVRvZ2dsZSBoYW5kbGVzIGV4cGFuZGluZyBhbmQgbWltaW1pemluZyB0aGUgY29tcG9uZW50J3MgZm9ybS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdHJpZ2dlckVsXG4gICAqL1xuICBiaW5kRm9ybVRvZ2dsZSAodHJpZ2dlckVsKSB7XG4gICAgRE9NLm9uKHRyaWdnZXJFbCwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgbmV3IFF1ZXN0aW9uU3VibWlzc2lvbih7XG4gICAgICAgICAgLi4uZm9ybURhdGEsXG4gICAgICAgICAgJ2V4cGFuZGVkJzogIWZvcm1EYXRhLnF1ZXN0aW9uRXhwYW5kZWQsXG4gICAgICAgICAgJ3N1Ym1pdHRlZCc6IGZvcm1EYXRhLnF1ZXN0aW9uU3VibWl0dGVkIH0sXG4gICAgICAgIGZvcm1EYXRhLmVycm9ycykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBmb3JtLCBhbmQgYnVpbGRzIGEgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW5wdXQgbmFtZXNcbiAgICogYW5kIHRleHQgZmllbGRzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHBhcnNlIChmb3JtRWwpIHtcbiAgICBjb25zdCBpbnB1dEZpZWxkcyA9IERPTS5xdWVyeUFsbChmb3JtRWwsICcuanMtcXVlc3Rpb24tZmllbGQnKTtcbiAgICBpZiAoIWlucHV0RmllbGRzIHx8IGlucHV0RmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGxldCBvYmogPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0RmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdmFsID0gaW5wdXRGaWVsZHNbaV0udmFsdWU7XG4gICAgICBpZiAoaW5wdXRGaWVsZHNbaV0udHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICB2YWwgPSBpbnB1dEZpZWxkc1tpXS5jaGVja2VkO1xuICAgICAgfVxuICAgICAgb2JqW2lucHV0RmllbGRzW2ldLm5hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBmaWVsZHMgZm9yIGNvcnJlY3QgZm9ybWF0dGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICogQHJldHVybnMge09iamVjdH0gZXJyb3JzIG9iamVjdCBpZiBhbnkgZXJyb3JzIGZvdW5kXG4gICAqL1xuICB2YWxpZGF0ZSAoZm9ybUVsKSB7XG4gICAgbGV0IGVycm9ycyA9IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IERPTS5xdWVyeUFsbChmb3JtRWwsICcuanMtcXVlc3Rpb24tZmllbGQnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFmaWVsZHNbaV0uY2hlY2tWYWxpZGl0eSgpKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgLy8gc2V0IGZvY3VzIHN0YXRlIG9uIGZpcnN0IGVycm9yXG4gICAgICAgICAgZmllbGRzW2ldLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZHNbaV0ubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgIGVycm9yc1snZW1haWxFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghZmllbGRzW2ldLnZhbGlkaXR5LnZhbHVlTWlzc2luZykge1xuICAgICAgICAgICAgICBlcnJvcnNbJ2VtYWlsRXJyb3JUZXh0J10gPSB0aGlzLl9jb25maWcuZW1haWxGb3JtYXRFcnJvclRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGVycm9yc1snbmFtZUVycm9yJ10gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJpdmFjeVBvbGljeSc6XG4gICAgICAgICAgICBlcnJvcnNbJ3ByaXZhY3lQb2xpY3lFcnJvclRleHQnXSA9IHRoaXMuX2NvbmZpZy5wcml2YWN5UG9saWN5RXJyb3JUZXh0O1xuICAgICAgICAgICAgZXJyb3JzWydwcml2YWN5UG9saWN5RXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdxdWVzdGlvblRleHQnOlxuICAgICAgICAgICAgZXJyb3JzWydxdWVzdGlvblRleHRFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvcHRpb25zIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb250ZXh0IG9mIGEgcmVwb3J0YWJsZSBldmVudFxuICAgKi9cbiAgZ2V0QW5hbHl0aWNzRXZlbnQgKGV2ZW50VHlwZSkge1xuICAgIGNvbnN0IGFuYWx5dGljc0V2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KGV2ZW50VHlwZSk7XG4gICAgYW5hbHl0aWNzRXZlbnQuYWRkT3B0aW9ucyh7XG4gICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIHNlYXJjaGVyOiB0aGlzLl92ZXJ0aWNhbEtleSA/ICdWRVJUSUNBTCcgOiAnVU5JVkVSU0FMJ1xuICAgIH0pO1xuICAgIHJldHVybiBhbmFseXRpY3NFdmVudDtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHSWNvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEBwYXJhbSBjb25maWcubmFtZVxuICAgKiBAcGFyYW0gY29uZmlnLnBhdGhcbiAgICogQHBhcmFtIGNvbmZpZy5jb21wbGV4Q29udGVudHNcbiAgICogQHBhcmFtIGNvbmZpZy52aWV3Qm94XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBpY29uXG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgLyoqXG4gICAgICogYW4gc3ZnIHBhdGggZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IGNvbmZpZy5wYXRoO1xuICAgIC8qKlxuICAgICAqIGlmIG5vdCB1c2luZyBhIHBhdGgsIGEgdGhlIG1hcmt1cCBmb3IgYSBjb21wbGV4IFNWR1xuICAgICAqL1xuICAgIHRoaXMuY29tcGxleENvbnRlbnRzID0gY29uZmlnLmNvbXBsZXhDb250ZW50cztcbiAgICAvKipcbiAgICAgKiB0aGUgdmlldyBib3ggZGVmaW5pdGlvbiwgZGVmYXVsdHMgdG8gMjR4MjRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmlld0JveCA9IGNvbmZpZy52aWV3Qm94IHx8ICcwIDAgMjQgMjQnO1xuICAgIC8qKlxuICAgICAqIGFjdHVhbCBjb250ZW50cyB1c2VkXG4gICAgICovXG4gICAgdGhpcy5jb250ZW50cyA9IHRoaXMucGF0aERlZmluaXRpb24oKTtcbiAgfVxuXG4gIHBhdGhEZWZpbml0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb21wbGV4Q29udGVudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXhDb250ZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gYDxwYXRoIGQ9XCIke3RoaXMucGF0aH1cIj48L3BhdGg+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBzdmcgbWFya3VwXG4gICAqL1xuICBtYXJrdXAgKCkge1xuICAgIHJldHVybiBgPHN2ZyB2aWV3Qm94PVwiJHt0aGlzLnZpZXdCb3h9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPiR7dGhpcy5jb250ZW50c308L3N2Zz5gO1xuICB9XG59XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAndGh1bWInLFxuICB2aWV3Qm94OiAnMCAwIDI0IDIyJyxcbiAgcGF0aDogJ00xNS4yNzMgMUg1LjQ1NWMtLjkwNiAwLTEuNjguNTUtMi4wMDggMS4zNDJMLjE1MyAxMC4wOTdBMi4xOSAyLjE5IDAgMDAwIDEwLjl2Mi4yYzAgMS4yMS45ODIgMi4yIDIuMTgyIDIuMmg2Ljg4M0w4LjAzIDIwLjMyN2wtLjAzMy4zNTJjMCAuNDUxLjE4Ni44NjkuNDggMS4xNjZMOS42MzMgMjNsNy4xNzgtNy4yNDlhMi4xNiAyLjE2IDAgMDAuNjQ0LTEuNTUxdi0xMWMwLTEuMjEtLjk4Mi0yLjItMi4xODItMi4yem0wIDEzLjJsLTQuNzM1IDQuNzc0TDExLjc1IDEzLjFIMi4xODJ2LTIuMmwzLjI3My03LjdoOS44MTh2MTF6TTE5LjYzNiAxSDI0djEzLjJoLTQuMzY0VjF6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncmVjZWlwdCcsXG4gIHBhdGg6ICdNMTQuNjA2IDkuNWMtLjY3MS0uNTE1LTEuNTkxLS44MzMtMi42MDYtLjgzMyAxLjAxNSAwIDEuOTM1LjMxOCAyLjYwNi44MzN6bS03Ljk4NSAwSDEuNjU1QTEuNjYgMS42NiAwIDAxMCA3LjgzM1YzLjY2N0MwIDIuNzQ3Ljc0MSAyIDEuNjU1IDJoMjAuNjlBMS42NiAxLjY2IDAgMDEyNCAzLjY2N3Y0LjE2NkExLjY2IDEuNjYgMCAwMTIyLjM0NSA5LjVoLTQuOTY2VjIySDYuNjIxVjkuNWgyLjc3M0g2LjYyem0xMC43NTgtMS42NjdoNC45NjZWMy42NjdIMS42NTV2NC4xNjZoNC45NjZ2LTIuNWgxMC43NTh2Mi41eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3BhbnRoZW9uJyxcbiAgcGF0aDogJ005Ljk0NyAxNi41OThoLjI1MlY5LjQxMmgtLjI1MmEuNDMyLjQzMiAwIDAxLS4yMy0uMDY1Yy0uMDctLjA0My0uMTA2LS4wOTMtLjEwNi0uMTVMOS4xNSA3Ljgydi0uMTVjMC0uMDQ0LjAyOC0uMDguMDg0LS4xMDlhLjY5MS42OTEgMCAwMS4xMDUtLjA4Ni4yNTQuMjU0IDAgMDEuMTQ2LS4wNDNIMTMuNmMuMDU2IDAgLjEwNC4wMTUuMTQ2LjA0My4wNDIuMDMuMDkxLjA1OC4xNDcuMDg2YS4yNzEuMjcxIDAgMDEuMDYzLjEwOGMuMDE0LjA0My4wMDcuMDkzLS4wMi4xNWwtLjQyIDEuMzc4YS4zNzQuMzc0IDAgMDEtLjE0Ny4xNS4zNy4zNyAwIDAxLS4xOS4wNjVoLS4yNTF2Ny4xODZoLjI1MmEuMzcuMzcgMCAwMS4xODkuMDY1Yy4wNy4wNDMuMTE5LjA5My4xNDcuMTVsLjQyIDEuMzc4Yy4wMjcuMDI4LjAzNC4wNzEuMDIuMTI5YS4yNzUuMjc1IDAgMDEtLjA2My4xMjkgMS4zNjQgMS4zNjQgMCAwMC0uMTQ3LjA4Ni4yNTQuMjU0IDAgMDEtLjE0Ni4wNDNIOS40ODVhLjI1NC4yNTQgMCAwMS0uMTQ2LS4wNDMuNjkxLjY5MSAwIDAxLS4xMDUtLjA4NmMtLjA1Ni0uMDI5LS4wODQtLjA3Mi0uMDg0LS4xM3YtLjEyOGwuNDYxLTEuMzc3YzAtLjA1OC4wMzUtLjEwOC4xMDUtLjE1MWEuNDMyLjQzMiAwIDAxLjIzMS0uMDY1em01Ljc5MiAwaC4yNTJWOS40MTJoLS4yNTJhLjQzMi40MzIgMCAwMS0uMjMtLjA2NS4zNzQuMzc0IDAgMDEtLjE0OC0uMTVsLS40Mi0xLjM3N2MtLjAyNy0uMDI5LS4wMzQtLjA3Mi0uMDItLjEzYS4yNzUuMjc1IDAgMDEuMDYzLS4xMjljLjA1Ni0uMDI4LjEwNS0uMDU3LjE0Ni0uMDg2YS4yNTQuMjU0IDAgMDEuMTQ3LS4wNDNoNC4xMTRjLjA1NSAwIC4xMDQuMDE1LjE0Ni4wNDNhLjY5MS42OTEgMCAwMS4xMDUuMDg2Yy4wNTYuMDMuMDg0LjA3Mi4wODQuMTN2LjEyOWwtLjQyIDEuMzc3YS4zNzQuMzc0IDAgMDEtLjE0Ni4xNS40MzIuNDMyIDAgMDEtLjIzMS4wNjVoLS4yMXY3LjE4NmguMjFhLjQzLjQzIDAgMDEuMjMuMDY1Yy4wNy4wNDMuMTIuMDkzLjE0OC4xNWwuNDIgMS4zNzh2LjE1YzAgLjA0My0uMDI5LjA4LS4wODUuMTA4YS42OTEuNjkxIDAgMDEtLjEwNS4wODYuMjU0LjI1NCAwIDAxLS4xNDYuMDQzaC00LjExNGEuMjU0LjI1NCAwIDAxLS4xNDctLjA0MyAxLjM2NCAxLjM2NCAwIDAwLS4xNDYtLjA4Ni4yNzEuMjcxIDAgMDEtLjA2My0uMTA4Yy0uMDE0LS4wNDMtLjAwNy0uMDkzLjAyLS4xNWwuNDItMS4zNzdhLjM3NC4zNzQgMCAwMS4xNDctLjE1MS40MzIuNDMyIDAgMDEuMjMxLS4wNjV6bS0xMS43OTQtLjA4NmguMjUyVjkuNDk4aC0uMjUyYS4zMzQuMzM0IDAgMDEtLjIxLS4wNjUuMzg2LjM4NiAwIDAxLS4xMjYtLjE5M2wtLjQyLTEuMzc3YS4yNDguMjQ4IDAgMDEtLjAyLS4xNzIuODU0Ljg1NCAwIDAxLjA2My0uMTczYy4wMjgtLjA1Ny4wNy0uMS4xMjYtLjEyOWEuMzY1LjM2NSAwIDAxLjE2OC0uMDQzaDQuMDdjLjA1NyAwIC4xMTMuMDE1LjE2OS4wNDNhLjI3OC4yNzggMCAwMS4xMjYuMTMuODU0Ljg1NCAwIDAxLjA2Mi4xNzIuMjQ4LjI0OCAwIDAxLS4wMi4xNzJsLS40MiAxLjM3N2EuMzg2LjM4NiAwIDAxLS4xMjYuMTkzLjMzNC4zMzQgMCAwMS0uMjEuMDY1aC0uMjF2Ny4wMTRoLjIxYy4wODQgMCAuMTU0LjAyOS4yMS4wODZhLjY3My42NzMgMCAwMS4xMjYuMTcybC40MiAxLjM3OGEuMjQ4LjI0OCAwIDAxLjAyLjE3Mi44NTQuODU0IDAgMDEtLjA2Mi4xNzIuMjc4LjI3OCAwIDAxLS4xMjYuMTI5LjM2NS4zNjUgMCAwMS0uMTY4LjA0M0gzLjUyNmEuMzY1LjM2NSAwIDAxLS4xNjgtLjA0My4yNzguMjc4IDAgMDEtLjEyNi0uMTMuODU0Ljg1NCAwIDAxLS4wNjMtLjE3MS4yNDguMjQ4IDAgMDEuMDItLjE3MmwuNDItMS4zNzhhLjY3My42NzMgMCAwMS4xMjYtLjE3Mi4yODEuMjgxIDAgMDEuMjEtLjA4NnpNMS43NjMgNi42NThhLjcxNy43MTcgMCAwMS0uNTA0LS4xOTQuNjQ0LjY0NCAwIDAxLS4yMS0uNDk1di0uNDNhLjczLjczIDAgMDEuMTA1LS4zODcuNjguNjggMCAwMS4yNzMtLjI1OUM0LjMwOSAzLjQwMiA2LjU0IDIuMjc2IDguMTIxIDEuNTE1IDkuNzAyLjc1NSAxMC40OTMuMzYxIDEwLjQ5My4zMzJjLjUzMS0uMjU4Ljk3Mi0uMzY2IDEuMzIyLS4zMjMuMzUuMDQzLjczNC4xNjUgMS4xNTQuMzY2bDguMzEgNC41MThjLjE0LjA1OC4yNDUuMTQ0LjMxNS4yNTlhLjczLjczIDAgMDEuMTA1LjM4N3YuNDNjMCAuMjAxLS4wNy4zNjYtLjIxLjQ5NWEuNzE3LjcxNyAwIDAxLS41MDQuMTk0SDEuNzYzem0tLjcxNCAxMy4zNGEuNTQuNTQgMCAwMS4xNjgtLjM4Ny41MTYuNTE2IDAgMDEuMzc4LS4xNzJoMTkuNjQyYy4xNjggMCAuMzA4LjA1Ny40Mi4xNzJhLjU0MS41NDEgMCAwMS4xNjguMzg3di44MThhLjUyMi41MjIgMCAwMS0uMTY4LjQwOC42MDUuNjA1IDAgMDEtLjQyLjE1MUgxLjU5NWEuNTUxLjU1MSAwIDAxLS4zNzgtLjE1LjUyMi41MjIgMCAwMS0uMTY4LS40MXYtLjgxN3ptMjEuNDA1IDIuMDIyYy4xNCAwIC4yNjYuMDU4LjM3OC4xNzNhLjU5Mi41OTIgMCAwMS4xNjguNDN2LjgxOGEuNTQxLjU0MSAwIDAxLS4xNjguMzg3LjUxNi41MTYgMCAwMS0uMzc4LjE3MkwuNTQ2IDIzLjk1N2EuNTE2LjUxNiAwIDAxLS4zNzgtLjE3Mi41NDEuNTQxIDAgMDEtLjE2OC0uMzg3di0uODE4YS41OS41OSAwIDAxLjE2OC0uNDMuNTE2LjUxNiAwIDAxLjM3OC0uMTczbDIxLjkwOC4wNDN6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbWljJyxcbiAgcGF0aDogJ00xMiAxNWMxLjY2IDAgMi45OS0xLjM0IDIuOTktM0wxNSA2YzAtMS42Ni0xLjM0LTMtMy0zUzkgNC4zNCA5IDZ2NmMwIDEuNjYgMS4zNCAzIDMgM3ptNS4zLTNjMCAzLTIuNTQgNS4xLTUuMyA1LjFTNi43IDE1IDYuNyAxMkg1YzAgMy40MSAyLjcyIDYuMjMgNiA2LjcyVjIyaDJ2LTMuMjhjMy4yOC0uNDggNi0zLjMgNi02LjcyaC0xLjd6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnZGlyZWN0aW9ucycsXG4gIHBhdGg6ICdNMjMuNjQ5IDExLjE1NEwxMi44NDYuMzVhMS4xOTUgMS4xOTUgMCAwMC0xLjY5MiAwTC4zNSAxMS4xNTRhMS4xOTUgMS4xOTUgMCAwMDAgMS42OTJMMTEuMTU0IDIzLjY1YTEuMTk1IDEuMTk1IDAgMDAxLjY5MiAwTDIzLjY1IDEyLjg0NmMuNDY4LS40NTYuNDY4LTEuMjEyIDAtMS42OTJ6bS05LjI1NCAzLjg1M3YtMy4wMDFIOS41OTN2My42aC0yLjR2LTQuOGMwLS42Ni41NC0xLjIgMS4yLTEuMmg2LjAwMlY2LjYwNGw0LjIgNC4yLTQuMiA0LjIwMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjYWxlbmRhcicsXG4gIHBhdGg6ICdNMTguMTExIDEzLjJIMTJ2Nmg2LjExMXYtNnpNMTYuODkgMHYyLjRINy4xMVYwSDQuNjY3djIuNEgzLjQ0NGMtMS4zNTYgMC0yLjQzMiAxLjA4LTIuNDMyIDIuNEwxIDIxLjZDMSAyMi45MiAyLjA4OCAyNCAzLjQ0NCAyNGgxNy4xMTJDMjEuOSAyNCAyMyAyMi45MiAyMyAyMS42VjQuOGMwLTEuMzItMS4xLTIuNC0yLjQ0NC0yLjRoLTEuMjIzVjBIMTYuODl6bTMuNjY3IDIxLjZIMy40NDRWOC40aDE3LjExMnYxMy4yeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2NhbGxvdXQnLFxuICBwYXRoOiAnTTIxLjk5IDRjMC0xLjEtLjg5LTItMS45OS0ySDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTRsNCA0LS4wMS0xOHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdpbmZvJyxcbiAgcGF0aDogJ00xMiA4LjRBMS4yIDEuMiAwIDEwMTIgNmExLjIgMS4yIDAgMDAwIDIuNHpNMTIgMGM2LjYyNCAwIDEyIDUuMzc2IDEyIDEycy01LjM3NiAxMi0xMiAxMlMwIDE4LjYyNCAwIDEyIDUuMzc2IDAgMTIgMHptMCAxOGMuNjYgMCAxLjItLjU0IDEuMi0xLjJWMTJjMC0uNjYtLjU0LTEuMi0xLjItMS4yLS42NiAwLTEuMi41NC0xLjIgMS4ydjQuOGMwIC42Ni41NCAxLjIgMS4yIDEuMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdicmllZmNhc2UnLFxuICBwYXRoOiAnTTIwIDdoLTRWNWMwLTEuMTEtLjg5LTItMi0yaC00Yy0xLjExIDAtMiAuODktMiAydjJINGMtMS4xMSAwLTEuOTkuODktMS45OSAyTDIgMjBjMCAxLjExLjg5IDIgMiAyaDE2YzEuMTEgMCAyLS44OSAyLTJWOWMwLTEuMTEtLjg5LTItMi0yem0tNiAwaC00VjVoNHYyeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2thYm9iJyxcbiAgdmlld0JveDogJzAgMCAzIDExJyxcbiAgY29tcGxleENvbnRlbnRzOiBgPGNpcmNsZSBjeD1cIjEuNVwiIGN5PVwiMS41XCIgcj1cIjEuNVwiLz48Y2lyY2xlIGN4PVwiMS41XCIgY3k9XCI1LjVcIiByPVwiMS41XCIvPjxjaXJjbGUgY3g9XCIxLjVcIiBjeT1cIjkuNVwiIHI9XCIxLjVcIi8+YFxufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncGVyc29uJyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNOSA5YzIuNDg2IDAgNC41LTIuMDE0IDQuNS00LjVTMTEuNDg2IDAgOSAwYTQuNDk5IDQuNDk5IDAgMDAtNC41IDQuNUM0LjUgNi45ODYgNi41MTQgOSA5IDl6bTAgMi4yNWMtMy4wMDQgMC05IDEuNTA4LTkgNC41djEuMTI1QzAgMTcuNDk0LjUwNiAxOCAxLjEyNSAxOGgxNS43NWMuNjE5IDAgMS4xMjUtLjUwNiAxLjEyNS0xLjEyNVYxNS43NWMwLTIuOTkyLTUuOTk2LTQuNS05LTQuNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdtYWduaWZ5aW5nX2dsYXNzJyxcbiAgcGF0aDogJ00xNi4xMjQgMTMuMDUxYTUuMTU0IDUuMTU0IDAgMTEwLTEwLjMwOCA1LjE1NCA1LjE1NCAwIDAxMCAxMC4zMDhNMTYuMTE0IDBhNy44ODYgNy44ODYgMCAwMC02LjQ2IDEyLjQwN0wwIDIyLjA2IDEuOTQgMjRsOS42NTMtOS42NTNBNy44ODYgNy44ODYgMCAxMDE2LjExMyAwJ1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnb2ZmaWNlJyxcbiAgcGF0aDogJ00xMiA3VjNIMnYxOGgyMFY3SDEyek02IDE5SDR2LTJoMnYyem0wLTRINHYtMmgydjJ6bTAtNEg0VjloMnYyem0wLTRINFY1aDJ2MnptNCAxMkg4di0yaDJ2MnptMC00SDh2LTJoMnYyem0wLTRIOFY5aDJ2MnptMC00SDhWNWgydjJ6bTEwIDEyaC04di0yaDJ2LTJoLTJ2LTJoMnYtMmgtMlY5aDh2MTB6bS0yLThoLTJ2Mmgydi0yem0wIDRoLTJ2Mmgydi0yeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2xpbmsnLFxuICBwYXRoOiAnTTIuMjggMTJBMy43MjMgMy43MjMgMCAwMTYgOC4yOGg0LjhWNkg2Yy0zLjMxMiAwLTYgMi42ODgtNiA2czIuNjg4IDYgNiA2aDQuOHYtMi4yOEg2QTMuNzIzIDMuNzIzIDAgMDEyLjI4IDEyem00LjkyIDEuMmg5LjZ2LTIuNEg3LjJ2Mi40ek0xOCA2aC00Ljh2Mi4yOEgxOEEzLjcyMyAzLjcyMyAwIDAxMjEuNzIgMTIgMy43MjMgMy43MjMgMCAwMTE4IDE1LjcyaC00LjhWMThIMThjMy4zMTIgMCA2LTIuNjg4IDYtNnMtMi42ODgtNi02LTZ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnd2luZG93JyxcbiAgcGF0aDogJ00zIDEzaDhWM0gzdjEwem0wIDhoOHYtNkgzdjZ6bTEwIDBoOFYxMWgtOHYxMHptMC0xOHY2aDhWM2gtOHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwaG9uZScsXG4gIHBhdGg6ICdNNC44MjcgMTAuMzg3YTIwLjE5OCAyMC4xOTggMCAwMDguNzg2IDguNzg2bDIuOTM0LTIuOTMzYy4zNi0uMzYuODkzLS40OCAxLjM2LS4zMmExNS4yMSAxNS4yMSAwIDAwNC43Ni43NmMuNzMzIDAgMS4zMzMuNiAxLjMzMyAxLjMzM3Y0LjY1NEMyNCAyMy40IDIzLjQgMjQgMjIuNjY3IDI0IDEwLjE0NyAyNCAwIDEzLjg1MyAwIDEuMzMzIDAgLjYuNiAwIDEuMzMzIDBINmMuNzMzIDAgMS4zMzMuNiAxLjMzMyAxLjMzMyAwIDEuNjY3LjI2NyAzLjI2Ny43NiA0Ljc2LjE0Ny40NjcuMDQuOTg3LS4zMzMgMS4zNmwtMi45MzMgMi45MzR6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAndGFnJyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNMTcuNDY5IDguNjIybC04LjEtOC4xQTEuNzg5IDEuNzg5IDAgMDA4LjEgMEgxLjhDLjgxIDAgMCAuODEgMCAxLjh2Ni4zYzAgLjQ5NS4xOTguOTQ1LjUzMSAxLjI3OGw4LjEgOC4xYy4zMjQuMzI0Ljc3NC41MjIgMS4yNjkuNTIyYTEuNzYgMS43NiAwIDAwMS4yNjktLjUzMWw2LjMtNi4zQTEuNzYgMS43NiAwIDAwMTggOS45YzAtLjQ5NS0uMjA3LS45NTQtLjUzMS0xLjI3OHpNMy4xNSA0LjVjLS43NDcgMC0xLjM1LS42MDMtMS4zNS0xLjM1IDAtLjc0Ny42MDMtMS4zNSAxLjM1LTEuMzUuNzQ3IDAgMS4zNS42MDMgMS4zNSAxLjM1IDAgLjc0Ny0uNjAzIDEuMzUtMS4zNSAxLjM1eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2RvY3VtZW50JyxcbiAgcGF0aDogJ000IDZIMnYxNGMwIDEuMS45IDIgMiAyaDE0di0ySDRWNnptMTYtNEg4Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDEyYzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS0xIDlIOVY5aDEwdjJ6bS00IDRIOXYtMmg2djJ6bTQtOEg5VjVoMTB2MnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjaGV2cm9uJyxcbiAgdmlld0JveDogJzAgMCA3IDknLFxuICBjb21wbGV4Q29udGVudHM6IGA8ZyBmaWxsLXJ1bGU9XCJldmVub2RkXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xIC04KVwiPjxwYXRoIGQ9XCJtMi42NDE3MDA0IDgtMS4xNDE3MDA0IDEuMDU3NSAzLjcwODUwMjAyIDMuNDQyNS0zLjcwODUwMjAyIDMuNDQyNSAxLjE0MTcwMDQgMS4wNTc1IDQuODU4Mjk5Ni00LjV6XCIvPjwvZz5gXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdzdXBwb3J0JyxcbiAgcGF0aDogJ00xMiwwIEM1LjM3NiwwIDAsNS4zNzYgMCwxMiBDMCwxOC42MjQgNS4zNzYsMjQgMTIsMjQgQzE4LjYyNCwyNCAyNCwxOC42MjQgMjQsMTIgQzI0LDUuMzc2IDE4LjYyNCwwIDEyLDAgWiBNMTMsMTkgTDExLDE5IEwxMSwxNyBMMTMsMTcgTDEzLDE5IFogTTE1LjA3LDExLjI1IEwxNC4xNywxMi4xNyBDMTMuNDUsMTIuOSAxMywxMy41IDEzLDE1IEwxMSwxNSBMMTEsMTQuNSBDMTEsMTMuNCAxMS40NSwxMi40IDEyLjE3LDExLjY3IEwxMy40MSwxMC40MSBDMTMuNzgsMTAuMDUgMTQsOS41NSAxNCw5IEMxNCw3LjkgMTMuMSw3IDEyLDcgQzEwLjksNyAxMCw3LjkgMTAsOSBMOCw5IEM4LDYuNzkgOS43OSw1IDEyLDUgQzE0LjIxLDUgMTYsNi43OSAxNiw5IEMxNiw5Ljg4IDE1LjY0LDEwLjY4IDE1LjA3LDExLjI1IFonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd5ZXh0JyxcbiAgdmlld0JveDogJzAgMCAzMCAzMCcsXG4gIHBhdGg6ICdNMjUuNTE3IDI4LjE0MnYuMDk1aC0uMjA0di45MDVoLS4wNjZ2LS45MDVoLS4xOTd2LS4wOTVoLjQ2N3ptLjY2NyAwaC4wNjZ2MWgtLjA2NnYtLjgyNWwtLjI0LjU5NWgtLjAxM2wtLjI0LS41OTV2LjgyNWgtLjA2NnYtMWguMDY2bC4yNDcuNjEuMjQ2LS42MXpNMTUgMjguOGM3LjYyMiAwIDEzLjgtNi4xNzggMTMuOC0xMy44IDAtNy42MjItNi4xNzgtMTMuOC0xMy44LTEzLjhDNy4zNzggMS4yIDEuMiA3LjM3OCAxLjIgMTVjMCA3LjYyMiA2LjE3OCAxMy44IDEzLjggMTMuOHpNMTUgMGM4LjI4NCAwIDE1IDYuNzE2IDE1IDE1IDAgOC4yODQtNi43MTYgMTUtMTUgMTUtOC4yODQgMC0xNS02LjcxNi0xNS0xNUMwIDYuNzE2IDYuNzE2IDAgMTUgMHptLjQ1IDE2LjY1di0xLjJoNi42djEuMmgtMi43djUuNGgtMS4ydi01LjRoLTIuN3ptLTEuNTk5LTEuMzVsLjg0OS44NDktMi42MDEgMi42MDEgMi42MDEgMi42MDEtLjg0OS44NDktMi42MDEtMi42MDFMOC42NDkgMjIuMmwtLjg0OS0uODQ5IDIuNjAxLTIuNjAxTDcuOCAxNi4xNDlsLjg0OS0uODQ5IDIuNjAxIDIuNjAxIDIuNjAxLTIuNjAxek0xOC42NzUgOWEyLjE3NSAyLjE3NSAwIDAwLTEuODQ3IDMuMzIzbDIuOTk1LTIuOTk1QTIuMTYzIDIuMTYzIDAgMDAxOC42NzUgOXptMCA1LjU1YTMuMzc1IDMuMzc1IDAgMTEyLjgzMy01LjIwOWwtMy43ODkgMy43ODhhMi4xNzUgMi4xNzUgMCAwMDMuMTMtMS45NTRoMS4yMDFhMy4zNzUgMy4zNzUgMCAwMS0zLjM3NSAzLjM3NXptLTcuNDI1LTMuNzM0TDEzLjc4IDcuOGwuOTIuNzcxLTIuODUgMy4zOTd2Mi41ODJoLTEuMnYtMi41ODJMNy44IDguNTdsLjkyLS43NzEgMi41MyAzLjAxNnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwaW4nLFxuICB2aWV3Qm94OiAnMCAwIDEzIDE4JyxcbiAgcGF0aDogJ205LjM3NSAwYy0zLjUyNDQ2NDI5IDAtNi4zNzUgMi44MTctNi4zNzUgNi4zIDAgNC43MjUgNi4zNzUgMTEuNyA2LjM3NSAxMS43czYuMzc1LTYuOTc1IDYuMzc1LTExLjdjMC0zLjQ4My0yLjg1MDUzNTctNi4zLTYuMzc1LTYuM3ptLjAwMDAwMDE4IDguNTUwMDAwMDdjLTEuMjU2Nzg1NzYgMC0yLjI3Njc4NTc5LTEuMDA4LTIuMjc2Nzg1NzktMi4yNXMxLjAyMDAwMDAzLTIuMjUgMi4yNzY3ODU3OS0yLjI1YzEuMjU2Nzg1NzIgMCAyLjI3Njc4NTgyIDEuMDA4IDIuMjc2Nzg1ODIgMi4yNXMtMS4wMjAwMDAxIDIuMjUtMi4yNzY3ODU4MiAyLjI1eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2dlYXInLFxuICBwYXRoOiAnTTEyIDEwYy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnptNy03SDVhMiAyIDAgMDAtMiAydjE0YTIgMiAwIDAwMiAyaDE0YTIgMiAwIDAwMi0yVjVhMiAyIDAgMDAtMi0yem0tMS43NSA5YzAgLjIzLS4wMi40Ni0uMDUuNjhsMS40OCAxLjE2Yy4xMy4xMS4xNy4zLjA4LjQ1bC0xLjQgMi40MmMtLjA5LjE1LS4yNy4yMS0uNDMuMTVsLTEuNzQtLjdjLS4zNi4yOC0uNzYuNTEtMS4xOC42OWwtLjI2IDEuODVjLS4wMy4xNy0uMTguMy0uMzUuM2gtMi44Yy0uMTcgMC0uMzItLjEzLS4zNS0uMjlsLS4yNi0xLjg1Yy0uNDMtLjE4LS44Mi0uNDEtMS4xOC0uNjlsLTEuNzQuN2MtLjE2LjA2LS4zNCAwLS40My0uMTVsLTEuNC0yLjQyYS4zNTMuMzUzIDAgMDEuMDgtLjQ1bDEuNDgtMS4xNmMtLjAzLS4yMy0uMDUtLjQ2LS4wNS0uNjkgMC0uMjMuMDItLjQ2LjA1LS42OGwtMS40OC0xLjE2YS4zNTMuMzUzIDAgMDEtLjA4LS40NWwxLjQtMi40MmMuMDktLjE1LjI3LS4yMS40My0uMTVsMS43NC43Yy4zNi0uMjguNzYtLjUxIDEuMTgtLjY5bC4yNi0xLjg1Yy4wMy0uMTcuMTgtLjMuMzUtLjNoMi44Yy4xNyAwIC4zMi4xMy4zNS4yOWwuMjYgMS44NWMuNDMuMTguODIuNDEgMS4xOC42OWwxLjc0LS43Yy4xNi0uMDYuMzQgMCAuNDMuMTVsMS40IDIuNDJjLjA5LjE1LjA1LjM0LS4wOC40NWwtMS40OCAxLjE2Yy4wMy4yMy4wNS40Ni4wNS42OXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdsaWdodF9idWxiJyxcbiAgdmlld0JveDogJzAgMCAzMiAzNScsXG4gIHBhdGg6ICdNMTEuNTg1IDMxLjA1Nmw4LjM4LS40OTN2LS45ODZsLTguMzguNDkzek0xMS41ODUgMzMuMDI4TDE1Ljc3NSAzNWw0LjE5LTEuOTcyVjMxLjU1bC04LjM4LjQ5M3YuOTg2em02LjkyNi0uNDA3bC0yLjczNiAxLjI5LTIuMTMtMS4wMDQgNC44NjYtLjI4NnpNMTUuNzc1IDcuMzk0Yy00LjYzIDAtOC4zOCAzLjIwNS04LjM4IDguMzggMCA1LjE3NyA0LjE5IDYuOTAyIDQuMTkgMTIuODE4di40OTNsOC4zOC0uNDkzYzAtNS45MTYgNC4xOS04LjE4OCA0LjE5LTEyLjgxN2E4LjM4IDguMzggMCAwMC04LjM4LTguMzh6bTUuNjE3IDEzLjQ4Yy0xLjAyNSAxLjgzNy0yLjE3NCAzLjg5Mi0yLjM4MSA2Ljc4NmwtNi40NC4zOGMtLjEyOS0zLjAxLTEuMjktNS4wMjEtMi4zMi02LjgwOC0uNDkzLS44LS45MjgtMS42MzYtMS4yOTktMi41aDEzLjU1NmMtLjMyNS43MDgtLjcwNCAxLjQwMy0xLjExNiAyLjE0MnptMS40NzktMy4xMjhIOC42MjdhNy43OTMgNy43OTMgMCAwMS0uMjQ3LTEuOTcxYzAtNC4zNTMgMy4wNDItNy4zOTUgNy4zOTUtNy4zOTVhNy4zOTQgNy4zOTQgMCAwMTcuMzk0IDcuMzk1IDYuNzM5IDYuNzM5IDAgMDEtLjMgMS45NzFoLjAwMnpNMjYuNjIgMTUuMjgyaDQuOTN2MWgtNC45M3pNMjMuMDk0IDcuNzU2bDIuMDkxLTIuMDkxLjY5OC42OTctMi4wOTIgMi4wOTJ6TTE1LjI4MiAwaDF2NC45M2gtMXpNNS42NjYgNi4zNjJsLjY5Ny0uNjk3IDIuMDkxIDIuMDkxLS42OTcuNjk3ek0wIDE1LjI4Mmg0LjkzdjFIMHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdyZWNlaXB0JyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNOC45OTEgMEM0LjAyMyAwIDAgNC4wMzIgMCA5czQuMDIzIDkgOC45OTEgOUMxMy45NjggMTggMTggMTMuOTY4IDE4IDlzLTQuMDMyLTktOS4wMDktOXptMy44MTYgMTQuNEw5IDEyLjEwNSA1LjE5MyAxNC40bDEuMDA4LTQuMzI5LTMuMzU3LTIuOTA3IDQuNDI4LS4zNzhMOSAyLjdsMS43MjggNC4wNzcgNC40MjguMzc4LTMuMzU3IDIuOTA3eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2Nsb3NlJyxcbiAgY29tcGxleENvbnRlbnRzOiBgXG4gICAgPHBhdGggZD1cIk03IDhsOS43MTYgOS43MTZtMC05LjcxNkw3IDE3LjcxNlwiIFxuICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIi8+XG4gIGBcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2VsZW1lbnRzJyxcbiAgcGF0aDogJ00xMywxNSBMMTMsMTcgTDIxLDE3IEwyMSwxOSBMMTMsMTkgTDEzLDIxIEwxMSwyMSBMMTEsMTUgTDEzLDE1IFogTTksMTcgTDksMTkgTDMsMTkgTDMsMTcgTDksMTcgWiBNOSwxNSBMNywxNSBMNywxMyBMMywxMyBMMywxMSBMNywxMSBMNyw5IEw5LDkgTDksMTUgWiBNMjEsMTEgTDIxLDEzIEwxMSwxMyBMMTEsMTEgTDIxLDExIFogTTE3LDMgTDE3LDUgTDIxLDUgTDIxLDcgTDE3LDcgTDE3LDkgTDE1LDkgTDE1LDMgTDE3LDMgWiBNMTMsNSBMMTMsNyBMMyw3IEwzLDUgTDEzLDUgWidcbn0pO1xuIiwiaW1wb3J0IHRodW1iSWNvbiBmcm9tICcuL3RodW1iLmpzJztcbmltcG9ydCByZWNlaXB0SWNvbiBmcm9tICcuL3JlY2VpcHQuanMnO1xuaW1wb3J0IHBhbnRoZW9uSWNvbiBmcm9tICcuL3BhbnRoZW9uLmpzJztcbmltcG9ydCBtaWNJY29uIGZyb20gJy4vbWljLmpzJztcbmltcG9ydCBkaXJlY3Rpb25zSWNvbiBmcm9tICcuL2RpcmVjdGlvbnMuanMnO1xuaW1wb3J0IGNhbGVuZGFySWNvbiBmcm9tICcuL2NhbGVuZGFyLmpzJztcbmltcG9ydCBjYWxsb3V0SWNvbiBmcm9tICcuL2NhbGxvdXQuanMnO1xuaW1wb3J0IGluZm9JY29uIGZyb20gJy4vaW5mby5qcyc7XG5pbXBvcnQgYnJpZWZjYXNlSWNvbiBmcm9tICcuL2JyaWVmY2FzZS5qcyc7XG5pbXBvcnQga2Fib2JJY29uIGZyb20gJy4va2Fib2IuanMnO1xuaW1wb3J0IHBlcnNvbkljb24gZnJvbSAnLi9wZXJzb24uanMnO1xuaW1wb3J0IG1hZ25pZnlpbmdHbGFzc0ljb24gZnJvbSAnLi9tYWduaWZ5aW5nX2dsYXNzLmpzJztcbmltcG9ydCBvZmZpY2VJY29uIGZyb20gJy4vb2ZmaWNlLmpzJztcbmltcG9ydCBsaW5rSWNvbiBmcm9tICcuL2xpbmsuanMnO1xuaW1wb3J0IHdpbmRvd0ljb24gZnJvbSAnLi93aW5kb3cuanMnO1xuaW1wb3J0IHBob25lSWNvbiBmcm9tICcuL3Bob25lLmpzJztcbmltcG9ydCB0YWdJY29uIGZyb20gJy4vdGFnLmpzJztcbmltcG9ydCBkb2N1bWVudEljb24gZnJvbSAnLi9kb2N1bWVudC5qcyc7XG5pbXBvcnQgY2hldnJvbkljb24gZnJvbSAnLi9jaGV2cm9uLmpzJztcbmltcG9ydCBzdXBwb3J0SWNvbiBmcm9tICcuL3N1cHBvcnQuanMnO1xuaW1wb3J0IHlleHRJY29uIGZyb20gJy4veWV4dC5qcyc7XG5pbXBvcnQgcGluSWNvbiBmcm9tICcuL3Bpbi5qcyc7XG5pbXBvcnQgZ2Vhckljb24gZnJvbSAnLi9nZWFyLmpzJztcbmltcG9ydCBsaWdodEJ1bGJJY29uIGZyb20gJy4vbGlnaHRfYnVsYi5qcyc7XG5pbXBvcnQgc3Rhckljb24gZnJvbSAnLi9zdGFyLmpzJztcbmltcG9ydCBjbG9zZSBmcm9tICcuL2Nsb3NlLmpzJztcbmltcG9ydCBlbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJztcblxuY29uc3QgaWNvbnNBcnJheSA9IFtcbiAgdGh1bWJJY29uLFxuICByZWNlaXB0SWNvbixcbiAgcGFudGhlb25JY29uLFxuICBtaWNJY29uLFxuICBkaXJlY3Rpb25zSWNvbixcbiAgY2FsZW5kYXJJY29uLFxuICBjYWxsb3V0SWNvbixcbiAgaW5mb0ljb24sXG4gIGJyaWVmY2FzZUljb24sXG4gIGthYm9iSWNvbixcbiAgcGVyc29uSWNvbixcbiAgbWFnbmlmeWluZ0dsYXNzSWNvbixcbiAgb2ZmaWNlSWNvbixcbiAgbGlua0ljb24sXG4gIHdpbmRvd0ljb24sXG4gIHBob25lSWNvbixcbiAgdGFnSWNvbixcbiAgZG9jdW1lbnRJY29uLFxuICBjaGV2cm9uSWNvbixcbiAgc3VwcG9ydEljb24sXG4gIHlleHRJY29uLFxuICBwaW5JY29uLFxuICBnZWFySWNvbixcbiAgbGlnaHRCdWxiSWNvbixcbiAgZWxlbWVudHMsXG4gIGNsb3NlXG5dO1xuXG5jb25zdCBJY29ucyA9IHt9O1xuXG5pY29uc0FycmF5LmZvckVhY2goaWNvbiA9PiB7XG4gIEljb25zW2ljb24ubmFtZV0gPSBpY29uLm1hcmt1cCgpO1xufSk7XG5cbkljb25zLmRlZmF1bHQgPSBzdGFySWNvbi5tYXJrdXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbnM7XG4iLCIvKiogQG1vZHVsZSBJY29uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBJY29ucyBmcm9tICcuLi8uLi9pY29ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogSWNvbkNvbXBvbmVudFxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcGFyYW0gb3B0cy5pY29uTmFtZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gb3B0cy5jdXN0b21JY29uIHtzdHJpbmd9XG4gICAqIEBwYXJhbSBvcHRzLmljb25Vcmwge3N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIHN5c3RlbU9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbU9wdHMpO1xuXG4gICAgLyoqXG4gICAgICogbmFtZSBvZiBhbiBpY29uIGZyb20gdGhlIGRlZmF1bHQgaWNvbiBzZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWNvbk5hbWUgPSBvcHRzLmljb25OYW1lIHx8ICdkZWZhdWx0JztcblxuICAgIC8qKlxuICAgICAqIHRoZSBtYXJrdXAgZm9yIGEgZnVsbHkgY3VzdG9tIGljb25cbiAgICAgKiBAdHlwZSB7KnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY3VzdG9tSWNvbiA9IG9wdHMuY3VzdG9tSWNvbiB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIHRoZSB1cmwgdG8gYSBjdXN0b20gaW1hZ2UgaWNvblxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaWNvblVybCA9IG9wdHMuaWNvblVybCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldHRlciBmb3IgdGhlIGltYWdlIHBhc3RlZCB0byBoYW5kbGViYXJzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW1hZ2UgKCkge1xuICAgIGlmICh0aGlzLmN1c3RvbUljb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUljb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaWNvblVybCkge1xuICAgICAgcmV0dXJuIGA8aW1nIHNyYz1cIiR7dGhpcy5pY29uVXJsfVwiIGFsdD1cIlwiIGNsYXNzPVwiSWNvbi1pbWFnZVwiPmA7XG4gICAgfVxuXG4gICAgaWYgKEljb25zW3RoaXMuaWNvbk5hbWVdKSB7XG4gICAgICByZXR1cm4gSWNvbnNbdGhpcy5pY29uTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBJY29ucy5kZWZhdWx0O1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ljb25Db21wb25lbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdpY29ucy9pY29uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBhbGxvd2luZyBkdXBsaWNhdGVzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIG92ZXJyaWRlcyBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgdG8gcHJvdmlkZSBuYW1lIGFuZCBtYXJrdXBcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge0ljb25Db21wb25lbnR9XG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIGltYWdlOiB0aGlzLmltYWdlLFxuICAgICAgbmFtZTogdGhpcy5pY29uTmFtZSA/IHRoaXMuaWNvbk5hbWUgOiAnY3VzdG9tJ1xuICAgIH0pKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmltcG9ydCBOYXZpZ2F0aW9uQ29tcG9uZW50IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uY29tcG9uZW50JztcblxuaW1wb3J0IFNlYXJjaENvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9zZWFyY2hjb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlclNlYXJjaENvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9maWx0ZXJzZWFyY2hjb21wb25lbnQnO1xuaW1wb3J0IEF1dG9Db21wbGV0ZUNvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9hdXRvY29tcGxldGVjb21wb25lbnQnO1xuaW1wb3J0IFNwZWxsQ2hlY2tDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvc3BlbGxjaGVja2NvbXBvbmVudCc7XG5pbXBvcnQgTG9jYXRpb25CaWFzQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL2xvY2F0aW9uYmlhc2NvbXBvbmVudCc7XG5cbmltcG9ydCBGaWx0ZXJCb3hDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2ZpbHRlcmJveGNvbXBvbmVudCc7XG5pbXBvcnQgRmlsdGVyT3B0aW9uc0NvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZmlsdGVyb3B0aW9uc2NvbXBvbmVudCc7XG5pbXBvcnQgUmFuZ2VGaWx0ZXJDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL3JhbmdlZmlsdGVyY29tcG9uZW50JztcbmltcG9ydCBEYXRlUmFuZ2VGaWx0ZXJDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2RhdGVyYW5nZWZpbHRlcmNvbXBvbmVudCc7XG5pbXBvcnQgRmFjZXRzQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9mYWNldHNjb21wb25lbnQnO1xuaW1wb3J0IEdlb0xvY2F0aW9uQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9nZW9sb2NhdGlvbmNvbXBvbmVudCc7XG5pbXBvcnQgU29ydE9wdGlvbnNDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL3NvcnRvcHRpb25zY29tcG9uZW50JztcblxuaW1wb3J0IERpcmVjdEFuc3dlckNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvZGlyZWN0YW5zd2VyY29tcG9uZW50JztcbmltcG9ydCBSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9yZXN1bHRzY29tcG9uZW50JztcbmltcG9ydCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9hY2NvcmRpb25yZXN1bHRzY29tcG9uZW50LmpzJztcbmltcG9ydCBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy91bml2ZXJzYWxyZXN1bHRzY29tcG9uZW50JztcbmltcG9ydCBQYWdpbmF0aW9uQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9wYWdpbmF0aW9uY29tcG9uZW50JztcblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvbG9jYXRpb25yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvZXZlbnRyZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5cbmltcG9ydCBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvcGVvcGxlcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5pbXBvcnQgTWFwQ29tcG9uZW50IGZyb20gJy4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50IGZyb20gJy4vcXVlc3Rpb25zL3F1ZXN0aW9uc3VibWlzc2lvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBJY29uQ29tcG9uZW50IGZyb20gJy4vaWNvbnMvaWNvbmNvbXBvbmVudC5qcyc7XG5cbmNvbnN0IENPTVBPTkVOVF9DTEFTU19MSVNUID0gW1xuICAvLyBDb3JlIENvbXBvbmVudFxuICBDb21wb25lbnQsXG5cbiAgLy8gTmF2aWdhdGlvbiBDb21wb25lbnRzXG4gIE5hdmlnYXRpb25Db21wb25lbnQsXG5cbiAgLy8gU2VhcmNoIENvbXBvbmVudHNcbiAgU2VhcmNoQ29tcG9uZW50LFxuICBGaWx0ZXJTZWFyY2hDb21wb25lbnQsXG4gIEF1dG9Db21wbGV0ZUNvbXBvbmVudCxcbiAgU3BlbGxDaGVja0NvbXBvbmVudCxcbiAgTG9jYXRpb25CaWFzQ29tcG9uZW50LFxuXG4gIC8vIEZpbHRlciBDb21wb25lbnRzXG4gIEZpbHRlckJveENvbXBvbmVudCxcbiAgRmlsdGVyT3B0aW9uc0NvbXBvbmVudCxcbiAgUmFuZ2VGaWx0ZXJDb21wb25lbnQsXG4gIERhdGVSYW5nZUZpbHRlckNvbXBvbmVudCxcbiAgRmFjZXRzQ29tcG9uZW50LFxuICBHZW9Mb2NhdGlvbkNvbXBvbmVudCxcbiAgU29ydE9wdGlvbnNDb21wb25lbnQsXG5cbiAgLy8gUmVzdWx0cyBDb21wb25lbnRzXG4gIERpcmVjdEFuc3dlckNvbXBvbmVudCxcbiAgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCxcbiAgUmVzdWx0c0NvbXBvbmVudCxcbiAgUGFnaW5hdGlvbkNvbXBvbmVudCxcbiAgUmVzdWx0c0l0ZW1Db21wb25lbnQsXG4gIEFjY29yZGlvblJlc3VsdHNDb21wb25lbnQsXG4gIExvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQsXG4gIEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQsXG4gIFBlb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50LFxuICBNYXBDb21wb25lbnQsXG5cbiAgLy8gUXVlc3Rpb25zIENvbXBvbmVudHNcbiAgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50LFxuXG4gIC8vIEhlbHBlciBDb21wb25lbnRzXG4gIEljb25Db21wb25lbnRcbl07XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCByZWdpc3RyeSBpcyBhIG1hcCB0aGF0IGNvbnRhaW5zXG4gKiBhbGwgYXZhaWxhYmxlIGNvbXBvbmVudCBjbGFzc2VzIHVzZWQgZm9yIGNyZWF0aW9uIG9yIGV4dGVuc2lvbi5cbiAqIEVhY2ggY29tcG9uZW50IGNsYXNzIGhhcyBhIHVuaXF1ZSB0eXBlLCB3aGljaCBpcyB1c2VkIGFzIHRoZSBrZXkgZm9yIHRoZSByZWdpc3RyeVxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDb21wb25lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgQ09NUE9ORU5UX1JFR0lTVFJZID0gQ09NUE9ORU5UX0NMQVNTX0xJU1QucmVkdWNlKChyZWdpc3RyeSwgY2xhenopID0+IHtcbiAgcmVnaXN0cnlbY2xhenoudHlwZV0gPSBjbGF6ejtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufSwge30pO1xuIiwiLyoqIEBtb2R1bGUgQ29tcG9uZW50TWFuYWdlciAqL1xuXG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi9kb20vZG9tJztcbmltcG9ydCB7IENPTVBPTkVOVF9SRUdJU1RSWSB9IGZyb20gJy4vcmVnaXN0cnknO1xuXG4vKipcbiAqIENvbXBvbmVudE1hbmFnZXIgaXMgYSBTaW5nbGV0b25lIHRoYXQgY29udGFpbnMgYm90aCBhbiBpbnRlcm5hbCByZWdpc3RyeSBvZlxuICogZWxpZ2libGUgY29tcG9uZW50cyB0byBiZSBjcmVhdGVkLCBhcyB3ZWxsIGFzIGtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50XG4gKiBpbnN0YW50aWF0ZWQgYW5kIGFjdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIEFMTCBjb21wb25lbnRzIHNob3VsZCBiZSBjb25zdHJ1Y3RlZCB1c2luZyB0aGUge0NvbXBvbmVudE1hbmFnZXJ9IHZpYSBpdHMgYGNyZWF0ZWAgbWV0aG9kLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBhY3RpdmUgY29tcG9uZW50cyBpcyBhbiBpbnRlcm5hbCBjb250YWluZXIgdG8ga2VlcCB0cmFja1xuICAgICAqIG9mIGFsbCBvZiB0aGUgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIGxpYnJhcnkgZGVwZW5kZW5jeVxuICAgICAqXG4gICAgICogVGhlIENvcmUgY29udGFpbnMgYm90aCB0aGUgc3RvcmFnZSBBTkQgc2VydmljZXMgdGhhdCBhcmUgbmVlZGVkIGZvciBwZXJmb3JtaW5nIG9wZXJhdGlvbnNcbiAgICAgKiBsaWtlIHNlYXJjaCBhbmQgYXV0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBzdG9yYWdlIGlzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBzdGF0ZSBvZiBBTEwgY29tcG9uZW50cy5cbiAgICAgKiBXaGVuZXZlciB0aGUgc3RvcmFnZSBpcyB1cGRhdGVkLCB0aGUgc3RhdGUgZ2V0cyBwdXNoZWQgZG93biB0byB0aGUgbmVjZXNzYXJ5IGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0NvcmV9XG4gICAgICovXG4gICAgdGhpcy5fY29yZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSByZW5kZXJlciB0byB1c2UgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogQHR5cGUge0hhbmRsZWJhcnNSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgYW5hbHl0aWNzIHJlcG9ydGVyIGRlcGVuZGVuY3lcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDb21wb25lbnRNYW5hZ2VyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBzZXRSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q29yZSAoY29yZSkge1xuICAgIHRoaXMuX2NvcmUgPSBjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QW5hbHl0aWNzUmVwb3J0ZXIgKHJlcG9ydGVyKSB7XG4gICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiByZWdpc3RlcnMgYSBjb21wb25lbnQgdG8gYmUgZWxpZ2libGUgZm9yIGNyZWF0aW9uIGFuZCBvdmVycmlkZS5cbiAgICogQHBhcmFtIHtDb21wb25lbnR9IFRoZSBDb21wb25lbnQgQ2xhc3MgdG8gcmVnaXN0ZXJcbiAgICovXG4gIHJlZ2lzdGVyIChjb21wb25lbnRDbGF6eikge1xuICAgIENPTVBPTkVOVF9SRUdJU1RSWVtjb21wb25lbnRDbGF6ei50eXBlXSA9IGNvbXBvbmVudENsYXp6O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGNvbnN0cnVjdGluZyBhbnkgYW5kIGFsbCBjb21wb25lbnRzLlxuICAgKiBJdCB3aWxsIGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQsIGFuZCBib3RoIGFwcGx5XG4gICAqIGluaXRpYWwgc3RhdGUgZnJvbSB0aGUgc3RvcmFnZSBhbmQgYmluZCBpdCB0byB0aGUgc3RvcmFnZSBmb3IgdXBkYXRlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFR5cGUgVGhlIGNvbXBvbmVudCB0eXBlIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwaXBlIHRvIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY3JlYXRlIChjb21wb25lbnRUeXBlLCBvcHRzKSB7XG4gICAgLy8gRXZlcnkgY29tcG9uZW50IG5lZWRzIGxvY2FsIGFjY2VzcyB0byB0aGUgY29tcG9uZW50IG1hbmFnZXJcbiAgICAvLyBiZWNhdXNlIHNvbWV0aW1lcyBjb21wb25lbnRzIGhhdmUgc3ViY29tcG9uZW50cyB0aGF0IG5lZWQgdG8gYmVcbiAgICAvLyBjb25zdHJ1Y3RlZCBkdXJpbmcgY3JlYXRpb25cbiAgICBsZXQgc3lzdGVtT3B0cyA9IHtcbiAgICAgIGNvcmU6IHRoaXMuX2NvcmUsXG4gICAgICByZW5kZXJlcjogdGhpcy5fcmVuZGVyZXIsXG4gICAgICBhbmFseXRpY3NSZXBvcnRlcjogdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXIsXG4gICAgICBjb21wb25lbnRNYW5hZ2VyOiB0aGlzXG4gICAgfTtcblxuICAgIGxldCBjb21wb25lbnRDbGFzcyA9IENPTVBPTkVOVF9SRUdJU1RSWVtjb21wb25lbnRUeXBlXTtcblxuICAgIGlmIChcbiAgICAgICFjb21wb25lbnRDbGFzcy5hcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQoKSAmJlxuICAgICAgdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5zb21lKGMgPT4gYy5uYW1lID09PSBvcHRzLm5hbWUpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICBgQW5vdGhlciBjb21wb25lbnQgd2l0aCBuYW1lICR7b3B0cy5uYW1lfSBhbHJlYWR5IGV4aXN0c2AsXG4gICAgICAgIGNvbXBvbmVudFR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGlzVHdpbjogdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5zb21lKGNvbXBvbmVudCA9PiBjb21wb25lbnQuY29uc3RydWN0b3IudHlwZSA9PT0gY29tcG9uZW50VHlwZSksXG4gICAgICAuLi5vcHRzXG4gICAgfTtcblxuICAgIC8vIEluc3RhbnRpYXRlIG91ciBuZXcgY29tcG9uZW50IGFuZCBrZWVwIHRyYWNrIG9mIGl0XG4gICAgbGV0IGNvbXBvbmVudCA9XG4gICAgICBuZXcgQ09NUE9ORU5UX1JFR0lTVFJZW2NvbXBvbmVudFR5cGVdKGNvbmZpZywgc3lzdGVtT3B0cylcbiAgICAgICAgLmluaXQoY29uZmlnKTtcblxuICAgIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBnbG9iYWwgc3RvcmFnZSB0byBwb3dlciBzdGF0ZSwgYXBwbHkgdGhlIHN0YXRlXG4gICAgLy8gZnJvbSB0aGUgc3RvcmFnZSB0byB0aGUgY29tcG9uZW50LCBhbmQgdGhlbiBiaW5kIHRoZSBjb21wb25lbnRcbiAgICAvLyBzdGF0ZSB0byB0aGUgc3RvcmFnZSB2aWEgaXRzIHVwZGF0ZXNcbiAgICBpZiAodGhpcy5fY29yZSAmJiB0aGlzLl9jb3JlLmdsb2JhbFN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgIGlmIChjb21wb25lbnQubW9kdWxlSWQgPT09IHVuZGVmaW5lZCB8fCBjb21wb25lbnQubW9kdWxlSWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29yZS5nbG9iYWxTdG9yYWdlXG4gICAgICAgIC5vbigndXBkYXRlJywgY29tcG9uZW50Lm1vZHVsZUlkLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbXBvbmVudC5zZXRTdGF0ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBjb21wb25lbnRzIGFuZCByZW1vdmVcbiAgICogdGhlIGFzc29jaWF0ZWQgc3RvcmFnZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmUgKGNvbXBvbmVudCkge1xuICAgIHRoaXMuX2NvcmUuZ2xvYmFsU3RvcmFnZS5vZmYoJ3VwZGF0ZScsIGNvbXBvbmVudC5tb2R1bGVJZCk7XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuZmluZEluZGV4KGMgPT4gYy5uYW1lID09PSBjb21wb25lbnQubmFtZSk7XG4gICAgdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29tcG9uZW50IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbXBuZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlQnlOYW1lIChuYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5maW5kKGMgPT4gYy5uYW1lID09PSBuYW1lKTtcbiAgICBjb21wb25lbnQucmVtb3ZlKCk7XG4gICAgRE9NLmVtcHR5KGNvbXBvbmVudC5fY29udGFpbmVyKTtcbiAgfVxuXG4gIGdldEFjdGl2ZUNvbXBvbmVudCAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVDb21wb25lbnRzLmZpbmQoYyA9PiBjLmNvbnN0cnVjdG9yLnR5cGUgPT09IHR5cGUpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBOYXZpZ2F0aW9uQ29uZmlnICovXG5cbmV4cG9ydCBjbGFzcyBUYWJDb25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGFiIHRoYXQgaXMgZXhwb3NlZCBmb3IgdGhlIGxpbmtcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBjb25maWcubGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGV0ZSBVUkwsIGluY2x1ZGluZyB0aGUgcGFyYW1zXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IGNvbmZpZy51cmwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXJzaWRlIHZlcnRpY2FsIGNvbmZpZyBpZCB0aGF0IHRoaXMgaXMgcmVmZXJlbmNlZCB0by5cbiAgICAgKiBCeSBwcm92aWRpbmcgdGhpcywgZW5hYmxlcyBkeW5hbWljIHNvcnRpbmcgYmFzZWQgb24gcmVzdWx0cy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29uZmlnSWQgPSBjb25maWcuY29uZmlnSWQgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IHRoaXMgdGFiIGZpcnN0IGluIHRoZSBvcmRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNGaXJzdCA9IGNvbmZpZy5pc0ZpcnN0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byBhcHBseSBhIHNwZWNpYWwgY2xhc3MgdG8gdGhlXG4gICAgICogbWFya3VwIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIGFjdGl2ZSB0YWJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzQWN0aXZlID0gY29uZmlnLmlzQWN0aXZlIHx8IGZhbHNlO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICB9XG5cbiAgc3RhdGljIGZyb20gKHRhYnMpIHtcbiAgICBsZXQgdGFiQ29uZmlncyA9IFtdO1xuICAgIGlmICh0YWJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0YWJDb25maWdzO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0YWIgPSB0YWJzW2ldO1xuICAgICAgdGFiQ29uZmlncy5wdXNoKG5ldyBUYWJDb25maWcodGFiKSk7XG4gICAgfVxuICAgIHJldHVybiB0YWJDb25maWdzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25Db25maWcge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLnRhYnNDb25maWcgPSBUYWJDb25maWcuZnJvbShjb25maWcudGFicyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmltcG9ydCBDb3JlIGZyb20gJy4vY29yZS9jb3JlJztcblxuaW1wb3J0IHtcbiAgVGVtcGxhdGVMb2FkZXIsXG4gIFJlbmRlcmVycyxcbiAgRE9NXG59IGZyb20gJy4vdWkvaW5kZXgnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL3VpL2NvbXBvbmVudHMvY29tcG9uZW50JztcblxuaW1wb3J0IEVycm9yUmVwb3J0ZXIgZnJvbSAnLi9jb3JlL2Vycm9ycy9lcnJvcnJlcG9ydGVyJztcbmltcG9ydCBDb25zb2xlRXJyb3JSZXBvcnRlciBmcm9tICcuL2NvcmUvZXJyb3JzL2NvbnNvbGVlcnJvcnJlcG9ydGVyJztcbmltcG9ydCB7IEFuYWx5dGljc1JlcG9ydGVyLCBOb29wQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IFBlcnNpc3RlbnRTdG9yYWdlIGZyb20gJy4vdWkvc3RvcmFnZS9wZXJzaXN0ZW50c3RvcmFnZSc7XG5pbXBvcnQgR2xvYmFsU3RvcmFnZSBmcm9tICcuL2NvcmUvc3RvcmFnZS9nbG9iYWxzdG9yYWdlJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgU2VhcmNoQ29uZmlnIGZyb20gJy4vY29yZS9tb2RlbHMvc2VhcmNoY29uZmlnJztcbmltcG9ydCBBdXRvQ29tcGxldGVBcGkgZnJvbSAnLi9jb3JlL3NlYXJjaC9hdXRvY29tcGxldGVhcGknO1xuaW1wb3J0IE1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIGZyb20gJy4vY29yZS9zZWFyY2gvbW9ja2F1dG9jb21wbGV0ZXNlcnZpY2UnO1xuaW1wb3J0IFF1ZXN0aW9uQW5zd2VyQXBpIGZyb20gJy4vY29yZS9zZWFyY2gvcXVlc3Rpb25hbnN3ZXJhcGknO1xuaW1wb3J0IE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UgZnJvbSAnLi9jb3JlL3NlYXJjaC9tb2NrcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJztcbmltcG9ydCBTZWFyY2hBcGkgZnJvbSAnLi9jb3JlL3NlYXJjaC9zZWFyY2hhcGknO1xuaW1wb3J0IE1vY2tTZWFyY2hTZXJ2aWNlIGZyb20gJy4vY29yZS9zZWFyY2gvbW9ja3NlYXJjaHNlcnZpY2UnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi91aS9jb21wb25lbnRzL2NvbXBvbmVudG1hbmFnZXInO1xuaW1wb3J0IE5hdmlnYXRpb25Db25maWcgZnJvbSAnLi9jb3JlL21vZGVscy9uYXZpZ2F0aW9uY29uZmlnJztcbmltcG9ydCB7IFNBTkRCT1gsIFBST0RVQ1RJT04gfSBmcm9tICcuL2NvcmUvY29uc3RhbnRzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9zZWFyY2hzZXJ2aWNlJykuZGVmYXVsdH0gU2VhcmNoU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvc2VydmljZXMvZXJyb3JyZXBvcnRlcnNlcnZpY2UnKS5kZWZhdWx0fSBFcnJvclJlcG9ydGVyU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9hbmFseXRpY3NyZXBvcnRlcnNlcnZpY2UnKS5kZWZhdWx0fSBBbmFseXRpY3NSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBTZXJ2aWNlc1xuICogQHByb3BlcnR5IHtTZWFyY2hTZXJ2aWNlfSBzZWFyY2hTZXJ2aWNlXG4gKiBAcHJvcGVydHkge0F1dG9Db21wbGV0ZVNlcnZpY2V9IGF1dG9Db21wbGV0ZVNlcnZpY2VcbiAqIEBwcm9wZXJ0eSB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfSBxdWVzdGlvbkFuc3dlclNlcnZpY2VcbiAqIEBwcm9wZXJ0eSB7RXJyb3JSZXBvcnRlclNlcnZpY2V9IGVycm9yUmVwb3J0ZXJTZXJ2aWNlXG4gKi9cblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIGxvY2FsZTogJ2VuJ1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBBbnN3ZXJzIGludGVyZmFjZVxuICovXG5jbGFzcyBBbnN3ZXJzIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmICghQW5zd2Vycy5zZXRJbnN0YW5jZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIEFuc3dlcnMuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgQ29tcG9uZW50IGJhc2UgY2xhc3MgZm9yIGN1c3RvbVxuICAgICAqIGNvbXBvbmVudHMgdG8gZXh0ZW5kXG4gICAgICovXG4gICAgdGhpcy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgQW5hbHl0aWNzRXZlbnQgYmFzZSBjbGFzcyBmb3IgcmVwb3J0aW5nXG4gICAgICogY3VzdG9tIGFuYWx5dGljc1xuICAgICAqL1xuICAgIHRoaXMuQW5hbHl0aWNzRXZlbnQgPSBBbmFseXRpY3NFdmVudDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIHRoZSBjb21wb25lbnRzXG4gICAgICogVGhpcyBpcyBwcm92aWRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJzLkhhbmRsZWJhcnMoKTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQgbWFuYWdlclxuICAgICAqIEB0eXBlIHtDb21wb25lbnRNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuY29tcG9uZW50cyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIGFwaVxuICAgICAqIEB0eXBlIHtDb3JlfVxuICAgICAqL1xuICAgIHRoaXMuY29yZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBvbmNlIHRoZSBsaWJyYXJ5IGlzIHJlYWR5LlxuICAgICAqIFR5cGljYWxseSBmaXJlZCBhZnRlciB0ZW1wbGF0ZXMgYXJlIGZldGNoZWQgZnJvbSBzZXJ2ZXIgZm9yIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICB0aGlzLl9vblJlYWR5ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2VydmljZXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZXJ2aWNlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBzZXRJbnN0YW5jZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgaW5pdCAoY29uZmlnKSB7XG4gICAgY29uc3QgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZUNvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudmFsaWRhdGVDb25maWcocGFyc2VkQ29uZmlnKTtcblxuICAgIHBhcnNlZENvbmZpZy5zZWFyY2ggPSBuZXcgU2VhcmNoQ29uZmlnKHBhcnNlZENvbmZpZy5zZWFyY2gpO1xuICAgIHBhcnNlZENvbmZpZy5uYXZpZ2F0aW9uID0gbmV3IE5hdmlnYXRpb25Db25maWcocGFyc2VkQ29uZmlnLm5hdmlnYXRpb24pO1xuXG4gICAgY29uc3QgZ2xvYmFsU3RvcmFnZSA9IG5ldyBHbG9iYWxTdG9yYWdlKCk7XG4gICAgY29uc3QgcGVyc2lzdGVudFN0b3JhZ2UgPSBuZXcgUGVyc2lzdGVudFN0b3JhZ2Uoe1xuICAgICAgdXBkYXRlTGlzdGVuZXI6IHBhcnNlZENvbmZpZy5vblN0YXRlQ2hhbmdlLFxuICAgICAgcmVzZXRMaXN0ZW5lcjogZGF0YSA9PiBnbG9iYWxTdG9yYWdlLnNldEFsbChkYXRhKVxuICAgIH0pO1xuICAgIGdsb2JhbFN0b3JhZ2Uuc2V0QWxsKHBlcnNpc3RlbnRTdG9yYWdlLmdldEFsbCgpKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHLCBwYXJzZWRDb25maWcuc2VhcmNoKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OX0NPTkZJRywgcGFyc2VkQ29uZmlnLm5hdmlnYXRpb24pO1xuICAgIGdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkxPQ0FMRSwgcGFyc2VkQ29uZmlnLmxvY2FsZSk7XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VTU0lPTlNfT1BUX0lOLCBwYXJzZWRDb25maWcuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCk7XG5cbiAgICB0aGlzLl9zZXJ2aWNlcyA9IHBhcnNlZENvbmZpZy5tb2NrXG4gICAgICA/IGdldE1vY2tTZXJ2aWNlcygpXG4gICAgICA6IGdldFNlcnZpY2VzKHBhcnNlZENvbmZpZywgZ2xvYmFsU3RvcmFnZSk7XG5cbiAgICB0aGlzLmNvcmUgPSBuZXcgQ29yZSh7XG4gICAgICBhcGlLZXk6IHBhcnNlZENvbmZpZy5hcGlLZXksXG4gICAgICBnbG9iYWxTdG9yYWdlOiBnbG9iYWxTdG9yYWdlLFxuICAgICAgcGVyc2lzdGVudFN0b3JhZ2U6IHBlcnNpc3RlbnRTdG9yYWdlLFxuICAgICAgZXhwZXJpZW5jZUtleTogcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICBmaWVsZEZvcm1hdHRlcnM6IHBhcnNlZENvbmZpZy5maWVsZEZvcm1hdHRlcnMsXG4gICAgICBleHBlcmllbmNlVmVyc2lvbjogcGFyc2VkQ29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgbG9jYWxlOiBwYXJzZWRDb25maWcubG9jYWxlLFxuICAgICAgc2VhcmNoU2VydmljZTogdGhpcy5fc2VydmljZXMuc2VhcmNoU2VydmljZSxcbiAgICAgIGF1dG9Db21wbGV0ZVNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLmF1dG9Db21wbGV0ZVNlcnZpY2UsXG4gICAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLnF1ZXN0aW9uQW5zd2VyU2VydmljZVxuICAgIH0pO1xuXG4gICAgaWYgKHBhcnNlZENvbmZpZy5vblN0YXRlQ2hhbmdlICYmIHR5cGVvZiBwYXJzZWRDb25maWcub25TdGF0ZUNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyc2VkQ29uZmlnLm9uU3RhdGVDaGFuZ2UocGVyc2lzdGVudFN0b3JhZ2UuZ2V0QWxsKCksIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNcbiAgICAgIC5zZXRDb3JlKHRoaXMuY29yZSlcbiAgICAgIC5zZXRSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcblxuICAgIHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzID0gcGFyc2VkQ29uZmlnLmJ1c2luZXNzSWQgIT0gbnVsbDtcbiAgICBpZiAodGhpcy5fZWxpZ2libGVGb3JBbmFseXRpY3MpIHtcbiAgICAgIC8vIFRPRE8oYW11bGxpbmdzKTogSW5pdGlhbGl6ZSB3aXRoIG90aGVyIHNlcnZpY2VzXG4gICAgICBjb25zdCByZXBvcnRlciA9IHBhcnNlZENvbmZpZy5tb2NrXG4gICAgICAgID8gbmV3IE5vb3BBbmFseXRpY3NSZXBvcnRlcigpXG4gICAgICAgIDogbmV3IEFuYWx5dGljc1JlcG9ydGVyKFxuICAgICAgICAgIHRoaXMuY29yZSxcbiAgICAgICAgICBwYXJzZWRDb25maWcuZXhwZXJpZW5jZUtleSxcbiAgICAgICAgICBwYXJzZWRDb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmJ1c2luZXNzSWQsXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmFuYWx5dGljc09wdGlvbnMsXG4gICAgICAgICAgcGFyc2VkQ29uZmlnLmVudmlyb25tZW50KTtcblxuICAgICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlID0gcmVwb3J0ZXI7XG5cbiAgICAgIHRoaXMuY29tcG9uZW50cy5zZXRBbmFseXRpY3NSZXBvcnRlcihyZXBvcnRlcik7XG4gICAgICBpbml0U2Nyb2xsTGlzdGVuZXIocmVwb3J0ZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldERlZmF1bHRJbml0aWFsU2VhcmNoKHBhcnNlZENvbmZpZy5zZWFyY2gpO1xuXG4gICAgdGhpcy5fb25SZWFkeSA9IHBhcnNlZENvbmZpZy5vblJlYWR5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgaWYgKHBhcnNlZENvbmZpZy51c2VUZW1wbGF0ZXMgPT09IGZhbHNlIHx8IHBhcnNlZENvbmZpZy50ZW1wbGF0ZUJ1bmRsZSkge1xuICAgICAgaWYgKHBhcnNlZENvbmZpZy50ZW1wbGF0ZUJ1bmRsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmluaXQocGFyc2VkQ29uZmlnLnRlbXBsYXRlQnVuZGxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25SZWFkeSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVGVtcGxhdGVzIGFyZSBjdXJyZW50bHkgZG93bmxvYWRlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIENPUkUgYW5kIFVJIGJ1bmRsZS5cbiAgICAvLyBGdXR1cmUgZW5oYW5jZW1lbnQgaXMgdG8gc2hpcCB0aGUgY29tcG9uZW50cyB3aXRoIHRlbXBsYXRlcyBpbiBhIHNlcGFyYXRlIGJ1bmRsZS5cbiAgICB0aGlzLnRlbXBsYXRlcyA9IG5ldyBUZW1wbGF0ZUxvYWRlcih7XG4gICAgICB0ZW1wbGF0ZVVybDogcGFyc2VkQ29uZmlnLnRlbXBsYXRlVXJsXG4gICAgfSkub25Mb2FkZWQoKHRlbXBsYXRlcykgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5pbml0KHRlbXBsYXRlcyk7XG5cbiAgICAgIHRoaXMuX29uUmVhZHkoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZG9tUmVhZHkgKGNiKSB7XG4gICAgRE9NLm9uUmVhZHkoY2IpO1xuICB9XG5cbiAgb25SZWFkeSAoY2IpIHtcbiAgICB0aGlzLl9vblJlYWR5ID0gY2I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBjb25maWcgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIEluIHRoZSBwYXJzZWQgY29uZmlnLCBhbnkgb3B0aW9ucyBub3Qgc3VwcGxpZWQgYnkgdGhlXG4gICAqIHVzZXIgYXJlIGdpdmVuIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSB1c2VyIHN1cHBsaWVkIGNvbmZpZy5cbiAgICovXG4gIHBhcnNlQ29uZmlnIChjb25maWcpIHtcbiAgICBjb25zdCBwYXJzZWRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUUywgY29uZmlnKTtcbiAgICBsZXQgc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjb25maWcuc2Vzc2lvblRyYWNraW5nRW5hYmxlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBzZXNzaW9uVHJhY2tpbmdFbmFibGVkID0gY29uZmlnLnNlc3Npb25UcmFja2luZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHBhcnNlZENvbmZpZy5zZXNzaW9uVHJhY2tpbmdFbmFibGVkID0gc2Vzc2lvblRyYWNraW5nRW5hYmxlZDtcblxuICAgIGNvbnN0IHNhbmRib3hQcmVmaXggPSBgJHtTQU5EQk9YfS1gO1xuICAgIHBhcnNlZENvbmZpZy5hcGlLZXkuaW5jbHVkZXMoc2FuZGJveFByZWZpeClcbiAgICAgID8gcGFyc2VkQ29uZmlnLmVudmlyb25tZW50ID0gU0FOREJPWFxuICAgICAgOiBwYXJzZWRDb25maWcuZW52aXJvbm1lbnQgPSBQUk9EVUNUSU9OO1xuICAgIHBhcnNlZENvbmZpZy5hcGlLZXkgPSBwYXJzZWRDb25maWcuYXBpS2V5LnJlcGxhY2Uoc2FuZGJveFByZWZpeCwgJycpO1xuXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIEFuc3dlcnMgY29uZmlnIG9iamVjdCB0byBlbnN1cmUgdGhpbmdzIGxpa2UgYXBpIGtleSBhbmQgZXhwZXJpZW5jZSBrZXkgYXJlXG4gICAqIHByb3Blcmx5IHNldC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgQW5zd2VycyBjb25maWcuXG4gICAqL1xuICB2YWxpZGF0ZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgLy8gVE9ETyAodG1leWVyKTogRXh0cmFjdCB0aGlzIG1ldGhvZCBpbnRvIGl0J3Mgb3duIGNsYXNzLiBJbnZlc3RpZ2F0ZSB0aGUgdXNlIG9mIEpTT04gc2NoZW1hXG4gICAgLy8gdG8gdmFsaWRhdGUgdGhlc2UgY29uZmlncy5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5hcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYGFwaUtleWAuIFR5cGUgbXVzdCBiZSB7c3RyaW5nfScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmV4cGVyaWVuY2VLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYGV4cGVyaWVuY2VLZXlgLiBUeXBlIG11c3QgYmUge3N0cmluZ30nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjdXN0b20gY29tcG9uZW50IHR5cGUgc28gaXQgY2FuIGJlIGNyZWF0ZWQgdmlhXG4gICAqIGFkZENvbXBvbmVudCBhbmQgdXNlZCBhcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50Q2xhc3NcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50VHlwZSAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0aGlzLmNvbXBvbmVudHMucmVnaXN0ZXIoY29tcG9uZW50Q2xhc3MpO1xuICB9XG5cbiAgYWRkQ29tcG9uZW50ICh0eXBlLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBvcHRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuY3JlYXRlKHR5cGUsIG9wdHMpLm1vdW50KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcignRmFpbGVkIHRvIGFkZCBjb21wb25lbnQnLCB0eXBlLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgLSBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlbiAtIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudCAobmFtZSkge1xuICAgIHRoaXMuY29tcG9uZW50cy5yZW1vdmVCeU5hbWUobmFtZSk7XG4gIH1cblxuICBjcmVhdGVDb21wb25lbnQgKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmNyZWF0ZSgnQ29tcG9uZW50Jywgb3B0cykubW91bnQoKTtcbiAgfVxuXG4gIHJlZ2lzdGVySGVscGVyIChuYW1lLCBjYikge1xuICAgIHRoaXMucmVuZGVyZXIucmVnaXN0ZXJIZWxwZXIobmFtZSwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdCBpbiBvciBvdXQgb2YgY29udmVydGlvbiB0cmFja2luZyBhbmFseXRpY3NcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRJblxuICAgKi9cbiAgc2V0Q29udmVyc2lvbnNPcHRJbiAob3B0SW4pIHtcbiAgICBpZiAodGhpcy5fZWxpZ2libGVGb3JBbmFseXRpY3MpIHtcbiAgICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyU2VydmljZS5zZXRDb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkKG9wdEluKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3B0IGluIG9yIG91dCBvZiBzZXNzaW9uIGNvb2tpZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRJblxuICAgKi9cbiAgc2V0U2Vzc2lvbnNPcHRJbiAob3B0SW4pIHtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VTU0lPTlNfT1BUX0lOLCBvcHRJbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHNlYXJjaCBxdWVyeSBvbiBpbml0aWFsaXphdGlvbiBmb3IgdmVydGljYWwgc2VhcmNoZXJzIHRoYXQgaGF2ZSBhXG4gICAqIGRlZmF1bHRJbml0aWFsU2VhcmNoIHByb3ZpZGVkLCBpZiB0aGUgdXNlciBoYXNuJ3QgYWxyZWFkeSBwcm92aWRlZCB0aGVpclxuICAgKiBvd24gdmlhIFVSTCBwYXJhbS5cbiAgICogQHBhcmFtIHtTZWFyY2hDb25maWd9IHNlYXJjaENvbmZpZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldERlZmF1bHRJbml0aWFsU2VhcmNoIChzZWFyY2hDb25maWcpIHtcbiAgICBpZiAoc2VhcmNoQ29uZmlnLmRlZmF1bHRJbml0aWFsU2VhcmNoID09IG51bGwgfHwgIXNlYXJjaENvbmZpZy52ZXJ0aWNhbEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmVwb3B1bGF0ZWRRdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcbiAgICBpZiAocHJlcG9wdWxhdGVkUXVlcnkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoJ3F1ZXJ5VHJpZ2dlcicsICdpbml0aWFsaXplJyk7XG4gICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHNlYXJjaENvbmZpZy5kZWZhdWx0SW5pdGlhbFNlYXJjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0dsb2JhbFN0b3JhZ2V9IGdsb2JhbFN0b3JhZ2VcbiAqIEByZXR1cm5zIHtTZXJ2aWNlc31cbiAqL1xuZnVuY3Rpb24gZ2V0U2VydmljZXMgKGNvbmZpZywgZ2xvYmFsU3RvcmFnZSkge1xuICByZXR1cm4ge1xuICAgIHNlYXJjaFNlcnZpY2U6IG5ldyBTZWFyY2hBcGkoe1xuICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5LFxuICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgbG9jYWxlOiBjb25maWcubG9jYWxlLFxuICAgICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudFxuICAgIH0pLFxuICAgIGF1dG9Db21wbGV0ZVNlcnZpY2U6IG5ldyBBdXRvQ29tcGxldGVBcGkoXG4gICAgICB7XG4gICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICAgIGV4cGVyaWVuY2VWZXJzaW9uOiBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgIGxvY2FsZTogY29uZmlnLmxvY2FsZSxcbiAgICAgICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudFxuICAgICAgfSxcbiAgICAgIGdsb2JhbFN0b3JhZ2UpLFxuICAgIHF1ZXN0aW9uQW5zd2VyU2VydmljZTogbmV3IFF1ZXN0aW9uQW5zd2VyQXBpKFxuICAgICAgeyBhcGlLZXk6IGNvbmZpZy5hcGlLZXksIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnQgfSxcbiAgICAgIGdsb2JhbFN0b3JhZ2UpLFxuICAgIGVycm9yUmVwb3J0ZXJTZXJ2aWNlOiBuZXcgRXJyb3JSZXBvcnRlcihcbiAgICAgIHtcbiAgICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5LFxuICAgICAgICBleHBlcmllbmNlS2V5OiBjb25maWcuZXhwZXJpZW5jZUtleSxcbiAgICAgICAgZXhwZXJpZW5jZVZlcnNpb246IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgcHJpbnRWZXJib3NlOiBjb25maWcuZGVidWcsXG4gICAgICAgIHNlbmRUb1NlcnZlcjogIWNvbmZpZy5zdXBwcmVzc0Vycm9yUmVwb3J0cyxcbiAgICAgICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudFxuICAgICAgfSxcbiAgICAgIGdsb2JhbFN0b3JhZ2UpXG4gIH07XG59XG5cbi8qKlxuICogQHJldHVybnMge1NlcnZpY2VzfVxuICovXG5mdW5jdGlvbiBnZXRNb2NrU2VydmljZXMgKCkge1xuICByZXR1cm4ge1xuICAgIHNlYXJjaFNlcnZpY2U6IG5ldyBNb2NrU2VhcmNoU2VydmljZSgpLFxuICAgIGF1dG9Db21wbGV0ZVNlcnZpY2U6IG5ldyBNb2NrQXV0b0NvbXBsZXRlU2VydmljZSgpLFxuICAgIHF1ZXN0aW9uQW5zd2VyU2VydmljZTogbmV3IE1vY2tRdWVzdGlvbkFuc3dlclNlcnZpY2UoKSxcbiAgICBlcnJvclJlcG9ydGVyU2VydmljZTogbmV3IENvbnNvbGVFcnJvclJlcG9ydGVyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgdG8gc2VuZCBhbmFseXRpY3MgZXZlbnRzXG4gKiB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIGJvdHRvbS4gRGVib3VuY2VzIHNjcm9sbCBldmVudHMgc29cbiAqIHRoZXkgYXJlIHByb2Nlc3NlZCBhZnRlciB0aGUgdXNlciBzdG9wcyBzY3JvbGxpbmdcbiAqL1xuZnVuY3Rpb24gaW5pdFNjcm9sbExpc3RlbmVyIChyZXBvcnRlcikge1xuICBjb25zdCBERUJPVU5DRV9USU1FID0gMTAwO1xuICBsZXQgdGltZW91dCA9IG51bGw7XG5cbiAgY29uc3Qgc2VuZEV2ZW50ID0gKCkgPT4ge1xuICAgIGlmICgod2luZG93LmlubmVySGVpZ2h0ICsgd2luZG93LnBhZ2VZT2Zmc2V0KSA+PSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQW5hbHl0aWNzRXZlbnQoJ1NDUk9MTF9UT19CT1RUT01fT0ZfUEFHRScpO1xuICAgICAgcmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChzZW5kRXZlbnQsIERFQk9VTkNFX1RJTUUpO1xuICB9KTtcbn1cblxuY29uc3QgQU5TV0VSUyA9IG5ldyBBbnN3ZXJzKCk7XG5leHBvcnQgZGVmYXVsdCBBTlNXRVJTO1xuIl0sIm5hbWVzIjpbImZldGNoIiwiUFJFX1NFQVJDSCIsIlNFQVJDSF9MT0FESU5HIiwiU0VBUkNIX0NPTVBMRVRFIiwiUmVzdWx0IiwiZGF0YSIsIl9yYXciLCJyYXciLCJfZm9ybWF0dGVkIiwiZm9ybWF0dGVkIiwiX2hpZ2hsaWdodGVkIiwiaGlnaGxpZ2h0ZWQiLCJvcmRpbmFsIiwidGl0bGUiLCJkZXRhaWxzIiwibGluayIsImlkIiwic3VidGl0bGUiLCJtb2RpZmllciIsImJpZ0RhdGUiLCJpbWFnZSIsImNhbGxzVG9BY3Rpb24iLCJjb2xsYXBzZWQiLCJ1bmRlZmluZWQiLCJIaWdobGlnaHRlZFZhbHVlIiwidmFsdWUiLCJzaG9ydFZhbHVlIiwibWF0Y2hlZFN1YnN0cmluZ3MiLCJnZXQiLCJfc29ydE1hdGNoZWRTdWJzdHJpbmdzIiwiYnVpbGRIaWdobGlnaHRlZFZhbHVlIiwiZ2V0SW52ZXJ0ZWQiLCJpbnZlcnRlZFN1YnN0cmluZ3MiLCJfZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzIiwibGVuZ3RoIiwidmFsIiwiaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzIiwiaGlnaGxpZ2h0ZWRWYWx1ZSIsIm5leHRTdGFydCIsImoiLCJzdGFydCIsIk51bWJlciIsIm9mZnNldCIsImVuZCIsInNsaWNlIiwiam9pbiIsInNvcnQiLCJhIiwiYiIsInZhbHVlTGVuZ3RoIiwiaSIsInN1YnN0cmluZyIsIm5leHRPZmZzZXQiLCJwdXNoIiwiQW5zd2Vyc0Jhc2VFcnJvciIsImVycm9yQ29kZSIsIm1lc3NhZ2UiLCJib3VuZGFyeSIsImNhdXNlZEJ5IiwiZXJyb3JNZXNzYWdlIiwicmVwb3J0ZWQiLCJmcm9tIiwic3RhY2siLCJ0b0pzb24iLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJzdHJpbmciLCJidWlsdGluRXJyb3IiLCJlcnJvciIsIkFuc3dlcnNCYXNpY0Vycm9yIiwiRXJyb3IiLCJBbnN3ZXJzQ29uZmlnRXJyb3IiLCJBbnN3ZXJzQ29tcG9uZW50RXJyb3IiLCJjb21wb25lbnQiLCJBbnN3ZXJzRW5kcG9pbnRFcnJvciIsIkFuc3dlcnNDb3JlRXJyb3IiLCJBbnN3ZXJzU3RvcmFnZUVycm9yIiwic3RvcmFnZUtleSIsIkFuc3dlcnNBbmFseXRpY3NFcnJvciIsImV2ZW50IiwiUmVzdWx0RmFjdG9yeSIsInJlc3VsdHNEYXRhIiwiZm9ybWF0dGVycyIsInZlcnRpY2FsSWQiLCJzb3VyY2UiLCJyZXN1bHRzIiwiZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSIsImZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lIiwiZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUiLCJmcm9tQWxnb2xpYVNlYXJjaEVuZ2luZSIsImhpZ2hsaWdodGVkRmllbGRzIiwiZnJvbUtub3dsZWRnZU1hbmFnZXIiLCJmcm9tR2VuZXJpYyIsImNvbXB1dGVGb3JtYXR0ZWREYXRhIiwiZW50aXR5UHJvZmlsZURhdGEiLCJoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhIiwiT2JqZWN0Iiwia2V5cyIsImZvcm1hdHRlZERhdGEiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImZpZWxkTmFtZSIsImZpZWxkVmFsIiwiaGlnaGxpZ2h0ZWRGaWVsZFZhbCIsImVudGl0eUZpZWxkVmFsdWUiLCJoaWdobGlnaHRlZEVudGl0eUZpZWxkVmFsdWUiLCJpc0RpcmVjdEFuc3dlciIsImNvbXB1dGVIaWdobGlnaHRlZERhdGEiLCJoaWdobGlnaHRlZERhdGEiLCJoaWdobGlnaHRlZEZpZWxkTmFtZSIsImhpZ2hsaWdodGVkRmllbGQiLCJoaWdobGlnaHRlZERhdGFWYWx1ZSIsImluZGV4IiwibmFtZSIsInRydW5jYXRlIiwiZGVzY3JpcHRpb24iLCJ3ZWJzaXRlIiwiZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEiLCJyZXN1bHREZXRhaWxzIiwiaHRtbFRpdGxlIiwicmVwbGFjZSIsImh0bWxTbmlwcGV0Iiwic25pcHBldCIsInVybCIsImh0bWxfdXJsIiwib2JqZWN0SUQiLCJzdHIiLCJsaW1pdCIsInRyYWlsaW5nIiwic2VwIiwid29yZHMiLCJzcGxpdCIsIm1heCIsInRydW5jYXRlZCIsIndvcmQiLCJTZWN0aW9uIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZXMiLCJ2ZXJ0aWNhbENvbmZpZ0lkIiwicmVzdWx0c0NvdW50IiwiZW5jb2RlZFN0YXRlIiwiYXBwbGllZFF1ZXJ5RmlsdGVycyIsIkFwcGxpZWRRdWVyeUZpbHRlciIsImZhY2V0cyIsIm1hcCIsInBhcnNlTWFwIiwidmVydGljYWxVUkwiLCJtYXBNYXJrZXJzIiwiY2VudGVyQ29vcmRpbmF0ZXMiLCJyZXN1bHQiLCJ5ZXh0RGlzcGxheUNvb3JkaW5hdGUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsIml0ZW0iLCJsYWJlbCIsIm1vZHVsZXMiLCJ1cmxzIiwic2VjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhcHBsaWVkUXVlcnlGaWx0ZXIiLCJrZXkiLCJkaXNwbGF5S2V5IiwiZGlzcGxheVZhbHVlIiwiZmlsdGVycyIsIlVuaXZlcnNhbFJlc3VsdHMiLCJxdWVyeUlkIiwicmVzcG9uc2UiLCJzZWFyY2hMb2FkaW5nIiwiRGlyZWN0QW5zd2VyIiwiZGlyZWN0QW5zd2VyIiwiYXNzaWduIiwiZnJlZXplIiwiYW5zd2VyIiwicmVsYXRlZEl0ZW0iLCJmaWVsZEFwaU5hbWUiLCJmaWVsZFZhbHVlcyIsIk5hdmlnYXRpb24iLCJ0YWJPcmRlciIsIm5hdiIsIlZlcnRpY2FsUmVzdWx0cyIsImFwcGVuZCIsIm1lcmdlZCIsImNvbmNhdCIsImFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCIsIlNwZWxsQ2hlY2siLCJxdWVyeSIsImNvcnJlY3RlZFF1ZXJ5IiwiY29ycmVjdGVkUXVlcnlEaXNwbGF5IiwidHlwZSIsInNob3VsZFNob3ciLCJvcmlnaW5hbFF1ZXJ5IiwiTkFWSUdBVElPTiIsIlVOSVZFUlNBTF9SRVNVTFRTIiwiVkVSVElDQUxfUkVTVUxUUyIsIkFVVE9DT01QTEVURSIsIkRJUkVDVF9BTlNXRVIiLCJGSUxURVIiLCJRVUVSWSIsIlFVRVJZX0lEIiwiRkFDRVRfRklMVEVSIiwiRFlOQU1JQ19GSUxURVJTIiwiUEFSQU1TIiwiR0VPTE9DQVRJT04iLCJJTlRFTlRTIiwiUVVFU1RJT05fU1VCTUlTU0lPTiIsIlNFQVJDSF9DT05GSUciLCJTRUFSQ0hfT0ZGU0VUIiwiU1BFTExfQ0hFQ0siLCJMT0NBVElPTl9CSUFTIiwiU0VTU0lPTlNfT1BUX0lOIiwiTkFWSUdBVElPTl9DT05GSUciLCJMT0NBTEUiLCJTT1JUX0JZUyIsIkR5bmFtaWNGaWx0ZXJzIiwiZHluYW1pY0ZpbHRlcnMiLCJmIiwiZmllbGRJZCIsIm9wdGlvbnMiLCJvIiwiY291bnRMYWJlbCIsInNlbGVjdGVkIiwiZmlsdGVyIiwiU2VhcmNoSW50ZW50cyIsImludGVudHMiLCJuZWFyTWUiLCJpbmNsdWRlcyIsIkxvY2F0aW9uQmlhcyIsImFjY3VyYWN5IiwibG9jYXRpb25EaXNwbGF5TmFtZSIsIlNlYXJjaERhdGFUcmFuc2Zvcm1lciIsInRyYW5zZm9ybSIsIlN0b3JhZ2VLZXlzIiwic2VhcmNoSW50ZW50cyIsInNwZWxsQ2hlY2siLCJsb2NhdGlvbkJpYXMiLCJ0cmFuc2Zvcm1WZXJ0aWNhbCIsIlF1ZXN0aW9uU3VibWlzc2lvbiIsInF1ZXN0aW9uIiwiZXJyb3JzIiwiZW1haWwiLCJwcml2YWN5UG9saWN5IiwicXVlc3Rpb25UZXh0IiwicXVlc3Rpb25EZXNjcmlwdGlvbiIsInF1ZXN0aW9uRXhwYW5kZWQiLCJleHBhbmRlZCIsInF1ZXN0aW9uU3VibWl0dGVkIiwic3VibWl0dGVkIiwiRmlsdGVyIiwiZnJvbVJlc3BvbnNlIiwicmVzcG9uc2VGaWx0ZXIiLCJwYXJzZSIsIm9yIiwiYW5kIiwiZ3JvdXAiLCJncm91cHMiLCJncm91cEZpbHRlcnMiLCJmaWVsZCIsImVxdWFsIiwiX2Zyb21NYXRjaGVyIiwibGVzc1RoYW4iLCJsZXNzVGhhbkVxdWFsIiwiZ3JlYXRlclRoYW4iLCJncmVhdGVyVGhhbkVxdWFsIiwiaW5jbHVzaXZlUmFuZ2UiLCJtaW4iLCJleGNsdXNpdmVSYW5nZSIsInBvc2l0aW9uIiwibGF0IiwibG5nIiwicmFkaXVzIiwibWF0Y2hlciIsIkNvcmUiLCJjb25maWciLCJfYXBpS2V5IiwiYXBpS2V5IiwiX2V4cGVyaWVuY2VLZXkiLCJleHBlcmllbmNlS2V5IiwiX2V4cGVyaWVuY2VWZXJzaW9uIiwiZXhwZXJpZW5jZVZlcnNpb24iLCJfbG9jYWxlIiwibG9jYWxlIiwiX2ZpZWxkRm9ybWF0dGVycyIsImZpZWxkRm9ybWF0dGVycyIsImdsb2JhbFN0b3JhZ2UiLCJwZXJzaXN0ZW50U3RvcmFnZSIsIl9zZWFyY2hlciIsInNlYXJjaFNlcnZpY2UiLCJfYXV0b0NvbXBsZXRlIiwiYXV0b0NvbXBsZXRlU2VydmljZSIsIl9xdWVzdGlvbkFuc3dlciIsInF1ZXN0aW9uQW5zd2VyU2VydmljZSIsInZlcnRpY2FsU2VhcmNoIiwidmVydGljYWxLZXkiLCJzZXQiLCJnZXRTdGF0ZSIsImdlb2xvY2F0aW9uIiwiaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJfaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQiLCJza2lwU3BlbGxDaGVjayIsInF1ZXJ5VHJpZ2dlciIsInNlc3Npb25UcmFja2luZ0VuYWJsZWQiLCJzb3J0QnlzIiwidGhlbiIsIm1lcmdlZFJlc3VsdHMiLCJ2ZXJ0aWNhbFBhZ2UiLCJhbGxGaWx0ZXJzIiwiZ2V0QWxsIiwidG90YWxGaWx0ZXIiLCJmYWNldEZpbHRlciIsImlucHV0Iiwic2VhcmNoIiwicXVlcnlTdHJpbmciLCJ1bml2ZXJzYWxTZWFyY2giLCJhdXRvQ29tcGxldGVVbml2ZXJzYWwiLCJuYW1lc3BhY2UiLCJxdWVyeVVuaXZlcnNhbCIsImF1dG9Db21wbGV0ZVZlcnRpY2FsIiwicXVlcnlWZXJ0aWNhbCIsImF1dG9Db21wbGV0ZUZpbHRlciIsInF1ZXJ5RmlsdGVyIiwic3VibWl0UXVlc3Rpb24iLCJzZXRTb3J0QnlzIiwic29ydEJ5T3B0aW9ucyIsIm9wdGlvbiIsImRpcmVjdGlvbiIsImNsZWFyU29ydEJ5cyIsInNldFF1ZXJ5Iiwic2V0UXVlcnlJZCIsInNldEZpbHRlciIsInNldEZhY2V0RmlsdGVyIiwiZW5hYmxlRHluYW1pY0ZpbHRlcnMiLCJvbiIsImV2dCIsIm1vZHVsZUlkIiwiY2IiLCJkb2N1bWVudCIsIndpbmRvdyIsIkRPTSIsInNldHVwIiwiZCIsInAiLCJjcmVhdGUiLCJodG1sIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsImZyYWciLCJjcmVhdGVSYW5nZSIsImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCIsImFwcGVuZENoaWxkIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keSIsInBhcmVudCIsInNlbGVjdG9yIiwiSFRNTEVsZW1lbnQiLCJXaW5kb3ciLCJIVE1MRG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlBbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwib25SZWFkeSIsInJlYWR5U3RhdGUiLCJjcmVhdGVFbCIsImVsIiwib3B0c19kYXRhIiwibm9kZSIsInByb3BzIiwiYWRkQ2xhc3MiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJjbGFzc05hbWUiLCJjbGFzc2VzIiwibGVuIiwiY2xhc3NMaXN0IiwiYWRkIiwiZW1wdHkiLCJpbm5lckhUTUwiLCJjc3MiLCJzdHlsZXMiLCJwcm9wIiwic3R5bGUiLCJhdHRyIiwic2V0QXR0cmlidXRlIiwiYXR0cmlidXRlcyIsImF0dHJzIiwidHJpZ2dlciIsInNldHRpbmdzIiwiZSIsIkV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWxlZ2F0ZSIsImN0eHQiLCJ0YXJnZXQiLCJpc0VxdWFsTm9kZSIsIm1hdGNoZXMiLCJwYXJlbnROb2RlIiwiU2VhcmNoUGFyYW1zIiwiX3BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInBhcmFtcyIsImluZGV4T2YiLCJlbmNvZGVkUGFyYW1zIiwia2V5VmFsIiwiZGVjb2RlIiwiU3RyaW5nIiwiaGFzIiwiZW5jb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJSZW5kZXJlciIsInJlbmRlciIsInRlbXBsYXRlIiwicmVnaXN0ZXJIZWxwZXIiLCJjb21waWxlIiwiSGFuZGxlYmFyc1JlbmRlcmVyIiwidGVtcGxhdGVzIiwib3B0cyIsIl9oYW5kbGViYXJzIiwiX2hiIiwiX3RlbXBsYXRlcyIsImluaXQiLCJfcmVnaXN0ZXJDdXN0b21IZWxwZXJzIiwidGVtcGxhdGVOYW1lIiwiYXJnMSIsImFyZzIiLCJmbiIsImludmVyc2UiLCJwaG9uZU51bWJlclN0cmluZyIsImNsZWFuZWQiLCJpbnRsQ29kZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJyb290IiwidiIsIlJlbmRlcmVycyIsIlNPWSIsIkhhbmRsZWJhcnMiLCJMSUJfVkVSU0lPTiIsIlBST0RVQ1RJT04iLCJTQU5EQk9YIiwiQ09NUElMRURfVEVNUExBVEVTX1VSTCIsIlRlbXBsYXRlTG9hZGVyIiwic2V0SW5zdGFuY2UiLCJnZXRJbnN0YW5jZSIsIl90ZW1wbGF0ZVVybCIsInRlbXBsYXRlVXJsIiwiX29uTG9hZGVkIiwiX2luaXQiLCJpbnN0YW5jZSIsImZldGNoVGVtcGxhdGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzY3JpcHQiLCJvbmxvYWQiLCJvbmVycm9yIiwiYXN5bmMiLCJzcmMiLCJjb25zb2xlIiwibG9nIiwicmVnaXN0ZXIiLCJvbkxvYWRlZCIsImdldFRlbXBsYXRlcyIsIkV2ZW50RW1pdHRlciIsIl9saXN0ZW5lcnMiLCJlbWl0IiwibGlzdGVuZXJzIiwia2VlcCIsIlN0YXRlIiwiX3N0YXRlIiwib3B0VmFsIiwiX3NldCIsInVwZGF0ZSIsIm9wdFByb3AiLCJhc0pTT04iLCJNZXRob2RzIiwiR0VUIiwiUE9TVCIsIlBVVCIsIkRFTEVURSIsIkh0dHBSZXF1ZXN0ZXIiLCJyZXF1ZXN0IiwiZW5jb2RlUGFyYW1zIiwicG9zdCIsInVybFBhcmFtcyIsImpzb25Cb2R5IiwicmVxdWVzdENvbmZpZyIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwicmVxQXJncyIsImJlYWNvbiIsIm5hdmlnYXRvciIsInNlbmRCZWFjb24iLCJoYXNQYXJhbSIsInNlYXJjaFF1ZXJ5IiwiZ2V0TGl2ZUFwaVVybCIsImVudiIsImdldEtub3dsZWRnZUFwaVVybCIsImdldEFuYWx5dGljc1VybCIsImNvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQiLCJBcGlSZXF1ZXN0IiwiX3JlcXVlc3RlciIsIl9lbnZpcm9ubWVudCIsImVudmlyb25tZW50IiwiX2Jhc2VVcmwiLCJiYXNlVXJsIiwiX2VuZHBvaW50IiwiZW5kcG9pbnQiLCJfdmVyc2lvbiIsInZlcnNpb24iLCJfZ2xvYmFsU3RvcmFnZSIsImJhc2VQYXJhbXMiLCJzYW5pdGl6ZVBhcmFtcyIsImxvY2F0aW9uIiwiU2VhcmNoQXBpIiwianNvbiIsIkFuYWx5dGljc0V2ZW50IiwiZXZlbnRUeXBlIiwidG9VcHBlckNhc2UiLCJhZGRPcHRpb25zIiwidG9BcGlFdmVudCIsIkFuYWx5dGljc1JlcG9ydGVyIiwiY29yZSIsImJ1c2luZXNzSWQiLCJnbG9iYWxPcHRpb25zIiwiX2J1c2luZXNzSWQiLCJfZ2xvYmFsT3B0aW9ucyIsIl9jb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwicmVwb3J0IiwiY29va2llRGF0YSIsInl0YWciLCJzZXRDb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIiwiaXNFbmFibGVkIiwiTm9vcEFuYWx5dGljc1JlcG9ydGVyIiwiTW9kdWxlRGF0YSIsIl9pZCIsIl9oaXN0b3J5IiwiX2RhdGEiLCJjYXB0dXJlUHJldmlvdXMiLCJzaGlmdCIsInVuZG8iLCJwcmV2aW91cyIsIl9wcmV2aW91cyIsInBvcCIsIkdsb2JhbFN0b3JhZ2UiLCJfbW9kdWxlRGF0YUNvbnRhaW5lciIsIl9mdXR1cmVMaXN0ZW5lcnMiLCJfaW5pdERhdGFDb250YWluZXIiLCJzZXRBbGwiLCJfYXBwbHlGdXR1cmVMaXN0ZW5lcnMiLCJkYXRhS2V5Iiwic3RhcnRzV2l0aCIsIm1vZHVsZURhdGEiLCJmdXR1cmVzIiwiZnV0dXJlIiwiQ29tcG9uZW50Iiwic3lzdGVtQ29uZmlnIiwiY29uc3RydWN0b3IiLCJfY29uZmlnIiwiX3R5cGUiLCJfcGFyZW50Q29udGFpbmVyIiwicGFyZW50Q29udGFpbmVyIiwiX2NoaWxkcmVuIiwic3RhdGUiLCJjb21wb25lbnRNYW5hZ2VyIiwiYW5hbHl0aWNzUmVwb3J0ZXIiLCJfYW5hbHl0aWNzT3B0aW9ucyIsImFuYWx5dGljc09wdGlvbnMiLCJfY29udGFpbmVyIiwiX2NsYXNzTmFtZSIsIl9yZW5kZXIiLCJfcmVuZGVyZXIiLCJyZW5kZXJlciIsIl90ZW1wbGF0ZSIsIl90ZW1wbGF0ZU5hbWUiLCJkZWZhdWx0VGVtcGxhdGVOYW1lIiwiX2lzTW91bnRlZCIsInRyYW5zZm9ybURhdGEiLCJvbkNyZWF0ZSIsIm9uQ3JlYXRlT3ZlcnJpZGUiLCJiaW5kIiwib25Nb3VudCIsIm9uTW91bnRPdmVycmlkZSIsIm9uVXBkYXRlIiwib25VcGRhdGVPdmVycmlkZSIsInVzZXJPbkNyZWF0ZSIsInVzZXJPbk1vdW50IiwidXNlck9uVXBkYXRlIiwic2V0U3RhdGUiLCJ1bk1vdW50IiwibW91bnQiLCJuZXdTdGF0ZSIsImhhc1N0YXRlIiwiYWRkQ2hpbGQiLCJjaGlsZENvbXBvbmVudCIsIl9wYXJlbnRPcHRzIiwicmVtb3ZlIiwiYyIsInNldFJlbmRlciIsInNldFJlbmRlcmVyIiwic2V0VGVtcGxhdGUiLCJjaGlsZCIsIm9uVW5Nb3VudCIsImJlZm9yZU1vdW50IiwiZG9tQ29tcG9uZW50cyIsIl9jcmVhdGVTdWJjb21wb25lbnQiLCJkb21Ib29rcyIsIl9jcmVhdGVBbmFseXRpY3NIb29rIiwiYmVmb3JlUmVuZGVyIiwiYWZ0ZXJSZW5kZXIiLCJkb21Db21wb25lbnQiLCJkYXRhc2V0IiwiaXNDb21wb25lbnRNb3VudGVkIiwiY2hpbGREYXRhIiwicmV2ZXJzZSIsImlzQW5hbHl0aWNzQXR0YWNoZWQiLCJldmVudHR5cGUiLCJldmVudGxhYmVsIiwiZXZlbnRvcHRpb25zIiwib25EZXN0cm95IiwiRXJyb3JSZXBvcnRlciIsInByaW50VmVyYm9zZSIsInNlbmRUb1NlcnZlciIsImVyciIsInByaW50RXJyb3IiLCJDb25zb2xlRXJyb3JSZXBvcnRlciIsIlBlcnNpc3RlbnRTdG9yYWdlIiwiX2hpc3RvcnlUaW1lciIsIl91cGRhdGVMaXN0ZW5lciIsInVwZGF0ZUxpc3RlbmVyIiwiX3Jlc2V0TGlzdGVuZXIiLCJyZXNldExpc3RlbmVyIiwib25wb3BzdGF0ZSIsIl9jYWxsTGlzdGVuZXIiLCJyZXBsYWNlSGlzdG9yeSIsIm5ld0RhdGEiLCJfdXBkYXRlSGlzdG9yeSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwicHVzaFN0YXRlIiwibGlzdGVuZXIiLCJhbGxQYXJhbXMiLCJTZWFyY2hDb25maWciLCJkZWZhdWx0SW5pdGlhbFNlYXJjaCIsInZhbGlkYXRlIiwiQXV0b0NvbXBsZXRlRGF0YSIsImlucHV0SW50ZW50cyIsInMiLCJyIiwiQXV0b0NvbXBsZXRlUmVzdWx0IiwicXVlcnlJbnRlbnRzIiwiQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIiwiY2xlYW4iLCJ1bml2ZXJzYWwiLCJ2ZXJ0aWNhbCIsIkF1dG9Db21wbGV0ZUFwaSIsInNlYXJjaFBhcmFtZXRlcnMiLCJ1bml2ZXJzYWxPcHRpb25zIiwidmVydGljYWxPcHRpb25zIiwiTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2UiLCJlbXB0eVJlc3VsdHMiLCJmaWx0ZXJPcHRpb25zIiwib3B0IiwibG93ZXJjYXNlIiwidG9Mb3dlckNhc2UiLCJyYW5kb21TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwiUXVlc3Rpb25BbnN3ZXJBcGkiLCJlbnRpdHlJZCIsInNpdGUiLCJxdWVzdGlvbkxhbmd1YWdlIiwibW9kZSIsImhlYWRlcnMiLCJNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlIiwiQVJCSVRSQVJZX0JVU0lORVNTX0lEIiwiTW9ja1NlYXJjaFNlcnZpY2UiLCJfZ2V0TW9ja0RhdGFKc29uIiwicmVzcCIsInRleHQiLCJ1c2VNb2NrRGF0YSIsImRlbGF5ZWRSZXNwb25zZSIsImNvbnN0cnVjdFZlcnRpY2FsUmVzcG9uc2UiLCJzZWN0aW9uIiwiZmluZCIsInZlcnRpY2FsTW9kdWxlIiwiZmxvb3IiLCJtb2RpZnlSZXN1bHRzIiwiZ2V0UmVzdWx0c0ZpbHRlcmVyIiwiY29uc3RydWN0VW5pdmVyc2FsUmVzcG9uc2UiLCJjb25zdW1lciIsIm1vZGlmeUZuIiwiZmlsbFNlY3Rpb25GaWVsZHMiLCJtZXRhIiwidXVpZCIsInV1aWRWNCIsImZhaWxlZFZlcnRpY2FscyIsInF1ZXJ5RHVyYXRpb25NaWxsaXMiLCJyYW5kb21JbnQiLCJSRVNJWkVfREVCT1VOQ0UiLCJNT0JJTEVfQlJFQUtQT0lOVCIsIk1PQklMRV9PVkVSRkxPV19CRUhBVklPUl9PUFRJT04iLCJDT0xMQVBTRSIsIklOTkVSU0NST0xMIiwiVGFiIiwiY29uZmlnSWQiLCJpc0ZpcnN0IiwiaXNBY3RpdmUiLCJ0YWJzQ29uZmlnIiwidGFicyIsInRhYiIsIk5hdmlnYXRpb25Db21wb25lbnQiLCJvdmVyZmxvd0xhYmVsIiwib3ZlcmZsb3dJY29uIiwiX3RhYnNDb25maWciLCJfdGFicyIsIl90YWJPcmRlciIsImdldERlZmF1bHRUYWJPcmRlciIsImdldFVybFBhcmFtcyIsIl9uYXZCcmVha3BvaW50cyIsIl9tb2JpbGVPdmVyZmxvd0JlaGF2aW9yIiwibW9iaWxlT3ZlcmZsb3dCZWhhdmlvciIsIl9hcmlhTGFiZWwiLCJhcmlhTGFiZWwiLCJjaGVja091dHNpZGVDbGljayIsImNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvciIsInNob3VsZENvbGxhcHNlIiwiYmluZE92ZXJmbG93SGFuZGxlcnMiLCJyZWZpdE5hdiIsInRvZ2dsZU1vcmVEcm9wZG93biIsInVuYmluZE92ZXJmbG93SGFuZGxlcnMiLCJtb3JlQnV0dG9uIiwibWFpbkxpbmtzIiwiY29sbGFwc2VkTGlua3MiLCJuYXZXaWR0aCIsImNvbnRhaW5zIiwib2Zmc2V0V2lkdGgiLCJudW1CcmVha3BvaW50cyIsIm1haW5MaW5rc1dpZHRoIiwiY2hpbGRyZW4iLCJsYXN0TGluayIsInByZXBlbmQiLCJmaXJzdExpbmsiLCJjbG9zZU1vcmVEcm9wZG93biIsIm9wZW5Nb3JlRHJvcGRvd24iLCJ0b2dnbGUiLCJjbG9zZXN0IiwiX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyIiwibWVyZ2VUYWJPcmRlciIsImdlbmVyYXRlVGFiVXJsIiwic2hvd0NvbGxhcHNlIiwidW5zaGlmdCIsIm90aGVyVGFiT3JkZXIiLCJ0YWJDb25maWciLCJTZWFyY2hDb21wb25lbnQiLCJfdmVydGljYWxLZXkiLCJfZm9ybUVsIiwiZm9ybVNlbGVjdG9yIiwiX2lucHV0RWwiLCJpbnB1dEVsIiwibGFiZWxUZXh0Iiwic3VibWl0VGV4dCIsImNsZWFyVGV4dCIsInN1Ym1pdEljb24iLCJwcm9tcHRIZWFkZXIiLCJhdXRvRm9jdXMiLCJjbGVhckJ1dHRvbiIsImF1dG9jb21wbGV0ZU9uTG9hZCIsInJlZGlyZWN0VXJsIiwiX2lzVHdpbiIsImlzVHdpbiIsInEiLCJkZWJvdW5jZWRTZWFyY2giLCJfc2VhcmNoQ29vbGRvd24iLCJzZWFyY2hDb29sZG93biIsIl9wcm9tcHRGb3JMb2NhdGlvbiIsInByb21wdEZvckxvY2F0aW9uIiwiQm9vbGVhbiIsIl9zaG93Q2xlYXJCdXR0b24iLCJfYWxsb3dFbXB0eVNlYXJjaCIsImFsbG93RW1wdHlTZWFyY2giLCJfYXV0b0NvbXBsZXRlTmFtZSIsImZvY3VzSW5wdXRFbGVtZW50IiwiaW5pdFNlYXJjaCIsImluaXRBdXRvQ29tcGxldGUiLCJpbml0Q2xlYXJCdXR0b24iLCJfYXV0b2NvbXBsZXRlIiwiYnV0dG9uIiwiZm9ybSIsInByZXZlbnREZWZhdWx0IiwiaHJlZiIsImJsdXIiLCJpbnB1dFNlbGVjdG9yIiwib25TdWJtaXQiLCJvbkNoYW5nZSIsIl90aHJvdHRsZWQiLCJmZXRjaFF1ZXJ5SW50ZW50cyIsInF1ZXJ5SGFzTmVhck1lSW50ZW50IiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwiY29vcmRzIiwiZ2V0QWN0aXZlQ29tcG9uZW50IiwiYXV0b2NvbXBsZXRlRGF0YSIsImF1dG9jb21wbGV0ZVJlcXVlc3QiLCJmbGF0TWFwIiwibWF0Y2hpbmdSZXN1bHQiLCJldmVudE9wdGlvbnMiLCJzaG93Q2xlYXJCdXR0b24iLCJmb2N1cyIsImJ1aWxkU2VhcmNoUGFyYW1ldGVycyIsInNlYXJjaFBhcmFtZXRlckNvbmZpZ3MiLCJzZWN0aW9uZWQiLCJmaWVsZHMiLCJidWlsZEZpZWxkcyIsImZpZWxkQ29uZmlncyIsImZjIiwiZmV0Y2hFbnRpdGllcyIsIkZpbHRlclNlYXJjaENvbXBvbmVudCIsIl9zdG9yZU9uQ2hhbmdlIiwic3RvcmVPbkNoYW5nZSIsInNlYXJjaFRleHQiLCJpc0ZpbHRlclNlYXJjaCIsIm9yaWdpbmFsRmlsdGVyIiwiS2V5cyIsIkJBQ0tTUEFDRSIsIlRBQiIsIkVOVEVSIiwiU0hJRlQiLCJDVFJMIiwiQUxUIiwiRVNDQVBFIiwiTEVGVCIsIlJJR0hUIiwiVVAiLCJET1dOIiwiTEVGVF9PU19LRVkiLCJSSUdIVF9PU19LRVkiLCJTRUxFQ1RfS0VZIiwiQXV0b0NvbXBsZXRlQ29tcG9uZW50Iiwic3lzdGVtT3B0cyIsIl9hdXRvY29tcGxldGVFbHMiLCJhdXRvQ29tcGxldGVFbHMiLCJfb3JpZ2luYWxRdWVyeSIsIl9zZWN0aW9uSW5kZXgiLCJfcmVzdWx0SW5kZXgiLCJfYXV0b0ZvY3VzIiwiX29uU3VibWl0IiwiX29uQ2hhbmdlIiwiX3NlYXJjaFBhcmFtZXRlcnMiLCJpc1F1ZXJ5SW5wdXRGb2N1c2VkIiwiaGFzUmVzdWx0cyIsInNlY3Rpb25JbmRleCIsInJlc3VsdEluZGV4IiwiYWN0aXZlRWxlbWVudCIsInVwZGF0ZVN0YXRlIiwicXVlcnlJbnB1dCIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0Iiwic3BlbGxjaGVjayIsImNsb3NlIiwicmVzZXQiLCJhdXRvQ29tcGxldGUiLCJoYW5kbGVOYXZpZ2F0ZVJlc3VsdHMiLCJrZXlDb2RlIiwiaGFuZGxlU3VibWl0UmVzdWx0IiwidXBkYXRlUXVlcnkiLCJoYW5kbGVUeXBpbmciLCJvcHRWYWx1ZSIsInF1ZXJ5RWwiLCJpZ25vcmVkS2V5cyIsIlNwZWxsQ2hlY2tDb21wb25lbnQiLCJjb3JyZWN0ZWRRdWVyeVVybCIsIl9idWlsZFJlZGlyZWN0UXVlcnlVcmwiLCJoZWxwVGV4dCIsIl9nZXRIZWxwVGV4dCIsIkxvY2F0aW9uQmlhc0NvbXBvbmVudCIsIl91cGRhdGVMb2NhdGlvbkVsIiwidXBkYXRlTG9jYXRpb25FbCIsIl9sb2NhdGlvbkRpc3BsYXlOYW1lIiwiX2FjY3VyYWN5IiwiX2FsbG93VXBkYXRlIiwiX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQiLCJfZG9TZWFyY2giLCJjb2RlIiwiX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSIsIl9nZXRMb2NhdGlvbkRpc3BsYXlOYW1lIiwiYWNjdXJhY3lUZXh0IiwiX2dldEFjY3VyYWN5SGVscFRleHQiLCJpc1ByZWNpc2VMb2NhdGlvbiIsImlzVW5rbm93bkxvY2F0aW9uIiwiYWxsb3dVcGRhdGUiLCJwZXJtaXNzaW9ucyIsIkZhY2V0IiwiZnJvbUZpbHRlcnMiLCJhdmFpbGFibGVGaWVsZElkcyIsImZsYXRGaWx0ZXJzIiwiJG9yIiwiRmlsdGVyQm94Q29uZmlnIiwic2hvd0NvdW50Iiwic2VhcmNoT25DaGFuZ2UiLCJyZXNldEZpbHRlciIsInJlc2V0RmFjZXQiLCJyZXNldEZpbHRlckxhYmVsIiwicmVzZXRGYWNldExhYmVsIiwicmVzZXRGaWx0ZXJzIiwicmVzZXRGYWNldHMiLCJyZXNldEZpbHRlcnNMYWJlbCIsInJlc2V0RmFjZXRzTGFiZWwiLCJzaG93TW9yZUxpbWl0Iiwic2hvd01vcmVMYWJlbCIsInNob3dMZXNzTGFiZWwiLCJzaG93TW9yZSIsImV4cGFuZCIsInNob3dOdW1iZXJBcHBsaWVkIiwiYXBwbHlMYWJlbCIsImFwcGx5QnV0dG9uU2VsZWN0b3IiLCJmaWx0ZXJDb25maWdzIiwiaXNEeW5hbWljIiwiRmlsdGVyQm94Q29tcG9uZW50IiwiX2ZpbHRlckNvbXBvbmVudHMiLCJfZmlsdGVycyIsInNob3dSZXNldCIsInJlc2V0TGFiZWwiLCJzaG93QXBwbHlCdXR0b24iLCJzaG93RXhwYW5kIiwib25GaWx0ZXJDaGFuZ2UiLCJnZXRGaWx0ZXIiLCJfc2F2ZUZpbHRlcnNUb1N0b3JhZ2UiLCJfc2VhcmNoIiwiY2xlYXJPcHRpb25zIiwidmFsaWRGaWx0ZXJzIiwiY29tYmluZWRGaWx0ZXIiLCJTVVBQT1JURURfQ09OVFJPTFMiLCJGaWx0ZXJPcHRpb25zQ29uZmlnIiwiY29udHJvbCIsIm9wdGlvblNlbGVjdG9yIiwicHJldmlvdXNPcHRpb25zIiwic2VsZWN0ZWRPcHRpb25zIiwic2V0RGVmYXVsdFNlbGVjdGVkVmFsdWVzIiwiZ2V0U2VsZWN0ZWRDb3VudCIsInJlZHVjZSIsIm51bVNlbGVjdGVkIiwiRmlsdGVyT3B0aW9uc0NvbXBvbmVudCIsInNlbGVjdGVkQ291bnQiLCJhbGxTaG93biIsImlzU2luZ2xlT3B0aW9uIiwiX3VwZGF0ZU9wdGlvbiIsInBhcnNlSW50IiwiY2hlY2tlZCIsImxlZ2VuZCIsImNsaWNrIiwidXBkYXRlTGlzdGVuZXJzIiwiX2J1aWxkRmlsdGVyIiwiY2xlYXIiLCJlbGVtZW50cyIsIl9hcHBseUZpbHRlciIsIlJhbmdlRmlsdGVyQ29tcG9uZW50IiwiX2ZpZWxkIiwibWluVmFsIiwibWF4VmFsIiwiX3JhbmdlIiwiaW5pdGlhbE1pbiIsImluaXRpYWxNYXgiLCJfdGl0bGUiLCJfbWluTGFiZWwiLCJtaW5MYWJlbCIsIl9tYXhMYWJlbCIsIm1heExhYmVsIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIl91cGRhdGVSYW5nZSIsInNldE1pbiIsInNldE1heCIsIkRhdGVSYW5nZUZpbHRlckNvbXBvbmVudCIsIl9pc0V4Y2x1c2l2ZSIsImlzRXhjbHVzaXZlIiwidG9kYXkiLCJEYXRlIiwidG9kYXlTdHJpbmciLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJnZXREYXRlIiwibWluRGF0ZSIsIm1heERhdGUiLCJfZGF0ZSIsImRhdGVNaW4iLCJkYXRlTWF4IiwiZGF0ZSIsIkZhY2V0c0NvbmZpZyIsImZpZWxkQ29udHJvbHMiLCJGYWNldHNDb21wb25lbnQiLCJfYXBwbHlCdXR0b25TZWxlY3RvciIsIl9maWx0ZXJib3giLCJNRVRFUlNfUEVSX01JTEUiLCJERUZBVUxUX0NPTkZJRyIsImdlb0J1dHRvbkljb24iLCJnZW9CdXR0b25UZXh0IiwiZW5hYmxlZFRleHQiLCJsb2FkaW5nVGV4dCIsImVycm9yVGV4dCIsImJ1dHRvblNlbGVjdG9yIiwiR2VvTG9jYXRpb25Db21wb25lbnQiLCJwbGFjZWhvbGRlciIsIl9lbmFibGVkIiwiZ2VvTG9hZGluZyIsImdlb0Vycm9yIiwiZ2VvRW5hYmxlZCIsImdlb1ZhbHVlIiwiZ2VvUGxhY2Vob2xkZXIiLCJfaW5pdEF1dG9Db21wbGV0ZSIsIl90b2dnbGVHZW9GaWx0ZXIiLCJfc2F2ZURhdGFUb1N0b3JhZ2UiLCJTb3J0T3B0aW9uc0NvbXBvbmVudCIsImFzc2lnbkRlZmF1bHRzIiwic2VsZWN0ZWRPcHRpb25JbmRleCIsImlzU2VsZWN0ZWQiLCJoaWRlRXhjZXNzT3B0aW9ucyIsImhhbmRsZU9wdGlvblNlbGVjdGlvbiIsIl9zb3J0UmVzdWx0cyIsIm9wdGlvbkluZGV4IiwiX3VwZGF0ZVNlbGVjdGVkT3B0aW9uIiwidXBkYXRlZENvbmZpZyIsImRlZmF1bHRTb3J0TGFiZWwiLCJPUFRJT05fVFlQRVMiLCJuZXdPcHRpb24iLCJpc0ZpZWxkIiwiRXZlbnRUeXBlcyIsIlRIVU1CU19VUCIsIlRIVU1CU19ET1dOIiwiRGlyZWN0QW5zd2VyQ29tcG9uZW50IiwiZm9ybUVsIiwiX3RodW1ic1VwU2VsZWN0b3IiLCJ0aHVtYnNVcFNlbGVjdG9yIiwiX3RodW1ic0Rvd25TZWxlY3RvciIsInRodW1ic0Rvd25TZWxlY3RvciIsIl92aWV3RGV0YWlsc1RleHQiLCJ2aWV3RGV0YWlsc1RleHQiLCJjaGVja2VkVmFsdWUiLCJyZXBvcnRRdWFsaXR5Iiwic2VhcmNoZXIiLCJjdGFMYWJlbCIsImlzR29vZCIsIlJlc3VsdHNJdGVtQ29tcG9uZW50IiwiX3ZlcnRpY2FsQ29uZmlnSWQiLCJfaXNVbml2ZXJzYWwiLCJpc1VuaXZlcnNhbCIsIkxvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQiLCJFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50IiwiUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQiLCJNYXBQcm92aWRlciIsIl96b29tIiwiem9vbSIsIl9kZWZhdWx0UG9zaXRpb24iLCJkZWZhdWx0UG9zaXRpb24iLCJfc2hvd0VtcHR5TWFwIiwic2hvd0VtcHR5TWFwIiwiX21hcCIsIl9pc0xvYWRlZCIsIl9vblBpbkNsaWNrIiwib25QaW5DbGljayIsIl9waW5Db25maWciLCJwaW4iLCJERUZBVUxUX1BJTl9DT05GSUciLCJfY29sbGFwc2VQaW5zIiwiY29sbGFwc2VQaW5zIiwiaXNMb2FkZWQiLCJsb2FkSlMiLCJtYXBEYXRhIiwiX2NvbGxhcHNlTWFya2VycyIsIm1hcmtlcnMiLCJsb2NhdGlvblRvSXRlbSIsIm0iLCJjb2xsYXBzZWRNYXJrZXJzIiwiY29sbGFwc2VkTWFya2VyIiwiaWNvbiIsImFuY2hvciIsInN2ZyIsInNjYWxlZFNpemUiLCJsYWJlbFR5cGUiLCJHb29nbGVNYXBQcm92aWRlciIsIl96b29tT2Zmc2V0IiwiX2NsaWVudElkIiwiY2xpZW50SWQiLCJfc2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiaGFzVmFsaWRDbGllbnRDcmVkZW50aWFscyIsIm9uTG9hZCIsImdlbmVyYXRlQ3JlZGVudGlhbHMiLCJnb29nbGUiLCJtYXBzIiwiTWFwIiwiY2VudGVyIiwiZ2V0Q2VudGVyTWFya2VyIiwiZ29vZ2xlTWFwTWFya2VyQ29uZmlncyIsIkdvb2dsZU1hcE1hcmtlckNvbmZpZyIsImJvdW5kcyIsIkxhdExuZ0JvdW5kcyIsIm1hcmtlciIsIk1hcmtlciIsImFkZExpc3RlbmVyIiwiZXh0ZW5kIiwiZml0Qm91bmRzIiwibWFwQ2VudGVyIiwic2VyaWFsaXplIiwic2VyaWFsaXplZE1hcmtlcnMiLCJwaW5Db25maWciLCJwaW5Db25maWdPYmoiLCJQb2ludCIsIngiLCJ5IiwiU2l6ZSIsInciLCJoIiwiTWFwQm94TWFwUHJvdmlkZXIiLCJtYXBib3hnbCIsImFjY2Vzc1Rva2VuIiwicmVsIiwibWFwYm94TWFwTWFya2VyQ29uZmlncyIsIk1hcEJveE1hcmtlckNvbmZpZyIsIkxuZ0xhdEJvdW5kcyIsIndyYXBwZXIiLCJMbmdMYXQiLCJzZXRMbmdMYXQiLCJnZXRMbmdMYXQiLCJhZGRUbyIsImdldEVsZW1lbnQiLCJwYWRkaW5nIiwic3RhdGljTWFwUGluIiwiUHJvdmlkZXJUeXBlcyIsIk1hcENvbXBvbmVudCIsIl9tYXBQcm92aWRlciIsIm1hcFByb3ZpZGVyIiwiZ2V0UHJvdmlkZXJJbnN0YW5jZSIsIlJlc3VsdFR5cGUiLCJFVkVOVCIsIkxPQ0FUSU9OIiwiUEVPUExFIiwiUmVzdWx0c0NvbXBvbmVudCIsIl9pdGVtQ29uZmlnIiwiZ2xvYmFsIiwicmVuZGVySXRlbSIsIml0ZW1UZW1wbGF0ZSIsImNvbmZpZ3VyZUl0ZW0iLCJfdW5pdmVyc2FsVXJsIiwidW5pdmVyc2FsVXJsIiwiaXNQcmVTZWFyY2giLCJpc1NlYXJjaExvYWRpbmciLCJpc1NlYXJjaENvbXBsZXRlIiwiaW5jbHVkZU1hcCIsIm1hcENvbmZpZyIsInNob3dOb1Jlc3VsdHMiLCJzZXRJdGVtUmVuZGVyIiwic2V0SXRlbVRlbXBsYXRlIiwiY2xhenoiLCJnZXRJdGVtQ29tcG9uZW50IiwiY29tcCIsIm5ld09wdHMiLCJnbG9iYWxDb25maWciLCJpdGVtQ29uZmlnIiwiaGFzR2xvYmFsUmVuZGVyIiwiaGFzR2xvYmFsVGVtcGxhdGUiLCJBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IiwiX3NlbGVjdG9yQmFzZSIsInNlbGVjdG9yQmFzZSIsImNvbGxhcHNlZENsYXNzIiwic2VsZkVsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJhY2NvcmRpb25FbHMiLCJhY2NvcmRpb25FbCIsInRvZ2dsZUVsIiwidG9nZ2xlU2VsZWN0b3IiLCJjb250ZW50RWwiLCJib2R5U2VsZWN0b3IiLCJjaGFuZ2VIZWlnaHQiLCJoYW5kbGVDbGljayIsIndyYXBwZXJFbCIsImlzQ29sbGFwc2VkIiwidGFyZ2V0RWwiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJidWlsZFNlbGVjdG9yIiwiVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCIsIl9saW1pdCIsImNoaWxkT3B0cyIsImdldENoaWxkQ29uZmlnIiwidXNlQWNjb3JkaW9uIiwiZGVmYXVsdENvbmZpZyIsIlBhZ2luYXRpb25Db21wb25lbnQiLCJfZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCIsInNob3dGaXJzdCIsIl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJzaG93TGFzdCIsIl9wYWdlTGFiZWwiLCJwYWdlTGFiZWwiLCJzaG93Q29udHJvbHMiLCJwcmV2aW91c1BhZ2VCdXR0b24iLCJuZXh0UGFnZUJ1dHRvbiIsIm1heFBhZ2UiLCJ0cnVuYyIsInVwZGF0ZVBhZ2UiLCJmaXJzdFBhZ2VCdXR0b24iLCJsYXN0UGFnZUJ1dHRvbiIsInNjcm9sbFRvVG9wIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwicGFnZU51bWJlciIsImlzTW9yZVJlc3VsdHMiLCJmaXJzdFBhZ2VCdXR0b25FbmFibGVkIiwibGFzdFBhZ2VCdXR0b25FbmFibGVkIiwic2hvd0ZpcnN0UGFnZUJ1dHRvbiIsInNob3dQcmV2aW91c1BhZ2VCdXR0b24iLCJzaG93TmV4dFBhZ2VCdXR0b24iLCJzaG93TGFzdFBhZ2VCdXR0b24iLCJRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQiLCJ2YWxpZGF0ZUNvbmZpZyIsIm9uUmVzdWx0c1VwZGF0ZSIsInRyaWdnZXJFbCIsImJpbmRGb3JtVG9nZ2xlIiwiYmluZEZvcm1Gb2N1cyIsImJpbmRGb3JtU3VibWl0IiwiZ2V0QW5hbHl0aWNzRXZlbnQiLCJmb3JtRGF0YSIsImlucHV0RmllbGRzIiwib2JqIiwiY2hlY2tWYWxpZGl0eSIsInZhbGlkaXR5IiwidmFsdWVNaXNzaW5nIiwiZW1haWxGb3JtYXRFcnJvclRleHQiLCJwcml2YWN5UG9saWN5RXJyb3JUZXh0IiwiYW5hbHl0aWNzRXZlbnQiLCJTVkdJY29uIiwicGF0aCIsImNvbXBsZXhDb250ZW50cyIsInZpZXdCb3giLCJjb250ZW50cyIsInBhdGhEZWZpbml0aW9uIiwibWFya3VwIiwiaWNvbnNBcnJheSIsInRodW1iSWNvbiIsInJlY2VpcHRJY29uIiwicGFudGhlb25JY29uIiwibWljSWNvbiIsImRpcmVjdGlvbnNJY29uIiwiY2FsZW5kYXJJY29uIiwiY2FsbG91dEljb24iLCJpbmZvSWNvbiIsImJyaWVmY2FzZUljb24iLCJrYWJvYkljb24iLCJwZXJzb25JY29uIiwibWFnbmlmeWluZ0dsYXNzSWNvbiIsIm9mZmljZUljb24iLCJsaW5rSWNvbiIsIndpbmRvd0ljb24iLCJwaG9uZUljb24iLCJ0YWdJY29uIiwiZG9jdW1lbnRJY29uIiwiY2hldnJvbkljb24iLCJzdXBwb3J0SWNvbiIsInlleHRJY29uIiwicGluSWNvbiIsImdlYXJJY29uIiwibGlnaHRCdWxiSWNvbiIsIkljb25zIiwic3Rhckljb24iLCJJY29uQ29tcG9uZW50IiwiaWNvbk5hbWUiLCJjdXN0b21JY29uIiwiaWNvblVybCIsIkNPTVBPTkVOVF9DTEFTU19MSVNUIiwiQ09NUE9ORU5UX1JFR0lTVFJZIiwicmVnaXN0cnkiLCJDb21wb25lbnRNYW5hZ2VyIiwiX2FjdGl2ZUNvbXBvbmVudHMiLCJfY29yZSIsIl9hbmFseXRpY3NSZXBvcnRlciIsInNldENvcmUiLCJzZXRBbmFseXRpY3NSZXBvcnRlciIsInJlcG9ydGVyIiwiY29tcG9uZW50Q2xhenoiLCJjb21wb25lbnRUeXBlIiwiY29tcG9uZW50Q2xhc3MiLCJzb21lIiwiZmluZEluZGV4Iiwic3BsaWNlIiwicmVtb3ZlQnlOYW1lIiwiVGFiQ29uZmlnIiwidGFiQ29uZmlncyIsIk5hdmlnYXRpb25Db25maWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztFQUFBLElBQUksT0FBTyxHQUFHO0VBQ2QsRUFBRSxZQUFZLEVBQUUsaUJBQWlCLElBQUksSUFBSTtFQUN6QyxFQUFFLFFBQVEsRUFBRSxRQUFRLElBQUksSUFBSSxJQUFJLFVBQVUsSUFBSSxNQUFNO0VBQ3BELEVBQUUsSUFBSTtFQUNOLElBQUksWUFBWSxJQUFJLElBQUk7RUFDeEIsSUFBSSxNQUFNLElBQUksSUFBSTtFQUNsQixJQUFJLENBQUMsV0FBVztFQUNoQixNQUFNLElBQUk7RUFDVixRQUFRLElBQUksSUFBSSxHQUFFO0VBQ2xCLFFBQVEsT0FBTyxJQUFJO0VBQ25CLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtFQUNsQixRQUFRLE9BQU8sS0FBSztFQUNwQixPQUFPO0VBQ1AsS0FBSyxHQUFHO0VBQ1IsRUFBRSxRQUFRLEVBQUUsVUFBVSxJQUFJLElBQUk7RUFDOUIsRUFBRSxXQUFXLEVBQUUsYUFB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